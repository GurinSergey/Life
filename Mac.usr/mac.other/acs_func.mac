import rsd, OprInter;
import "diver.mac";  

/* EVG 22/03/12 Непонятно, для чего тут это. Разве что для потенциальных переопределений :)
   Может, убрать? */
Macro OperInGroup(oper, group)
  return ВходитВГруппу(Oper,Group);
end;

/*SDA - macro ПроверитьИсполнение(claimid, fiid, amount) перенесено по месту использования в acclaim.mac*/

// KS 01.03.2012 Для корректировки сконвертированных претензий
Macro КорректировкаСуммПр(Account);

       private var rs,str,cmd;

       /* EVG 4/12/2013 Функциональность отключена до того, как мы разберёмся с функционированием претензий в 2031.

       // KS Оберну в один блок для объединения в одну транзакцию
       str = "begin " +
             "      delete from dacclaimamount_dbt a where a.t_account = '"+Account+"'; " + // Чистим
             "      insert into dacclaimamount_dbt " +                                      // Вставляем
             "        select t.t_account, " +
             "        t.t_chapter, " +
             "        t.t_fiid, " +
             "        t.t_claimkind, " +
             "        t.t_priority, " +
             "        max(st.t_statedate) t_claimdate, " +
             "        round(sum(st.t_currentamount),2) t_amount " + 
             "   from dacclaim_dbt t,dacclaimstate_dbt st " +
             "  where t.t_claimid = st.t_claimid " +
             "    and (st.t_claimid, st.t_statedate) in " +
             "        (select s.t_claimid, max(s.t_statedate) " +
             "           from dacclaimstate_dbt s " +
             "          where s.t_claimid in " +
             "                (select t_claimid " +
             "                   from dacclaim_dbt " +
             "                  where t_account = '"+Account+"' )" +
                          // EVG 29/03/2012 Здесь нужно тоже проверять на статус
             "            and ( s.t_state in (1,2,4) " +  // EVG 30/03/2012 Статус 4 (отмена) также нужно учитывать, т.к. претензия может быть отменена.
                                // EVG 30/03/2012 Статус 5 (закрыта) тоже надо проверять - это претензии, окончившиеся по сроку действия.
                                // SDA 11.04.2012 Статус 3 - так же
             "                  or (s.t_state in (3,5) AND s.t_statedate <= '"+{CurDate}+"')) " +
             "          group by s.t_claimid) " +
             "    and st.t_state in (1,2) " +
             "  group by t.t_account, t.t_chapter, t.t_fiid, t.t_claimkind, t.t_priority; " +
             "end;";
       //msgbox (str);
       cmd = RSDCommand(str);
       cmd.Execute;
/*SDA 24.03.2012 - в пакетном режиме отключил вывод результирующей информации, поскольку функция корректировки включена 
                   в шаг проверки свободного остатка на счете плательщика */
    if ( not IsOprMultiExec() )
       str = "select t_priority, t_claimdate, t_amount from dacclaimamount_dbt a where a.t_account = '"+Account+"' order by t_priority";
       rs = trsbdataset (str);
       str = "";

       while(rs and rs.movenext)
         str = str + "||Сумма претензий приоритета " + rs.priority + " на дату " + date(rs.claimdate) + " равна " + rs.amount;
       end;

       if (strlen(str) == 0)
         str = "Действующих претензий на счете "+Account+" нет";
       else
         str = "Суммы скорректированы!||Список действующих претензий на счете "+Account+":" + str;
       end;
    end;*/
    str = "EVG 4/12/2013 Корректировка претензий отключена до того, как мы разберёмся с их функционированием в 2031";

    return str;
end;

// KS 01.03.2012 Для проверки сконвертированных претензий
//               true - сумма претензий на текущий день корректна
//               false - сумма претензий на текущий день некорректна
Macro ПроверкаСуммПр(Account);

       /* EVG 4/12/2013 Функциональность отключена до того, как мы разберёмся с функционированием претензий в 2031.

       private var rs,str,cmd;

       str = "select sum(t_amount) from " + "\n" + // Узнаю в чем разница
             "( " + "\n" +
             // Узнаю как сейчас есть
             "  select t_priority, t_claimkind, round(t_amount, 2) t_amount " + "\n" +
             "    from dacclaimamount_dbt t " + "\n" +
             "   where t_account = '"+Account+"' " + "\n" +
             "     and (t_claimdate, t_priority, t_claimkind) in " + "\n" +
             "         (select max(t_claimdate), t_priority, t_claimkind " + "\n" +
             "            from dacclaimamount_dbt t " + "\n" +
             "           where t_account = '"+Account+"' " + "\n" +
             /* EVG 22/03/2012 К сожалению, это условие отсекает часть вариантов кривизны, т.к.
                некорректная сумма может присутствовать и на дату окончания действия претензии
                (будущая дата).
             "             and t_claimdate <= " + "\n" + getSqlDate({curdate}) + // На текущий день
             */
             "           group by t_priority, t_claimkind) " + "\n" +
             "  union all " + "\n" +
             // Узнаю как должно быть
             "  select t.t_priority, " + "\n" +
             "         t.t_claimkind, " + "\n" +
             "         -round(sum(case s.t_state when 1 then t.t_startamount else -t.t_startamount end), 2) t_amount " + "\n" + // Специально минусую, чтобы узнать разницу
             "    from dacclaim_dbt t, dacclaimstate_dbt s " + "\n" +
             "   where t.t_claimid = s.t_claimid " + "\n" +
             "     and s.t_state in (1, 4) " + "\n" +
             "     and t.t_account = '"+Account+"' " + "\n" +
             "   group by t.t_account, " + "\n" +
             "            t.t_chapter, " + "\n" +
             "            t.t_fiid, " + "\n" +
             "            t.t_claimkind, " + "\n" +
             "            t.t_priority " + "\n" +
             ") " + "\n" +
             " group by t_priority, t_claimkind " + "\n" + // собираю в разрезе типов и приоритетов претензий
             "having sum(t_amount)!=0"; // Интересуют только неправильные суммы по претензиям (разница между тем, что есть, и тем, что должно быть - ноль)
       //getstring (str);
       rs = trsbdataset (str);

       if(rs and rs.movenext)
         return false;
       end;
       */

       return true;

end;