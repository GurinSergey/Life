//-----------------------------------------------------------------------------------------
// Выгрузка в электронный архив, интерфейсная часть
// В.Горленко
// @changes: 09.02.2012 zip_z. изменения в алгоритме поиска библиотеки ресурсов
//           19.02.2013 joy Жаворонкова Н. I-00327917-1 Увеличен размер поля для протокола
//-----------------------------------------------------------------------------------------
import oralib, likepy, bankinter, Календарь, eautils;

Var Setup, Parm, Mutex;
//-----------------------------------------------------------------------------------------

// Класс для формирования файла протокола
Class CProtokol (dt)
    Var fName = NULL;
    Var PutTable = false;
    Var DateParm = dt;
    Var DateParmStr = "_NULL";
    Var Б_1,  Э_1,  К_1,  О_1;    Б_1  = Э_1  = К_1  = О_1  = 0;
    Var Б_2,  Э_2,  К_2,  О_2;    Б_2  = Э_2  = К_2  = О_2  = 0;
    Var Б_п1, Э_п1, К_п1, О_п1;   Б_п1 = Э_п1 = К_п1 = О_п1 = 0;
    Var Б_п2, Э_п2, К_п2, О_п2;   Б_п2 = Э_п2 = К_п2 = О_п2 = 0;


    Macro GenerateFileName
        Var day, mon, year, hh, mm, ss;
        Var dayParm, monParm, yearParm;
        DateSplit (date, day, mon, year);
        TimeSplit (time, hh, mm, ss);
        if (DateParm!=NULL)
           DateSplit (DateParm, dayParm, monParm, yearParm);
           DateParmStr = String ("_", yearParm:4:o, monParm:2:o, dayParm:2:o);
        end;
        return MergeFile (Setup.LogPath, String (year:4:o, mon:2:o, day:2:o, hh:2:o, mm:2:o, ss:2:o, DateParmStr), ".log");
    End;

    Macro View
        ViewFile (fName);
    End;

    Macro PutTime ( Sec )
        if ( fName == NULL )
            fName = GenerateFileName ();
        end;
        SetOutput (fName, true);

        Sec = int (Sec/100);
        Var mm = int (Sec/60);
        Var ss = Sec-mm*60;
        println ("\nПродолжительность работы: ", mm, " минут ", ss, " секунд");
        SetOutput (NULL, true);
    End;

    Macro PutSeansHeader
        [  
           ┌─────┬───────┬─────────────────────────────────────────────────────────────────────────────┬───────────┐
           │Номер│  Тип  │                                     Файл                                    │  Кол-во   │
           │     │       │                                                                             │документов │
           ├─────┼───────┼─────────────────────────────────────────────────────────────────────────────┼───────────┤];
    End;

    Macro PutSeans ( Num, Type, Name, cnt )
        if ( fName == NULL )
            fName = GenerateFileName ();
        end;
        SetOutput (fName, true);

        if ( not PutTable )
            PutSeansHeader ();
        end;
        PutTable = true;
        [  │#####│#######│#############################################################################│###########│]
        (Num, Type, Name, cnt);
        SetOutput (NULL, true);
    End;

    Macro Put ( str )
        if ( fName == NULL )
            fName = GenerateFileName ();
        end;
        SetOutput (fName, true);
        if ( PutTable )
            PutTable = false;
            [  └─────┴───────┴─────────────────────────────────────────────────────────────────────────────┴───────────┘];
            [ ];
        end;
        println (str);
        SetOutput (NULL, true);
    End;

    Macro JRN_status_calc (do_posle)
       Var sql = "select distinct f.t, count (1) over (partition by t) cnt "+
                 "from (select substr(t_devcode, instr(t_devcode,'_')+1)||decode(t_state,4,'-p','') t  "+
                 "      from user_ealog log "+
                 "      where t_bankdate = :dt "+
                 "      and t_devkind = 0  "+
                 "     ) f  ";

       sql = ExecSqlSelect (sql, MakeArray (SqlParam ("dt", Parm.("Date"))), false);
       BegAction (500, "Выборка данных, ждите...", false);
       Var y = sql.MoveNext ();
       if (do_posle==1)
          while (y)
             if   (sql.value ("t")=="b")   Б_1  = sql.value ("cnt"); 
             elif (sql.value ("t")=="e")   Э_1  = sql.value ("cnt"); 
             elif (sql.value ("t")=="k")   К_1  = sql.value ("cnt"); 
             elif (sql.value ("t")=="i")   О_1  = sql.value ("cnt"); 
             elif (sql.value ("t")=="b-p") Б_п1 = sql.value ("cnt"); 
             elif (sql.value ("t")=="e-p") Э_п1 = sql.value ("cnt"); 
             elif (sql.value ("t")=="k-p") К_п1 = sql.value ("cnt"); 
             elif (sql.value ("t")=="i-p") О_п1 = sql.value ("cnt"); 
             end;                            
             y = sql.MoveNext ();
          end;
       else
          while (y)
             if   (sql.value ("t")=="b")   Б_2  = sql.value ("cnt"); 
             elif (sql.value ("t")=="e")   Э_2  = sql.value ("cnt"); 
             elif (sql.value ("t")=="k")   К_2  = sql.value ("cnt"); 
             elif (sql.value ("t")=="i")   О_2  = sql.value ("cnt"); 
             elif (sql.value ("t")=="b-p") Б_п2 = sql.value ("cnt"); 
             elif (sql.value ("t")=="e-p") Э_п2 = sql.value ("cnt"); 
             elif (sql.value ("t")=="k-p") К_п2 = sql.value ("cnt"); 
             elif (sql.value ("t")=="i-p") О_п2 = sql.value ("cnt"); 
             end;                            
             y = sql.MoveNext ();
          end;
       end;
       EndAction ();
    End;

    Macro JRN_status1 
       if ( fName == NULL )
           fName = GenerateFileName ();
       end;
       JRN_status_calc (1);
       SetOutput (fName, true);
       [Состояние журнала выгрузки ДО начала выгрузки.
           ВЫГРУЖЕНО:           ПОМЕЧЕНО ДЛЯ ПОВТОРНОЙ ВЫГРУЗКИ:   
          ┌───────┬───────┐    ┌───────┬───────┐ 
          │(Б)    │#######│    │(Б)    │#######│ 
          │(Э)    │#######│    │(Э)    │#######│ 
          │(К)    │#######│    │(К)    │#######│ 
          │(Б+Э+К)│#######│    │(Б+Э+К)│#######│ 
          │(ОСН)  │#######│    │(ОСН)  │#######│    
          ├───────┼───────┤    ├───────┼───────┤ 
          │Всего: │#######│    │Всего: │#######│ 
          └───────┴───────┘    └───────┴───────┘ ]
       (Б_1:7:0:r,               Б_п1:7:0:r,
        Э_1:7:0:r,               Э_п1:7:0:r,
        К_1:7:0:r,               К_п1:7:0:r,
        (Б_1+Э_1+К_1):7:0:r,     (Б_п1+Э_п1+К_п1):7:0:r,
        О_1:7:0:r,               О_п1:7:0:r,
        (Б_1+Э_1+К_1+О_1):7:0:r, (Б_п1+Э_п1+К_п1+О_п1):7:0:r );
       SetOutput (NULL, true);
    End;

    Macro JRN_status2 
       if ( fName == NULL )
           fName = GenerateFileName ();
       end;
       JRN_status_calc (2);
       SetOutput (fName, true);
       [
        Состояние журнала выгрузки ПОСЛЕ выгрузки.
           ВЫГРУЖЕНО:           ИЗМЕНЕНИЕ:           ПОМЕЧЕНО ДЛЯ ПОВТОРНОЙ ВЫГРУЗКИ:   
          ┌───────┬───────┐    ┌───────┬───────┐    ┌───────┬───────┐ 
          │(Б)    │#######│    │(Б)    │#######│    │(Б)    │#######│ 
          │(Э)    │#######│    │(Э)    │#######│    │(Э)    │#######│ 
          │(К)    │#######│    │(К)    │#######│    │(К)    │#######│
          │(Б+Э+К)│#######│    │(Б+Э+К)│#######│    │(Б+Э+К)│#######│ 
          │(ОСН)  │#######│    │(ОСН)  │#######│    │(ОСН)  │#######│    
          ├───────┼───────┤    ├───────┼───────┤    ├───────┼───────┤ 
          │Всего: │#######│    │Всего: │#######│    │Всего: │#######│ 
          └───────┴───────┘    └───────┴───────┘    └───────┴───────┘ ]
       (Б_2:7:0:r,               (Б_2-Б_1):7:0:r,                         Б_п2:7:0:r,
        Э_2:7:0:r,               (Э_2-Э_1):7:0:r,                         Э_п2:7:0:r,
        К_2:7:0:r,               (К_2-К_1):7:0:r,                         К_п2:7:0:r,
        (Б_2+Э_2+К_2):7:0:r,     (Б_2-Б_1+Э_2-Э_1+К_2-К_1):7:0:r,         (Б_п2+Э_п2+К_п2):7:0:r,
        О_2:7:0:r,               (О_2-О_1):7:0:r,                         О_п2:7:0:r,
        (Б_2+Э_2+К_2+О_2):7:0:r, (Б_2-Б_1+Э_2-Э_1+К_2-К_1+О_2-О_1):7:0:r, (Б_п2+Э_п2+К_п2+О_п2):7:0:r );
       SetOutput (NULL, true);
    End;

End;
//-----------------------------------------------------------------------------------------

// класс-защелка, экземпляры используются для предотвращения обдновременного запуска
Private class CMutex
    Var fName, f;

    Macro Set ( name )
        fName = MergeFile (Setup.LogPath, name);
        if ( ExistFile (fName) )
            if ( not DelFile (fName) )
                return false;
            end;
        end;
        f = TStream (fName, "C");
        return true;
    OnError
        return false;
    End;

    Macro Unset
        f = NULL;
        DelFile (fName);
    End;

    Macro Destructor
        Unset ();
    End;
End;
//-----------------------------------------------------------------------------------------

// Класс с настройками модуля
Private class CSetup
    Var AbsCode     :String,
        AbsVersion  :String,
        MaxCountDEV :Integer,
        ArhivCount  :Integer,
        OutPath     :String,
        InPath      :String,
        ReportPath  :String,
        ArhPath     :String,
        LogPath     :String,
        IdSeansRef;

    Macro SaveRegVal ( Path, Value )
        Var sql;
        if ( ValType (Value) == V_STRING )
            sql = "MERGE INTO dregval_dbt USING (select rsb_common.GetRegParm (:path) keyid from dual) ON (t_keyid = keyid and t_regkind=0) "+
                  "WHEN NOT MATCHED THEN INSERT VALUES (keyid, 0, 0, chr (0), 0, 0, 0, utl_raw.cast_to_raw (:v1)) "+
                  "WHEN MATCHED THEN UPDATE SET t_fmtblobdata_xxxx = utl_raw.cast_to_raw (:v2)";
        elif ( ValType (Value) == V_INTEGER )
            sql = "MERGE INTO dregval_dbt USING (select rsb_common.GetRegParm (:path) keyid from dual) ON (t_keyid = keyid and t_regkind=0) "+
                  "WHEN NOT MATCHED THEN INSERT VALUES (keyid, 0, 0, chr (0), 0, :v1, 0, null) "+
                  "WHEN MATCHED THEN UPDATE SET t_lintvalue=:v2";
        end;
        if ( sql )
            return ExecSql (sql, MakeArray (SqlParam ("path", Path), SqlParam ("v1", value), SqlParam ("v2", value)), false) != NULL;
        end;
        return false;
    End;

    Macro LoadRegVal ( Path, Type )
        Var sql, DefVal = "";
        if ( Type == V_INTEGER )
            sql = "select t_lintvalue from dregval_dbt where t_keyid = rsb_common.GetRegParm (:path) and t_regkind=0";
            DefVal = 0;
        elif ( Type == V_STRING )
            sql = "select utl_raw.cast_to_varchar2 (t_fmtblobdata_xxxx) from dregval_dbt where t_keyid = rsb_common.GetRegParm (:path) and t_regkind=0";
        end;
        if ( sql )
            sql = ExecSqlSelect (sql, MakeArray (SqlParam ("path", Path)));
            if ( sql.MoveNext () and (ValType (sql.value (0)) != V_SPECVAL) )
                return sql.value (0);
            end;
        end;
        return DefVal;
    End;
                    
    Macro Save ( newAbsCode, newAbsVersion, newMaxCountDev, newArhivCount, newOutPath, newInPath, newReportPath, newArhPath, newLogPath )
        if ( not SaveRegVal ("PRBB\\EA\\ABSCODE", newAbsCode) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ABSCODE");
            return false;
        else
            AbsCode = newAbsCode;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\VERSION", newAbsVersion) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\VERSION");
            return false;
        else
            AbsVersion = newAbsVersion;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\ГЛУБИНА АРХИВА", newArhivCount) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ГЛУБИНА АРХИВА");
            return false;
        else
            ArhivCount = newArhivCount;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\КОЛИЧЕСТВО ДОКУМЕНТОВ", newMaxCountDEV) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\КОЛИЧЕСТВО ДОКУМЕНТОВ");
            return false;
        else
            MaxCountDEV = newMaxCountDEV;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\OUT", newOutPath) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ДИРЕКТОРИИ\\OUT");
            return false;
        else
            OutPath = newOutPath;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\IN", newInPath) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ДИРЕКТОРИИ\\IN");
            return false;
        else
            InPath = newInPath;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\REPORT", newReportPath) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ДИРЕКТОРИИ\\REPORT");
            return false;
        else
            ReportPath = newReportPath;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\ARHIV", newArhPath) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ДИРЕКТОРИИ\\ARHIV");
            return false;
        else
            ArhPath = newArhPath;
        end;

        if ( not SaveRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\LOG", newLogPath) )
            MsgBox ("Ошибка сохранения параметра PRBB\\EA\\ДИРЕКТОРИИ\\LOG");
            return false;
        else
            LogPath = newLogPath;
        end;

        return true;
    End;
    
    Macro Load
        AbsCode     = LoadRegVal ("PRBB\\EA\\ABSCODE", V_STRING);
        AbsVersion  = LoadRegVal ("PRBB\\EA\\VERSION", V_STRING);;
        ArhivCount  = LoadRegVal ("PRBB\\EA\\ГЛУБИНА АРХИВА", V_INTEGER);
        MaxCountDEV = LoadRegVal ("PRBB\\EA\\КОЛИЧЕСТВО ДОКУМЕНТОВ", V_INTEGER);
        OutPath     = LoadRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\OUT", V_STRING);
        InPath      = LoadRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\IN", V_STRING);
        ReportPath  = LoadRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\REPORT", V_STRING);
        ArhPath     = LoadRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\ARHIV", V_STRING);
        LogPath     = LoadRegVal ("PRBB\\EA\\ДИРЕКТОРИИ\\LOG", V_STRING);
    End;
End;
//-----------------------------------------------------------------------------------------

// Возвращает последний закрытый опердень - day
Private macro GetDefaultDate ( day )
    Var sql = "select max (t_curdate) from dcurdate_dbt where t_isclosed='X' and t_branch=1";
    sql = ExecSqlSelect (sql);
    if ( sql.Movenext () and (ValType (sql.value (0)) != V_SPECVAL) )
        return Date (sql.value (0)) - day;
    else
        Exit (0, "Не найдено ни одного закрытого дня");
        return Date (0,0,0);
    end;
End;
//-----------------------------------------------------------------------------------------

// класс интерфейса для задания параметров и вызова процедур
Private class (TRecHandler) TParm
    
    // 2012-02-09 zip_z. Адаптация под особенности Life >
    //InitTRecHandler ("eastart", "ea.lbr", true);
    InitTRecHandler ("eastart", getResourceLibPath (), true);
    // < 2012-02-09 zip_z.
    
    Var KindDoc = 0, KindRep = 0, Mode = 0;

    // настроечная часть
    Private macro RunSetup
        ExecMacroFile ("easetup.mac");
    End;

    // обработчик для скроллинга
    Macro ScrollHandler ( rs, cmd, id, key )
        if ( (cmd == DLG_KEY) and (key == kbEnter) )
            return CM_SELECT;
        end;
    End;

    // показывает список видов ДЭВ по типу
    Macro SelectDEVKind ( type )
        Var sql = "select * from user_eadev where t_kind=:kind order by t_id";
        sql = ExecSqlSelect (sql, MakeArray (SqlParam ("kind", type)), false, RSDVAL_CLIENT, RSDVAL_STATIC);
        if ( RunScroll (sql, 2, MakeArray ("t_code", "Код", 10, 0, 10, 0, "t_name", "Наименование", 40, 0, 40, 0),
                        NULL, R2M (this, "ScrollHandler"), "Виды ДЭВ", "Enter Выбор  ESC Отмена", TRUE) )
            SetParm (2, sql.value ("t_id"));
            SetParm (3, sql.value ("t_name"));
        end;
    End;

    // проверка возможности запуска процедуры загрузки
    Macro CheckLoad
        if ( Setup.InPath == "" )
            MemoryError (1, "Не настроен параметр \"Путь для загрузки\"");
            return false;
        end;
        if ( Setup.LogPath == "" )
            MemoryError (1, "Не настроен параметр \"Путь для протоколов\"");
            return false;
        end;
        return true;
    end;

    // проверка возможности запуска процедуры выгрузки
    Macro CheckUpload
        if ( Setup.AbsCode == "" )
            MemoryError (1, "Не настроен параметр \"Код АБС\"");
            return false;
        end;
        if ( Setup.OutPath == "" )
            MemoryError (1, "Не настроен параметр \"Путь для выгрузки\"");
            return false;
        end;
        if ( (this.("CheckRep") == "X") and (Setup.ReportPath == "") )
            MemoryError (1, "Не настроен параметр \"Путь для отчетов\"");
            return false;
        end;
        if ( Setup.LogPath == "" )
            MemoryError (1, "Не настроен параметр \"Путь для протоколов\"");
            return false;
        end;

        Var sql = "select count (1) from dcurdate_dbt where t_curdate=:dt and t_isclosed = 'X' and t_branch = 1";
        sql = ExecSqlSelect (sql, MakeArray (SqlParam ("dt", this.("Date"))), false);
        if ( not (sql.MoveNext () and (sql.value (0) > 0)) )
            if (not Gettrue(false, "Операционный день "+ this.("Date")+ " не найден в списке закрытых операционных дней|Продолжить выгрузку?"))
               MemoryError (1, "Операционный день "+ this.("Date")+ " не найден в списке закрытых операционных дней");
               return false;
            end;
        end;
        return true;
    End;

    // проверка возможности запуска процедуры выгрузки реестра
    Macro CheckUploadReg
        Var sql = "select count (decode (t_state, 1, 1)) cnt1, count (decode (t_state, 3, 1)) cnt3, count (decode (t_state, 4, 1)) cnt4, count (decode (t_regseanse, 0, 1)) cnt from user_ealog where t_bankdate = :dt";
        sql = ExecSqlSelect (sql, MakeArray (SqlParam ("dt", this.("Date"))), false);
        if ( sql.MoveNext () )
            if ( sql.value ("cnt1") )
                MemoryError (1, "Имеются записи, не подтвержденные ТПР");
                return false;
            end;
            if ( sql.value ("cnt3") )
                MemoryError (1, "Имеются записи, отвергнутые ТПР");
                return false;
            end;
            if ( sql.value ("cnt4") )
                MemoryError (1, "Имеются записи, помеченные для повторной выгрузки");
                return false;
            end;
            if ( sql.value ("cnt") == 0 )
                MemoryError (1, "Нет записей для выгрузки в реестр");
                return false;
            end;
        end;
        return true;
    End;

    Macro Handler ( dlg, cmd, id, key )
        if ( cmd == DLG_INIT )
            Message ("F2 Выгрузка  Ctrl-F2 Выгрузка реестра  F4 Загрузка  F5 Настройки  (Ctrl)F6 Журнал  F7 Сеансы  ESC Выход");
            if ( dlg.("CheckDoc") == "" )
                DisableFields (dlg, FldIndex ("DocKind"));
            end;
            if ( dlg.("CheckRep") == "" )
                DisableFields (dlg, FldIndex ("RepKind"));
            end;
            UpdateFields (dlg);

        elif ( cmd == DLG_SAVE )
            if ( not Mutex.Set ("uploadflag") ) 
                MemoryError (1, "Данная процедура сейчас работает из другой сессии RS-Bank, параллельное выполнение запрещено");
                if ( not IsShedulerRunning () )
                    DisplayError ();
                end;
                return CM_CANCEL;
            end;
        elif ( (cmd == DLG_KEY) and (key == kbF2) )
            if ( CheckUpload () )
                Mode = M_UPLOAD;
                return CM_SAVE;
            else
                DisplayError ();
            end;

        elif ( (cmd == DLG_KEY) and (key == kbCtrlF2) and GetTrue (true, "Выгрузить реестр за "+dlg.("Date")+"?") )
            if ( CheckUpload () and CheckUploadReg () )
                Mode = M_UPLOADREG;
                return CM_SAVE;
            else
                DisplayError ();
            end;
            
        elif ( (cmd == DLG_KEY) and (key == kbF4) )
            if ( CheckLoad () )
                Mode = M_LOAD;
                return CM_SAVE;
            else
                DisplayError ();
            end;

        elif ( (cmd == DLG_KEY) and (key == kbF5) )
            RunSetup ();

        elif ( (cmd == DLG_KEY) and (key == kbF6) )
            ExecMacroFile ("ealog.mac", "AllLog", dlg.("Date"));

        elif ( (cmd == DLG_KEY) and (key == kbCtrlF6) )
            ExecMacroFile ("ealog.mac", "SelLog", dlg.("Date"));

        elif ( (cmd == DLG_KEY) and (key == kbF7) )
            ExecMacroFile ("ealog.mac", "Seance", dlg.("Date"));

        elif ( (cmd == DLG_KEY) and (key == kbSpace) and (id == FldIndex ("CheckDoc")) )
            dlg.(id) = iif (dlg.(id), "", "X");
            if ( dlg.(id) )
                EnableFields (dlg, FldIndex ("DocKind"));
            else
                DisableFields (dlg, FldIndex ("DocKind"));
            end;
            UpdateFields (dlg);

        elif ( (cmd == DLG_KEY) and (key == kbSpace) and (id == FldIndex ("CheckRep")) )
            dlg.(id) = iif (dlg.(id), "", "X");
            if ( dlg.(id) )
                EnableFields (dlg, FldIndex ("RepKind"));
            else
                DisableFields (dlg, FldIndex ("RepKind"));
            end;
            UpdateFields (dlg);

        elif ( (cmd == DLG_KEY) and (key == kbF3) and (id == FldIndex ("date")) )
            dlg.(id) = GetDateByCalendar (dlg.(id));

        elif ( (cmd == DLG_KEY) and (key == kbF3) and (id == FldIndex ("DocKind")) )
            SelectDEVKind (0, KindDoc, dlg.(id));

        elif ( (cmd == DLG_KEY) and (key == kbF3) and (id == FldIndex ("RepKind")) )
            SelectDEVKind (1, KindRep, dlg.(id));

        elif ( (cmd == DLG_KEY) and (key == kbSpace) and (id == FldIndex ("RepKind")) )
            KindDoc = 0;
            dlg.(id) = "Все";

        elif ( (cmd == DLG_KEY) and (key == kbSpace) and (id == FldIndex ("DocKind")) )
            KindRep = 0;
            dlg.(id) = "Все";
        end;
    End;
    
    Macro Init
        this.("Date") = GetDefaultDate (Setup.ArhivCount);
        this.("CheckDoc") = "X";
        this.("DocKind") = "Все";
        this.("CheckRep") = "";
        this.("RepKind") = "Все";
    End;

    Macro Run
        Init ();
        return RunDialog (this, R2M (this, "Handler"));
    End;
End;
//-----------------------------------------------------------------------------------------

Macro Upload
    if ( (not ExecMacroFile ("eaupload.mac", "UploadDEV")) and (not IsShedulerRunning ()) )
        DisplayError ();
    end;
End;
//-----------------------------------------------------------------------------------------

Macro UploadReg
    ExecMacroFile ("eaupload.mac", "UploadReg");
End;
//-----------------------------------------------------------------------------------------

Macro Load 
    MsgBox ("Не реализовано");
End;

//-----------------------------------------------------------------------------------------
macro Chek_oper_acs
   Var sql = "select 1 from dacsgroupoper_dbt where t_oper = :oper and t_groupID = 102";

   sql = ExecSqlSelect (sql, MakeArray (SqlParam ("oper", {Oper})));

   return sql.MoveNext ();
end;


//-----------------------------------------------------------------------------------------


/*Перед стартом проверка на право пользоваться функционалом*/
if (not Chek_oper_acs)
  Msgbox("Нет права работать с этим функционалом. Необходимо вхождение в группу 102.");
  Exit(1);
end;


Setup = CSetup ();
Setup.Load ();
Mutex = CMutex ();

Parm = TParm ();
if ( IsShedulerRunning () ) // запуск из планировщика
    Parm.Init;
    Parm.("CheckRep") = "X";
    if ( not Parm.CheckUpload () )
        Exit (1);
    end;
    Parm.Mode = M_UPLOAD;
else
    if ( not Parm.Run () ) Exit (1); end;
end;

/*по умолчанию*/
Setup.IdSeansRef = 1000036;

if   (Setup.AbsCode == "00") /*ПРОБИЗНЕСА*/
   Setup.IdSeansRef = 1000036;
elif (Setup.AbsCode == "01") /*УЛЬЯНОВСК*/
   Setup.IdSeansRef = 1000036;
elif (Setup.AbsCode == "02") /*ГЭБ*/
   Setup.IdSeansRef = 1000036;
end;

if ( Parm.Mode == M_UPLOAD )
    Upload ();
elif ( Parm.Mode == M_UPLOADREG )
    UploadReg ();
elif ( Parm.Mode == M_LOAD )
    Load ();
end;
Mutex.Unset ();
Exit (1);
