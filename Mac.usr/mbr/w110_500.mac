//-----------------------------------------------------------------------------
// Блок      : 29006 - "Перенос на незавершенные"
// Шаг       : 500   - "Перенос на незавершенные"
// Назначение: Макрос шага
// Описание  : Макрос шага
//-----------------------------------------------------------------------------
import InsCarryDoc, OprInter, BankInter, PSInter, RMInter, "cbsttls.mac", "pm_tools.mac";
import pmsummo, "pm_opr.mac", "wldoc.mac", "pmcarfun.mac", "rmtools.mac";
import oralib; //Jushmanov 2014-02-24 C-19151

RECORD Corschem( corschem );
var PaymentObj:RsbPayment;

//-----------------------------------------------------------------------------
// Счет получателя клиентский?
//-----------------------------------------------------------------------------
private macro СчетПлательщикаКлиентский( Payment:RsbPayment ):bool
    if( ( Payment.PayerGroup != PAYMENTS_GROUP_EXTERNAL ) and MFR_IsOurBank( Payment.Payer ) )
        return false;
    elif( PM_FindBalanceInReg_117( "PS\\REQOPENACC\\Счета клиентов", Payment.PayerAccount, 1 ) )
        return true;
    else
        return false;
    end;
end;

//-----------------------------------------------------------------------------
// Счет получателя клиентский?
//-----------------------------------------------------------------------------
private macro СчетПолучателяКлиентский( Payment:RsbPayment ):bool
    if( ( Payment.ReceiverGroup != PAYMENTS_GROUP_EXTERNAL ) and MFR_IsOurBank( Payment.Receiver ) )
        return false;
    elif( PM_FindBalanceInReg_117( "PS\\REQOPENACC\\Счета клиентов", Payment.ReceiverAccount, 1 ) )
        return true;
    else
        return false;
    end;
end;


//-----------------------------------------------------------------------------
// Выполнение шага
//-----------------------------------------------------------------------------
macro ExecuteStep( doc, first, DocKind, ID_Operation, ID_Step  )

    var accUncs;
    var AccountCarry:string = "", Acc:string = "";
    var rs:RsdRecordset;  
    // Проводка
    var paymtr:RsbPaymTransaction = PaymentObj.MakeTransaction();

    var PaymOnMFR  :bool    = false;
    var PaymDocKind:integer = PaymentObj.PrimDocKind;
    record cors(corschem);

    var FuturePayerAccount = PaymentObj.FuturePayerAccount,
        FuturePayerFIID    = PaymentObj.FuturePayerFIID;
    record _wlreq ( "wlreq.dbt" );

    if( PaymDocKind == 0 )
      PaymDocKind = PaymentObj.DocKind;
    end;

    // Документ, "зависший" в блоке "МФР"
    PaymOnMFR = PM_IsMFRProcessing( PaymentObj.PaymentID, PaymDocKind );

    if( CheckUnFin( PaymentObj, true ) ); //делаем проверки
      return 1;
    end;

    if( PaymentObj.StartDepartment != PaymentObj.EndDepartment )
        if( IsExistCallBackRSL( PaymentObj.PaymentID, 60/*WLD_STATUS_REQ_RECEIV*/, ID_Operation, ID_Step ) )
            return 1;
        end;
    end;

    if( (PaymentObj.PrimDocKind != WL_INDOC) or ( GetOprStatus(OPR_PAYM_IN_KVIT) != OPR_PM_ST_UNKVIT) )
        if( not CarryPlanDocuments(PaymentObj.PaymentID) ) // Актуализируем проводки 
            MsgBox("Ошибка при помещении планируемой проводки в проведенные");
            return 1;
        end;
    end;

    // Определить счет незавершенных
    if(PaymentObj.PrimDocKind != WL_INDOC)
        accUncs = OutPaymentAccUnclosed( PaymentObj );
    else
        accUncs = InPaymentAccUnclosed( PaymentObj );
    end;
    AccountCarry = accUncs.FindAndOpenAccount();  

    if( AccountCarry == "" )
        MsgBox("Не определен счет незавершенных");
        return 1;
    end;

  // Для документов, "зависших" в блоке "МФР" выполнить проводку
  //  Дб: FuturePayerAccount 
  //  Кр: Счет незавершенных расчетов
    if( PaymOnMFR )

        if( paymtr == NULL )
            MsgBox("Ошибка при создании проводки по платежу");
            return 1;
        end;

        paymtr.Chapter         = 1;                                            
        paymtr.Date_Carry      = PaymentObj.ValueDate;
        paymtr.Number_Pack     = PaymentObj.NumberPack;
        paymtr.Numb_Document   = PaymentObj.Number;
        paymtr.ResultCarry     = 1;
        paymtr.Kind_Oper       = " 1";

        if (PaymentObj.ShifrOper != "")
            paymtr.Shifr_Oper  = PaymentObj.ShifrOper;
        else
            paymtr.Shifr_Oper  = "09";
        end;

        paymtr.Ground          = PaymentObj.Ground;
        paymtr.Department      = PaymentObj.Department;
        paymtr.FIIDPayer       = PaymentObj.FuturePayerFIID;
        paymtr.FIIDReceiver    = PaymentObj.BaseFIID;
        paymtr.SumPayer        = PaymentObj.FuturePayerAmount;
        paymtr.SumReceiver     = PaymentObj.FutureBaseAmount;
        paymtr.AccountPayer    = PaymentObj.FuturePayerAccount;
        paymtr.AccountReceiver = AccountCarry;
        paymtr.ClaimID         = GetClaimID( PaymentObj, paymtr.AccountPayer, paymtr.Chapter, paymtr.FIIDPayer );
        paymtr.Status_After    = ACCTRN_STATUS_DOCUMENT; // статус - проведенная

        if( PaymentObj.CoverAmount != $0 )
            paymtr.SumEquivalentCarry = PaymentObj.CoverAmount;
        end;

        if( not paymtr.Carry )
            MsgBox("Ошибка при актуализации платежа");
            return 1;
        end;  

        // Удалить претензию резервирования по FuturePayerAccount, который был до выполнения проводки
        PaymentObj.FreeReserve( FuturePayerAccount, 1/*CHAPT1*/, FuturePayerFIID );

    elif( PaymentObj.PrimDocKind == WL_INDOC)

        if( PaymentObj.Purpose == PM_PURP_MULTI)
            msgbox("Постановка на счет незавершенных расчетов для сводных входящих платежей не требуется");
            return 1;
        end;

        if(НайтиКорсхему(PaymentObj.InCorschem, PaymentObj.BaseFIID, cors))
            msgbox("Не удается найти входящую корсхему");
            return 1;
        end;

        if(cors.Account != PaymentObj.FuturePayerAccount)

            if( GetDialogFlag() )
                var Text = TArray(), Buttons = TArray();
                Text(0) = string("Счет ",PaymentObj.FuturePayerAccount,", на котором находятся средства, не является корсчетом входящей схемы расчетов.");
                Text(1) = "Перенести средства на счет незавершенных расчетов?";
                Buttons( 0 ) = "Да";
                Buttons( 1 ) = "Нет";
                if( ConfWin( Text, Buttons ) == 1 )
                    return 1;
                end;
            else
                msgbox(string("Счет ",PaymentObj.FuturePayerAccount,", на котором находятся средства, не является корсчетом входящей схемы расчетов"));
                return 1;
            end;
        end;

        if( paymtr == NULL )
            MsgBox("Ошибка при создании проводки по платежу");
            return 1;
        end;

        paymtr.Chapter         = 1;                                            
        paymtr.Date_Carry      = PaymentObj.InTransferDate;
        paymtr.Number_Pack     = PaymentObj.NumberPack;
        paymtr.Numb_Document   = PaymentObj.Number;
        paymtr.ResultCarry     = 1;
        paymtr.Kind_Oper       = " 1";

        paymtr.Ground          = PaymentObj.Ground;
        paymtr.Department      = PaymentObj.Department;
        paymtr.FIIDPayer       = PaymentObj.FuturePayerFIID;
        paymtr.FIIDReceiver    = PaymentObj.BaseFIID;
        paymtr.SumPayer        = PaymentObj.FuturePayerAmount;
        paymtr.SumReceiver     = PaymentObj.FutureBaseAmount;
        paymtr.AccountPayer    = PaymentObj.FuturePayerAccount;
        paymtr.AccountReceiver = AccountCarry;
        paymtr.ClaimID         = GetClaimID( PaymentObj, paymtr.AccountPayer, paymtr.Chapter, paymtr.FIIDPayer );
        paymtr.Status_After    = GetPaymentCarryKind(PaymentObj);

        if( not paymtr.Carry )
            MsgBox("Ошибка при актуализации платежа");
            return 1;
        end;  

        // Удалить претензию резервирования по FuturePayerAccount, который был до выполнения проводки
        PaymentObj.FreeReserve( FuturePayerAccount, 1/*CHAPT1*/, FuturePayerFIID );
        if(GetOprStatus(OPR_PAYM_DO) == OPR_PM_ST_UNFIN)
            if( УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_PREP ) )
                msgbox("Ошибка при установке сегментов статуса экземпляра операции");
                return 1;
            end;
        end;

    else

        if(ПолучитьВсеПроводки(PaymentObj.PaymentID,@rs) and rs.moveLast())
            if(rs.movePrev())
                PaymentObj.ValueDate = rs.value("t_Date"); 
            end;
            SetOprDate(29000000, {curdate});

            if(  (rs.moveLast()) AND ( not НайтиКорсхему(PaymentObj.OutCorschem, PaymentObj.ReceiverFIID, cors)) and (rs.value("t_ReceiverAccount") == cors.Account) )
                if(DeleteCarryOnAccount( PaymentObj, PRT_Credit, rs.value("t_ReceiverFIID"), rs.value("t_ReceiverAccount") ))
                    msgbox("Ошибка при удалении балансовых проводок");
                    return 1;
                end;
            end;

            if(rs.movePrev())
                Acc = rs.value("t_ReceiverAccount");
            else
                Acc = PaymentObj.FuturePayerAccount;
            end;

            if( Acc != AccountCarry )
                if( paymtr == NULL )
                    MsgBox("Ошибка при создании проводки по платежу");
                    return 1;
                end;

                paymtr.Chapter         = 1;                                            
                paymtr.Date_Carry      = PaymentObj.ValueDate;
                paymtr.Number_Pack     = PaymentObj.NumberPack;
                paymtr.Numb_Document   = PaymentObj.Number;
                paymtr.ResultCarry     = 1;
                paymtr.Kind_Oper       = " 1";
    
                if (PaymentObj.ShifrOper != "")
                    paymtr.Shifr_Oper  = PaymentObj.ShifrOper;
                else
                    paymtr.Shifr_Oper  = "09";
                end;

                paymtr.Ground          = PaymentObj.Ground;
                paymtr.Department      = PaymentObj.Department;
                paymtr.FIIDPayer       = PaymentObj.FuturePayerFIID;
                paymtr.FIIDReceiver    = PaymentObj.FutureReceiverFIID;
                paymtr.SumPayer        = PaymentObj.FuturePayerAmount;
                paymtr.SumReceiver     = PaymentObj.FutureReceiverAmount;
                paymtr.AccountPayer    = PaymentObj.FuturePayerAccount;
                paymtr.AccountReceiver = AccountCarry;
                paymtr.ClaimID         = GetClaimID( PaymentObj, paymtr.AccountPayer, paymtr.Chapter, paymtr.FIIDPayer );
                paymtr.Status_After    = ACCTRN_STATUS_DOCUMENT; // статус - проведенная

                if( PaymentObj.CoverAmount != $0 ) 
                    paymtr.SumEquivalentCarry = PaymentObj.CoverAmount;
                end;

                if( not paymtr.Carry )
                    MsgBox("Ошибка при актуализации платежа");
                    return 1;
                end;  

                // Удалить претензию резервирования по FuturePayerAccount, который был до выполнения проводки
                PaymentObj.FreeReserve( FuturePayerAccount, 1/*CHAPT1*/, FuturePayerFIID );

            end;
        end;
    end;

    if( not PaymOnMFR  and (PaymentObj.PrimDocKind == WL_INDOC) )
        // Обработка незавершенного
        PaymentObj.ValueDate = PM_GetOperDay_Balance(PaymentObj.Department);
    end;

    return 0;
end;


//Jushmanov 2014-02-24 C-19151
macro PostStepAction( message,      /* 1 - выполнение шага; 2 - откат шага;   */
                      errTrn,       /* статус выполнения шага. 0 - ошибки нет */
                      FirstDoc,     /* указатель на первичный документ        */
                      ID_Oper,      /* внутренний идентификатор операции      */
                      Number_Step,  /* Номер шага операции (из настроек)      */
                      KindOper,     /* номер вида операции                    */
                      KindDoc,      /* номер вида первичного документа        */
                      KindStep,     /* вид шага операции                      */
                      ID_Step )     /* внутренний идентификатор шага операции */
    private var logquery, idStep = ID_Step, idOper = ID_Oper;

    if(( message == OP_EXECUTE_STEP ) and (errTrn == 0) and (IsOprMultiExec))
        if ((valtype(idOper) != V_INTEGER) and (valtype(idOper) != V_STRING)) idOper = 0; end;
        if ((valtype(idStep) != V_INTEGER) and (valtype(idStep) != V_STRING)) idStep = 0; end;

        logquery = "UPDATE usr_doprstep_robot_dbt SET t_is_robot_step = chr(88)" +
                   " WHERE t_id_operation = " + idOper + " AND t_id_step = " + idStep;
        ExecSQL(logquery, null, false);
    end;

    return 0;
end;