 /*
 $Name: w110_350.mac
 $Module: МБР
 $Description: Макрос шага(29003 - "Возврат инициатору"/350   - "Возврат инициатору")
 */
//-----------------------------------------------------------------------------
// Блок      : 29003 - "Возврат инициатору"
// Шаг       : 350   - "Возврат инициатору"
// Назначение: Макрос шага
// Описание  : Макрос шага
// 10.11.2014 LAO адаптация для хф 97
//-----------------------------------------------------------------------------
import InsCarryDoc, OprInter, BankInter, RMInter, "rmconst.mac", "wldoc.mac", "rmtools.mac", "cbsttls.mac", "pmdeltrn.mac", pm_setst, pm_tools;
import pmsummo, "pm_opr.mac";
import oralib; //Jushmanov 2014-02-24 C-19151

RECORD Corschem( corschem );

var PaymentObj:RsbPayment;

// Определяется период, в котором пользователь может выполнять/окатывать проводки
private macro GetOperPeriod(BeginDate:@date, EndDate:@date)
  BeginDate = date(0,0,0); EndDate = date(0,0,0);
  var rs = execSQLselect("select RsbSessionData.OperCurDateMin, " +
                         "       RsbSessionData.OperCurDateMax  " +
                         "  from dual                           ");
  if(rs and rs.moveNext)
    BeginDate = rs.value(0);
    EndDate   = rs.value(1);

    var Department = {OperDprt};

    // Если пользователь не может работать в закрытых дняx
    if({OperCloseDateRestrict})
      // проверить все операционные дни периода удаления (включая границы), 
      // начиная с даты окончания периода
      var IsClosed = "";
      var tmpdate = EndDate;
      while( (IsClosed != "X") and (tmpdate >= BeginDate) )
        if( existsOperDay(tmpdate, Department, null, @IsClosed) and (IsClosed == "X") )
          break;
        end;
        tmpdate = tmpdate - 1;
      end;
      // принять дату начала периода равной дате предыдущего (открытого) операционного дня
      BeginDate = tmpdate + 1;
      while( not existsOperDay(BeginDate, Department) and (BeginDate <= EndDate) )          
        BeginDate = BeginDate + 1;
      end;
    end;

    // операционный день, являющейся датой начала периода удаления, 
    // должен иметь признак "баланс" 
    var IsBalance = "";
    if( not existsOperDay(BeginDate, Department, @IsBalance) or (IsBalance != "X") )
      BeginDate = PM_GetOperDay_Balance(Department, BeginDate);
    end;
  end;
end;

//-----------------------------------------------------------------------------
// Выполнение шага
//-----------------------------------------------------------------------------
macro ExecuteStep( doc, first, DocKind, ID_Operation, ID_Step )

  var BeginDate = date(0,0,0), EndDate = date(0,0,0);
  GetOperPeriod(@BeginDate, @EndDate);

  // Если период удаления не существует 
  if( (BeginDate > EndDate)
      or
      ( (BeginDate == date(0,0,0)) and (EndDate == date(0,0,0)) )
    )
    msgbox("У Вас недостаточно прав для выполнения возврата");
    return 1;
  end;

  file dp_dep("dp_dep.dbt");
  file party("party.dbt");

  record _wlreq( "wlreq.dbt" );
  var text, depName = "", partyName = "";
  var query:string, param:TArray, rs:RsdRecordset;
  var BindingFlag:bool = true;

  if( IsClaimByOperStep(ID_Operation) )
    text = "По платежному документу имеется документ, изменяющий претензию. ";
    if(not IsOprMultiExec())
      if( RsbGetTrue( false, false,text + "|Вы действительно хотите выполнить возврат платежного документа?" ) == false ) 
        return 1;
      end;
    else
      msgbox(text + "Платежный документ должен быть обработан в единичном режиме.");
      return 1;  
    end;
  end;

  if(PaymentObj.IsExternalIncoming or PaymentObj.IsTransit)
    // Найти входящую корсхему
    if( НайтиКорсхему( PaymentObj.InCorschem, PaymentObj.ReceiverFIID, Corschem ) )
      msgBox("Не найдена входящая корсхема");
      return 1;
    end;

    // Удалить резервирование средств
    PaymentObj.FreeReserve( Corschem.Account, CHAPT1, PaymentObj.ReceiverFIID );
  elif( PaymentObj.IsCredit() ) 
    PaymentObj.FreeReserve( PaymentObj.PayerAccount, CHAPT1, PaymentObj.PayerFIID );
  end;

  // Дата значения платежа устанавливается равной дате начала периода удаления
  //Gurin S. 14.08.2015
  //PaymentObj.ValueDate = BeginDate;
  PaymentObj.ValueDate = {Curdate};

  // Удаляем проводки или формируем обратные
  var errtext:string = "";
  if( not PM_DeleteAllPaymTransactions( PaymentObj, @errtext, BeginDate ) )
    msgbox( errtext );
    return 1;
  end;

  PaymentObj.PaymStatus = PM_REJECTED;
  
  if( not PaymentObj.IsExternalIncoming )
    PaymentObj.PropStatus = PM_PROP_CORREJECTED;

    // Установить примечанию "Причина отказа (возврата)" платежа значение "Возвращен с отправки сообщения"
    if( PaymentObj.Notes.AddNote( PM_NOTEKIND_DENIALGROUND, "Возвращен с отправки сообщения" ) != 0 )
      msgbox( "Ошибка при вставке примечания платежа" );
      return 1;
    end;

    // Если у платежа есть исходящие сообщения, сделать их невалидными
    if( UnvalidPaymentMessage( PaymentObj.PaymentID, BindingFlag ) )
      msgbox( "Ошибка при смене статуса сообщения по платежу" );
      return 1;
    end;
  end;

  PM_SetPrimDocumentState( PaymentObj, DOCUMENT_ST_REJECTED );

  //PaymentObj.PaymStatus = PM_FINISHED;
  //PaymentObj.PropStatus = PM_PROP_CLOSED;

  var AttrFound : bool = false, OprPmState : integer = OPR_PM_ST_REJECT;
  if( PaymentObj.Categories.IsAttrPresense(18, 1, NULL, NULL, false, {curdate}) )
    OprPmState = OPR_PM_ST_CLOSE;
  end;

  if( УстановитьСтатусыПлатежа( OPR_PAYM_STATE, OprPmState ) )
    MsgBox("Возникла ошибка при смене статусов операции платежа");
    return 1;
  end;
  
  if( IsReturnMFR )
  debugbreak;
    var NoteFlag = 0;  /*нет отзыва со статусом "Принято"*/  
    if( not IsExistCallBackRSL( PaymentObj.PaymentID, 60/*WLD_STATUS_REQ_RECEIV*/, ID_Operation, ID_Step, @NoteFlag ) )
/*    
        IsExistCallBack( PaymentObj.PaymentID, 60, _wlreq))

      if(PlaceReqToClose(_wlreq.ReqID, ID_Operation, ID_Step))
        msgbox( "Ошибка при помещении отзыва в обработанные" );
        return 1;
      end;
*/   
      if(NoteFlag == 2)
        query = "select dp.t_Name, pt.t_Name "
                  "from ddp_dep_dbt dp, "
                       "dparty_dbt pt "
                 "where dp.t_PartyID = ? "
                   "and pt.t_PartyID = dp.t_PartyID";
        param = makeArray( SQLParam( "", _wlreq.OriginatorID ) );
        rs = execSQLselect( query, param, TRUE );
        rs.moveNext();

        if( PaymentObj.Notes.AddNote( PM_NOTEKIND_DENIALGROUND, string("Отозван из филиала ", rs.value(0), " ", rs.value(1) ) ) != 0 )
          msgbox( "Ошибка при вставке примечания платежа" );
          return 1;
        end;
      end;
       
    elif( NoteFlag == 0 )
      KeyNum(dp_dep, 0);
      dp_dep.Code = PaymentObj.Department;
      if(getEQ(dp_dep))
        depName = dp_dep.Name;
        if(dp_dep.PartyID)
          party.PartyID = dp_dep.PartyID;
          if(getEQ(party))
            partyName = party.Name;
          end;
        end;
      end;

      if( PaymentObj.Notes.AddNote( PM_NOTEKIND_DENIALGROUND, string("Отбракован филиалом ", depName, " ", partyName) ) != 0 )
        msgbox( "Ошибка при вставке примечания платежа" );
        return 1;
      end;
    else
      return 1;
    end; 

  end;

  //PaymentObj.StatusInfo = "Возвращен отправителю";
       
  return 0;
end;

//Jushmanov 2014-02-24 C-19151
macro PostStepAction( message,      /* 1 - т√яюыэхэшх °рур; 2 - юЄърЄ °рур;   */
                      errTrn,       /* ёЄрЄєё т√яюыэхэш  °рур. 0 - ю°шсъш эхЄ */
                      FirstDoc,     /* єърчрЄхы№ эр яхЁтшўэ√щ фюъєьхэЄ        */
                      ID_Oper,      /* тэєЄЁхээшщ шфхэЄшЇшърЄюЁ юяхЁрЎшш      */
                      Number_Step,  /* ═юьхЁ °рур юяхЁрЎшш (шч эрёЄЁюхъ)      */
                      KindOper,     /* эюьхЁ тшфр юяхЁрЎшш                    */
                      KindDoc,      /* эюьхЁ тшфр яхЁтшўэюую фюъєьхэЄр        */
                      KindStep,     /* тшф °рур юяхЁрЎшш                      */
                      ID_Step )     /* тэєЄЁхээшщ шфхэЄшЇшърЄюЁ °рур юяхЁрЎшш */
    private var logquery, idStep = ID_Step, idOper = ID_Oper;

    if(( message == OP_EXECUTE_STEP ) and (errTrn == 0) and (IsOprMultiExec))
        if ((valtype(idOper) != V_INTEGER) and (valtype(idOper) != V_STRING)) idOper = 0; end;
        if ((valtype(idStep) != V_INTEGER) and (valtype(idStep) != V_STRING)) idStep = 0; end;

        logquery = "UPDATE usr_doprstep_robot_dbt SET t_is_robot_step = chr(88)" +
                   " WHERE t_id_operation = " + idOper + " AND t_id_step = " + idStep;
        ExecSQL(logquery, null, false);
    end;

    return 0;
end;

