/*
    Programmed by: Alexander A. Zaitsev ( BugZ )
    SCR 47318
    Date: 28.10.05
    (+) CheckBalanceConvergence()               - Контроль на сходимость баланса
    (+) CheckAccountInOutRestsConformity()      - Контроль на соответствие входящих и исходящих остатков по л/с
    (+) CheckAccountRestsTurnsConformity()      - Контроль на соответствие остатков и оборотов по л/с
    (+) CheckAccountRestSignConformity()        - Контроль на соответствие признака лицевого счета (А / П) и вида остатка
    (*) CheckBalanceAccountUniqueness()         - Контроль на уникальность б/с
    (+) CheckPairAccountsRests()                - Контроль остатков на парных счетах
    (+) CheckCoverAccountRests()                - Контроль остатков по счетам покрытий
    (*) CheckOffBalanceAccountsCorrespondence() - Контроль корреспонденции счетов по Главе В

    Коркин И.Н. 25.06.2010  По заявке I-032797.
    (*) CheckDocumentsAfterCloseAccount()       - Контроль на проводки выполненые после закрытия счета

    + - используется только вместе с расчетом баланса.
    * - используется с расчетом баланса и как независимая процедура.

*/




import cb_sql, treport, globals;
import FIInter;
import ReptCbInter;
import DepartmentFilter;

class (CTableReport) CGroupingTableReport( Head )
    InitCTableReport(0, false, false );

    private var m_IsFirstString = true;
    private var m_ValuesRow = TArray();
    private var m_Head = Head;


    private macro ClearValuesRow()
        m_ValuesRow = TArray();
    end;

    private macro PrintHeadIfNeeded()
        if ( m_IsFirstString )
            m_IsFirstString = false;
            PrintHead( m_Head );
        end;
    end;

    macro PrintValuesRow()
        if ( not m_IsFirstString )
            PrintStringTransferByWord( m_ValuesRow );
        end;
    end;

    macro PrintBottomIfNeeded()
        if ( not m_IsFirstString  )
            PrintBottom();
        else
            PrintFreeString("Контроль прошел успешно" );
        end;
        [ ];
    end;

    

end;

class (CGroupingTableReport) CGroupingChapterTableReport( Head, chapterFieldNumber )
    InitCGroupingTableReport( Head );

    private var m_ChapterFieldNumber = chapterFieldNumber;
    private var m_ChapterSymbol;

    private macro PrintChapterIfNeeded( chapterSymbol )
        if ( m_ChapterSymbol != chapterSymbol )
            m_ChapterSymbol = chapterSymbol;
            ClearValuesRow();
            m_ValuesRow[m_ChapterFieldNumber] = "Глава " + chapterSymbol;
            PrintValuesRow();
        end;
    end;
    
end;


/* Контроль на сходимость баланса 
   ------------------------------
   Проверяется выполнение следующих условий:
   - сумма остатков по всем активным счетам должна быть равны сумме остатков по всем пассивным счетам;
   - сумма кредитовых оборотов должна быть равны сумме дебетовых оборотов. 
*/
private macro CheckBalanceConvergence()

    var convergenceQuery = 
        " select sum( t_oas  ) sumActive,   " +
        "        sum( t_ops  ) sumPassive,  " +
        "        sum( t__ds  ) sumDebet,    " +
        "        sum( t__ks  ) sumCredit    " +
        " from   dblaccr_tmp                ";

    var convergenceDataSet = TRsbDataSet( convergenceQuery );

    var table;
    var restsDiffers;
    var turnsDiffers;

    PrintLn("КОНТРОЛЬ НА СХОДИМОСТЬ БАЛАНСА");
    

    if ( convergenceDataSet.MoveNext() )
        restsDiffers = ( convergenceDataSet.sumActive != convergenceDataSet.sumPassive );
        turnsDiffers = ( convergenceDataSet.sumDebet != convergenceDataSet.sumCredit   );

        if ( turnsDiffers or restsDiffers )
             table = CTableReport( 0, false, false );
             table.AddColumn( "Глава",                                  3 );
             table.AddColumn( "Код валюты",                             3 );
             table.AddColumn( "Остаток по активу/Обороты по дебету",   25 );
             table.AddColumn( "Остаток по пассиву/Обороты по кредиту", 25 );
             table.AddColumn( "Разность",                              25 );
             table.AddColumn( "Примечание",                            25 );

             table.PrintHead( "Баланс нарушен. Проверьте правильность открытия счетов и отражения операций." );

             if ( restsDiffers )
                table.PrintStringTransferByWord( "Все", 
                                                  string({ISONatCur}),
                                                  convergenceDataSet.sumActive,
                                                  convergenceDataSet.sumPassive,
                                                  abs(convergenceDataSet.sumActive - convergenceDataSet.sumPassive),
                                                  "Расхождение в остатках" );
                                                  
             end;
             if ( turnsDiffers )
                table.PrintStringTransferByWord( "Все", 
                                                  string({ISONatCur}),
                                                  convergenceDataSet.sumDebet,
                                                  convergenceDataSet.sumCredit,
                                                  abs(convergenceDataSet.sumDebet - convergenceDataSet.sumCredit),
                                                  "Расхождение в оборотах" );

             end;

             table.PrintBottom();
        else 
            PrintLn("Контроль прошел успешно.");
        end;
    end;

    PrintLn("");    
    
end;


/* Контроль на соответствие входящих и исходящих остатков по л/с 
   -------------------------------------------------------------
   Для каждого л/с выполняется следующая проверка:
     - входящий остаток по л/с на начало текущего периода должен 
       быть равен исходящему ос-татку по тому же л/с 
       на конец предыдущего периода;
*/
private macro CheckAccountInOutRestsConformity()

    var accountInOutRestsQuery =
        " select  blac.t_account account, " +
        "         blac.t_chapter chapter, " +
        "         decode(ac.t_Kind_Account, 'А', -1, 1) * rsb_account.RestA(blac.t_account, " + GetSqlDate(ДатаОтчетаПП) + ", blac.t_chapter, 0) outRest," +
        "         decode(ac.t_Kind_Account, 'А', blac.t_ias, blac.t_ips) inRest," +
        "         ab.t_Balance" + ЛогическийПланСчетов + "                          balance,        " +
        "         ch.t_symbol                                                       chapterSymbol   " +
        " from dblaccr_tmp      blac,                                                               " +
        "      daccblnc_dbt     ab,                                                                 " +
        "      daccount_dbt     ac,                                                                 " +
        "      dobchaptr_dbt    ch                                                                  " +
        " where ab.t_chapter        = blac.t_chapter                                                " +
        "   and ab.t_account        = blac.t_account                                                " +
        "   and ac.t_chapter        = blac.t_chapter                                                " +
        "   and ac.t_account        = blac.t_account                                                " +
        "   and ab.t_code_currency  = blac.t_code_currency                                          " +
        "   and blac.t_chapter      = ch.t_chapter                                                  " +
        " order by ab.t_chapter,                                                                    " +
        "          ab.t_balance" + ЛогическийПланСчетов +",                                         " +
        "          blac.t_account ";


    var balanceSumsQuery_ =
      " select ar.chapterSymbol,              " +
      "        ar.balance,                    " +
      "        ar.account,                    " +
      "        sum(ar.OutRest) outRest,       " +
      "        sum(ar.InRest)  inRest,        " +
      "        sum(ar.OutRest - ar.InRest) diff " +
      " from ( " + accountInOutRestsQuery + " ) ar  " +
      " group by ar.chapterSymbol,            " +
      "          rollup(ar.balance),          " +
      "          ar.account                   ";

    var balanceSumsQuery =
      " select ar.chapterSymbol,              " +
      "        NVL(ar.balance,CHR(1)) balance,    " +
      "        ar.account,                    " +
      "        ar.outRest,       " +
      "        ar.inRest,        " +
      "        ar.diff           " +
      " from ( " + balanceSumsQuery_ + " ) ar " +
      " where ar.diff != 0 ";
    
        
    var accountInOutRestsDataSet = TRsbDataSet( balanceSumsQuery );

    accountInOutRestsDataSet.SetFieldType("OutRest", V_MONEY);
    accountInOutRestsDataSet.SetFieldType("InRest", V_MONEY);
    accountInOutRestsDataSet.SetFieldType("Diff", V_MONEY);

    PrintLn("КОНТРОЛЬ НА СООТВЕТСТВИЕ ВХОДЯЩИХ И ИСХОДЯЩИХ ОСТАТКОВ ПО ЛИЦЕВЫМ СЧЕТАМ");
    
                
    class (CGroupingChapterTableReport) CAccountInOutRestsConformityReport()
        InitCGroupingChapterTableReport( "По следующим лицевым счета обнаружено расхождение входящих остатков текущего периода и исходящих остатков предыдущего периода. " +
                                         "Проверьте правильность отражения операций по указанным счетам ", 0 );


        AddColumn( "Номер счета",                           25 );
        AddColumn( "Исходящий остаток предыдущего периода", 25 );
        AddColumn( "Входящий остаток текущего периода",     25 );
        AddColumn( "Разность",                              25 );
        
        private const m_Account = 0;
        private const m_OutRest = 1;
        private const m_InRest  = 2;
        private const m_Diff    = 3;

        private var   m_Balance;

       
        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            PrintChapterIfNeeded( r.chapterSymbol );
            if ( r.balance == "" )
                m_ValuesRow[0] = m_Balance;
            else 
                m_ValuesRow[m_Account] = r.account;
            end;
            m_ValuesRow[m_OutRest] = r.outRest;
            m_ValuesRow[m_InRest]  = r.inRest;
            m_ValuesRow[m_Diff]    = r.diff;
            PrintValuesRow();

            m_Balance = r.balance;
        end;


       
    end;

    var table = CAccountInOutRestsConformityReport();

    while( accountInOutRestsDataSet.MoveNext() )
        table.FillFromRecord( accountInOutRestsDataSet.GetRecord() )
    end;
    table.PrintBottomIfNeeded();
        
end;


/* Контроль на соответствие остатков и оборотов по л/с.
   ----------------------------------------------------
   Для каждого л/с выполняется проверка на соответствие 
   остатков и оборотов по л/с: 
   - Исходящий остаток = Входящий остаток + / - Обороты
*/
private macro CheckAccountRestsTurnsConformity()

    var accountRestsTurnsQuery =
        " select blac.t_account     account,                           " +
        "        case                                                  " +
        "            when ac.t_Kind_Account = 'А' then                 " +
        "                blac.t_oas                                    " +
        "            else                                              " +
        "                blac.t_ops                                    " +
        "        end                outRest,                           " +
        "        case                                                  " +
        "            when ac.t_Kind_Account = 'А' then                 " +
        "                blac.t_ias + blac.t__ds - blac.t__ks          " +
        "            else                                              " +
        "                blac.t_ips - blac.t__ds + blac.t__ks          " +
        "        end                outRestCalculated,                 " +
        "        ab.t_Balance" + ЛогическийПланСчетов +" balance,      " +
        "        ch.t_symbol        chapterSymbol,                     " +
        "        ac.t_Kind_Account  kindAccount                        " +
        " from  dblaccr_tmp     blac,                                  " +
        "       daccblnc_dbt    ab,                                    " +
        "       daccount_dbt    ac,                                    " +
        "       dobchaptr_dbt   ch                                     " +
        " where ab.t_chapter       = blac.t_chapter                    " +
        " and   ab.t_account       = blac.t_account                    " +
        " and   ab.t_code_currency = blac.t_code_currency              " +
        " and   blac.t_chapter     = ch.t_chapter                      " +
        " and   ac.t_chapter       = blac.t_chapter                    " +
        " and   ac.t_account       = blac.t_account                    " +
        " order   by ab.t_chapter,                                     " +
        "         ab.t_balance" + ЛогическийПланСчетов + ",            " +
        "         blac.t_account                                       ";

    var nonConformingRestsQuery = 
        " SELECT art.*                                         " +
        " FROM ( " + accountRestsTurnsQuery + " ) art          " +
        " WHERE  outRest != outRestCalculated                   ";
        
    var balanceSumsQuery_ =
        " select nc.chapterSymbol,                             " +
        "        nc.balance,                                   " +
        "        nc.account,                                   " +
        "        sum(nc.outRest)            outRest,           " +
        "        sum(nc.outRestCalculated)  outRestCalculated, " +
        "        sum(nc.outRest-nc.outRestCalculated)  diff    " +
        " from ( " + nonConformingRestsQuery + " ) nc          " +
        " group by nc.chapterSymbol,                           " +
        "          rollup(nc.balance),                         " +
        "          nc.account                                  ";



    var balanceSumsQuery =
      " select nc.chapterSymbol,                " +
      "        NVL(nc.balance,CHR(1)) balance,  " +
      "        nc.account,                      " +
      "        nc.outRest,                      " +
      "        nc.outRestCalculated,            " +
      "        nc.diff                          " +
      " from ( " + balanceSumsQuery_ + " ) nc   ";


    
        
    var accountRestsTurnsDataSet = TRsbDataSet( balanceSumsQuery );

    accountRestsTurnsDataSet.SetFieldType("OutRest", V_MONEY);
    accountRestsTurnsDataSet.SetFieldType("OutRestCalculated", V_MONEY);
    accountRestsTurnsDataSet.SetFieldType("Diff", V_MONEY);

    PrintLn("КОНТРОЛЬ НА СООТВЕТСТВИЕ ОСТАТКОВ И ОБОРОТОВ ПО ЛИЦЕВЫМ СЧЕТАМ");
                
    class (CGroupingChapterTableReport) CAccountInRestsTurnsConformityReport()
        InitCGroupingChapterTableReport( "По следующим лицевым счета обнаружено расхождение между остатками и оборотами." +
                                         "Проверьте правильность отражения операций по указанным счетам ", 0 );


        AddColumn( "Номер счета",                    25 );
        AddColumn( "Исходящий остаток",              25 );
        AddColumn( "Рассчитанный исходящий остаток", 25 );
        AddColumn( "Разность",                       25 );
        
        private const m_Account           = 0;
        private const m_OutRest           = 1;
        private const m_OutRestCalculated = 2;
        private const m_Diff              = 3;

        private var   m_Balance;

       
        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            PrintChapterIfNeeded( r.chapterSymbol );
            if ( r.balance == "" )
                m_ValuesRow[0]                = m_Balance;
            else 
                m_ValuesRow[m_Account]        = r.account;
            end;
            m_ValuesRow[m_OutRest]            = r.outRest;
            m_ValuesRow[m_OutRestCalculated]  = r.outRestCalculated;
            m_ValuesRow[m_Diff]               = r.diff;
            PrintValuesRow();

            m_Balance = r.balance;
        end;


       
    end;

    var table = CAccountInRestsTurnsConformityReport();

    while( accountRestsTurnsDataSet.MoveNext() )
        table.FillFromRecord( accountRestsTurnsDataSet.GetRecord() )
    end;
    table.PrintBottomIfNeeded();
        
end;

/* Контроль на соответствие признака лицевого счета (А / П) и вида остатка
   -----------------------------------------------------------------------
   Проводится контроль на отсутствие "красного сальдо": 
   - по пассивным счетам может быть только кредитовый остаток, 
     по активным счетам ? только дебетовый.
*/
private macro CheckAccountRestSignConformity(processAndExit:bool)

    if (processAndExit == null) processAndExit = true; end;

    var accountRestSignConformityQuery = 
      " select ov.t_account       account,       " +
      "        ov.t_Kind_Account  kindAccount,   " +
      "        ov.t_InRest        inRest,        " +
      "        ov.t_OutRest       outRest,       " +
      "        ch.t_symbol     chapterSymbol     " +
      " from   dblovrd_tmp ov,                   " +
      "        dobchaptr_dbt ch                  " +
      " where  ov.t_chapter = ch.t_chapter       ";
       
    var accountRestSignConformityDataSet = TRsbDataSet( accountRestSignConformityQuery );

    var haveErrors = false;

    accountRestSignConformityDataSet.SetFieldType("OutRest", V_MONEY);

    PrintLn("КОНТРОЛЬ НА СООТВЕТСТВИЕ ПРИЗНАКА СЧЕТА (А / П) И ВИДА ОСТАТКА ПО ЛИЦЕВОМУ СЧЕТУ");
                
    class (CGroupingChapterTableReport) CAccountRestSignConformityReport()
        InitCGroupingChapterTableReport( "По следующим счетам вид остатка не соответствует признаку счета (А/П). " +
                                         "Проверьте правильность отражения операций по указанным счетам.", 0 );


        AddColumn( "№ счета",           25 );
        AddColumn( "Признак",           5 );
        AddColumn( "Входящий остаток",  25 );
        AddColumn( "Исходящий остаток", 25 );
        AddColumn( "Примечание",        25 );
        
        private const m_Account     = 0;
        private const m_KindAccount = 1;
        private const m_InRest      = 2;
        private const m_OutRest     = 3;
        private const m_Comment     = 4;

        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            PrintChapterIfNeeded( r.chapterSymbol );
            m_ValuesRow[m_Account]     = r.account;
            m_ValuesRow[m_KindAccount] = r.kindAccount;
            m_ValuesRow[m_InRest]      = r.inRest;
            m_ValuesRow[m_OutRest]     = r.outRest;
            if ( r.kindAccount == "А" )
                m_ValuesRow[m_Comment]     = "По активному счету кредитовый остаток";
            elif ( r.kindAccount == "П" )
                m_ValuesRow[m_Comment]     = "По пассивному счету дебетовый остаток";
            end;
            PrintValuesRow();
        end;

    end;

    var table = CAccountRestSignConformityReport();

    while( accountRestSignConformityDataSet.MoveNext() )
        table.FillFromRecord( accountRestSignConformityDataSet.GetRecord() );
        haveErrors = true;
    end;
    table.PrintBottomIfNeeded();

    if ((not haveErrors) and processAndExit) 
      УстановитьФлагВозврата( OK_MACRO_FLAG); /* Успешное завершение макроса */
      //exit(1); // KS 10.01.2011 Убрал по I-00134718
    end;
    
end;


/* Контроль на уникальность б/с 
   ----------------------------
   Проводится контроль на уникальность открытых б/с. 
   - Каждый б/с может быть открыт только в одной 
     главе баланса и только один раз; 

*/
private macro CheckBalanceAccountUniqueness()
   
    var balanceChapterQuery = 
        "\n" + "SELECT   t_Balance,  " +
        "\n" + "         t_Chapter   " +
        "\n" + "    FROM dbalance_dbt " +
        "\n" + "   WHERE t_iNumPlan = " + ЛогическийПланСчетов +
        "\n" + "     AND t_Balance IN (SELECT   DISTINCT bl.t_Balance " +
        "\n" + "                           FROM dbalance_dbt  bl," +
        "\n" + "                                dobchaptr_dbt ch " +
        "\n" + "                          WHERE bl.t_iNumPlan = " + ЛогическийПланСчетов +
        "\n" + "                            AND ch.t_chapter  = bl.t_chapter        " +
        "\n" + "                            AND ch.t_ExcludeFromFormalAcnt = CHR(0) " +
        "\n" + "                       GROUP BY bl.t_Balance                        " +
        "\n" + "                         HAVING COUNT(bl.t_Balance) > 1)            " +
        "\n" + "ORDER BY t_balance, t_chapter ";

    var balanceChapterDataSet = TRsbDataSet( balanceChapterQuery );


    PrintLn("КОНТРОЛЬ НА УНИКАЛЬНОСТЬ ОТКРЫТЫХ БАЛАНСОВЫХ СЧЕТОВ");

    class (CGroupingTableReport) CDuplicateBalanceTableReport()
        InitCGroupingTableReport( "Следующие балансовые счета открыты в нескольких главах одновременно. " +
                                  "Проверьте правильность открытия счетов" );
        AddColumn( "Номер б/с",  10 );                                                                                                                       
        AddColumn( "Примечание", 70 );                                                                                                                    


        private const m_Balance = 0;
        private const m_Comment = 1;

        macro FillFromRecord( r )
            if ( m_ValuesRow[m_Balance] != r.balance )
                PrintHeadIfNeeded();
                PrintValuesRow();
                m_ValuesRow[m_Balance] = r.balance;
                m_ValuesRow[m_Comment] = " Балансовый счет открыт в Главе " + r.chapter;
            else
                m_ValuesRow[m_Comment] = m_ValuesRow[m_Comment] + ", Главе " + r.chapter;
            end;
        end;

    end;

    var table = CDuplicateBalanceTableReport();


    while ( balanceChapterDataSet.MoveNext() )
        table.FillFromRecord( balanceChapterDataSet.GetRecord() );
    end;
    table.PrintValuesRow();
    table.PrintBottomIfNeeded();

end;


/* Контроль остатков на парных счетах
   ----------------------------------
   Для каждого лицевого счета, имеющего парный счет, 
   проводится контроль остатков на парных лицевых сче-тах:
   - Остаток может быть только на одном из парных счетов;
*/
private macro CheckPairAccountsRests()

    var pairAccountsRestsQuery =     "WITH pairAccountsWithRepeat AS (SELECT t_chapter,"
                             +"\n"+  "                                        t_code_currency," 
                             +"\n"+  "                                        t_account,"                                         
                             +"\n"+  "                                        t_pairaccount"                                          
                             +"\n"+  "                                   FROM daccount_dbt"
                             +"\n"+  "                                  WHERE t_pairAccount != CHR(1)),"
                             +"\n"+  " pairAccountsWithUniqueField AS (SELECT pairAccountsWithRepeat.*,"
                             +"\n"+  "                                   CASE"
                             +"\n"+  "                                        WHEN t_account < t_pairaccount"
                             +"\n"+  "                                        THEN t_account || t_pairaccount"
                             +"\n"+  "                                        ELSE t_pairaccount || t_account"
                             +"\n"+  "                                   END t_uniquefield"
                             +"\n"+  "                              FROM pairAccountsWithRepeat),"
                             +"\n"+  "           pairAccounts AS (SELECT MIN(t_account) t_account,"
                             +"\n"+  "                                   MAX(t_pairAccount) t_pairAccount,"
                             +"\n"+  "                                   t_chapter,"
                             +"\n"+  "                                   t_code_currency"
                             +"\n"+  "                              FROM pairAccountsWithUniqueField"
                             +"\n"+  "                          GROUP BY t_chapter, t_code_currency, t_uniquefield),"
                             +"\n"+  "             resultData AS (SELECT prac.t_account account,"
                             +"\n"+  "                                   prac.t_pairaccount pairaccount,"
                             +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blac.t_ias, blac.t_ips) restin,"
                             +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blac.t_oas, blac.t_ops) restout,"
                             +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blpr.t_ips, blpr.t_ias) pairrestin,"
                             +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blpr.t_ops, blpr.t_oas) pairrestout,"
                             +"\n"+  "                                   ch.t_symbol chaptersymbol"
                             +"\n"+  "                              FROM pairAccounts prac,"
                             +"\n"+  "                                   daccount_dbt ac,"                                         
                             +"\n"+  "                                   dblaccr_tmp blac,"
                             +"\n"+  "                                   dblaccr_tmp blpr,"
                             +"\n"+  "                                   dobchaptr_dbt ch"
                             +"\n"+  "                             WHERE prac.t_chapter = blac.t_chapter"
                             +"\n"+  "                               AND prac.t_code_currency = blac.t_code_currency"
                             +"\n"+  "                               AND prac.t_account = blac.t_account"
                             +"\n"+  "                               AND prac.t_chapter = blpr.t_chapter"
                             +"\n"+  "                               AND prac.t_code_currency = blpr.t_code_currency"
                             +"\n"+  "                               AND prac.t_pairaccount = blpr.t_account"
                             +"\n"+  "                               AND prac.t_chapter = ch.t_chapter"
                             +"\n"+  "                               AND prac.t_chapter = ac.t_chapter"
                             +"\n"+  "                               AND prac.t_code_currency = ac.t_code_currency"
                             +"\n"+  "                               AND prac.t_account = ac.t_account"
                             +"\n"+  "                               AND blac.t_account <> blpr.t_account)";        

    pairAccountsRestsQuery = pairAccountsRestsQuery
        +"\n"+                    "SELECT *"
        +"\n"+                    "  FROM resultData"
        +"\n"+                    " WHERE (restIn <> 0 AND pairRestIn <> 0) OR (restOut <> 0 AND pairRestOut <> 0)";

    var pairAccountsRestsDataSet = TRsbDataSet(pairAccountsRestsQuery);

    pairAccountsRestsDataSet.SetFieldType("Rest", V_MONEY);
    pairAccountsRestsDataSet.SetFieldType("pairRest", V_MONEY);

    PrintLn("КОНТРОЛЬ ОСТАТКОВ НА ПАРНЫХ СЧЕТАХ");

    class (CGroupingChapterTableReport) CPairAccountsRestsReport()
        InitCGroupingChapterTableReport( "Обнаружены остатки на обоих парных счетах. " +
                                         "Выполните процедуру урегулирования парных счетов", 0 );

        AddColumn( "Номер счета", 25  );
        AddColumn( "Остаток вх",  25 );
        AddColumn( "Остаток исх", 25 );
        AddColumn( "Номер парного счета", 25  );
        AddColumn( "Остаток вх",  25 );
        AddColumn( "Остаток исх", 25 );

        private const m_Account           = 0;
        private const m_Rest              = 1;
        private const m_RestOut           = 2;
        private const m_PairAccount       = 3;
        private const m_PairRest          = 4;
        private const m_PairRestOut       = 5;

        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            PrintChapterIfNeeded( r.chapterSymbol );
            m_ValuesRow[m_Account]     = r.account;
            m_ValuesRow[m_Rest]        = r.restIn;
            m_ValuesRow[m_RestOut]     = r.restOut;
            m_ValuesRow[m_PairAccount] = r.pairAccount;
            m_ValuesRow[m_PairRest]    = r.pairRestIn;
            m_ValuesRow[m_PairRestOut] = r.pairRestOut;
            PrintValuesRow();
        end;


       
    end;


    var table = CPairAccountsRestsReport();


    while( pairAccountsRestsDataSet.MoveNext() )
        table.FillFromRecord( pairAccountsRestsDataSet.GetRecord() )
    end;
    table.PrintBottomIfNeeded();
    
end;


/* Контроль остатков по счетам покрытий
   ------------------------------------
   Для каждого валютного л/с производится контроль соответствия 
   исходящих остатков по валютному счету и по счету покрытия:
   - Остаток по счету покрытия = Остаток по валютному счету * Курс ЦБ 
     на дату окончания отчетного периода по данной валюте.
*/
private macro CheckCoverAccountRests()


    var coverAccountRestsQuery = 
        " select ch.t_symbol                                chapterSymbol,                              " +
            "        fi.t_fiid                                  fiid,                                       " +
            "        fi.t_fi_code                               currencyCode,                               " +
            "        ac.t_account                               account,                                    " +
            "        decode( ba.t_oas, 0, ba.t_ops, ba.t_oas )   coverRest,                                 " +
            "        round( abs( rsb_fiinstr.ConvSum ( rsb_rep_ac.restac( ac.t_account,                     " +
        "                                                             acc.t_code_currency,              " +
        "                                                         " + GetSqlDate( ДатаОтчета ) + ",     " +
        "                                                             ac.t_chapter,                     " +
        "                                                             ac.t_r0 ),                        " +
                "                                          acc.t_code_currency,                                 " +
                "                                          0,                                                   " +
                "                                      " + GetSqlDate( ДатаОтчета ) + ") ),                     " +
        "               2 )                                 coverRestCalculated                         " +
        " from dblaccr_tmp      ba,                                                                     " +
        "      daccount_dbt     ac,                                                                     " +
        "      daccount$_dbt    acc,                                                                    " +
        "      dfininstr_dbt    fi,                                                                     " +
        "      dobchaptr_dbt    ch                                                                      " +
        " where ac.t_chapter      = ba.t_chapter                                                        " +
        " and   ac.t_account      = ba.t_account                                                        " +
        " and   ac.t_type_account = 'П'                                                                 " +
        " and   ac.t_account      = acc.t_connect_account                                               " +
        " and   fi.t_fiid         = acc.t_code_currency                                                 " +
        " and   ac.t_chapter      = ch.t_chapter                                                        " +
        " order by fi.t_fiid,                                                                           " +
                "          ch.t_chapter,                                                                        " +
                "          ac.t_account                                                                         ";

    

    var nonConformingQuery =
        " SELECT nc.*,                                           " +
        "        abs(nc.coverRestCalculated-nc.coverRest) diff   " +
        " FROM ( " + coverAccountRestsQuery + " ) nc             " +
        " WHERE nc.coverRestCalculated - nc.coverRest != 0       ";

    

    var coverAccountRestsDataSet = TRsbDataSet( nonConformingQuery );
                
    coverAccountRestsDataSet.SetFieldType("CoverRest", V_MONEY);
    coverAccountRestsDataSet.SetFieldType("CoverRestCalculated", V_MONEY);
    coverAccountRestsDataSet.SetFieldType("Diff", V_MONEY);

    PrintLn( "КОНТРОЛЬ ОСТАТКОВ ПО СЧЕТАМ ПОКРЫТИЙ" );

    class (CGroupingChapterTableReport) CCoverAccountRestsReport()
        InitCGroupingChapterTableReport( "По следующим лицевым счетам остаток по счету покрытия не соответствует остатку по валютному счету. " +
                                         "Выполните процедуру урегулирования покрытий ", 0 );

        AddColumn( "Номер счета",                    25 );
        AddColumn( "Остаток по покрытию",            25 );
        AddColumn( "Пересчитанный валютный остаток", 25 );
        AddColumn( "Разность",                       25 );
        
        private const m_Account             = 0;
        private const m_СoverRest           = 1;
        private const m_СoverRestCalculated = 2;
        private const m_Diff                = 3;

        private var   m_fiid;


        private macro GetCbRateString( fiid )

            record rate( ratedef );
            var rateString = "";
    
            if ( ПолучитьКурс( rate,  0, fiid ) == 0 ) 
                if ( ПолучитьЗначениеКурса( rate, ДатаОтчета ) == 0 )
                    ПолучитьСтрокуЗначенияКурса( rate, 1, rateString );
                end;
            end;

            return rateString;
           
        end;


        private macro PrintCurrencyIfNeeded( fiid, currencyCode )
            var rate;
            if ( m_fiid != fiid )
                rate = GetCbRateString( fiid );
                ClearValuesRow();
                m_ValuesRow[0] = string( "Код валюты ", currencyCode ) ;
                m_ValuesRow[1] = string( "Курс ЦБ ",    rate ) ;
                PrintValuesRow();
                m_fiid = fiid;
            end;
        end;

       
        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            PrintCurrencyIfNeeded( r.fiid, r.currencyCode );
            PrintChapterIfNeeded(  r.chapterSymbol );
            m_ValuesRow[m_Account]             = r.account;
            m_ValuesRow[m_СoverRest]           = r.coverRest;
            m_ValuesRow[m_СoverRestCalculated] = r.coverRestCalculated;
            m_ValuesRow[m_Diff]                = r.diff;
            PrintValuesRow();
        end;


       
    end;

    var table = CCoverAccountRestsReport();

    while( coverAccountRestsDataSet.MoveNext() )
        table.FillFromRecord( coverAccountRestsDataSet.GetRecord() )
    end;
    table.PrintBottomIfNeeded();
        

end;


/* Контроль корреспонденции счетов по Главе В
   ------------------------------------------
   Проводится контроль корреспонденции счетов по проводкам Главы В:
   - Счет, открытый на б/с 99998, может использоваться для корреспонденции с пассивными счетами;
   - Счет, открытый на б/с 99999, может использоваться для корреспонденции с активными счетами.
*/
private macro CheckOffBalanceAccountsCorrespondence()

    macro GetOffBalanceAccountsCorrespondenceQuery()
        var query =
             "\n" + "SELECT   doc.t_Numb_Document    documentNumber," +
             "\n" + "         doc.t_Date_Carry       dateCarry,     " +
             "\n" + "         doc.t_Sum              sumCarry,      " +
             "\n" + "         doc.t_Account_Payer    debet,         " +
             "\n" + "         doc.t_Account_Receiver credit         " +
             "\n" + "    FROM darhdoc_dbt  doc,                     " +
             "\n" + "         daccount_dbt acp,                     " +
             "\n" + "         daccount_dbt acr,                     " +
             "\n" + "         daccblnc_dbt abp,                     " +
             "\n" + "         daccblnc_dbt abr                      " +
             "\n" + "   WHERE doc.t_Chapter = 3                     " +
             "\n" + "     AND doc.t_Result_Carry != 23              " +
             "\n" + "     AND doc.t_Date_Carry BETWEEN " + GetSqlDate(ПредДатаОтчета) +
             "\n" + "                              AND " + GetSqlDate(ДатаОтчета) +
             "\n" + "     AND abp.t_Account = doc.t_Account_Payer   " +
             "\n" + "     AND abp.t_Chapter = doc.t_Chapter         " +
             "\n" + "     AND abr.t_Account = doc.t_Account_Receiver" +
             "\n" + "     AND abr.t_Chapter = doc.t_Chapter         " +
             "\n" + "     AND acp.t_Account = abp.t_Account         " +
             "\n" + "     AND acp.t_Chapter = abp.t_Chapter         " +
             "\n" + "     AND acr.t_Account = abr.t_Account         " +
             "\n" + "     AND acr.t_Chapter = abr.t_Chapter         " +
//             "\n" + "     AND " + RcbBranchAndDepartmentFieldFilter().GetAsSqlString("acp.t_department", "acp.t_branch") +
//             "\n" + "     AND " + RcbBranchAndDepartmentFieldFilter().GetAsSqlString("acr.t_department", "acr.t_branch") +
             "\n" + "     AND (    (abp.t_Balance" + ЛогическийПланСчетов + " = '99998' AND (acr.t_Kind_Account != 'П' OR abr.t_Balance" + ЛогическийПланСчетов + " = '99999')) " +
             "\n" + "           OR (abr.t_Balance" + ЛогическийПланСчетов + " = '99998' AND (acp.t_Kind_Account != 'П' OR abp.t_Balance" + ЛогическийПланСчетов + " = '99999')) " +
             "\n" + "           OR (abp.t_Balance" + ЛогическийПланСчетов + " = '99999' AND (acr.t_Kind_Account != 'А' OR abr.t_Balance" + ЛогическийПланСчетов + " = '99998')) " +
             "\n" + "           OR (abr.t_Balance" + ЛогическийПланСчетов + " = '99999' AND (acp.t_Kind_Account != 'А' OR abp.t_Balance" + ЛогическийПланСчетов + " = '99998')))";
             "\n" + "ORDER BY dateCarry, sumCarry";

        return query;     
    end;

    var offBalanceAccountsCorrespondenceDataSet = TRsbDataSet(GetOffBalanceAccountsCorrespondenceQuery());

    offBalanceAccountsCorrespondenceDataSet.SetFieldType("SumCarry", V_MONEY);

    PrintLn( "КОНТРОЛЬ КОРРЕСПОНДЕНЦИИ СЧЕТОВ ПО ГЛАВЕ В" );
                
    class (CGroupingTableReport) COffBalanceAccountsCorrespondenceReport()
        InitCGroupingTableReport( "<Глава В. Нарушена корреспонденция счетов. " +
                                  " Проверьте правильность отражения следующих операций:> " );


        AddColumn( "№ док",           10 );
        AddColumn( "Дата док-та",     12 );
        AddColumn( "Сумма док-та",    25 );
        AddColumn( "Счет по дебету",  25 );
        AddColumn( "Счет по кредиту", 25 );
        
        private const m_DocumentNumber    = 0;
        private const m_DateCarry         = 1;
        private const m_SumCarry          = 2;
        private const m_Debet             = 3;
        private const m_Credit            = 4;
        
        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            m_ValuesRow[m_DocumentNumber]   = r.documentNumber;
            m_ValuesRow[m_DateCarry]        = Date(r.dateCarry);
            m_ValuesRow[m_SumCarry]         = r.sumCarry;
            m_ValuesRow[m_Debet]            = r.debet;
            m_ValuesRow[m_Credit]           = r.credit;
            PrintValuesRow();
        end;


       
    end;


    var table = COffBalanceAccountsCorrespondenceReport();

    while( offBalanceAccountsCorrespondenceDataSet.MoveNext() )
        table.FillFromRecord( offBalanceAccountsCorrespondenceDataSet.GetRecord() )
    end;
    table.PrintBottomIfNeeded();
    
end;


/* Коркин И.Н. По заявке I-032797.
	Контроль на проводки выполненые после закрытия счета. По главам 1 и 3.
   -----------------------------------------------------------------------
   Проводится контроль по дате проводки и датам закрытия участвующих счетов
*/
private macro CheckDocumentsAfterCloseAccount()

    var accountRestSignConformityQuery = " SELECT   ARHDOC.T_NUMB_DOCUMENT numbdocument, "
    + "\n" + "         ARHDOC.T_ACCOUNT_PAYER payer, "
    + "\n" + "         ARHDOC.T_ACCOUNT_RECEIVER receiver, "
    + "\n" + "         ARHDOC.T_SUM sum, "
    + "\n" + "         ARHDOC.T_OPER oper"
    + "\n" + "  FROM   darhdoc_dbt arhdoc "
    + "\n" + " WHERE   arhdoc.t_chapter = 1 "
    + "\n" + "         AND EXISTS "
    + "\n" + "               (SELECT   1 "
    + "\n" + "                  FROM   daccount_dbt account "
    + "\n" + "                 WHERE   ARHDOC.T_ACCOUNT_payer = ACCOUNT.T_ACCOUNT "
    + "\n" + "                         AND ARHDOC.T_DATE_CARRY > ACCOUNT.T_CLOSE_DATE "
    + "\n" + "                         AND ACCOUNT.T_CLOSE_DATE > "
    + "\n" + "                               TO_DATE ('01.01.0001', 'dd.mm.yyyy')) "
    + "\n" + "         AND ARHDOC.T_DATE_CARRY BETWEEN " + GetSqlDate(ПредДатаОтчета)
    + "\n" + "                                     AND " + GetSqlDate(ДатаОтчета)
    + "\n" + "UNION ALL "
    + "\n" + "SELECT   ARHDOC.T_NUMB_DOCUMENT numbdocument, "
    + "\n" + "         ARHDOC.T_ACCOUNT_PAYER payer, "
    + "\n" + "         ARHDOC.T_ACCOUNT_RECEIVER receiver, "
    + "\n" + "         ARHDOC.T_SUM sum, "
    + "\n" + "         ARHDOC.T_OPER oper"
    + "\n" + "  FROM   darhdoc_dbt arhdoc "
    + "\n" + " WHERE   arhdoc.t_chapter = 3 "
    + "\n" + "         AND EXISTS "
    + "\n" + "               (SELECT   1 "
    + "\n" + "                  FROM   daccount_dbt account "
    + "\n" + "                 WHERE   ARHDOC.T_ACCOUNT_payer = ACCOUNT.T_ACCOUNT "
    + "\n" + "                         AND ARHDOC.T_DATE_CARRY > ACCOUNT.T_CLOSE_DATE "
    + "\n" + "                         AND ACCOUNT.T_CLOSE_DATE > "
    + "\n" + "                               TO_DATE ('01.01.0001', 'dd.mm.yyyy')) "
    + "\n" + "         AND ARHDOC.T_DATE_CARRY BETWEEN " + GetSqlDate(ПредДатаОтчета)
    + "\n" + "                                     AND " + GetSqlDate(ДатаОтчета);

    var accountRestSignConformityDataSet = TRsbDataSet( accountRestSignConformityQuery );

    PrintLn("КОНТРОЛЬ НА ПРОВОДКИ ВЫПОЛНЕННЫЕ ПОСЛЕ ЗАКРЫТИЯ СЧЕТА");
                
    class (CGroupingChapterTableReport) CAccountRestSignConformityReport()
        InitCGroupingChapterTableReport( "Следующие проводки выполнены после закрытия участвующего счета " +
                                         "и не участвуют в расчете.", 0 );


        AddColumn( "№ Док.",           11 );
        AddColumn( "Плательщик",       25 );
        AddColumn( "Получатель",       25 );
        AddColumn( "Сумма",            25 );
        AddColumn( "Операционист",      5 );
        
        private const m_Num      = 0;
        private const m_payer    = 1;
        private const m_receiver = 3;
        private const m_sum      = 4;
        private const m_oper     = 5;
        
        macro FillFromRecord( r )
            PrintHeadIfNeeded();
            m_ValuesRow[m_Num]      = r.numbdocument;
            m_ValuesRow[m_payer]    = r.payer;
            m_ValuesRow[m_receiver] = r.receiver;
            m_ValuesRow[m_sum]      = r.sum;
            m_ValuesRow[m_oper]     = r.oper;
            PrintValuesRow();
        end;
    end;

    var table = CAccountRestSignConformityReport();

    while( accountRestSignConformityDataSet.MoveNext() )
        table.FillFromRecord( accountRestSignConformityDataSet.GetRecord() )
    end;
    table.PrintBottomIfNeeded();
end;

private macro ControlBalance()

    [ # ] ( "БАЛАНС КРЕДИТНОЙ ОРГАНИЗАЦИИ" );
    [ # ] ( "ПРОТОКОЛ РАСЧЕТА" );
    [ Дата и время выпуска отчета ########## ########## ] ( date(), time() );
    [ Исполнитель # ] ( Исполнитель );
    [ ];

    CheckBalanceConvergence();               
    CheckAccountInOutRestsConformity();      
    CheckAccountRestsTurnsConformity();      
    CheckAccountRestSignConformity();        
    CheckBalanceAccountUniqueness();         
//    CheckPairAccountsRests();                
//    CheckCoverAccountRests();                
    CheckOffBalanceAccountsCorrespondence(); 
    /* Коркин И.Н. По заявке I-032797. */
	 CheckDocumentsAfterCloseAccount();
    
end;
