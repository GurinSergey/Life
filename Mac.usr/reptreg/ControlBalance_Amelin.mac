/*********************************************************************************************************************/
//  Всякие проверки Ф 101    
//  27.07.2012  Amelin A.N.  
/*          
Контроль на проводки выполненые после закрытия счета. По главам 1 и 3.
 Проводится контроль корреспонденции счетов по проводкам Главы В:
   - Счет, открытый на б/с 99998, может использоваться для корреспонденции с пассивными счетами;
   - Счет, открытый на б/с 99999, может использоваться для корреспонденции с активными счетами.
 ---------------------------------------------------------------------------------------------------
 Контроль остатков по счетам покрытий
   Для каждого валютного л/с производится контроль соответствия исходящих остатков по валютному счету и по счету покрытия:
   - Остаток по счету покрытия = Остаток по валютному счету * Курс ЦБ на дату окончания отчетного периода по данной валюте.
 ---------------------------------------------------------------------------------------------------
 Контроль остатков на парных счетах
   Для каждого лицевого счета, имеющего парный счет, проводится контроль остатков на парных лицевых сче-тах:
   - Остаток может быть только на одном из парных счетов;
---------------------------------------------------------------------------------------------------
 Контроль на уникальность б/с 
 Проводится контроль на уникальность открытых б/с. 
   - Каждый б/с может быть открыт только в одной главе баланса и только один раз; 
 ---------------------------------------------------------------------------------------------------
 Контроль на соответствие признака лицевого счета (А / П) и вида остатка
 Проводится контроль на отсутствие "красного сальдо": 
   - по пассивным счетам может быть только кредитовый остаток, по активным счетам ? только дебетовый.
 ---------------------------------------------------------------------------------------------------
 Контроль на соответствие остатков и оборотов по л/с.
 Для каждого л/с выполняется проверка на соответствие остатков и оборотов по л/с: 
   - Исходящий остаток = Входящий остаток + / - Обороты
 ---------------------------------------------------------------------------------------------------
 Контроль на соответствие входящих и исходящих остатков по л/с 
   Для каждого л/с выполняется следующая проверка:
     - входящий остаток по л/с на начало текущего периода должен быть равен исходящему ос-татку по тому же л/с 
       на конец предыдущего периода;
 ---------------------------------------------------------------------------------------------------
 Контроль на сходимость баланса 
   Проверяется выполнение следующих условий:
   - сумма остатков по всем активным счетам должна быть равны сумме остатков по всем пассивным счетам;
   - сумма кредитовых оборотов должна быть равны сумме дебетовых оборотов. 
 ---------------------------------------------------------------------------------------------------
 ВАЛЮТНЫЕ ПРОВОДКИ, КОТОРЫМ НЕ СООТВЕТСТВУЮТ ПРОВОДКИ ПОКРЫТИЯ
 ПРОВОДКИ, У КОТОРЫХ СЧЕТ ПЛАТЕЛЬЩИКА ИЛИ СЧЕТ ПОЛУЧАТЕЛЯ НЕ ПРИВЯЗАН К КЛИЕНТУ ИЛИ ПРИВЯЗАН НЕВЕРНО
 ПРОВОДКИ, ДАТА КОТОРЫХ БОЛЬШЕ ИЛИ РАВНА ДАТЕ ЗАКРЫТИЯ СЧЕТА (ПОЛУЧАТЕЛЯ ИЛИ ПЛАТЕЛЬЩИКА)
 СЧЕТА ПОКРЫТИЯ, КОТОРЫЕ ПРИВЯЗАНЫ БОЛЕЕ ЧЕМ К ОДНОМУ ВАЛЮТНОМУ СЧЕТУ
 НЕ КАССОВЫЕ ПРОВОДКИ, ИМЕЮЩИЕ КАССОВЫЙ СИМВОЛ
 ВАЛЮТНЫЕ СЧЕТА, ИМЕЮЩИЕ НЕ СУЩЕСТВУЮЩИЕ СЧЕТА ПОКРЫТИЯ
 ВАЛЮТНЫЕ СЧЕТА, ИМЕЮЩИЕ БОЛЕЕ ОДНОГО СЧЕТА ПОКРЫТИЯ
 СЧЕТА ПОКРЫТИЯ, СВЯЗАННЫЕ БОЛЕЕ ЧЕМ С ОДНИМ ВАЛЮТНЫМ СЧЕТОМ
 ВАЛЮТНЫЕ СЧЕТА, КОТОРЫЕ НЕ ИМЕЮТ СЧЕТА ПОКРЫТИЯ
 СЧЕТА ПОКРЫТИЯ, НА КОТОРЫХ НЕ СТОИТ ПРИЗНАК ПОКРЫТИЯ
 РУБЛЕВЫЕ СЧЕТА, НА КОТОРЫХ СТОИТ ПРИЗНАК ПОКРЫТИЯ
 
 ТАБЛИЦА drestdate_dbt ВЫБИРАЕМ ЗАПИСИ С НЕПРАВИЛЬНЫМИ ОСТАТКАМИ ВХ\ВЫХ И ОБОРОТЫ, ПРОВЕРЯЕМ ПО ПРОВОДАМ 
  */
/*********************************************************************************************************************/

import cb_sql, treport, globals, FIInter, ReptCbInter, DepartmentFilter;
import rslx, RSD, RsbDataSet, RcbCoreInter, rsbdataset, OprInter, "VBAconst.mac", rsexts, payminter, pm_note;

var kolwo:integer, rs, str, kolwo_all:integer, period = RcbApplication.currentReport.context.period;
var t5=ctablereport,
    t6=ctablereport,
    t7=ctablereport,
    t8=ctablereport,
    ob,ex,nmob,nmtlg,DecimalSeparator,m_path, gol:string;

class (CTableReport) CGroupingTableReport( Head )
   InitCTableReport(0, false, false );
   private var m_IsFirstString = true;
   private var m_ValuesRow = TArray();
   private var m_Head = Head;

   private macro ClearValuesRow()
       m_ValuesRow = TArray();
   end;

   private macro PrintHeadIfNeeded()
       if ( m_IsFirstString )
           m_IsFirstString = false;
           PrintHead( m_Head );
       end;
   end;

   macro PrintValuesRow()
       if ( not m_IsFirstString )
           PrintStringTransferByWord( m_ValuesRow );
       end;
   end;

   macro PrintBottomIfNeeded()
       if ( not m_IsFirstString  )
           PrintBottom();
       else
           PrintFreeString("Контроль прошел успешно" );
       end;
       [ ];
   end;

end;

class (CGroupingTableReport) CGroupingChapterTableReport( Head, chapterFieldNumber )
   InitCGroupingTableReport( Head );
   private var m_ChapterFieldNumber = chapterFieldNumber;
   private var m_ChapterSymbol;

   private macro PrintChapterIfNeeded( chapterSymbol )
       if ( m_ChapterSymbol != chapterSymbol )
           m_ChapterSymbol = chapterSymbol;
           ClearValuesRow();
           m_ValuesRow[m_ChapterFieldNumber] = "Глава " + chapterSymbol;
           PrintValuesRow();
       end;
   end;
end;

/* Контроль на сходимость баланса 
   ------------------------------
   Проверяется выполнение следующих условий:
   - сумма остатков по всем активным счетам должна быть равны сумме остатков по всем пассивным счетам;
   - сумма кредитовых оборотов должна быть равны сумме дебетовых оборотов. 
*/
private macro CheckBalanceConvergence()

   var convergenceQuery = 
      " select sum( t_oas  ) sumActive,   " +
      "        sum( t_ops  ) sumPassive,  " +
      "        sum( t__ds  ) sumDebet,    " +
      "        sum( t__ks  ) sumCredit    " +
      " from   dblaccr_tmp                ";
   var convergenceDataSet = TRsbDataSet( convergenceQuery );
   var table, restsDiffers, turnsDiffers;

   PrintLn("КОНТРОЛЬ НА СХОДИМОСТЬ БАЛАНСА");
   if ( convergenceDataSet.MoveNext() )
      restsDiffers = ( convergenceDataSet.sumActive != convergenceDataSet.sumPassive );
      turnsDiffers = ( convergenceDataSet.sumDebet != convergenceDataSet.sumCredit   );
      if ( turnsDiffers or restsDiffers )
         table = CTableReport( 0, false, false );
         table.AddColumn( "Глава",                                  3 );
         table.AddColumn( "Код валюты",                             3 );
         table.AddColumn( "Остаток по активу/Обороты по дебету",   25 );
         table.AddColumn( "Остаток по пассиву/Обороты по кредиту", 25 );
         table.AddColumn( "Разность",                              25 );
         table.AddColumn( "Примечание",                            25 );
         table.PrintHead( "Баланс нарушен. Проверьте правильность открытия счетов и отражения операций." );
         if ( restsDiffers )
            table.PrintStringTransferByWord( "Все", 
                                              string({ISONatCur}),
                                              convergenceDataSet.sumActive,
                                              convergenceDataSet.sumPassive,
                                              abs(convergenceDataSet.sumActive - convergenceDataSet.sumPassive),
                                              "Расхождение в остатках" );
         end;
         if ( turnsDiffers )
            table.PrintStringTransferByWord( "Все", 
                                              string({ISONatCur}),
                                              convergenceDataSet.sumDebet,
                                              convergenceDataSet.sumCredit,
                                              abs(convergenceDataSet.sumDebet - convergenceDataSet.sumCredit),
                                              "Расхождение в оборотах" );
         end;
         table.PrintBottom();
      else 
         PrintLn("Контроль прошел успешно.");
      end;
   end;
   PrintLn("");
end;

/* Контроль на соответствие входящих и исходящих остатков по л/с 
   -------------------------------------------------------------
   Для каждого л/с выполняется следующая проверка:
     - входящий остаток по л/с на начало текущего периода должен 
       быть равен исходящему ос-татку по тому же л/с 
       на конец предыдущего периода;
*/
private macro CheckAccountInOutRestsConformity()

   var accountInOutRestsQuery =
      " select  blac.t_account account, " +
      "         blac.t_chapter chapter, " +
      "         decode(ac.t_Kind_Account, 'А', -1, 1) * rsb_account.RestA(blac.t_account, " + GetSqlDate(ДатаОтчетаПП) + ", blac.t_chapter, 0) outRest," +
      "         decode(ac.t_Kind_Account, 'А', blac.t_ias, blac.t_ips) inRest," +
      "         ab.t_Balance" + ЛогическийПланСчетов + "                          balance,        " +
      "         ch.t_symbol                                                       chapterSymbol   " +
      " from dblaccr_tmp      blac,                                                               " +
      "      daccblnc_dbt     ab,                                                                 " +
      "      daccount_dbt     ac,                                                                 " +
      "      dobchaptr_dbt    ch                                                                  " +
      " where ab.t_chapter        = blac.t_chapter                                                " +
      "   and ab.t_account        = blac.t_account                                                " +
      "   and ac.t_chapter        = blac.t_chapter                                                " +
      "   and ac.t_account        = blac.t_account                                                " +
      "   and ab.t_code_currency  = blac.t_code_currency                                          " +
      "   and blac.t_chapter      = ch.t_chapter                                                  " +
      " order by ab.t_chapter,                                                                    " +
      "          ab.t_balance" + ЛогическийПланСчетов +",                                         " +
      "          blac.t_account ";
   var balanceSumsQuery_ =
      " select ar.chapterSymbol,              " +
      "        ar.balance,                    " +
      "        ar.account,                    " +
      "        sum(ar.OutRest) outRest,       " +
      "        sum(ar.InRest)  inRest,        " +
      "        sum(ar.OutRest - ar.InRest) diff " +
      " from ( " + accountInOutRestsQuery + " ) ar  " +
      " group by ar.chapterSymbol,            " +
      "          rollup(ar.balance),          " +
      "          ar.account                   ";

   var balanceSumsQuery =
      " select ar.chapterSymbol,              " +
      "        NVL(ar.balance,CHR(1)) balance,    " +
      "        ar.account,                    " +
      "        ar.outRest,       " +
      "        ar.inRest,        " +
      "        ar.diff           " +
      " from ( " + balanceSumsQuery_ + " ) ar " +
      " where ar.diff != 0 ";
   var accountInOutRestsDataSet = TRsbDataSet( balanceSumsQuery );
   accountInOutRestsDataSet.SetFieldType("OutRest", V_MONEY);
   accountInOutRestsDataSet.SetFieldType("InRest", V_MONEY);
   accountInOutRestsDataSet.SetFieldType("Diff", V_MONEY);
   PrintLn("КОНТРОЛЬ НА СООТВЕТСТВИЕ ВХОДЯЩИХ И ИСХОДЯЩИХ ОСТАТКОВ ПО ЛИЦЕВЫМ СЧЕТАМ");

   class (CGroupingChapterTableReport) CAccountInOutRestsConformityReport()
      InitCGroupingChapterTableReport( "По следующим лицевым счета обнаружено расхождение входящих остатков текущего периода и исходящих остатков предыдущего периода. " +
                                       "Проверьте правильность отражения операций по указанным счетам ", 0 );
      AddColumn( "Номер счета",                           25 );
      AddColumn( "Исходящий остаток предыдущего периода", 25 );
      AddColumn( "Входящий остаток текущего периода",     25 );
      AddColumn( "Разность",                              25 );
      private const m_Account = 0;
      private const m_OutRest = 1;
      private const m_InRest  = 2;
      private const m_Diff    = 3;
      private var   m_Balance;
      
      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         PrintChapterIfNeeded( r.chapterSymbol );
         if ( r.balance == "" )
             m_ValuesRow[0] = m_Balance;
         else 
             m_ValuesRow[m_Account] = r.account;
         end;
         m_ValuesRow[m_OutRest] = r.outRest;
         m_ValuesRow[m_InRest]  = r.inRest;
         m_ValuesRow[m_Diff]    = r.diff;
         PrintValuesRow();
         m_Balance = r.balance;
      end;
   end;
   var table = CAccountInOutRestsConformityReport();

   while( accountInOutRestsDataSet.MoveNext() )
      table.FillFromRecord( accountInOutRestsDataSet.GetRecord() )
   end;
   table.PrintBottomIfNeeded();
end;

/* Контроль на соответствие остатков и оборотов по л/с.
   ----------------------------------------------------
   Для каждого л/с выполняется проверка на соответствие 
   остатков и оборотов по л/с: 
   - Исходящий остаток = Входящий остаток + / - Обороты
*/
private macro CheckAccountRestsTurnsConformity()

   var accountRestsTurnsQuery =
      " select blac.t_account     account,                           " +
      "        case                                                  " +
      "            when ac.t_Kind_Account = 'А' then                 " +
      "                blac.t_oas                                    " +
      "            else                                              " +
      "                blac.t_ops                                    " +
      "        end                outRest,                           " +
      "        case                                                  " +
      "            when ac.t_Kind_Account = 'А' then                 " +
      "                blac.t_ias + blac.t__ds - blac.t__ks          " +
      "            else                                              " +
      "                blac.t_ips - blac.t__ds + blac.t__ks          " +
      "        end                outRestCalculated,                 " +
      "        ab.t_Balance" + ЛогическийПланСчетов +" balance,      " +
      "        ch.t_symbol        chapterSymbol,                     " +
      "        ac.t_Kind_Account  kindAccount                        " +
      " from  dblaccr_tmp     blac,                                  " +
      "       daccblnc_dbt    ab,                                    " +
      "       daccount_dbt    ac,                                    " +
      "       dobchaptr_dbt   ch                                     " +
      " where ab.t_chapter       = blac.t_chapter                    " +
      " and   ab.t_account       = blac.t_account                    " +
      " and   ab.t_code_currency = blac.t_code_currency              " +
      " and   blac.t_chapter     = ch.t_chapter                      " +
      " and   ac.t_chapter       = blac.t_chapter                    " +
      " and   ac.t_account       = blac.t_account                    " +
      " order   by ab.t_chapter,                                     " +
      "         ab.t_balance" + ЛогическийПланСчетов + ",            " +
      "         blac.t_account                                       ";
   var nonConformingRestsQuery = 
      " SELECT art.*                                         " +
      " FROM ( " + accountRestsTurnsQuery + " ) art          " +
      " WHERE  outRest != outRestCalculated                   ";
   var balanceSumsQuery_ =
      " select nc.chapterSymbol,                             " +
      "        nc.balance,                                   " +
      "        nc.account,                                   " +
      "        sum(nc.outRest)            outRest,           " +
      "        sum(nc.outRestCalculated)  outRestCalculated, " +
      "        sum(nc.outRest-nc.outRestCalculated)  diff    " +
      " from ( " + nonConformingRestsQuery + " ) nc          " +
      " group by nc.chapterSymbol,                           " +
      "          rollup(nc.balance),                         " +
      "          nc.account                                  ";
   var balanceSumsQuery =
      " select nc.chapterSymbol,                " +
      "        NVL(nc.balance,CHR(1)) balance,  " +
      "        nc.account,                      " +
      "        nc.outRest,                      " +
      "        nc.outRestCalculated,            " +
      "        nc.diff                          " +
      " from ( " + balanceSumsQuery_ + " ) nc   ";
   var accountRestsTurnsDataSet = TRsbDataSet( balanceSumsQuery );
   accountRestsTurnsDataSet.SetFieldType("OutRest", V_MONEY);
   accountRestsTurnsDataSet.SetFieldType("OutRestCalculated", V_MONEY);
   accountRestsTurnsDataSet.SetFieldType("Diff", V_MONEY);
   PrintLn("КОНТРОЛЬ НА СООТВЕТСТВИЕ ОСТАТКОВ И ОБОРОТОВ ПО ЛИЦЕВЫМ СЧЕТАМ");
   class (CGroupingChapterTableReport) CAccountInRestsTurnsConformityReport()
      InitCGroupingChapterTableReport( "По следующим лицевым счета обнаружено расхождение между остатками и оборотами." +
                                       "Проверьте правильность отражения операций по указанным счетам ", 0 );
      AddColumn( "Номер счета",                    25 );
      AddColumn( "Исходящий остаток",              25 );
      AddColumn( "Рассчитанный исходящий остаток", 25 );
      AddColumn( "Разность",                       25 );
      private const m_Account           = 0;
      private const m_OutRest           = 1;
      private const m_OutRestCalculated = 2;
      private const m_Diff              = 3;
      private var   m_Balance;
      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         PrintChapterIfNeeded( r.chapterSymbol );
         if ( r.balance == "" )
            m_ValuesRow[0]                = m_Balance;
         else 
            m_ValuesRow[m_Account]        = r.account;
         end;
         m_ValuesRow[m_OutRest]            = r.outRest;
         m_ValuesRow[m_OutRestCalculated]  = r.outRestCalculated;
         m_ValuesRow[m_Diff]               = r.diff;
         PrintValuesRow();
         m_Balance = r.balance;
      end;
   end;
   var table = CAccountInRestsTurnsConformityReport();
   while( accountRestsTurnsDataSet.MoveNext() )
      table.FillFromRecord( accountRestsTurnsDataSet.GetRecord() )
   end;
   table.PrintBottomIfNeeded();
end;

/* Контроль на соответствие признака лицевого счета (А / П) и вида остатка
   -----------------------------------------------------------------------
   Проводится контроль на отсутствие "красного сальдо": 
   - по пассивным счетам может быть только кредитовый остаток, 
     по активным счетам ? только дебетовый.
*/
private macro CheckAccountRestSignConformity(processAndExit:bool)

   if (processAndExit == null) processAndExit = true; end;
   var accountRestSignConformityQuery = 
      " select ov.t_account       account,       " +
      "        ov.t_Kind_Account  kindAccount,   " +
      "        ov.t_InRest        inRest,        " +
      "        ov.t_OutRest       outRest,       " +
      "        ch.t_symbol     chapterSymbol     " +
      " from   dblovrd_tmp ov,                   " +
      "        dobchaptr_dbt ch                  " +
      " where  ov.t_chapter = ch.t_chapter       ";
   var accountRestSignConformityDataSet = TRsbDataSet( accountRestSignConformityQuery );
   var haveErrors = false;
   accountRestSignConformityDataSet.SetFieldType("OutRest", V_MONEY);
   PrintLn("КОНТРОЛЬ НА СООТВЕТСТВИЕ ПРИЗНАКА СЧЕТА (А / П) И ВИДА ОСТАТКА ПО ЛИЦЕВОМУ СЧЕТУ");

   class (CGroupingChapterTableReport) CAccountRestSignConformityReport()
      InitCGroupingChapterTableReport( "По следующим счетам вид остатка не соответствует признаку счета (А/П). " +
                                       "Проверьте правильность отражения операций по указанным счетам.", 0 );
      AddColumn( "№ счета",           25 );
      AddColumn( "Признак",           5 );
      AddColumn( "Входящий остаток",  25 );
      AddColumn( "Исходящий остаток", 25 );
      AddColumn( "Примечание",        25 );
      private const m_Account     = 0;
      private const m_KindAccount = 1;
      private const m_InRest      = 2;
      private const m_OutRest     = 3;
      private const m_Comment     = 4;

      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         PrintChapterIfNeeded( r.chapterSymbol );
         m_ValuesRow[m_Account]     = r.account;
         m_ValuesRow[m_KindAccount] = r.kindAccount;
         m_ValuesRow[m_InRest]      = r.inRest;
         m_ValuesRow[m_OutRest]     = r.outRest;
         if ( r.kindAccount == "А" )
             m_ValuesRow[m_Comment]     = "По активному счету кредитовый остаток";
         elif ( r.kindAccount == "П" )
             m_ValuesRow[m_Comment]     = "По пассивному счету дебетовый остаток";
         end;
         PrintValuesRow();
      end;
   end;
   var table = CAccountRestSignConformityReport();
   while( accountRestSignConformityDataSet.MoveNext() )
      table.FillFromRecord( accountRestSignConformityDataSet.GetRecord() );
      haveErrors = true;
   end;
   table.PrintBottomIfNeeded();

   if ((not haveErrors) and processAndExit) 
      УстановитьФлагВозврата( OK_MACRO_FLAG); /* Успешное завершение макроса */
      //exit(1); // KS 10.01.2011 Убрал по I-00134718
   end;
end;

/* Контроль на уникальность б/с 
   ----------------------------
   Проводится контроль на уникальность открытых б/с. 
   - Каждый б/с может быть открыт только в одной 
     главе баланса и только один раз; 
*/
private macro CheckBalanceAccountUniqueness()
   
   var balanceChapterQuery = 
      "\n" + "SELECT   t_Balance,  " +
      "\n" + "         t_Chapter   " +
      "\n" + "    FROM dbalance_dbt " +
      "\n" + "   WHERE t_iNumPlan = " + ЛогическийПланСчетов +
      "\n" + "     AND t_Balance IN (SELECT   DISTINCT bl.t_Balance " +
      "\n" + "                           FROM dbalance_dbt  bl," +
      "\n" + "                                dobchaptr_dbt ch " +
      "\n" + "                          WHERE bl.t_iNumPlan = " + ЛогическийПланСчетов +
      "\n" + "                            AND ch.t_chapter  = bl.t_chapter        " +
      "\n" + "                            AND ch.t_ExcludeFromFormalAcnt = CHR(0) " +
      "\n" + "                       GROUP BY bl.t_Balance                        " +
      "\n" + "                         HAVING COUNT(bl.t_Balance) > 1)            " +
      "\n" + "ORDER BY t_balance, t_chapter ";
   var balanceChapterDataSet = TRsbDataSet( balanceChapterQuery );
   PrintLn("КОНТРОЛЬ НА УНИКАЛЬНОСТЬ ОТКРЫТЫХ БАЛАНСОВЫХ СЧЕТОВ");

   class (CGroupingTableReport) CDuplicateBalanceTableReport()
      InitCGroupingTableReport( "Следующие балансовые счета открыты в нескольких главах одновременно. " +
                                "Проверьте правильность открытия счетов" );
      AddColumn( "Номер б/с",  10 );
      AddColumn( "Примечание", 70 );


      private const m_Balance = 0;
      private const m_Comment = 1;

      macro FillFromRecord( r )
         if ( m_ValuesRow[m_Balance] != r.balance )
            PrintHeadIfNeeded();
            PrintValuesRow();
            m_ValuesRow[m_Balance] = r.balance;
            m_ValuesRow[m_Comment] = " Балансовый счет открыт в Главе " + r.chapter;
         else
            m_ValuesRow[m_Comment] = m_ValuesRow[m_Comment] + ", Главе " + r.chapter;
         end;
      end;
   end;

   var table = CDuplicateBalanceTableReport();
   while ( balanceChapterDataSet.MoveNext() )
      table.FillFromRecord( balanceChapterDataSet.GetRecord() );
   end;
   table.PrintValuesRow();
   table.PrintBottomIfNeeded();
end;

/* Контроль остатков на парных счетах
   ----------------------------------
   Для каждого лицевого счета, имеющего парный счет, 
   проводится контроль остатков на парных лицевых сче-тах:
   - Остаток может быть только на одном из парных счетов;
*/
private macro CheckPairAccountsRests()

   var pairAccountsRestsQuery =     "WITH pairAccountsWithRepeat AS (SELECT t_chapter,"
                           +"\n"+  "                                        t_code_currency," 
                           +"\n"+  "                                        t_account,"                                         
                           +"\n"+  "                                        t_pairaccount"                                          
                           +"\n"+  "                                   FROM daccount_dbt"
                           +"\n"+  "                                  WHERE t_pairAccount != CHR(1)),"
                           +"\n"+  " pairAccountsWithUniqueField AS (SELECT pairAccountsWithRepeat.*,"
                           +"\n"+  "                                   CASE"
                           +"\n"+  "                                        WHEN t_account < t_pairaccount"
                           +"\n"+  "                                        THEN t_account || t_pairaccount"
                           +"\n"+  "                                        ELSE t_pairaccount || t_account"
                           +"\n"+  "                                   END t_uniquefield"
                           +"\n"+  "                              FROM pairAccountsWithRepeat),"
                           +"\n"+  "           pairAccounts AS (SELECT MIN(t_account) t_account,"
                           +"\n"+  "                                   MAX(t_pairAccount) t_pairAccount,"
                           +"\n"+  "                                   t_chapter,"
                           +"\n"+  "                                   t_code_currency"
                           +"\n"+  "                              FROM pairAccountsWithUniqueField"
                           +"\n"+  "                          GROUP BY t_chapter, t_code_currency, t_uniquefield),"
                           +"\n"+  "             resultData AS (SELECT prac.t_account account,"
                           +"\n"+  "                                   prac.t_pairaccount pairaccount,"
                           +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blac.t_ias, blac.t_ips) restin,"
                           +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blac.t_oas, blac.t_ops) restout,"
                           +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blpr.t_ips, blpr.t_ias) pairrestin,"
                           +"\n"+  "                                   DECODE (ac.t_kind_account,'А', blpr.t_ops, blpr.t_oas) pairrestout,"
                           +"\n"+  "                                   ch.t_symbol chaptersymbol"
                           +"\n"+  "                              FROM pairAccounts prac,"
                           +"\n"+  "                                   daccount_dbt ac,"                                         
                           +"\n"+  "                                   dblaccr_tmp blac,"
                           +"\n"+  "                                   dblaccr_tmp blpr,"
                           +"\n"+  "                                   dobchaptr_dbt ch"
                           +"\n"+  "                             WHERE prac.t_chapter = blac.t_chapter"
                           +"\n"+  "                               AND prac.t_code_currency = blac.t_code_currency"
                           +"\n"+  "                               AND prac.t_account = blac.t_account"
                           +"\n"+  "                               AND prac.t_chapter = blpr.t_chapter"
                           +"\n"+  "                               AND prac.t_code_currency = blpr.t_code_currency"
                           +"\n"+  "                               AND prac.t_pairaccount = blpr.t_account"
                           +"\n"+  "                               AND prac.t_chapter = ch.t_chapter"
                           +"\n"+  "                               AND prac.t_chapter = ac.t_chapter"
                           +"\n"+  "                               AND prac.t_code_currency = ac.t_code_currency"
                           +"\n"+  "                               AND prac.t_account = ac.t_account"
                           +"\n"+  "                               AND blac.t_account <> blpr.t_account)";

   pairAccountsRestsQuery = pairAccountsRestsQuery + "\n" + "SELECT *"
                                                  +"\n" + "  FROM resultData"
                                                   +"\n" + " WHERE (restIn <> 0 AND pairRestIn <> 0) OR (restOut <> 0 AND pairRestOut <> 0)";
   var pairAccountsRestsDataSet = TRsbDataSet(pairAccountsRestsQuery);
   pairAccountsRestsDataSet.SetFieldType("Rest", V_MONEY);
   pairAccountsRestsDataSet.SetFieldType("pairRest", V_MONEY);
   PrintLn("КОНТРОЛЬ ОСТАТКОВ НА ПАРНЫХ СЧЕТАХ");

   class (CGroupingChapterTableReport) CPairAccountsRestsReport()
      InitCGroupingChapterTableReport( "Обнаружены остатки на обоих парных счетах. " +
                                       "Выполните процедуру урегулирования парных счетов", 0 );

      AddColumn( "Номер счета", 25  );
      AddColumn( "Остаток вх",  25 );
      AddColumn( "Остаток исх", 25 );
      AddColumn( "Номер парного счета", 25  );
      AddColumn( "Остаток вх",  25 );
      AddColumn( "Остаток исх", 25 );

      private const m_Account           = 0;
      private const m_Rest              = 1;
      private const m_RestOut           = 2;
      private const m_PairAccount       = 3;
      private const m_PairRest          = 4;
      private const m_PairRestOut       = 5;

      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         PrintChapterIfNeeded( r.chapterSymbol );
         m_ValuesRow[m_Account]     = r.account;
         m_ValuesRow[m_Rest]        = r.restIn;
         m_ValuesRow[m_RestOut]     = r.restOut;
         m_ValuesRow[m_PairAccount] = r.pairAccount;
         m_ValuesRow[m_PairRest]    = r.pairRestIn;
         m_ValuesRow[m_PairRestOut] = r.pairRestOut;
         PrintValuesRow();
      end;
   end;
   var table = CPairAccountsRestsReport();

   while( pairAccountsRestsDataSet.MoveNext() )
      table.FillFromRecord( pairAccountsRestsDataSet.GetRecord() )
   end;
   table.PrintBottomIfNeeded();
end;

/* Контроль остатков по счетам покрытий
   ------------------------------------
   Для каждого валютного л/с производится контроль соответствия 
   исходящих остатков по валютному счету и по счету покрытия:
   - Остаток по счету покрытия = Остаток по валютному счету * Курс ЦБ 
     на дату окончания отчетного периода по данной валюте.
*/
private macro CheckCoverAccountRests()

   var coverAccountRestsQuery = 
      " select ch.t_symbol                                chapterSymbol,                              " +
         "        fi.t_fiid                                  fiid,                                       " +
         "        fi.t_fi_code                               currencyCode,                               " +
         "        ac.t_account                               account,                                    " +
         "        decode( ba.t_oas, 0, ba.t_ops, ba.t_oas )   coverRest,                                 " +
         "        round( abs( rsb_fiinstr.ConvSum ( rsb_rep_ac.restac( ac.t_account,                     " +
      "                                                             acc.t_code_currency,              " +
      "                                                         " + GetSqlDate( ДатаОтчета ) + ",     " +
      "                                                             ac.t_chapter,                     " +
      "                                                             ac.t_r0 ),                        " +
              "                                          acc.t_code_currency,                                 " +
              "                                          0,                                                   " +
              "                                      " + GetSqlDate( ДатаОтчета ) + ") ),                     " +
      "               2 )                                 coverRestCalculated                         " +
      " from dblaccr_tmp      ba,                                                                     " +
      "      daccount_dbt     ac,                                                                     " +
      "      daccount$_dbt    acc,                                                                    " +
      "      dfininstr_dbt    fi,                                                                     " +
      "      dobchaptr_dbt    ch                                                                      " +
      " where ac.t_chapter      = ba.t_chapter                                                        " +
      " and   ac.t_account      = ba.t_account                                                        " +
      " and   ac.t_type_account = 'П'                                                                 " +
      " and   ac.t_account      = acc.t_connect_account                                               " +
      " and   fi.t_fiid         = acc.t_code_currency                                                 " +
      " and   ac.t_chapter      = ch.t_chapter                                                        " +
      " order by fi.t_fiid,                                                                           " +
              "          ch.t_chapter,                                                                        " +
              "          ac.t_account                                                                         ";

   var nonConformingQuery =
      " SELECT nc.*,                                           " +
      "        abs(nc.coverRestCalculated-nc.coverRest) diff   " +
      " FROM ( " + coverAccountRestsQuery + " ) nc             " +
      " WHERE nc.coverRestCalculated - nc.coverRest != 0       ";
   var coverAccountRestsDataSet = TRsbDataSet( nonConformingQuery );
   coverAccountRestsDataSet.SetFieldType("CoverRest", V_MONEY);
   coverAccountRestsDataSet.SetFieldType("CoverRestCalculated", V_MONEY);
   coverAccountRestsDataSet.SetFieldType("Diff", V_MONEY);

   PrintLn( "КОНТРОЛЬ ОСТАТКОВ ПО СЧЕТАМ ПОКРЫТИЙ" );

   class (CGroupingChapterTableReport) CCoverAccountRestsReport()
      InitCGroupingChapterTableReport( "По следующим лицевым счетам остаток по счету покрытия не соответствует остатку по валютному счету. " +
                                       "Выполните процедуру урегулирования покрытий ", 0 );

      AddColumn( "Номер счета",                    25 );
      AddColumn( "Остаток по покрытию",            25 );
      AddColumn( "Пересчитанный валютный остаток", 25 );
      AddColumn( "Разность",                       25 );
      
      private const m_Account             = 0;
      private const m_СoverRest           = 1;
      private const m_СoverRestCalculated = 2;
      private const m_Diff                = 3;

      private var   m_fiid;

      private macro GetCbRateString( fiid )
         record rate( ratedef );
         var rateString = "";
         if ( ПолучитьКурс( rate,  0, fiid ) == 0 ) 
            if ( ПолучитьЗначениеКурса( rate, ДатаОтчета ) == 0 )
               ПолучитьСтрокуЗначенияКурса( rate, 1, rateString );
            end;
         end;
         return rateString;
      end;

      private macro PrintCurrencyIfNeeded( fiid, currencyCode )
         var rate;
         if ( m_fiid != fiid )
            rate = GetCbRateString( fiid );
            ClearValuesRow();
            m_ValuesRow[0] = string( "Код валюты ", currencyCode ) ;
            m_ValuesRow[1] = string( "Курс ЦБ ",    rate ) ;
            PrintValuesRow();
            m_fiid = fiid;
         end;
      end;

      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         PrintCurrencyIfNeeded( r.fiid, r.currencyCode );
         PrintChapterIfNeeded(  r.chapterSymbol );
         m_ValuesRow[m_Account]             = r.account;
         m_ValuesRow[m_СoverRest]           = r.coverRest;
         m_ValuesRow[m_СoverRestCalculated] = r.coverRestCalculated;
         m_ValuesRow[m_Diff]                = r.diff;
         PrintValuesRow();
      end;
      
   end;

   var table = CCoverAccountRestsReport();

   while( coverAccountRestsDataSet.MoveNext() )
      table.FillFromRecord( coverAccountRestsDataSet.GetRecord() )
   end;
   table.PrintBottomIfNeeded();
end;

/* Контроль корреспонденции счетов по Главе В
   ------------------------------------------
   Проводится контроль корреспонденции счетов по проводкам Главы В:
   - Счет, открытый на б/с 99998, может использоваться для корреспонденции с пассивными счетами;
   - Счет, открытый на б/с 99999, может использоваться для корреспонденции с активными счетами.
*/
private macro CheckOffBalanceAccountsCorrespondence()

   macro GetOffBalanceAccountsCorrespondenceQuery()
      var query =
         "\n" + "SELECT   doc.t_Numb_Document    documentNumber," +
         "\n" + "         doc.t_Date_Carry       dateCarry,     " +
         "\n" + "         doc.t_Sum              sumCarry,      " +
         "\n" + "         doc.t_Account_Payer    debet,         " +
         "\n" + "         doc.t_Account_Receiver credit         " +
         "\n" + "    FROM darhdoc_dbt  doc,                     " +
         "\n" + "         daccount_dbt acp,                     " +
         "\n" + "         daccount_dbt acr,                     " +
         "\n" + "         daccblnc_dbt abp,                     " +
         "\n" + "         daccblnc_dbt abr                      " +
         "\n" + "   WHERE doc.t_Chapter = 3                     " +
         "\n" + "     AND doc.t_Result_Carry != 23              " +
         "\n" + "     AND doc.t_Date_Carry BETWEEN " + GetSqlDate(ПредДатаОтчета) +
         "\n" + "                              AND " + GetSqlDate(ДатаОтчета) +
         "\n" + "     AND abp.t_Account = doc.t_Account_Payer   " +
         "\n" + "     AND abp.t_Chapter = doc.t_Chapter         " +
         "\n" + "     AND abr.t_Account = doc.t_Account_Receiver" +
         "\n" + "     AND abr.t_Chapter = doc.t_Chapter         " +
         "\n" + "     AND acp.t_Account = abp.t_Account         " +
         "\n" + "     AND acp.t_Chapter = abp.t_Chapter         " +
         "\n" + "     AND acr.t_Account = abr.t_Account         " +
         "\n" + "     AND acr.t_Chapter = abr.t_Chapter         " +
           "\n" + "     AND " + RcbBranchAndDepartmentFieldFilter().GetAsSqlString("acp.t_department", "acp.t_branch") +
           "\n" + "     AND " + RcbBranchAndDepartmentFieldFilter().GetAsSqlString("acr.t_department", "acr.t_branch") +
         "\n" + "     AND (    (abp.t_Balance" + ЛогическийПланСчетов + " = '99998' AND (acr.t_Kind_Account != 'П' OR abr.t_Balance" + ЛогическийПланСчетов + " = '99999')) " +
         "\n" + "           OR (abr.t_Balance" + ЛогическийПланСчетов + " = '99998' AND (acp.t_Kind_Account != 'П' OR abp.t_Balance" + ЛогическийПланСчетов + " = '99999')) " +
         "\n" + "           OR (abp.t_Balance" + ЛогическийПланСчетов + " = '99999' AND (acr.t_Kind_Account != 'А' OR abr.t_Balance" + ЛогическийПланСчетов + " = '99998')) " +
         "\n" + "           OR (abr.t_Balance" + ЛогическийПланСчетов + " = '99999' AND (acp.t_Kind_Account != 'А' OR abp.t_Balance" + ЛогическийПланСчетов + " = '99998')))";
         "\n" + "ORDER BY dateCarry, sumCarry";
      return query;     
   end;
   var offBalanceAccountsCorrespondenceDataSet = TRsbDataSet(GetOffBalanceAccountsCorrespondenceQuery());
   offBalanceAccountsCorrespondenceDataSet.SetFieldType("SumCarry", V_MONEY);
   PrintLn( "КОНТРОЛЬ КОРРЕСПОНДЕНЦИИ СЧЕТОВ ПО ГЛАВЕ В" );

   class (CGroupingTableReport) COffBalanceAccountsCorrespondenceReport()
      InitCGroupingTableReport( "<Глава В. Нарушена корреспонденция счетов. " +
                                " Проверьте правильность отражения следующих операций:> " );
      AddColumn( "№ док",           10 );
      AddColumn( "Дата док-та",     12 );
      AddColumn( "Сумма док-та",    25 );
      AddColumn( "Счет по дебету",  25 );
      AddColumn( "Счет по кредиту", 25 );
      
      private const m_DocumentNumber    = 0;
      private const m_DateCarry         = 1;
      private const m_SumCarry          = 2;
      private const m_Debet             = 3;
      private const m_Credit            = 4;
      
      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         m_ValuesRow[m_DocumentNumber]   = r.documentNumber;
         m_ValuesRow[m_DateCarry]        = Date(r.dateCarry);
         m_ValuesRow[m_SumCarry]         = r.sumCarry;
         m_ValuesRow[m_Debet]            = r.debet;
         m_ValuesRow[m_Credit]           = r.credit;
         PrintValuesRow();
      end;
   end;

   var table = COffBalanceAccountsCorrespondenceReport();

   while( offBalanceAccountsCorrespondenceDataSet.MoveNext() )
      table.FillFromRecord( offBalanceAccountsCorrespondenceDataSet.GetRecord() )
   end;
   table.PrintBottomIfNeeded();
end;

/* Коркин И.Н. По заявке I-032797.
	Контроль на проводки выполненые после закрытия счета. По главам 1 и 3.
   -----------------------------------------------------------------------
   Проводится контроль по дате проводки и датам закрытия участвующих счетов
*/
private macro CheckDocumentsAfterCloseAccount()

   var accountRestSignConformityQuery = " SELECT   ARHDOC.T_NUMB_DOCUMENT numbdocument, "
                                + "\n" + "         ARHDOC.T_ACCOUNT_PAYER payer, "
                                + "\n" + "         ARHDOC.T_ACCOUNT_RECEIVER receiver, "
                                + "\n" + "         ARHDOC.T_SUM sum, "
                                + "\n" + "         ARHDOC.T_OPER oper"
                                + "\n" + " FROM    darhdoc_dbt arhdoc "
                                + "\n" + "  WHERE  arhdoc.t_chapter = 1 "
                                + "\n" + "         AND EXISTS "
                                + "\n" + "               (SELECT   1 "
                                + "\n" + "                  FROM   daccount_dbt account "
                                + "\n" + "                 WHERE   ARHDOC.T_ACCOUNT_payer = ACCOUNT.T_ACCOUNT "
                                + "\n" + "                         AND ARHDOC.T_DATE_CARRY > ACCOUNT.T_CLOSE_DATE "
                                + "\n" + "                         AND ACCOUNT.T_CLOSE_DATE > "
                                + "\n" + "                               TO_DATE ('01.01.0001', 'dd.mm.yyyy')) "
                                + "\n" + "         AND ARHDOC.T_DATE_CARRY BETWEEN " + GetSqlDate(ПредДатаОтчета)
                                + "\n" + "                                     AND " + GetSqlDate(ДатаОтчета)
                                + "\n" + " UNION ALL "
                                + "\n" + " SELECT  ARHDOC.T_NUMB_DOCUMENT numbdocument, "
                                + "\n" + "         ARHDOC.T_ACCOUNT_PAYER payer, "
                                + "\n" + "         ARHDOC.T_ACCOUNT_RECEIVER receiver, "
                                + "\n" + "         ARHDOC.T_SUM sum, "
                                + "\n" + "         ARHDOC.T_OPER oper"
                                + "\n" + "  FROM   darhdoc_dbt arhdoc "
                                + "\n" + " WHERE   arhdoc.t_chapter = 3 "
                                + "\n" + "         AND EXISTS "
                                + "\n" + "               (SELECT   1 "
                                + "\n" + "                  FROM   daccount_dbt account "
                                + "\n" + "                 WHERE   ARHDOC.T_ACCOUNT_payer = ACCOUNT.T_ACCOUNT "
                                + "\n" + "                         AND ARHDOC.T_DATE_CARRY > ACCOUNT.T_CLOSE_DATE "
                                + "\n" + "                         AND ACCOUNT.T_CLOSE_DATE > "
                                + "\n" + "                               TO_DATE ('01.01.0001', 'dd.mm.yyyy')) "
                                + "\n" + "         AND ARHDOC.T_DATE_CARRY BETWEEN " + GetSqlDate(ПредДатаОтчета)
                                + "\n" + "                                     AND " + GetSqlDate(ДатаОтчета);
   var accountRestSignConformityDataSet = TRsbDataSet( accountRestSignConformityQuery );

   PrintLn("КОНТРОЛЬ НА ПРОВОДКИ ВЫПОЛНЕННЫЕ ПОСЛЕ ЗАКРЫТИЯ СЧЕТА");

   class (CGroupingChapterTableReport) CAccountRestSignConformityReport()
      InitCGroupingChapterTableReport( "Следующие проводки выполнены после закрытия участвующего счета " +
                                       "и не участвуют в расчете.", 0 );


      AddColumn( "№ Док.",           11 );
      AddColumn( "Плательщик",       25 );
      AddColumn( "Получатель",       25 );
      AddColumn( "Сумма",            25 );
      AddColumn( "Операционист",      5 );
      
      private const m_Num      = 0;
      private const m_payer    = 1;
      private const m_receiver = 3;
      private const m_sum      = 4;
      private const m_oper     = 5;
      
      macro FillFromRecord( r )
         PrintHeadIfNeeded();
         m_ValuesRow[m_Num]      = r.numbdocument;
         m_ValuesRow[m_payer]    = r.payer;
         m_ValuesRow[m_receiver] = r.receiver;
         m_ValuesRow[m_sum]      = r.sum;
         m_ValuesRow[m_oper]     = r.oper;
         PrintValuesRow();
      end;
   end;
   var table = CAccountRestSignConformityReport();
   while( accountRestSignConformityDataSet.MoveNext() )
      table.FillFromRecord( accountRestSignConformityDataSet.GetRecord() )
   end;
   table.PrintBottomIfNeeded();
end;

private macro printtable(prov)
  private var table1 = CTableReport( 0, false, false );
  private var sql:string="";
  private var first_line:bool=true;
  private var ds;
  
   PrintLn("\n      КОНТРОЛЬ СДЕЛАНЫЙ РУЧКАМИ 1  \n");
  
  table1.addcolumn("Cчет Дт",                      20);
  table1.addcolumn("Cчет Кт",                      20);
  table1.addcolumn("Сумма",                        10);
  table1.addcolumn("Дата проводки",                10);
  table1.addcolumn("Основание проводки",           30);
  table1.addcolumn("Глава",                        2);
  table1.addcolumn("Шифр операции",                3);
  table1.addcolumn("Вид операции",                 3);
  table1.addcolumn("Опрационист",                  15);
  table1.addcolumn("Узел ТС",                      30);

  if (prov=="zad1")
      gol="ПРОВОДКИ, ДАТА КОТОРЫХ БОЛЬШЕ ИЛИ РАВНА ДАТЕ ЗАКРЫТИЯ СЧЕТА (ПОЛУЧАТЕЛЯ ИЛИ ПЛАТЕЛЬЩИКА)";
       sql="SELECT   t_account_payer, t_account_receiver, t_sum, t_date_carry, t_ground, "+
           " dc.t_chapter, t_shifr_oper, t_kind_oper, pr.t_name, ts.t_shortname"+
         " FROM darhdoc_dbt dc, daccount_dbt ac, dperson_dbt pr, dparty_dbt ts, ddp_dep_dbt dp"+
         " WHERE t_date_carry BETWEEN TO_DATE ('"+period.beginDate()+"', 'DD.MM.RRRR')"+
                          "     AND  TO_DATE ('"+period.endDate()+"', 'DD.MM.RRRR')  "+
            "  AND t_open_close = 'З' "+
            "  AND t_date_carry > t_close_date "+
            "  AND (t_account_payer = t_account OR t_account_receiver = t_account)"+
            "  AND dc.t_oper = pr.t_oper"+
            "  AND dc.t_chapter = ac.t_chapter"+
            "  AND pr.T_CODEDEPART = dp.t_code"+
            "  AND ts.t_partyid = dp.t_partyid"+
         " ORDER BY 4;";
  elif (prov=="zad2")
      gol="ПРОВОДКИ, У КОТОРЫХ СЧЕТ ПЛАТЕЛЬЩИКА ИЛИ СЧЕТ ПОЛУЧАТЕЛЯ НЕ ПРИВЯЗАН К КЛИЕНТУ ИЛИ ПРИВЯЗАН НЕВЕРНО";
      sql = "SELECT   t_account_payer, t_account_receiver, t_sum, t_date_carry, t_ground,"+
           "  dc.t_chapter, t_shifr_oper, t_kind_oper, pr.t_name, ts.t_shortname"+
           " FROM darhdoc_dbt dc, daccount_dbt ac, dperson_dbt pr, dparty_dbt ts, ddp_dep_dbt dp"+
           " WHERE   t_date_carry BETWEEN TO_DATE ('"+period.beginDate()+"', 'DD.MM.RRRR')"+
                           "    AND  TO_DATE ('"+period.endDate()+"', 'DD.MM.RRRR')"+
           "   AND (   NOT EXISTS (SELECT   t_partyid "+
                                 "   FROM   dparty_dbt "+
                                 "  WHERE   t_partyid = t_client)"+
                 "  OR t_client = 0 "+
                 "  OR t_client IS NULL)"+
           "   AND (t_account_payer = t_account OR t_account_receiver = t_account)"+
           "   AND dc.t_oper = pr.t_oper"+
           "   AND dc.t_chapter = ac.t_chapter"+
           "   AND pr.T_CODEDEPART = dp.t_code"+
           "   AND ts.t_partyid = dp.t_partyid"+
           " ORDER BY 4;     ";
   elif (prov=="zad3")
      gol="ВАЛЮТНЫЕ ПРОВОДКИ, КОТОРЫМ НЕ СООТВЕТСТВУЮТ ПРОВОДКИ ПОКРЫТИЯ";
      sql = "SELECT val.t_account_payer, val.t_account_receiver, val.t_sum,"+
         " val.t_date_carry, val.t_ground, val.t_chapter, val.t_shifr_oper,"+
         "  val.t_kind_oper, pr.t_name, ts.t_shortname"+
         " FROM darhdoc$_dbt val, dperson_dbt pr, dparty_dbt ts, ddp_dep_dbt dp"+
         " WHERE val.t_date_carry BETWEEN TO_DATE ('"+period.beginDate()+"', 'DD.MM.RRRR')"+
                          "     AND  TO_DATE ('"+period.endDate()+"', 'DD.MM.RRRR')  "+
         "  AND NOT EXISTS"+
                 " (SELECT   * "+
                   "  FROM   darhdoc_dbt rub "+
                  "  WHERE   rub.t_connappkind = val.t_iapplicationkind "+
                          "  AND rub.t_connappkey = val.t_applicationkey)"+
          "  AND NOT (t_account_payer LIKE 'ОВП%' "+
                   "  OR t_account_receiver LIKE 'ОВП%') "+
          "  AND val.t_oper = pr.t_oper "+
          "  AND pr.T_CODEDEPART = dp.t_code "+
          "  AND ts.t_partyid = dp.t_partyid "+
          "  and not (val.t_chapter = 4 and (val.t_account_payer like '00000%') or (val.t_account_receiver like '00000%') );";
   else
      msgbox("неверно переданы параметры в процедуру"); exit(1);
   end;   
   ds=trsbdataset(sql);
   table1.PrintHead(gol);
   kolwo_all=0;
   while (ds.movenext)
      kolwo_all=kolwo_all+1;
      if (not(first_line)) 	table1.printseparator; 
         end;
         table1.PrintStringTransferByWord(ds.value("T_ACCOUNT_PAYER"),ds.value("T_ACCOUNT_RECEIVER"),ds.value("T_SUM"),substr(string(ds.value("T_DATE_CARRY")),1,10),ds.value("t_ground"),
                                          ds.value("t_chapter":1),ds.value("t_shifr_oper":2),ds.value("t_kind_oper":2),ds.value("t_name"),ds.value("t_shortname")    );  
         first_line=false;
      end;
   table1.printbottom(string(" Всего проводок: "+kolwo_all));
   end;

private macro printtable2(acc)
   private var table1 = CTableReport( 0, false, false );
   private var sql:string="";
   private var first_line:bool=true;
   private var ds;
   table1.addcolumn("Cчет",20, AL_RIGHT);
   PrintLn("   \n     КОНТРОЛЬ СДЕЛАНЫЙ РУЧКАМИ 2  \n ");
   
   if (acc=="zad5")
      gol="\n     РУБЛЕВЫЕ СЧЕТА, НА КОТОРЫХ СТОИТ ПРИЗНАК ПОКРЫТИЯ  \n";
      sql = "SELECT t_account"+
          " FROM daccount_dbt"+
          " WHERE T_OPEN_DATE <= to_date ( '"+period.endDate()+"', 'DD.MM.RRRR' ) AND "+
          " (   INSTR (t_type_account, '%П%') != 0"+
          " OR INSTR (t_type_account, '%М%') != 0"+
          " OR INSTR (t_type_account, '%Н%') != 0"+
          " OR INSTR (t_type_account, '%U%') != 0"+
          " )"
          " AND SUBSTR (t_account, 6, 3) = '810' "
          " and not ( t_chapter = 4 and t_account like '00000%') ";
   elif (acc=="zad6")
      gol="\n     СЧЕТА ПОКРЫТИЯ, НА КОТОРЫХ НЕ СТОИТ ПРИЗНАК ПОКРЫТИЯ  \n";
      sql = " SELECT t_account"+
            " FROM daccount_dbt"+
            " WHERE T_OPEN_DATE <= to_date ( '"+period.endDate()+"', 'DD.MM.RRRR' ) AND "+
            " (   NOT (   t_type_account LIKE '%П%'"+
               "  OR t_type_account LIKE '%М%'"+
               "  OR t_type_account LIKE '%Н%'"+
               "  OR t_type_account LIKE '%U%'"+
                   " )"+
            " OR t_type_account IS NULL"+
            " )"+
            " AND SUBSTR (t_account, 6, 3) != '810' "+
            " and not ( t_chapter = 4 and t_account like '00000%') ";
   elif (acc=="zad7")
      gol="\n   ВАЛЮТНЫЕ СЧЕТА, КОТОРЫЕ НЕ ИМЕЮТ СЧЕТА ПОКРЫТИЯ   \n";
      sql = "SELECT t_account"+
         " FROM daccount$_dbt"+
         " WHERE T_OPEN_DATE <= to_date ( '"+period.endDate()+"', 'DD.MM.RRRR' ) AND "+
         " t_connect_account = CHR (1) OR t_connect_account IS NULL;";
   elif (acc=="zad8")
      gol="\n   СЧЕТА ПОКРЫТИЯ, НЕ ИМЕЮЩИЕ ВАЛЮТНОГО СЧЕТА  \n";
      sql = "SELECT t_account"+
         " FROM daccount_dbt rub"+
         " WHERE T_OPEN_DATE <= to_date ( '"+period.endDate()+"', 'DD.MM.RRRR' ) AND "+
         " ( INSTR (t_type_account, '%П%') != 0"+
         " OR INSTR (t_type_account, '%М%') != 0"+
         " OR INSTR (t_type_account, '%Н%') != 0"+
         " OR INSTR (t_type_account, '%U%') != 0"+
         " )"+
         " AND SUBSTR (t_account, 6, 3) <> '810'"+
         " AND NOT EXISTS (SELECT   *   "+
                         "  FROM   daccount$_dbt val"+
                         "  WHERE   rub.t_account = val.t_connect_account);";
      rs = trsbdataset(sql);
      println("\n     СЧЕТА ПОКРЫТИЯ, СВЯЗАННЫЕ БОЛЕЕ ЧЕМ С ОДНИМ ВАЛЮТНЫМ СЧЕТОМ   \n");
      t7.addcolumn("Счет покрытия",30);
      t7.addcolumn("Валютный счет",30);
      t7.printhead();
      t7.PrintHead(gol);
      while( rs and rs.movenext) 
         t7.printseparator();
         t7.PrintStringTransferByWord(rs.value("t_connect_account"),rs.value("t_account"));
      end;
      t7.printbottom();
      
      str= " select schet, kol "+
           " from (select   schet, count (schet) as kol "+
           "           from (select t_account schet "+
           "                   from daccount$_dbt) "+
           "       group by schet) "+
           " where kol > 1 ";
      rs = trsbdataset(str);
      println("\n    ВАЛЮТНЫЕ СЧЕТА, ИМЕЮЩИЕ БОЛЕЕ ОДНОГО СЧЕТА ПОКРЫТИЯ   \n");
      t5.addcolumn("Номер счета",30,AL_CENTER);
      t5.addcolumn("Количество",2,AL_CENTER);
      t5.printhead();
      while( rs and rs.movenext) 
         t5.printseparator();
         t5.printStringTransferByWord(rs.value("schet"), int (rs.value("kol")));
      end;
      t5.printbottom();
     

      str= " SELECT t_account, t_connect_account, t_chapter, t_nameaccount"+
           " FROM daccount$_dbt"+
           " WHERE NOT EXISTS ("+
           " SELECT t_account"+
           " FROM daccount_dbt"+
           " WHERE daccount$_dbt.t_connect_account ="+
           " daccount_dbt.t_account)"+
           " and not ( t_chapter = 4 and t_account like '00000%') ";
      rs = trsbdataset(str);
      println("\n    ВАЛЮТНЫЕ СЧЕТА, ИМЕЮЩИЕ НЕ СУЩЕСТВУЮЩИЕ СЧЕТА ПОКРЫТИЯ   \n");
      t6.addcolumn("Номер счета",30,AL_CENTER);
      t6.addcolumn("Счет покрытия",30,AL_CENTER);
      t6.addcolumn("Номер главы",1,AL_CENTER);
      t6.addcolumn("Комментарий к счету",30,AL_CENTER);
      t6.printhead();
      while( rs and rs.movenext) 
         t6.printseparator();
         t6.printStringTransferByWord(rs.value("t_account"),rs.value("t_connect_account"),rs.value("t_chapter"),rs.value("t_nameaccount"));
      end;
      t6.printbottom();
      
      
      str= " SELECT darhdoc_dbt.t_account_payer, darhdoc_dbt.t_account_receiver,"+
               " LPAD (darhdoc_dbt.t_iapplicationkind, 5, '0')  || darhdoc_dbt.t_applicationkey, darhdoc_dbt.t_sum,"+
               " darhdoc_dbt.t_date_carry, darhdoc_dbt.t_ground,"+
               " darhdoc_dbt.t_chapter"+
           " FROM darhdoc_dbt, dsymbcash_dbt"+
           " WHERE darhdoc_dbt.t_account_payer NOT LIKE '20202%'"+
              "	AND darhdoc_dbt.t_account_payer NOT LIKE '20206%'"+
              "	AND darhdoc_dbt.t_account_receiver NOT LIKE '20202%'"+
              "	AND darhdoc_dbt.t_account_receiver NOT LIKE '20206%'"+
              "	AND    LPAD (darhdoc_dbt.t_iapplicationkind, 5, '0')"+
               "	|| darhdoc_dbt.t_applicationkey = dsymbcash_dbt.t_applicationkey"+
           "	AND darhdoc_dbt.t_chapter = '1'"+
           "	AND darhdoc_dbt.t_date_carry BETWEEN TO_DATE ('"+period.beginDate()+"','DD.MM.RRRR')"+
           "	AND TO_DATE ('"+period.endDate()+"', 'DD.MM.RRRR')";
      rs = trsbdataset(str);
      println("\n    НЕ КАССОВЫЕ ПРОВОДКИ, ИМЕЮЩИЕ КАССОВЫЙ СИМВОЛ   \n");
      t8.addcolumn("Счет Дебета",30,AL_CENTER);
      t8.addcolumn("Счет Кредита",30,AL_CENTER);
      t8.addcolumn("Сумма",15,AL_CENTER);
      t8.addcolumn("Дата",11,AL_CENTER);
      t8.addcolumn("Основание",30,AL_CENTER);
      t8.addcolumn("Номер главы",1,AL_CENTER);
      t8.printhead();
      while( rs and rs.movenext) 
         t8.printseparator();
         t8.printStringTransferByWord(rs.value("t_account_payer"),rs.value("t_account_receiver"),rs.value("t_sum"),substr(string(rs.value("t_date_carry")),1,10),rs.value("t_ground"),rs.value("t_chapter"));
      end;
      t8.printbottom();
   elif (acc=="zad9")
      gol="\n     СЧЕТА ПОКРЫТИЯ, КОТОРЫЕ ПРИВЯЗАНЫ БОЛЕЕ ЧЕМ К ОДНОМУ ВАЛЮТНОМУ СЧЕТУ\n";
      sql = "SELECT t_account   FROM daccount_dbt  " 
     " WHERE T_OPEN_DATE <= to_date ( '"+period.endDate()+"', 'DD.MM.RRRR' ) AND "+ 
     " (  INSTR (t_type_account, '%П%') != 0"+
         "  OR INSTR (t_type_account, '%М%') != 0"+
          " OR INSTR (t_type_account, '%Н%') != 0"+
          " OR INSTR (t_type_account, '%U%') != 0"+
         " )"+
    "  AND SUBSTR (t_account, 6, 3) <> '810' "+
    "   AND 1 < (SELECT COUNT (t_connect_account) "+
                   "  FROM daccount$_dbt  "+
                  "  WHERE daccount_dbt.t_account = t_connect_account); ";
   else
      msgbox("неверно переданы параметры в процедуру");
      exit(1);
   end;  
   ds=trsbdataset(sql);
   table1.PrintHead(gol);
   kolwo_all=0;
   while (ds.movenext)
      kolwo_all=kolwo_all+1;
      if (not(first_line))
         table1.printseparator;
      end;
      table1.printStringTransferByWord(ds.value("t_account"));  
      first_line=false;
   end;        
   table1.printbottom(string(" Всего счетов: "+kolwo_all));
end;

private macro not_type_kassa()
   private var table1 = CTableReport( 0, false, false );
   private var sql:string="", gol, rs;
   
   table1.addcolumn("Cчет ",                       20);
   table1.addcolumn("Тип ",                        10);
   table1.addcolumn("Закр\откр ",                  10);
   table1.addcolumn("дата закрытия ",              10);
   gol="\n     КАССОВЫЕ СЧЕТА, НА КОТОРЫХ НЕ СТОИТ ТИП СЧЁТА \"А\"  \n";
   sql = " select * "
         " from daccount_dbt ac "
         " where (ac.t_account like '20202%' "
         "    or ac.t_account like '20208%') "
         " and not ac.t_type_account like '%А%' " ;
   rs = trsbdataset(sql);
   table1.PrintHead(gol);
   private var first_line = true;
   while(rs.movenext())
      if (not(first_line))
         table1.printseparator; 
      end;
      table1.PrintStringTransferByWord( rs.value("t_account"), rs.value("t_type_account"), rs.value("t_open_close"), string(rs.value("t_close_date")) );
      first_line=false;
      end;
   table1.printbottom();
END;

private macro prov_table_rest_date()
   private var table1 = CTableReport( 0, false, false );
   private var sql:string="", gol, rs;
   table1.addcolumn("Cчет ",                                   20);
   table1.addcolumn("Глава ",                                  20);
   table1.addcolumn("Вх остаток в таблице ",                   20);
   table1.addcolumn("Дт из таблицы ",                          20);
   table1.addcolumn("Дт по проводкам ",                        20);
   table1.addcolumn("Кт из таблицы ",                          20);
   table1.addcolumn("Кт по проводкам ",                        20);
   table1.addcolumn("Исх остаток в таблице ",                  20);
   gol="\n     ТАБЛИЦА drestdate_dbt ВЫБИРАЕМ ЗАПИСИ С НЕПРАВИЛЬНЫМИ ОСТАТКАМИ ВХ\ВЫХ И ОБОРОТЫ, ПРОВЕРЯЕМ ПО ПРОВОДАМ  \n";
   sql = " select * "+
         " from (select ac.t_account, ac.t_chapter "+
         "     ,rsi_rsb_account.resta (ac.t_account "+
         "                            , to_date ('"+ПредДатаОтчета+"', 'dd.mm.yyyy') - 1 "+    // + GetSqlDate(ПредДатаОтчета) + + GetSqlDate(ДатаОтчета) +
         "                            ,ac.t_chapter "+
         "                            ,null "+
         "                            ) rest_in_table "+
         "     ,rsi_rsb_account.debeta (ac.t_account "+
         "                             ,ac.t_chapter "+
         "                             , " + GetSqlDate(ПредДатаОтчета) +
         "                             , " + GetSqlDate(ДатаОтчета) +
         "                             ) debet_table "+
         "     ,nvl ((select sum (ar.t_sum) "+
         "              from darhdoc_dbt ar "+
         "             where ar.t_date_carry between "+ GetSqlDate(ПредДатаОтчета) +" and "+ GetSqlDate(ДатаОтчета) +
         "               and ar.t_account_payer = ac.t_account) "+
         "          , (select sum (ar.t_sum) "+
         "               from darhdoc_dbt ar "+
         "              where ar.t_date_carry between "+ GetSqlDate(ПредДатаОтчета) +" and "+ GetSqlDate(ДатаОтчета) +
         "                and ar.t_account_payer = ac.t_account) "+
         "          ) debet_provod "+
         "     ,rsi_rsb_account.kredita (ac.t_account "+
         "                              ,ac.t_chapter "+
         "                              , " + GetSqlDate(ПредДатаОтчета) +
         "                              , " + GetSqlDate(ДатаОтчета) +
         "                              ) kredet_table "+
         "     ,nvl ((select sum (ar.t_sum) "+
         "              from darhdoc_dbt ar "+
         "             where ar.t_date_carry between "+ GetSqlDate(ПредДатаОтчета) +" and "+ GetSqlDate(ДатаОтчета) +
         "               and ar.t_account_receiver = ac.t_account) "+
         "          , (select sum (ar.t_sum) "+
         "               from darhdoc_dbt ar "+
         "              where ar.t_date_carry between "+ GetSqlDate(ПредДатаОтчета) +" and "+ GetSqlDate(ДатаОтчета) +
         "                and ar.t_account_receiver = ac.t_account) "+
         "          ) kredet_provod "+
         "     ,rsi_rsb_account.resta (ac.t_account "+
         "                            , " + GetSqlDate(ДатаОтчета) +
         "                            ,ac.t_chapter "+
         "                            ,null "+
         "                            ) rest_out_table "+
         " from daccount_dbt ac) mas "+
         " where mas.debet_table <> mas.debet_provod "+
         " or mas.kredet_table <> mas.kredet_provod "+
         " or (mas.rest_in_table - mas.debet_table + mas.kredet_table) <> "+
         "                                                                mas.rest_out_table "+
         " or (mas.rest_in_table - mas.debet_provod + mas.kredet_provod) <> "+
         "                                                                mas.rest_out_table ";
   rs = trsbdataset(sql);
   table1.PrintHead(gol);
   private var first_line = true;
   while(rs.movenext())
      if (not(first_line))
         table1.printseparator; 
      end;
      table1.PrintStringTransferByWord(   rs.value("t_account"),
                                          rs.value("t_chapter"),
                                          rs.value("rest_in_table"),
                                          rs.value("debet_table"),
                                          rs.value("debet_provod"),
                                          rs.value("kredet_table"),
                                          rs.value("kredet_provod"),
                                          rs.value("rest_out_table")
                                       );
      first_line=false;
      end;
   table1.printbottom();
END;

private macro Bad_Symbol()
   private var table1 = CTableReport( 0, false, false );
   private var sql:string="", gol, rs;
   table1.addcolumn("Cчет плательщика",                           20);
   table1.addcolumn("Cчет получателя ",                           20);
   table1.addcolumn("Сумма  проводки",                            20);
   table1.addcolumn("дата проводки ",                             20);
   table1.addcolumn("Вид операции T_KIND_OPER",                   20);
   table1.addcolumn("Шифр документа T_SHIFR_OPER",                20);
   table1.addcolumn("Символ ",                                    20);
   gol="\n     ПРОВЕРЯЕМ НЕТ ЛИ ПРОВОДОК С СИМВОЛАМИ 03 23 62  \n";
   sql = " select ar.t_account_payer, ar.t_account_receiver, ar.t_sum , ar.t_date_carry, ar.t_kind_oper, ar.t_shifr_oper, sim.t_symbol "+
         "  from darhdoc_dbt ar, dsymbcash_dbt sim "+
         " where ar.t_chapter = 1 "+
         "   and ar.t_date_carry between " + GetSqlDate(ДатаОтчета) +
         "                           and " + GetSqlDate(ПредДатаОтчета) +
         "   and sim.t_applicationkey = lpad (ar.t_iapplicationkind, 5, '0') || ar.t_applicationkey "+
         "   and (trim (sim.t_symbol) = '03' "+
         "     or trim (sim.t_symbol) = '23' "+
         "     or trim (sim.t_symbol) = '62' ) ";

   rs = trsbdataset(sql);
   table1.PrintHead(gol);
   private var first_line = true;
   while(rs.movenext())
      if (not(first_line))
         table1.printseparator; 
      end;
      table1.PrintStringTransferByWord(   rs.value("t_account_payer"),
                                          rs.value("t_account_receiver"),
                                          rs.value("t_sum"),
                                          rs.value("t_date_carry"),
                                          rs.value("t_kind_oper"),
                                          rs.value("t_shifr_oper"),
                                          rs.value("t_symbol")
                                       );
      first_line=false;
      end;
   table1.printbottom();
END;

private macro ControlBalance()

   CheckBalanceConvergence();                // begin_dist_control
   CheckAccountInOutRestsConformity();
   CheckAccountRestsTurnsConformity();
   CheckAccountRestSignConformity();
   CheckBalanceAccountUniqueness();
//   CheckPairAccountsRests();
//   CheckCoverAccountRests();
   CheckOffBalanceAccountsCorrespondence();
   /* Коркин И.Н. По заявке I-032797. */
   CheckDocumentsAfterCloseAccount();        //  end_distr_control
   
   for(var x,1,3) 
      printtable("zad"+x);
      message("ПОИСК: "+gol);
      println();
      println();
   end;
   for(var y,5,8) 
      printtable2("zad"+y);
      message("ПОИСК: "+gol);
      println();
      println();
   end;
   not_type_kassa();
   prov_table_rest_date();
   Bad_Symbol();
end;


ControlBalance();