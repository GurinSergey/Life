import RcbClassLibInter;                                      
import rcbCoreInter;
import cb_sql;
import lib_lang;
import ReportNormalizer;
import ReptCbInter;
import ReportLinearRelation;
import controlExcludedAccounts;
import RcbProtocolView;
import testLib;
import RcbClassLibInter;

/**
 * Настройки!!!
 */

private const NORMALIZE_ROUBLE_TOTAL = true;

private const NORMALIZE_CURRENCY_TOTAL = true;

private const NORMALIZE_IN_REST = true;

private const PRINT_ERROR_PROTOCOL = true;

private const PRINT_CONSTRAINT_PROTOCOL = false;

//Эта настройка отключает поиск оптимального решения, её отключать не желательно.
//точность решения регулируется настройкой REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ
private const IS_OPTIMAL_DECISION = false;

/*******************************************************
 *Использeтся для перехода с алгоритма "В тысячах СМ"  *
 *в обычном режиме должна быть равна NULL              *
 ******************************************************/
private var ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER   : DOUBLE = 1.5;

if (    (rcbApplication.currentReport.createPreviousReport().normalizationAlgorithm != RCB_NA_MMB) 
    and (rcbApplication.currentReport.createPreviousReport().isCalculated()))
    ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER = 5.0;
end;

private var ERROR_OF_ROUBLE_OUT_REST_FOR_CHAPTER   : DOUBLE = 1.5;  //погрешность для рублевой составляющей по главе, если null, то стандартная
private var ERROR_OF_CURRENCY_OUT_REST_FOR_CHAPTER : DOUBLE = 1.5;  //погрешность для валютной составляющей по главе, если null, то стандартная

/******************************************************/

//константы для второй части нормализации
private const REST_MAX_ERROR_VALUE = 2.5; //максимальная погрешность на остатки
private const TURN_MAX_ERROR_VALUE = 3.0; //максимальная погрешность на обороты

private var ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_1;
private var ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_2;
private var ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_3;
private var ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_4;
private var ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_5;

private var ERROR_OF_OUTREST_FOR_CHAPTER_1;
private var ERROR_OF_OUTREST_FOR_CHAPTER_2;
private var ERROR_OF_OUTREST_FOR_CHAPTER_3;
private var ERROR_OF_OUTREST_FOR_CHAPTER_4;
private var ERROR_OF_OUTREST_FOR_CHAPTER_5;

private var ACCOUNT_PERMISSIBLE_DESICIONS;
private var MAX_TIME_OF_DESICIONS;

private var PRECISION;
private var ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;

getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ ПОГРЕШНОСТЬ/ГЛАВА 1", V_DOUBLE,  ERROR_OF_OUTREST_FOR_CHAPTER_1, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ ПОГРЕШНОСТЬ/ГЛАВА 2", V_DOUBLE,  ERROR_OF_OUTREST_FOR_CHAPTER_2, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ ПОГРЕШНОСТЬ/ГЛАВА 3", V_DOUBLE,  ERROR_OF_OUTREST_FOR_CHAPTER_3, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ ПОГРЕШНОСТЬ/ГЛАВА 4", V_DOUBLE,  ERROR_OF_OUTREST_FOR_CHAPTER_4, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНАЯ ПОГРЕШНОСТЬ/ГЛАВА 5", V_DOUBLE,  ERROR_OF_OUTREST_FOR_CHAPTER_5, null);



getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА 1", V_DOUBLE,  ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_1, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА 2", V_DOUBLE,  ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_2, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА 3", V_DOUBLE,  ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_3, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА 4", V_DOUBLE,  ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_4, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ПОГРЕШНОСТЬ ОКРУГЛЕНИЯ ОБОРОТОВ/ГЛАВА 5", V_DOUBLE,  ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_5, null);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/ОПТИМАЛЬНОСТЬ РЕШЕНИЯ",                   V_DOUBLE,  ACCOUNT_PERMISSIBLE_DESICIONS,          null);
ACCOUNT_PERMISSIBLE_DESICIONS = int(ACCOUNT_PERMISSIBLE_DESICIONS * 1000);
getRegistryValue("REPORT/FLOOR/НАСТРОЙКА ММБ/МАКСИМАЛЬНОЕ ВРЕМЯ РЕШЕНИЯ",              V_INTEGER, MAX_TIME_OF_DESICIONS,                  null);

getRegistryValue("REPTREG/REP_GROUPS/BALANCE_ACCOUNTS/ТОЧНОСТЬ ДЛЯ ГЛАВЫ Д", V_INTEGER,  PRECISION, null);        
ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5 = int("1" + mkstr( "0", PRECISION));


private class globalClass
    var currentReport : RcbReport = rcbApplication.currentReport();

    var previousReport = currentReport.createPreviousReport();

    //Рассчитать зависимые переменные (расчет по списку составляющих)
    var isCalculateDependencies = true;

    var variable = null;
end;

private var global = globalClass();

/**
 * Протокол.
 */
private class (TProtocolView) TBalanceProtocolView(description : String)
    private var m_table = CTableReport();

    initTProtocolView(description);

    macro constructor()
        m_table.addColumn("Имя переменной");
        m_table.addColumn("Точное значение|в нац. валюте", 25);
        m_table.addColumn("Округленное значение|в тысячах");
        m_table.addColumn("Нормализованное значение|в тысячах");
        m_table.addColumn("Погрешность|в тысячах");
        m_table.addColumn("Предупреждение");
    end;

    macro printDescription()
        setProtocolOutput();        
        printHead();
        resetProtocolOutput();    
    end;

    macro printHeadTable(chapter : String)
        setProtocolOutput(true);
        m_table.printHead();
        resetProtocolOutput();
    end;

    macro printString(variableName, exactValue, oldValue, newValue, def, warning)
        setProtocolOutput(true);
        m_table.printStringTransferByWord(variableName, exactValue, oldValue, newValue, def, warning);
        resetProtocolOutput();
    end;

    macro printStringExt(str : String)
        setProtocolOutput(true);
        m_table.printStringExt(str, m_table.getAColumns().size);
        resetProtocolOutput();
    end;

    macro printSeparator(isTop : Bool)
        setProtocolOutput(true);
        m_table.printSeparatorExt(true, isTop, m_table.getAColumns().size);
        resetProtocolOutput();
    end;

    macro printBottomTable()
        setProtocolOutput(true);
        m_table.printBottom();
        resetProtocolOutput();
    end;

    macro printLine(str)
        setProtocolOutput(true);
        printLine(str);
        resetProtocolOutput();
    end;
        
    constructor();
end;

private class TColumnKind
    const ACTIVE_IN_REST   : String = "ActiveInRest";
    const PASSIVE_IN_REST  : String = "PassiveInRest";

    const DEBET            : String = "Debet";
    const CREDIT           : String = "Credit";

    const ACTIVE_DEBET     : String = "ActiveDebet";
    const ACTIVE_CREDIT    : String = "ActiveCredit";

    const PASSIVE_DEBET    : String = "PassiveDebet";
    const PASSIVE_CREDIT   : String = "PassiveCredit";
    
    const ACTIVE_OUT_REST  : String = "ActiveOutRest";
    const PASSIVE_OUT_REST : String = "PassiveOutRest";
end;

private class TRowKind
    const TOTAL    : String = "Total";
    const ROUBLE   : String = "Rouble";
    const CURRENCY : String = "Currency";
end;


private class TChapter(chapter : Integer)
    
    private var m_chapter = chapter;
    
    const COLUMN_KIND = TColumnKind();

    const ROW_KIND = TRowKind();

    macro getName() : String
        return "Chapter_" + m_chapter;
    end;

    macro getChapter() : Integer
        return m_chapter;
    end;      

    macro isTerminalBalance(balanceNumber : String) : Bool
        if (balanceNumber == getName())
            return false;
        end;

        return true;    
    end;

    macro getTopBalance(balanceNumber : String)
        
        if (balanceNumber == getName())
            return "Root";
        end;

        if ((strLen(balanceNumber) == 5)and(balanceNumber != "99998")and(balanceNumber != "99999"))
            return substr(balanceNumber, 1, 3);
        end;

        return getName();        
    end;
      
end;

private class BalanceValue()
    private const ROW_KIND = TRowKind();

    private var m_rouble = 0.0;
    private var m_currency = 0.0;
    private var m_total = 0.0;

    macro plus(rowKind : String, value : Variant)
        if (rowKind == ROW_KIND.TOTAL)
            m_total = m_total + value;
        elif (rowKind == ROW_KIND.ROUBLE)
            m_rouble = m_rouble + value;
        elif (rowKind == ROW_KIND.CURRENCY)
            m_currency = m_currency + value;
        end;
        return this;
    end;

    macro get(rowKind : String)
        if (rowKind == ROW_KIND.TOTAL)
            return m_total;
        elif (rowKind == ROW_KIND.ROUBLE)
            return m_rouble;
        elif (rowKind == ROW_KIND.CURRENCY)
            return m_currency;
        end;
    end;
end;

private class Variable
    private var m_report = global.currentReport;

    private var m_previousReport = global.previousReport;

    private const COLUMN_KIND = TColumnKind();

    private const ROW_KIND = TRowKind();

    private macro VariableConstructor
        global.variable = this;
    end;


    macro getName(balanceNumber : String, columnKind : String, rowKind : String) : String

        var name = "Бн" + balanceNumber;

        if (rowKind == ROW_KIND.ROUBLE)
            name = name + "Ру";
        elif (rowKind == ROW_KIND.CURRENCY)
            name = name + "По";
        elif (rowKind == ROW_KIND.TOTAL)
            name = name + "__";
        end;

        if ((columnKind == COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == COLUMN_KIND.ACTIVE_OUT_REST))
            name = name + "А";
        elif ((columnKind == COLUMN_KIND.PASSIVE_IN_REST) or (columnKind == COLUMN_KIND.PASSIVE_OUT_REST))
            name = name + "П";
        elif (columnKind == COLUMN_KIND.DEBET)
            name = name + "Д";
        elif (columnKind == COLUMN_KIND.CREDIT)
            name = name + "К";
        end;

        return name;
    end;
    
    macro getExact(balanceNumber : String, columnKind : String, rowKind : String, chapter : Integer) : Money

        var av;

        if (columnKind == COLUMN_KIND.ACTIVE_IN_REST)
            if (m_previousReport.isCalculated())
                av = m_previousReport.attributeValue(this.getName(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, rowKind));

                if ((av == null) or (av.exact == null))
                    return $0.0;
                end;                    

                if(chapter == 5)
                    return av.exact * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
                else
                    return av.exact;
                end;
            
            else
                return getExact(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, rowKind)
                     - getExact(balanceNumber, COLUMN_KIND.DEBET, rowKind)
                     + getExact(balanceNumber, COLUMN_KIND.CREDIT, rowKind);                
            end;
        end;
        
        if (columnKind == COLUMN_KIND.PASSIVE_IN_REST)
            if (m_previousReport.isCalculated())
                av = m_previousReport.attributeValue(this.getName(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, rowKind));

                if ((av == null) or (av.exact == null))
                       return $0.0;
                end;                    

                if(chapter == 5)
                    return av.exact * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
                else
                    return av.exact;
                end;
            else
                return getExact(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, rowKind)
                     + getExact(balanceNumber, COLUMN_KIND.DEBET, rowKind)
                     - getExact(balanceNumber, COLUMN_KIND.CREDIT, rowKind);                
            end;
        end;

        var name;
        if ((columnKind == COLUMN_KIND.ACTIVE_DEBET) or (columnKind == COLUMN_KIND.PASSIVE_DEBET))
            name = this.getName(balanceNumber, COLUMN_KIND.DEBET, rowKind);           
        elif ((columnKind == COLUMN_KIND.ACTIVE_CREDIT) or (columnKind == COLUMN_KIND.PASSIVE_CREDIT))
            name = this.getName(balanceNumber, COLUMN_KIND.CREDIT, rowKind);           
        else
            name = this.getName(balanceNumber, columnKind, rowKind);       
        end;                                                                              
        
        av = m_report.attributeValue(name);
        
        if ((av == null) or (av.exact == null))
            return $0.0;
        end;

        if(chapter == 5)
            return av.exact * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
        else
            return av.exact;
        end;
    end;

    macro getScaled(balanceNumber : String, columnKind : String, rowKind : String, chapter : Integer) : Double
        
        var av;
                                       
        if (columnKind == COLUMN_KIND.ACTIVE_IN_REST)
            if (m_previousReport.isCalculated())
                av = m_previousReport.attributeValue(this.getName(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, rowKind));

                if ((av == null) or (av.exact == null))
                    return $0.0;
                end;                    

                if(chapter == 5)
                    return av.scaled * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
                else
                    return av.scaled; 
                end;
                                
            else
                return getScaled(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, rowKind)
                     - getScaled(balanceNumber, COLUMN_KIND.DEBET, rowKind)
                     + getScaled(balanceNumber, COLUMN_KIND.CREDIT, rowKind);
            end;            
        end;
        
        if (columnKind == COLUMN_KIND.PASSIVE_IN_REST)
            if (m_previousReport.isCalculated())
                av = m_previousReport.attributeValue(this.getName(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, rowKind));

                if ((av == null) or (av.exact == null))
                    return $0.0;
                end;                    

                if(chapter == 5)
                    return av.scaled * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
                else
                    return av.scaled; 
                end;
            else
                return getScaled(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, rowKind)
                     + getScaled(balanceNumber, COLUMN_KIND.DEBET, rowKind)
                     - getScaled(balanceNumber, COLUMN_KIND.CREDIT, rowKind);
            end;
        end;
        

        var name;
        if ((columnKind == COLUMN_KIND.ACTIVE_DEBET) or (columnKind == COLUMN_KIND.PASSIVE_DEBET))
            name = this.getName(balanceNumber, COLUMN_KIND.DEBET, rowKind);           
        elif ((columnKind == COLUMN_KIND.ACTIVE_CREDIT) or (columnKind == COLUMN_KIND.PASSIVE_CREDIT))
            name = this.getName(balanceNumber, COLUMN_KIND.CREDIT, rowKind);           
        else
            name = this.getName(balanceNumber, columnKind, rowKind);       
        end;                                                                              

        av = m_report.attributeValue(name);
        
        if ((av == null) or (av.exact == null))
            return 0.0;
        end;

        if(chapter == 5)
            return av.scaled * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
        else
            return av.scaled; 
        end;
    end;

    macro recalculateScaled(balanceNumber : String, columnKind : String, rowKind : String)
        var av = m_report.attributeValue(this.getName(balanceNumber, columnKind, rowKind));

        if (av == null)            
            return;
        end;

        av.recalculateScaled();
    end;

    macro setExact(balanceNumber : String, columnKind : String, rowKind : String, value : Money)
        var av = m_report.attributeValue(this.getName(balanceNumber, columnKind, rowKind));

        if (av == null)            
            return;
        end;
        av.exact = value;
    end;

    macro setScaled(balanceNumber : String, columnKind : String, rowKind : String, value : Double)
        var av = m_report.attributeValue(this.getName(balanceNumber, columnKind, rowKind));

        if (av == null)            
            return;
        end;
        av.scaled = value;
    end;

    VariableConstructor();
end;

Variable();



private class (ReportNormalizer) TBalanceChapterNormalizer(multipliyer : Double, chapter : Integer, isCalculateInRest : Bool)
    initReportNormalizer(multipliyer);
    var count = 0;
    
    private var m_chapterActiveInRestValue = BalanceValue();
    private var m_chapterPassiveInRestValue = BalanceValue();
    private var m_activeBalanceSet = TRcbSet();
    private var m_passiveBalanceSet = TRcbSet();



    private const COLUMN_KIND = TColumnKind();

    private const ROW_KIND = TRowKind();
    
    private var  m_report : RcbReport = rcbApplication.currentReport();

    private var m_previousReport = m_report.createPreviousReport();

    /**
     * Признак нормализации итоговых значений
     */
    private var m_isTotal = null;

    /**
     * Считать входящие остатки
     */
     var m_isCalculateInRest = isCalculateInRest;

    /**
     * Глава по каторой мы производим нормализацию.
     */
    private var m_chapter : TChapter = TChapter(chapter);

    /**
     * Последнее значенее группы для входящих остатков. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastGroupForInPutNodes = 3;
    /**
     * Последнее значенее группы для активных исходящих остатков и оборотов. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastGroupForOtherActiveNodes = 203;
    /**
     * Последнее значенее группы для пассивных исходящих остатков и оборотов. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastGroupForOtherPassiveNodes = 204;
    /**
     * Последнее значенее балансового счета первого порядка. Данная переменная необходима для задания групп балансовых счетов второго порядка.
     */
    private var m_lastFistBalance = "";
    /**
     * Дополнительнst условие для счетов 99998 и 99999 главы 3
     */
    private var m_relationFor99998InputTotal;

    private var m_relationFor99999InputTotal;

    private var m_relationFor99998OutputTotal;

    private var m_relationFor99999OutputTotal;

    private macro initRelationsForAccounts99998And99999(chapter : Integer)
        if (chapter == 3)                                                 
            m_relationFor99998InputTotal     = ReportLinearRelation(RCB_RS_EQUAL);

            m_relationFor99999InputTotal     = ReportLinearRelation(RCB_RS_EQUAL);

            m_relationFor99998OutputTotal    = ReportLinearRelation(RCB_RS_EQUAL);

            m_relationFor99999OutputTotal    = ReportLinearRelation(RCB_RS_EQUAL);
        end;
    end;

    macro addRelationsForLoroAccounts()
        this.addRelation(m_relationFor99998InputTotal);    

        this.addRelation(m_relationFor99999InputTotal);    

        this.addRelation(m_relationFor99998OutputTotal);    

        this.addRelation(m_relationFor99999OutputTotal);    
    end;

    macro getIsTotal() : Bool
        return m_isTotal;
    end;

    macro setIsTotal(isTotal : Bool)
        m_isTotal = isTotal;
    end;



    macro getNodeName(balanceNumber : String, columnKind : String, rowKind : String)
        return balanceNumber + columnKind + rowKind;
    end;

    /**
     * Возвращает верхний логический узел, для заданного узла.
     */
    private macro getTopNode(balanceNumber : String, columnKind : String, rowKind : String) 
        if (   (balanceNumber == m_chapter.getName()) 
            or (columnKind == m_chapter.COLUMN_KIND.DEBET) 
            or (columnKind == m_chapter.COLUMN_KIND.CREDIT))
            return this;
        end;

        return this.node(getNodeName(m_chapter.getName(), columnKind, rowKind));
    end;

    /**
     * Возвращает верхний уровень нормализации, для заданного узла.
     */
    private macro addTopNode(balanceNumber : String, columnKind : String, rowKind : String) 
        if (   (balanceNumber == m_chapter.getName()) 
            or (columnKind == m_chapter.COLUMN_KIND.DEBET) 
            or (columnKind == m_chapter.COLUMN_KIND.CREDIT))
            return this;
        end;        

        //Метод addNode не добавляет новый узел, если он уже содержится в нормализаторе.

        return this.addNode(getNodeName(m_chapter.getName(), columnKind, rowKind));
    end;    

    macro getChapter()
        return m_chapter;
    end;

    macro getNode(balanceNumber : String, columnKind : String, rowKind : String) : Variant
        //Если предыдущий период рассчитан, то возвращаем константное значение входящего остатка умноженное на множитель
        if (not m_isCalculateInRest) 
            if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST))
                var scaledValue = global.variable.getScaled(balanceNumber, columnKind, rowKind);
                var valueId = balanceNumber + rowKind;

                if (strLen(balanceNumber) == 5)
                    if (columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST)
        
                        if (not m_activeBalanceSet.find(valueId).isValid())
                            m_chapterActiveInRestValue.plus(rowKind, scaledValue);
                        end;
                        m_activeBalanceSet.insert(valueId);
                    elif (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST)

                        if (not m_passiveBalanceSet.find(valueId).isValid())
                            m_chapterPassiveInRestValue.plus(rowKind, scaledValue);
                        end;

                        m_passiveBalanceSet.insert(valueId);
                    end;
                elif (balanceNumber == m_chapter.getName())
                    if (columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST)
                        return m_chapterActiveInRestValue.get(rowKind);
                    elif (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST)
                        return m_chapterPassiveInRestValue.get(rowKind);
                    end;
                    return;
                end;

                return scaledValue;
            end;

        end;

        if (not getIsTotal() and (rowKind == m_chapter.ROW_KIND.TOTAL))
            return global.variable.getScaled(balanceNumber, columnKind, rowKind);
        end;


        var topNode = addTopNode(balanceNumber, columnKind, rowKind);
        
        var node = topNode.addNode(getNodeName(balanceNumber, columnKind, rowKind));

        return node;
    end;

    macro returnNode(balanceNumber : String, columnKind : String, rowKind : String)                               
        return this.node(getNodeName(balanceNumber, columnKind, rowKind));
    end;


    macro setNodeGroupAndPriority(balanceNumber : String, currentRecord, columnKind : String, rowKind : String)
        count = count + 1;
        var node = this.node(getNodeName(balanceNumber, columnKind, rowKind));
                        
        var group;
        if (balanceNumber == m_chapter.getName())
            if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST))

                if (m_isCalculateInRest)
                    node.setGroup(0);
                    group = this.getGroup(0);

                    if(rowKind == m_chapter.ROW_KIND.TOTAL)
                        node.setUserPriority(100.0);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE)                        
                        node.setUserPriority(50.0);
                    else                        
                        node.setUserPriority(0.0);
                    end;
                end;
            elif ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST))
                if(rowKind == m_chapter.ROW_KIND.TOTAL)
                    node.setGroup(200);
                elif (rowKind == m_chapter.ROW_KIND.ROUBLE)
                    node.setGroup(201);
                    node.setUserPriority(100.0);
                    group = this.getGroup(201);
                    group.setIsAdditionalCheck(true);
                    if (ERROR_OF_ROUBLE_OUT_REST_FOR_CHAPTER != null)
                        node.setDef(ERROR_OF_ROUBLE_OUT_REST_FOR_CHAPTER);
                    end;
                else
                    node.setGroup(201);
                    node.setUserPriority(0.0);
                    if (ERROR_OF_CURRENCY_OUT_REST_FOR_CHAPTER != null)
                        node.setDef(ERROR_OF_CURRENCY_OUT_REST_FOR_CHAPTER);
                    end;
                end;
            else
                if (ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER != null)
                    node.setDef(ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER);
                end;
                node.setGroup(202);
                group = this.getGroup(202);
                if (m_chapter.getChapter() == 1)
                    group.setIsSeparateOnSubgroups(true);
                    group.setIsOptimalDecision(false);
                    group.setMaxNumberOfDecision(ACCOUNT_PERMISSIBLE_DESICIONS);
                end;
                group.setIsAdditionalCheck(true);
                
                if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                    node.setUserPriority(100.0);
                elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                    node.setUserPriority(50.0);
                else
                    node.setUserPriority(0.0);
                end;
            end;

        elif ((strLen(balanceNumber) == 3)or(balanceNumber == "99998")or(balanceNumber == "99999") or (m_chapter.getChapter() == 5))
            if (columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST)
                node.setGroup(1);

                group = this.getGroup(1);
                
                if (m_isCalculateInRest)
                    group.setIsOptimalDecision(false);
                    group.setMaxNumberOfDecision(ACCOUNT_PERMISSIBLE_DESICIONS);

                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            elif (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST)
                node.setGroup(2);    

                group = this.getGroup(2);

                if (m_isCalculateInRest)
                    group.setIsOptimalDecision(false);
                    group.setMaxNumberOfDecision(ACCOUNT_PERMISSIBLE_DESICIONS);

                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            else
                node.setGroup(202);
                                              
                if ((columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST)or(columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST)) 
                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        if(currentRecord.isTotalExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);                        
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        if(currentRecord.isRoubleExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);                        
                    else
                        if(currentRecord.isCurrencyExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);                        
                    end;
                else
                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
                if (ERROR_OF_ROUBLE_OUT_REST_FOR_CHAPTER != null)
                    node.setDef(ERROR_OF_ROUBLE_OUT_REST_FOR_CHAPTER);
                end;
            end;
        else            
            if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_IN_REST))

                if (m_lastFistBalance == "")
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                elif (subStr(balanceNumber, 1, 3) != m_lastFistBalance)
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                    m_lastGroupForInPutNodes = m_lastGroupForInPutNodes + 1;
                    m_lastGroupForOtherActiveNodes = m_lastGroupForOtherActiveNodes + 2;
                    m_lastGroupForOtherPassiveNodes = m_lastGroupForOtherPassiveNodes + 2;
                end;

                node.setGroup(m_lastGroupForInPutNodes);

                group = this.getGroup(m_lastGroupForInPutNodes);
                
                if (m_isCalculateInRest)
                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            else
                if (m_lastFistBalance == "")
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                elif (subStr(balanceNumber, 1, 3) != m_lastFistBalance)
                    m_lastFistBalance = subStr(balanceNumber, 1, 3);
                    m_lastGroupForInPutNodes = m_lastGroupForInPutNodes + 1;
                    m_lastGroupForOtherActiveNodes = m_lastGroupForOtherActiveNodes + 2;
                    m_lastGroupForOtherPassiveNodes = m_lastGroupForOtherPassiveNodes + 2;                   
                end;

                if (    (columnKind == m_chapter.COLUMN_KIND.ACTIVE_DEBET) or (columnKind == m_chapter.COLUMN_KIND.ACTIVE_CREDIT)
                     or  (columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST))
                    node.setGroup(m_lastGroupForOtherActiveNodes);
                else
                    node.setGroup(m_lastGroupForOtherPassiveNodes);
                end;

                if ((columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST))
                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        if(currentRecord.isTotalExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);                        
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        if(currentRecord.isRoubleExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);                        
                    else
                        if(currentRecord.isCurrencyExcluded == 1)
                            node.setDef(0.5);
                        end;
                        node.setUserPriority(currentRecord.k);                        
                    end;
                else
                    if (rowKind == m_chapter.ROW_KIND.TOTAL) 
                        node.setUserPriority(currentRecord.k);
                    elif (rowKind == m_chapter.ROW_KIND.ROUBLE) 
                        node.setUserPriority(currentRecord.k);
                    else
                        node.setUserPriority(currentRecord.k);
                    end;
                end;
            end;    
        end;

        if ((node != null) and (node.exact == 0.0) and (node.getDef() > 1.0))
            node.setDef(1.0);
        end;

    end;

    macro setNodeValue(currentRecord, columnKind : String, rowKind : String, exactValue : Money, scaledValue : Double)
        var node = getNode(currentRecord.balance, columnKind, rowKind);
/*!!!*/        
        if ((strLen(currentRecord.balance) == 3)and((columnKind == m_chapter.COLUMN_KIND.ACTIVE_OUT_REST) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_OUT_REST)))
            node.setDef(2.0);    
        end;        

        if ((    (columnKind == m_chapter.COLUMN_KIND.ACTIVE_DEBET) or (columnKind == m_chapter.COLUMN_KIND.ACTIVE_CREDIT)
              or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_DEBET) or (columnKind == m_chapter.COLUMN_KIND.PASSIVE_CREDIT)
              or (columnKind == m_chapter.COLUMN_KIND.DEBET) or (columnKind == m_chapter.COLUMN_KIND.CREDIT)))            
            if(m_chapter.getChapter() == 1)
                node.setDef(ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_1);
            elif(m_chapter.getChapter() == 2)
                node.setDef(ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_2);
            elif(m_chapter.getChapter() == 3)
                node.setDef(ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_3);
            elif(m_chapter.getChapter() == 4)
                node.setDef(ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_4);
            elif(m_chapter.getChapter() == 5)
                node.setDef(ERROR_OF_DEDET_OR_CREDIT_FOR_CHAPTER_5);
            end;
        end;

        var value = nvl(exactValue, 0.0);

        node.setExact(value);

        var topNode;

        if (   (columnKind == m_chapter.COLUMN_KIND.DEBET) 
            or (columnKind == m_chapter.COLUMN_KIND.CREDIT))
            if (scaledValue == null)
                node.recalculateScaled();                
            else
                node.setScaled(int(scaledValue));
            end;
        else
            if (scaledValue == null)
                topNode = getTopNode(currentRecord.balance, columnKind, rowKind);

                topNode.setExact(topNode.getExact() + Double(value));

                topNode.recalculateScaled();
                node.recalculateScaled();
            else
                node.setScaled(int(scaledValue));

                topNode = getTopNode(currentRecord.balance, columnKind, rowKind);

                topNode.setExact(topNode.getExact() + Double(value));

                topNode.setScaled(topNode.getScaled() + nvl(int(scaledValue), 0));
            end;
        end;

        setNodeGroupAndPriority(currentRecord.balance, currentRecord, columnKind, rowKind);
    end;
    /**
     * Добавляем ограничения по строке ВхОстаток = ИсхОстаток +/- Обороты.
     */
    private macro addRowConstraint(balanceNumber : String, kindAccount : String, rowKind : String)
        var activeInRestNode;        
        var passiveInRestNode;
        
        var activeOutRestNode;        
        var passiveOutRestNode;
        
        var activeDebetNode;
        var passiveDebetNode;

        var activeCreditNode;
        var passiveCreditNode;

        var debetNode;
        var creditNode;

        var relation1; 
        var relation2;
        var relation3;
        var relation4;
        var relation5;
        
        if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))

            activeInRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST,  rowKind);        
            passiveInRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, rowKind);
        
            activeOutRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST,  rowKind);
            passiveOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, rowKind);
            
            activeDebetNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET,  rowKind);
            passiveDebetNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, rowKind);

            activeCreditNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT,  rowKind);
            passiveCreditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, rowKind); 

                relation1 = ReportLinearRelation(RCB_RS_EQUAL);
                relation1.lhs.plus(activeInRestNode).plus(activeDebetNode).minus(activeCreditNode);
                relation1.rhs.plus(activeOutRestNode); 
                this.addRelation(relation1);

                relation2 = ReportLinearRelation(RCB_RS_EQUAL);
                relation2.lhs.plus(passiveInRestNode).plus(passiveCreditNode).minus(passiveDebetNode);
                relation2.rhs.plus(passiveOutRestNode); 
                this.addRelation(relation2);

            if (kindAccount == "АП")
                debetNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.DEBET,  rowKind);
                creditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, rowKind);

                relation3 = ReportLinearRelation(RCB_RS_EQUAL);
                relation3.lhs.plus(activeDebetNode).plus(passiveDebetNode);
                relation3.rhs.plus(debetNode);
                this.addRelation(relation3);    

                relation4 = ReportLinearRelation(RCB_RS_EQUAL);
                relation4.lhs.plus(activeCreditNode).plus(passiveCreditNode);
                relation4.rhs.plus(creditNode);
                this.addRelation(relation4);
            elif ((balanceNumber == m_chapter.getName()) and (rowKind == m_chapter.ROW_KIND.TOTAL)) 

                relation3 = ReportLinearRelation(RCB_RS_EQUAL);
                relation3.lhs.plus(passiveInRestNode);
                relation3.rhs.plus(activeInRestNode);
                this.addRelation(relation3);    

                relation4 = ReportLinearRelation(RCB_RS_EQUAL);
                relation4.lhs.plus(activeOutRestNode);
                relation4.rhs.plus(passiveOutRestNode);
                this.addRelation(relation4);

                relation5 = ReportLinearRelation(RCB_RS_EQUAL);
                relation5.lhs.plus(activeDebetNode).plus(passiveDebetNode);
                relation5.rhs.plus(activeCreditNode).plus(passiveCreditNode);
                this.addRelation(relation5);  
            end;
            
        elif (kindAccount == "А")
            activeInRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, rowKind);        
            activeOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, rowKind);        
            activeDebetNode   = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, rowKind);
            activeCreditNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, rowKind);

            relation1 = ReportLinearRelation(RCB_RS_EQUAL);
            relation1.lhs.plus(activeInRestNode).plus(activeDebetNode).minus(activeCreditNode);
            relation1.rhs.plus(activeOutRestNode); 
            this.addRelation(relation1);
        else
            passiveInRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, rowKind);
            passiveOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, rowKind);
            passiveDebetNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, rowKind);
            passiveCreditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, rowKind); 

            relation2 = ReportLinearRelation(RCB_RS_EQUAL);
            relation2.lhs.plus(passiveInRestNode).plus(passiveCreditNode).minus(passiveDebetNode);
            relation2.rhs.plus(passiveOutRestNode); 
            this.addRelation(relation2);
        end;                                    
    end;

    /**
     * Проверяем наличие счетов с равными остатками. Причем остатки должны округляться без погрешности.
     */
    private macro checkEqualRests(balanceNumber : String, kindAccount : String, rowKind : String)
        var activeInRestNode;        
        var passiveInRestNode;
        
        var activeOutRestNode;        
        var passiveOutRestNode;
        
        var activeDebetNode;
        var passiveDebetNode;

        var activeCreditNode;
        var passiveCreditNode;        

        if (not m_isCalculateInRest)
            return;
        end;

                
        if (kindAccount == "А")
            activeInRestNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, rowKind);        
            activeOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, rowKind);        
            activeDebetNode   = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, rowKind);
            activeCreditNode  = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, rowKind);

            if ((activeInRestNode.getExact() == activeOutRestNode.getExact()) and (activeOutRestNode.getDef() == 0.5))                
                activeDebetNode.setGroup(202);
                activeCreditNode.setGroup(202);
            end;
        elif (kindAccount == "П")
            passiveInRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, rowKind);
            passiveOutRestNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, rowKind);
            passiveDebetNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, rowKind);
            passiveCreditNode = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, rowKind); 

            if ((passiveInRestNode.getExact() == passiveOutRestNode.getExact()) and (passiveOutRestNode.getDef() == 0.5))                
                passiveDebetNode.setGroup(202);
                passiveCreditNode.setGroup(202);
            end;
        end;                                    
    end;

     /**
     * Добавляем ограничения, по итогам Рубли + Валюта = Итог.
     */
    private macro addTotalConstraints(balanceNumber : String, columnKind : String)
        var totalNode    = getNode(balanceNumber, columnKind, m_chapter.ROW_KIND.TOTAL);        
        var roubleNode   = getNode(balanceNumber, columnKind, m_chapter.ROW_KIND.ROUBLE);
        var currencyNode = getNode(balanceNumber, columnKind, m_chapter.ROW_KIND.CURRENCY);

        var relation = ReportLinearRelation(RCB_RS_EQUAL);
                
        relation.lhs.plus(roubleNode).plus(currencyNode);        
        relation.rhs.plus(totalNode);
        this.addRelation(relation);

        if (not in(valType(totalNode), V_MONEY, V_DOUBLE))
            totalNode.exclude();
        end;
    end;
    /**
     * Добавляем ограничения для корреспонденских счетов 99998 и 99999 главы В.
     */
    private macro addConstraintForLoroAccount(balanceNumber : String, kindAccount : String)
        
        var inRestNodeTotal;
        var inRestNodeCurrency;        
        var inRestNodeRouble;        
                
        var outRestNodeTotal;        
        var outRestNodeCurrency;        
        var outRestNodeRouble;        

        if (kindAccount == "А")
            inRestNodeTotal      = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL);
                
            outRestNodeTotal     = getNode(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL);        
        elif (kindAccount == "П")
            inRestNodeTotal      = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL);
                
            outRestNodeTotal     = getNode(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL);        
        end;
                                
        if (balanceNumber == "99998")
            m_relationFor99998InputTotal.lhs.plus(inRestNodeTotal);

            m_relationFor99998OutputTotal.lhs.plus(outRestNodeTotal);
        elif (balanceNumber == "99999")
            m_relationFor99999InputTotal.lhs.plus(inRestNodeTotal);

            m_relationFor99999OutputTotal.lhs.plus(outRestNodeTotal);
        elif (kindAccount == "А")
            m_relationFor99999InputTotal.rhs.plus(inRestNodeTotal);

            m_relationFor99999OutputTotal.rhs.plus(outRestNodeTotal);
        elif (kindAccount == "П")
            m_relationFor99998InputTotal.rhs.plus(inRestNodeTotal);

            m_relationFor99998OutputTotal.rhs.plus(outRestNodeTotal);
        end;
    end;

    /** 
     * Добавляем ограничения.
     */
    macro addBalance(balanceNumber : String, kindAccount : String)

        if (getIsTotal())
            addRowConstraint(balanceNumber, kindAccount, m_chapter.ROW_KIND.TOTAL);
        else
            addRowConstraint(balanceNumber, kindAccount, m_chapter.ROW_KIND.ROUBLE);
            addRowConstraint(balanceNumber, kindAccount, m_chapter.ROW_KIND.CURRENCY);        

            if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST);
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST);
            elif (kindAccount == "А")
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST);
            else
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST);
            end;

            if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET);
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET);

                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT);
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT);

                if (kindAccount == "АП")
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.CREDIT);
                    addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.DEBET);                
                end;                       
            elif (kindAccount == "А")
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET);
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT);
            else
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET);
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT);
            end;
            
            if ((kindAccount == "АП") or (balanceNumber == m_chapter.getName()))
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST);
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST);
            elif (kindAccount == "А")
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST);
            else
                addTotalConstraints(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST);
            end;
        end;

        if (strLen(balanceNumber) == 5)
            if (getIsTotal())
                checkEqualRests(balanceNumber, kindAccount, m_chapter.ROW_KIND.TOTAL);
                if (m_chapter.getChapter() == 3)
                    addConstraintForLoroAccount(balanceNumber, kindAccount);
                end;
            else
                checkEqualRests(balanceNumber, kindAccount, m_chapter.ROW_KIND.ROUBLE);
                checkEqualRests(balanceNumber, kindAccount, m_chapter.ROW_KIND.CURRENCY);        
            end;
        end;

    end;

    /** 
     * Устанавливаем уровени для каждой вершины данног счета.
     */
    
    macro setLevelForNode(balanceNumber : String, kindAccount : String)
        var node;
        
        if((strLen(balanceNumber) == 3)or(balanceNumber == "99998")or(balanceNumber == "99999") or (m_chapter.getChapter() == 5))
            if (kindAccount == "А")
                if (m_isCalculateInRest)

                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));    
                        node.setLevel(3);
                    else
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));    
                        node.setLevel(8);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));    
                        node.setLevel(13);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(23);
                else

                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(28);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(33);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63); 
                end;
            elif(kindAccount == "П")
                if (m_isCalculateInRest)

                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));    
                        node.setLevel(3);
                    else
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));    
                        node.setLevel(8);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));    
                        node.setLevel(13);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(23);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(28);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(33);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63); 
                end;
            elif(kindAccount == "АП")
                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));    
                        node.setLevel(3);
                    else
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));    
                        node.setLevel(8);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));    
                        node.setLevel(13);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(23);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(28);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(33);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63); 
                end;

                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));    
                        node.setLevel(3);
                    else
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));    
                        node.setLevel(8);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));    
                        node.setLevel(13);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(23);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(28);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(33);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63); 
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(53);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(58);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(63);    
                end;
            end;               
        elif (strLen(balanceNumber) == 5)
            if (kindAccount == "А")
                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));    
                        node.setLevel(83);
                    else
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));    
                        node.setLevel(88);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));    
                        node.setLevel(93);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(103);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(108);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(113);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(133);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(138);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(143);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(133);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(138);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.ACTIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(143); 
                end;
            elif(kindAccount == "П")
                if (m_isCalculateInRest)
                    if (getIsTotal())
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.TOTAL));    
                        node.setLevel(83);
                    else
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.ROUBLE));    
                        node.setLevel(88);
                        node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.ROW_KIND.CURRENCY));    
                        node.setLevel(93);
                    end;
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(103);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(108);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(113);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(133);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(138);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(143);
                end;

                if (getIsTotal())
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.TOTAL));    
                    node.setLevel(133);
                else
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.ROUBLE));    
                    node.setLevel(138);
                    node = this.node(getNodeName(balanceNumber, m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.ROW_KIND.CURRENCY));    
                    node.setLevel(143); 
                end;
            end;
        end;        
    end;

    macro addAdditionalConstraints(balanceNumber : String, kindAccount : String)
        /***********************************************************************************************************************
        * Перед проведением нормализации определяются счета, нормализация которых производится по особым правилам.             *
        * К таким счетам относятся счета, для которых одновременно выполняются два условия:                                    *
        *    Одна из составляющих исходящего остатка (рубли или валюта) нулевая,                                               *
        *    Обороты по ненулевой составляющей исходящего остатка нулевые.                                                     *
        *                                                                                                                      *
        * Из этих условий следует, что сумма итогового исходящего остатка должна быть равна сумме ненулевой составляющей       *
        * исходящего остатка и равна этой же составляющей входящего остатка. Отсюда следует, что независимо от того с какой    *
        * погрешностью было получено рассматриваемое значение составляющей входящего остатка, такое же значение присваивается  *
        * итоговому исходящему остатку и это значение фиксируется. Надо понимать, что на втором этапе это же значение получит  *
        * ненулевая  составляющая итогового исходящего.                                                                        *
        ************************************************************************************************************************/

        macro addConstraint(node : Object, value : Double, sign : Integer)
            var relation = ReportLinearRelation(nvl(sign, RCB_RS_EQUAL));
            
            relation.lhs.plus(node);
            relation.rhs.plus(value); 

            this.addRelation(relation);
        end;

        //Если предыдущий не расчитан, то выходим, так как входящие остатки можно корректировать
        if (not m_previousReport.isCalculated())
            return;
        end;


        var outRestKind = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_OUT_REST, m_chapter.COLUMN_KIND.ACTIVE_OUT_REST);

        var debetKind   = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_DEBET, m_chapter.COLUMN_KIND.ACTIVE_DEBET);

        var creditKind  = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_CREDIT, m_chapter.COLUMN_KIND.ACTIVE_CREDIT);
        
        var inRestKind  = ternary (kindAccount == "П", m_chapter.COLUMN_KIND.PASSIVE_IN_REST, m_chapter.COLUMN_KIND.ACTIVE_IN_REST);

        var totalOutRestNode = this.node(getNodeName(balanceNumber, outRestKind, m_chapter.ROW_KIND.TOTAL));    

        //При нулевых значениях итогового значения, состовляющие по рублям и валюте будут тоже нулевыми
        if (totalOutRestNode.exact == $0.0)
           return;
        end;

        var roubleOutRestExactValue    = global.variable.getExact(balanceNumber, outRestKind, m_chapter.ROW_KIND.ROUBLE);
        var roubleOutRestScaledValue   = global.variable.getScaled(balanceNumber, outRestKind, m_chapter.ROW_KIND.ROUBLE);

        var currencyOutRestExactValue  = global.variable.getExact(balanceNumber, outRestKind, m_chapter.ROW_KIND.CURRENCY);
        var currencyOutRestScaledValue = global.variable.getScaled(balanceNumber, outRestKind, m_chapter.ROW_KIND.CURRENCY);

        //Если рублевая и валютная составляющая отличны от нуля, то это тоже не наш случай
        if ((roubleOutRestExactValue != 0) and (currencyOutRestExactValue != 0))
            return;
        end;

        var roubleDebetExactValue    = global.variable.getExact(balanceNumber, debetKind, m_chapter.ROW_KIND.ROUBLE);
        var roubleDebetScaledValue   = global.variable.getScaled(balanceNumber, debetKind, m_chapter.ROW_KIND.ROUBLE);

        var currencyDebetExactValue  = global.variable.getExact(balanceNumber, debetKind, m_chapter.ROW_KIND.CURRENCY);
        var currencyDebetScaledValue = global.variable.getScaled(balanceNumber, debetKind, m_chapter.ROW_KIND.CURRENCY);


        var roubleCreditExactValue    = global.variable.getExact(balanceNumber, creditKind, m_chapter.ROW_KIND.ROUBLE);
        var roubleCreditScaledValue   = global.variable.getScaled(balanceNumber, creditKind, m_chapter.ROW_KIND.ROUBLE);

        var currencyCreditExactValue  = global.variable.getExact(balanceNumber, creditKind, m_chapter.ROW_KIND.CURRENCY);
        var currencyCreditScaledValue = global.variable.getScaled(balanceNumber, creditKind, m_chapter.ROW_KIND.CURRENCY);

        //Если по одной из составляющих все значения нулевые, то значения оставшейся составляющей будет полностью равно итоговой 
        if (   ((roubleOutRestExactValue == 0.0) and (roubleCreditExactValue == 0.0) and (roubleDebetExactValue == 0.0))
            or
               ((currencyOutRestExactValue == 0.0) and (currencyCreditExactValue == 0.0) and (currencyDebetExactValue == 0.0)))

            return;
        end;

        var roubleInRestScaledValue = global.variable.getScaled(balanceNumber, inRestKind, m_chapter.ROW_KIND.ROUBLE);
        var currencyInRestScaledValue = global.variable.getScaled(balanceNumber, inRestKind, m_chapter.ROW_KIND.CURRENCY);

        var totalDebetNode  = this.node(getNodeName(balanceNumber, debetKind, m_chapter.ROW_KIND.TOTAL));    
        var totalCreditNode = this.node(getNodeName(balanceNumber, creditKind, m_chapter.ROW_KIND.TOTAL));    

        if ((roubleOutRestExactValue != 0.0) and (roubleCreditExactValue == 0.0) and (roubleDebetExactValue == 0.0))
            addConstraint(totalOutRestNode, roubleInRestScaledValue);
            
            totalOutRestNode.setDef(REST_MAX_ERROR_VALUE);
            totalCreditNode.setDef(TURN_MAX_ERROR_VALUE);
            totalDebetNode.setDef(TURN_MAX_ERROR_VALUE);
        end;

        if ((currencyOutRestExactValue != 0.0) and (currencyCreditExactValue == 0.0) and (currencyDebetExactValue == 0.0))
            addConstraint(totalOutRestNode, currencyInRestScaledValue);
            
            totalOutRestNode.setDef(REST_MAX_ERROR_VALUE);
            totalCreditNode.setDef(TURN_MAX_ERROR_VALUE);
            totalDebetNode.setDef(TURN_MAX_ERROR_VALUE);
        end;

        /***********************************************************************************************************************
        *  второй особый случай, т.е. еще одну поверку для нормализации по особым правилам.                                    *
        *    К таким счетам относятся счета, для которых одновременно выполняются два условия:                                 *
        *       Одна из составляющих исходящего остатка (рубли или валюта) нулевая, во входящем остатке эта составляющая       *
        *      ненулевая.                                                                                                      *
        *       Один из оборотов по этой составляющей нулевой, а во втором вторая составляющая - нулевая (т.е. в одном         *
        *      обороте одна составляющая нулевая, а во втором обороте - другая)                                                *
        *                                                                                                                      *
        *  Из этих условий следует, что сумма итогового оборота (в котором ненулевой оборот по рассматриваемой нами            *
        *  составляющей) должна быть равна сумме ненулевой составляющей входящего остатка и сумме ненулевой составляющей       *
        *  по этому же обороту.  Соответственно, вторая составляющая должна остаться нулевой.                                  *
        *                                                                                                                      *
        ************************************************************************************************************************/

        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue == 0) and (currencyCreditExactValue != 0) and (roubleCreditExactValue == 0))
            addConstraint(totalCreditNode, currencyInRestScaledValue);
            totalDebetNode.setDef(TURN_MAX_ERROR_VALUE);
        end;

        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue != 0) and (currencyCreditExactValue == 0) and (roubleDebetExactValue == 0))
            addConstraint(totalDebetNode, currencyInRestScaledValue);
            totalCreditNode.setDef(TURN_MAX_ERROR_VALUE);
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue == 0) and (roubleCreditExactValue != 0) and (currencyCreditExactValue == 0))
            addConstraint(totalCreditNode, roubleInRestScaledValue);
            totalDebetNode.setDef(TURN_MAX_ERROR_VALUE);
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue != 0) and (roubleCreditExactValue == 0) and (currencyDebetExactValue == 0))
            addConstraint(totalDebetNode, roubleInRestScaledValue);
            totalCreditNode.setDef(TURN_MAX_ERROR_VALUE);
        end;
        /***********************************************************************************************************************
        *
        * Третий особый случай. Определяем счета, для которых одновременно выполняются два условия:
        * Одна из составляющих исходящего остатка (рубли или валюта) нулевая, во входящем остатке эта составляющая ненулевая.
        * Один из оборотов по этой составляющей нулевой, вторая составляющая по этому обороту ненулевая.  
        *
        * Сумма  ненулевой составляющей  оборота  должна быть равна сумме ненулевой составляющей входящего остатка по этой же составляющей. 
        * Но, поскольку при выполнении первого этапа нормализуются только итоговые значения, то задать в качестве константы значение 
        * для составляющей невозможно, поэтому  условие, налагаемое на первый этап, будет следующим:
        * сумма итогового оборота (того, в котором ненулевая составляющая рассматриваемого счета) должна быть больше или равна сумме 
        * составляющей входящего остатка.
        *
        * Условие равенства составляющей входящего остатка и составляющей оборота будет выполнено автоматически на втором этапе, 
        * т.к. исходящая составляющая и составляющая второго оборота нулевые.
        *
        * пятую проверку в if добавил от себя, чтобы не трогать уже обработанные вторым особым случаем счета
        *************************************************************************************************************************/
        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue == 0) and (currencyCreditExactValue != 0) and (roubleCreditExactValue != 0))
            addConstraint(totalCreditNode, currencyInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;

        if ((currencyInRestScaledValue != 0) and (currencyOutRestExactValue == 0) and (currencyDebetExactValue != 0) and (currencyCreditExactValue == 0) and (roubleDebetExactValue != 0))
            addConstraint(totalDebetNode, currencyInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue == 0) and (roubleCreditExactValue != 0) and (currencyCreditExactValue != 0))
            addConstraint(totalCreditNode, roubleInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;

        if ((roubleInRestScaledValue != 0) and (roubleOutRestExactValue == 0) and (roubleDebetExactValue != 0) and (roubleCreditExactValue == 0) and (currencyDebetExactValue != 0))
            addConstraint(totalDebetNode, roubleInRestScaledValue, RCB_RS_GREATER_OR_EQUAL);
        end;
    end;

    initRelationsForAccounts99998And99999(chapter);

end;

private class TNormalizeBalanceController(chapter, isRecalculateIfNotNormalized)

    private var  m_report : RcbReport = rcbApplication.currentReport();

    private var m_previousReport = m_report.createPreviousReport();

    private const COLUMN_KIND = TColumnKind();

    private const ROW_KIND = TRowKind();

    private var m_protocolView;

    private var m_normalizer;

    /**
     Данная переменная показывает какие главы необходимо нормализовать
     0 - все главы
     1 - 1 глава
     2 - 2 глава
     3 - 3 глава
     4 - 4 глава
     5 - 5 глава    
    */    
    private var  m_chapter = chapter;

    /**
        Данная переменная показывает текущую главу, по которой происходит нормализация
     */
    private var  m_currentChapter;

    private var m_isRecalculateIfNotNormalized = nvl(isRecalculateIfNotNormalized, false);
    
    private macro initProtocolView(chapter);                                                     
        m_protocolView = TBalanceProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ " + String(chapter) + " ГЛАВЫ");        
    end;
    
    class BalanceInfo(chapter : Integer, balanceNumber : String, kindAccount: String, record_ : Object)

        private var m_balanceNumber = balanceNumber;
        private var m_kindAccount = kindAccount;
        private var m_record = record_;
        private var m_chapter = chapter;

        macro getRecord()
            return m_record;
        end;

        macro getChapter()
            return m_chapter;
        end;

        macro getBalanceNumber()
            return m_balanceNumber;
        end;

        macro getKindAccount()
            return m_kindAccount;
        end;
    end;

    private macro loadValue(normalizer : ReportNormalizer, currentRecord : Object, columnKind : String)
        if ((columnKind == COLUMN_KIND.ACTIVE_IN_REST) or (columnKind == COLUMN_KIND.PASSIVE_IN_REST))

            if (m_previousReport.isCalculated())

                return;            
            end;  
        
        end;

        if (currentRecord.balance == m_normalizer.getChapter().getName())
            if (m_normalizer.getIsTotal())
            normalizer.setNodeValue(currentRecord, 
                                    columnKind, 
                                    ROW_KIND.TOTAL, 
                                    $0.0);

            else
                normalizer.setNodeValue(currentRecord, 
                                        columnKind, 
                                        ROW_KIND.ROUBLE, 
                                        $0.0);

                normalizer.setNodeValue(currentRecord, 
                                        columnKind, 
                                        ROW_KIND.CURRENCY, 
                                        $0.0);
            end;
            return;
        end;       

        if (m_normalizer.getIsTotal())
            normalizer.setNodeValue(currentRecord, 
                                    columnKind, 
                                    ROW_KIND.TOTAL, 
                                    global.variable.getExact(currentRecord.balance, columnKind, ROW_KIND.TOTAL));

        else
            normalizer.setNodeValue(currentRecord, 
                                    columnKind, 
                                    ROW_KIND.ROUBLE, 
                                    global.variable.getExact(currentRecord.balance, columnKind, ROW_KIND.ROUBLE));

            normalizer.setNodeValue(currentRecord, 
                                    columnKind, 
                                    ROW_KIND.CURRENCY, 
                                    global.variable.getExact(currentRecord.balance, columnKind, ROW_KIND.CURRENCY));
        end;
    end;

    private macro loadBalance(normalizer : ReportNormalizer, currentRecord)

        if (currentRecord.kindAccount == "А")
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_IN_REST);
        elif (currentRecord.kindAccount == "П")
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_IN_REST);
        else
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_IN_REST);
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_IN_REST);
        end;

        if (currentRecord.kindAccount == "А")
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_DEBET);
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_CREDIT);
        elif (currentRecord.kindAccount == "П")
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_DEBET);
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_CREDIT);
        else            
            loadValue(normalizer, currentRecord, COLUMN_KIND.DEBET);
            loadValue(normalizer, currentRecord, COLUMN_KIND.CREDIT);
            
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_DEBET);
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_CREDIT);
            
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_DEBET);
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_CREDIT); 
        end;

        if (currentRecord.kindAccount == "А")
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_OUT_REST);

        
        elif (currentRecord.kindAccount == "П")
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_OUT_REST);

        else
            loadValue(normalizer, currentRecord, COLUMN_KIND.ACTIVE_OUT_REST);
            loadValue(normalizer, currentRecord, COLUMN_KIND.PASSIVE_OUT_REST);
        end;

        normalizer.addBalance(currentRecord.balance, currentRecord.kindAccount);
        normalizer.setLevelForNode(currentRecord.balance, currentRecord.kindAccount);
        normalizer.addAdditionalConstraints(currentRecord.balance, currentRecord.kindAccount);

    end;

    private macro recalculateValue(normalizer : ReportNormalizer, balanceNumber : String, kindAccount : String, columnKind : String, rowKind : String)
        if(m_currentChapter == 5)
            global.variable.setScaled(balanceNumber, kindAccount, columnKind, rowKind, floor(global.variable.getExact(balanceNumber, kindAccount, columnKind, rowKind) * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5)/ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5);
        else
            global.variable.recalculateScaled(balanceNumber, columnKind, rowKind);            
        end;
    end;

    private macro returnStr(value)
        return execExp("String(value:0:" + PRECISION + ")");
    end;

    private macro setMaxError(currentRecord : Object)

        var node = null;

        if (currentRecord.kindAccount == "П")
            node = m_normalizer.returnNode(currentRecord.balance, COLUMN_KIND.PASSIVE_OUT_REST, ROW_KIND.TOTAL);    
        else
            node = m_normalizer.returnNode(currentRecord.balance, COLUMN_KIND.ACTIVE_OUT_REST, ROW_KIND.TOTAL);    
        end;

        if (node.exact != $0.0)
            node.setDef(currentRecord.isMaxError);    
        end;
    end;


    private macro saveValue(normalizer : ReportNormalizer, balanceNumber : String, kindAccount : String, columnKind : String, rowKind : String)
        
        var name = global.variable.getName(balanceNumber, columnKind, rowKind);
            
        var av = m_report.attributeValue(name);

        if (av == null)            
            return;
        end;
            
        var node;

        if ((columnKind == COLUMN_KIND.DEBET) and m_normalizer.getIsTotal()) 
            if (kindAccount == "А")
                node = normalizer.returnNode(balanceNumber, COLUMN_KIND.ACTIVE_DEBET, rowKind);
            elif(kindAccount == "П")
                node = normalizer.returnNode(balanceNumber, COLUMN_KIND.PASSIVE_DEBET, rowKind);
            else
                node = normalizer.returnNode(balanceNumber, columnKind, rowKind);
            end;
        elif ((columnKind == COLUMN_KIND.CREDIT) and m_normalizer.getIsTotal())
            if (kindAccount == "А")
                node = normalizer.returnNode(balanceNumber, COLUMN_KIND.ACTIVE_CREDIT, rowKind);
            elif(kindAccount == "П")
                node = normalizer.returnNode(balanceNumber, COLUMN_KIND.PASSIVE_CREDIT, rowKind);
            else
                node = normalizer.returnNode(balanceNumber, columnKind, rowKind);
            end;
        else
            node = normalizer.returnNode(balanceNumber, columnKind, rowKind);
        end;

        var exact = av.exact;
        var scaled;
        var normalized;
                             
        if(m_currentChapter == 5)
            scaled = double(floor(av.exact * ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5));
            av.scaled = scaled/ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;
            normalized = node.getScaledInDoubleFormat();
        else
            av.recalculateScaled();
            scaled = av.scaled;
            normalized = node.getScaled();
        end;
        if (scaled != normalized)

            var warning : STRING = "Warning!!! Большая погрешность!";

            if(m_currentChapter == 5)
                av.scaled = normalized / ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5;

                var def = abs (exact/ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5 - av.scaled);

                if (def < 1.)
                    warning = "";
                end;


                m_protocolView.printString(name, 
                                           exact,
                                           int(exact/ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5),
                                           returnStr(av.scaled), 
                                           String(def:0:5),
                                           warning);
            else
                def = abs (exact/1000 - normalized);
                
                if (def < 1.)
                    warning = "";
                end;
                
                av.scaled = normalized;
                m_protocolView.printString(name, 
                                           exact, 
                                           int(exact/1000),
                                           normalized, 
                                           String(def:0:5),
                                           warning);
            end;

            
        end;
    end;

    private macro saveColumn(normalizer : ReportNormalizer, balanceNumber : String, kindAccount : String, columnKind : String)
        if (m_normalizer.getIsTotal())
            if(normalizer.isNormalized())
                saveValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.TOTAL);
            else 
                recalculateValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.TOTAL);
                recalculateValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.ROUBLE);
                recalculateValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.CURRENCY);
            end;
        else
            if(normalizer.isNormalized())
                saveValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.ROUBLE);
                saveValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.CURRENCY);
            else 
                recalculateValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.ROUBLE);
                recalculateValue(normalizer, balanceNumber, kindAccount, columnKind, ROW_KIND.CURRENCY);
            end;
        end;
    end;

    private macro saveBalance(normalizer : ReportNormalizer, balInfo : BalanceInfo)
        
        if (balInfo.getKindAccount() == "А")
            saveColumn(normalizer, balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.ACTIVE_OUT_REST);
        elif (balInfo.getKindAccount() == "П")
            saveColumn(normalizer, balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.PASSIVE_OUT_REST);
        else
            saveColumn(normalizer, balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.ACTIVE_OUT_REST);
            saveColumn(normalizer, balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.PASSIVE_OUT_REST);
        end;

        saveColumn(normalizer, balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.DEBET);
        saveColumn(normalizer, balInfo.getBalanceNumber(), balInfo.getKindAccount(), COLUMN_KIND.CREDIT);
    end;

    private macro isExistsBalanceData(normalizer, balanceNumber : String, kindAccount: String ) : Bool
        var inRestA   = $0.0;
        var outRestA  = $0.0;
        var inRestP   = $0.0;;
        var outRestP  = $0.0;;
        var debet     = $0.0;;
        var credit    = $0.0;;

        if (kindAccount == "А")
            inRestA  = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST,  ROW_KIND.TOTAL); 
            outRestA = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, ROW_KIND.TOTAL); 
        elif (kindAccount == "П")
            inRestP  = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST,  ROW_KIND.TOTAL);         
            outRestP = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, ROW_KIND.TOTAL); 
        else
            inRestA  = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST,  ROW_KIND.TOTAL); 
            outRestA = global.variable.getExact(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST, ROW_KIND.TOTAL);

            inRestP  = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST,  ROW_KIND.TOTAL); 
            outRestP = global.variable.getExact(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST, ROW_KIND.TOTAL);               
        end;

        debet  = global.variable.getExact(balanceNumber, COLUMN_KIND.DEBET,  ROW_KIND.TOTAL);
        credit = global.variable.getExact(balanceNumber, COLUMN_KIND.CREDIT, ROW_KIND.TOTAL);

        if (   (inRestA != $0.0)
            or (outRestA != $0.0)
            or (inRestP != $0.0)
            or (outRestP != $0.0)
            or (debet != $0.0)
            or (credit != $0.0))
            return true;
        end;

        return false;
    end;

    private macro loadOneBalance(balInfo : BalanceInfo)
        
        macro loadRow(balanceNumber : String, columnKind : String, rowKind : String)

            if (m_previousReport.isCalculated() and in(columnKind, COLUMN_KIND.PASSIVE_IN_REST, COLUMN_KIND.ACTIVE_IN_REST))
                return;
            end;

            var node = m_normalizer.addNode(m_normalizer.getNodeName(balanceNumber, columnKind, rowKind));

            node.exact = global.variable.getExact(balanceNumber, columnKind, rowKind);
            node.recalculateScaled();

            if (in(columnKind, COLUMN_KIND.PASSIVE_IN_REST, COLUMN_KIND.ACTIVE_IN_REST, COLUMN_KIND.PASSIVE_OUT_REST, COLUMN_KIND.ACTIVE_OUT_REST))
                node.setDef(REST_MAX_ERROR_VALUE);
            else
                node.setDef(TURN_MAX_ERROR_VALUE);
            end;

            if ((node != null) and (node.exact == 0.0) and (node.getDef() > 1.0))
                node.setDef(0.5);
            end;

        end;

        macro loadColumn(balanceNumber : String, columnKind : String)
            loadRow(balanceNumber, columnKind, ROW_KIND.ROUBLE);
            loadRow(balanceNumber, columnKind, ROW_KIND.CURRENCY);
        end;
        
        macro setRowConstraint(balInfo : BalanceInfo, rowKind : String)

            var inRestNode  = null;
            var outRestNode = null;
            var debetNode   = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, rowKind));
            var creditNode  = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, rowKind));

            macro setUserPriority(node : @Variant, priority : Integer, level : Integer)
                const MAX_USER_PRIORITY = 100;

                if (not in(ValType(node), V_DOUBLE, V_MONEY))
                  
                    node.setUserPriority(priority);

                    node.setLevel(level);

                    if ((node.exact == 0.0) and (node.getDef() > 1.0))
                        node.setUserPriority(1);
                    end;
                end;
            end;

            if (m_previousReport.isCalculated())
                if (balInfo.getKindAccount() == "П")
                    inRestNode = global.variable.getScaled(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_IN_REST, rowKind);
                else
                    inRestNode = global.variable.getScaled(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_IN_REST, rowKind);
                end;
            else
                if (balInfo.getKindAccount() == "П")
                    inRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_IN_REST, rowKind));
                else
                    inRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_IN_REST, rowKind));
                end;
            end;

            if (balInfo.getKindAccount() == "П")
                outRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_OUT_REST, rowKind));
            else
                outRestNode = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_OUT_REST, rowKind));
            end;

//Расстановка приоритетов отнесения погрешности

            IF (ROW_KIND.ROUBLE)
                setUserPriority(@inRestNode,  100, 1);
                setUserPriority(@outRestNode, 100, 1);

                setUserPriority(@debetNode,  5, 5000);
                setUserPriority(@creditNode, 5, 5000);
            else
                setUserPriority(@inRestNode, 90, 100);
                setUserPriority(@outRestNode,90, 100);
                
                setUserPriority(@debetNode,  1, 50000);
                setUserPriority(@creditNode, 1, 50000);
            end;

//Добавляем ограничения на итоги
            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            if (balInfo.getKindAccount() == "П")
                relation.lhs.plus(inRestNode).minus(debetNode).plus(creditNode);
                relation.rhs.plus(outRestNode); 
            else
                relation.lhs.plus(inRestNode).plus(debetNode).minus(creditNode);
                relation.rhs.plus(outRestNode); 
            end;

            m_normalizer.addRelation(relation);
        end;

        macro setTotalConstraint(balanceNumber : String, columnKind : String)
            var rouble   = null;
            var currency = null;
            var total    = global.variable.getScaled(balInfo.getBalanceNumber(), columnKind, ROW_KIND.TOTAL);

            if (m_previousReport.isCalculated() and in(columnKind, COLUMN_KIND.PASSIVE_IN_REST, COLUMN_KIND.ACTIVE_IN_REST))
                rouble   = global.variable.getScaled(balInfo.getBalanceNumber(), columnKind, ROW_KIND.ROUBLE);
                currency = global.variable.getScaled(balInfo.getBalanceNumber(), columnKind, ROW_KIND.CURRENCY);
            else
                rouble   = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), columnKind, ROW_KIND.ROUBLE));
                currency = m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), columnKind, ROW_KIND.CURRENCY));
            end;


            var relation = ReportLinearRelation(RCB_RS_EQUAL);

            relation.lhs.plus(rouble).plus(currency);
            relation.rhs.plus(total); 

            m_normalizer.addRelation(relation);
        end;

        macro excludeBalance(balInfo : BalanceInfo, isRouble : Bool)
            var rowKind = ternary(isRouble, ROW_KIND.ROUBLE, ROW_KIND.CURRENCY);

            if (ternary(isRouble, balInfo.getRecord().isRoubleExcluded, balInfo.getRecord().isCurrencyExcluded))
                if (not m_previousReport.isCalculated())
                    if (balInfo.getKindAccount() == "П")
                        m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_IN_REST, rowKind)).setDef(0.5);
                    else
                        m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_IN_REST, rowKind)).setDef(0.5);
                    end;
                end;
        
                if (balInfo.getKindAccount() == "П")
                    m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.PASSIVE_OUT_REST, rowKind)).setDef(0.5);
                else
                    m_normalizer.addNode(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.ACTIVE_OUT_REST, rowKind)).setDef(0.5);
                end;
            end;
        end;

        var balanceNumber = balInfo.getBalanceNumber();
//Загружаем данные баланса

        if (not m_previousReport.isCalculated())
            if (balInfo.getKindAccount() == "П")
                loadColumn(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST);
            else
                loadColumn(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST);
            end;
        end;

        loadColumn(balanceNumber, COLUMN_KIND.DEBET);
        loadColumn(balanceNumber, COLUMN_KIND.CREDIT);

        if (balInfo.getKindAccount() == "П")
            loadColumn(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST);
        else
            loadColumn(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST);
        end;

//Задаем ограничения по строке

        setRowConstraint(balInfo, ROW_KIND.ROUBLE);
        setRowConstraint(balInfo, ROW_KIND.CURRENCY);
        
//Задаем ограничения по итогам
                            
        if (balInfo.getKindAccount() == "П")
            setTotalConstraint(balanceNumber, COLUMN_KIND.PASSIVE_IN_REST);
        else
            setTotalConstraint(balanceNumber, COLUMN_KIND.ACTIVE_IN_REST);
        end;

        setTotalConstraint(balanceNumber, COLUMN_KIND.DEBET);
        setTotalConstraint(balanceNumber, COLUMN_KIND.CREDIT);

        if (balInfo.getKindAccount() == "П")
            setTotalConstraint(balanceNumber, COLUMN_KIND.PASSIVE_OUT_REST);
        else
            setTotalConstraint(balanceNumber, COLUMN_KIND.ACTIVE_OUT_REST);
        end;

//Задаем счета исключения для входящих и исходящих остатков

        excludeBalance(balInfo, true);
        excludeBalance(balInfo, false);
    end;

    private macro isZeroTurns(balInfo : BalanceInfo) : Bool
        var isZero = false;
        var roubleDedetNode    = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.ROUBLE));
        var currencyDedetNode  = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.CURRENCY));
        var roubleCreditNode   = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.ROUBLE));
        var currencyCreditNode = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.CURRENCY));

        if ((roubleDedetNode.exact == 0.0) and (roubleCreditNode.exact == 0.0))
            isZero = true;
        end;

        if ((currencyDedetNode.exact == 0.0) and (currencyCreditNode.exact == 0.0))
            isZero = true;
        end;

        return isZero;
    end;

    private macro setCorrectZeroValue(balInfo : BalanceInfo)
        var roubleDedetNode    = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.ROUBLE));
        var currencyDedetNode  = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.DEBET, ROW_KIND.CURRENCY));
        var roubleCreditNode   = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.ROUBLE));
        var currencyCreditNode = m_normalizer.node(m_normalizer.getNodeName(balInfo.getBalanceNumber(), COLUMN_KIND.CREDIT, ROW_KIND.CURRENCY));

        if ((roubleDedetNode.exact == 0.0) and (roubleCreditNode.exact == 0.0))
            roubleDedetNode.setDef(1.);
            roubleCreditNode.setDef(1.);
        end;

        if ((currencyDedetNode.exact == 0.0) and (currencyCreditNode.exact == 0.0))
            currencyDedetNode.setDef(1.);
            currencyCreditNode.setDef(1.);
        end;
    end;

    private macro normalizeOneBalance(balInfo : BalanceInfo) : Bool
        var chapter = m_normalizer.getChapter().getChapter();

        if (chapter == 5)
            m_normalizer = TBalanceChapterNormalizer(1,                   chapter, not m_previousReport.isCalculated());
        else
            m_normalizer = TBalanceChapterNormalizer(m_report.multiplier, chapter, not m_previousReport.isCalculated());
        end;

        m_normalizer.setIsTotal(false);
    
        m_normalizer.setIsOptimalDecision(true);

        loadOneBalance(balInfo);

        m_normalizer.normalize();

        if (not m_normalizer.isNormalized() and not m_normalizer.isErrorExact() and isZeroTurns(balInfo))

            if (chapter == 5)
                m_normalizer = TBalanceChapterNormalizer(1,                   chapter, not m_previousReport.isCalculated());
            else
                m_normalizer = TBalanceChapterNormalizer(m_report.multiplier, chapter, not m_previousReport.isCalculated());
            end;

            m_normalizer.setIsTotal(false);
        
            m_normalizer.setIsOptimalDecision(true);

            loadOneBalance(balInfo);
            
            setCorrectZeroValue(balInfo);
            
            m_protocolView.printSeparator(true);
            m_protocolView.printStringExt("Внимание! Установлен режим корректировки нулевых оборотов для балансового счета " + balInfo.getBalanceNumber() + ".");
            m_protocolView.printSeparator(false);
            m_normalizer.normalize();
        end;

        if (m_normalizer.isNormalized())
            saveBalance(m_normalizer, balInfo, false);
        else
            m_protocolView.printSeparator(true);
            if (m_normalizer.isErrorExact())
                m_protocolView.printStringExt("Ошибки на неокругленных значениях!");
            end;
            m_protocolView.printStringExt("Не удалось нормализовать значения по счету: " + balInfo.getBalanceNumber());
            m_protocolView.printStringExt("лог-файл:" + m_normalizer.getLogFilePath());
            m_protocolView.printSeparator(false);
            return false;
        end;

        return true;
    end;

    private macro processTurnsZero(balInfo : BalanceInfo)

        macro getAv(balInfo : BalanceInfo, isDebet : Bool, isRouble : Bool)
            var name = global.variable.getName(balInfo.getBalanceNumber(), 
                                               ternary(isDebet, COLUMN_KIND.DEBET, COLUMN_KIND.CREDIT), 
                                               ROW_KIND.TOTAL);

            return m_report.attributeValue(name);
        end;

        macro printProtocolString(av : Object)
            var val = int(av.exact/ternary((m_currentChapter == 5), ADDITIONAL_MULTIPLIER_FOR_CHAPTER_5, 1000.0));
            var def = val - av.scaled;
            m_protocolView.printString(av.attribute.id, 
                                       av.exact,
                                       val,
                                       av.scaledAsString, 
                                       String(def:0:5),
                                       "");
        end;

        var avDebet  = getAv(balInfo, true);
        var avCredit = getAv(balInfo, false);

        if ((avDebet == null) or (avCredit == null))
            return;
        end;

        if (    ((avDebet.exact == 0) or (avCredit.exact == 0))
            and ((avDebet.scaled > 0) and (avCredit.scaled > 0)))

            avDebet.scaled = avDebet.scaled - 1;
            avCredit.scaled = avCredit.scaled - 1;
            printProtocolString(avDebet);
            printProtocolString(avCredit);
        end;

    end;
         
    private macro normilizeChapterByParts(chapter, isOptimal, isNormalizeByGroup)        

        m_currentChapter = chapter;

        initProtocolView(chapter);

        m_protocolView.printDescription();

        m_protocolView.printLine("┌──────────────────────────────────────────────────────────────────────────────────────────┐");
        m_protocolView.printLine("│--------------------------------------ГЛАВА " + chapter + "---------------------------------------------│");
        m_protocolView.printLine("└──────────────────────────────────────────────────────────────────────────────────────────┘");
                                        
        if(ExcludedAccountsController().isExistConflictingSetting(chapter, m_protocolView))
            return;
        end;

        var normalizer;

        if (chapter == 5)
            m_normalizer = TBalanceChapterNormalizer(1,                   chapter, not m_previousReport.isCalculated());
        else
            m_normalizer = TBalanceChapterNormalizer(m_report.multiplier, chapter, not m_previousReport.isCalculated());
        end;
        

        private var balanceList = TRcbSet();
        
        balanceList.clear();
    
        var dataSet = TRsbDataSet("WITH tabcoff AS(SELECT --+inline"
                    +"\n"+        "                       rsb_common.getregstrvalue(rsb_common.GetRegKeyPath(val.t_keyId)) t_balancelist,"
                    +"\n"+        "                       TO_NUMBER(subStr(parm.t_name, 11, length(parm.t_name))) t_k"
                    +"\n"+        "                  FROM dregval_dbt val,"
                    +"\n"+        "                       dregparm_dbt parm"
                    +"\n"+        "                 WHERE parm.t_parentId = rsb_common.GetRegParm('REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter +"')"
                    +"\n"+        "                   AND val.t_keyId = parm.t_keyId),"
                    +"\n"+        "  tabexclbal AS(SELECT --+inline"
                    +"\n"+        "                       rsb_common.getregstrvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/РУБЛИ')t_roublebalancelist,"
                    +"\n"+        "                       rsb_common.getregstrvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ВАЛЮТА')t_currencybalancelist,"
                    +"\n"+        "                       rsb_common.getregstrvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "/ИТОГ')t_totalbalancelist"
                    +"\n"+        "                  FROM DUAL),"
                    +"\n"+        "  tabuse     AS(SELECT --+inline"
                    +"\n"+        "                       DECODE(rsb_common.getregflagvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ'),CHR (0), 0, 1) t_isusepriority,"
                    +"\n"+        "                       DECODE(rsb_common.getregflagvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ЗАДАТЬ ПРИОРИТЕТЫ СЧЕТОВ/ГЛАВА " + chapter + "'), CHR (0), 0, 1) t_isusepriorityforchapter,"
                    +"\n"+        "                       DECODE(rsb_common.getregflagvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА'), CHR (0), 0, 1) t_isuseexclude,"
                    +"\n"+        "                       DECODE(rsb_common.getregflagvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/ИСКЛЮЧИТЬ СЧЕТА/ГЛАВА " + chapter + "'), CHR (0), 0, 1) t_isuseexcludeforchapter"
                    +"\n"+        "                  FROM DUAL),"
                    +"\n"+        "  balanceMaxErrorList AS (SELECT --+inline"
                    +"\n"+        "                                 rsb_common.getregstrvalue('REPORT/FLOOR/НАСТРОЙКА ММБ/СЧЕТА С МАКС-НОЙ ПОГРЕШНОСТЬЮ/ГЛАВА " + chapter + "') t_list"
                    +"\n"+        "                            FROM dual)"
                    +"\n"+        "SELECT *"
                    +"\n"+        "  FROM (SELECT " + getSqlString(m_normalizer.getChapter().getName()) + " t_balance, 0 t_isMaxError, 'АП' t_kindaccount, 100 t_k, 0 t_isRoubleExcluded, 0 t_isCurrencyExcluded, 0 t_isTotalExcluded"
                    +"\n"+        "          FROM DUAL"
                    +"\n"+        "         WHERE " + ternary (m_previousReport.isCalculated(), "1=1", "1=0")
                    +"\n"+        "        UNION ALL"
                    +"\n"+        "        SELECT bal.t_balance,"
                    +"\n"+        "               CASE"
                    +"\n"+        "                   WHEN regexp_like((SELECT t_list FROM balanceMaxErrorList), '([^[:digit:]]|^)(' || bal.t_balance || ')([^[:digit:]]|$)')"
                    +"\n"+        "                       THEN 1"
                    +"\n"+        "                   ELSE 0"
                    +"\n"+        "               END t_isMaxError,"
                    +"\n"+        "               CASE"
                    +"\n"+        "                  WHEN LENGTH (bal.t_balance) = 3"
                    +"\n"+        "                       THEN CASE"
                    +"\n"+        "                            WHEN t_all = t_a"
                    +"\n"+        "                               THEN 'А'"
                    +"\n"+        "                            WHEN t_a IS NULL"
                    +"\n"+        "                               THEN 'П'"
                    +"\n"+        "                            ELSE 'АП'"
                    +"\n"+        "                         END"
                    +"\n"+        "                  ELSE DECODE (bal.t_kind_account, '0', 'А', bal.t_kind_account)"
                    +"\n"+        "               END AS t_kindaccount,"
                    +"\n"+        "               NVL((SELECT t_k"
                    +"\n"+        "                      FROM tabcoff"
                    +"\n"+        "                     WHERE (SELECT 1"
                    +"\n"+        "                              FROM tabuse"
                    +"\n"+        "                             WHERE t_isusepriority = 1"
                    +"\n"+        "                               AND t_isusepriorityforchapter =1) = 1"
                    +"\n"+        "                       AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                       AND REGEXP_LIKE (tabcoff.t_balancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')"
                    +"\n"+        "                       AND ROWNUM < 2), 50) t_k,"
                    +"\n"+        "               NVL ((SELECT 1"
                    +"\n"+        "                       FROM tabexclbal"
                    +"\n"+        "                      WHERE (SELECT 1" 
                    +"\n"+        "                               FROM tabuse"
                    +"\n"+        "                              WHERE t_isuseexclude = 1"
                    +"\n"+        "                                AND t_isuseexcludeforchapter =1) = 1"
                    +"\n"+        "                        AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                        AND REGEXP_LIKE (tabexclbal.t_roublebalancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')), 0) t_isroubleexcluded,"
                    +"\n"+        "               NVL ((SELECT 1"
                    +"\n"+        "                       FROM tabexclbal"
                    +"\n"+        "                      WHERE (SELECT 1" 
                    +"\n"+        "                               FROM tabuse"
                    +"\n"+        "                              WHERE t_isuseexclude = 1"
                    +"\n"+        "                                AND t_isuseexcludeforchapter =1) = 1"
                    +"\n"+        "                        AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                        AND REGEXP_LIKE (tabexclbal.t_currencybalancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')), 0) t_iscurrencyexcluded,"
                    +"\n"+        "               NVL ((SELECT 1"
                    +"\n"+        "                       FROM tabexclbal"
                    +"\n"+        "                      WHERE (SELECT 1" 
                    +"\n"+        "                               FROM tabuse"
                    +"\n"+        "                              WHERE t_isuseexclude = 1"
                    +"\n"+        "                                AND t_isuseexcludeforchapter =1) = 1"
                    +"\n"+        "                        AND LENGTH (bal.t_balance) = 5"
                    +"\n"+        "                        AND REGEXP_LIKE (tabexclbal.t_totalbalancelist, '([^[:digit:]]|^)('|| bal.t_balance || '|' || SUBSTR (bal.t_balance, 1, 2) || '|' || SUBSTR (bal.t_balance, 1, 3) || ')([^[:digit:]]|$)')), 0) t_istotalexcluded"
                    +"\n"+        "          FROM dbalance_dbt bal,"
                    +"\n"+        "               (SELECT SUBSTR(t_balance, 1, 3) t_balance,"
                    +"\n"+        "                       COUNT(*) t_all"
                    +"\n"+        "                  FROM dbalance_dbt"
                    +"\n"+        "                 WHERE t_balance NOT LIKE '%ОВП%'"
                    +"\n"+        "                   AND t_chapter = " + chapter 
                    +"\n"+        "                   AND t_inumplan = 0"
                    +"\n"+        "                   AND LENGTH(t_balance) = 5"
                    +"\n"+        "                   AND INSTR(t_type_balance, 'T') = 0"
                    +"\n"+        "              GROUP BY SUBSTR(t_balance, 1, 3)) dall,"
                    +"\n"+        "               (SELECT SUBSTR(t_balance, 1, 3) t_balance,"
                    +"\n"+        "                       COUNT(*) t_a"
                    +"\n"+        "                  FROM dbalance_dbt"
                    +"\n"+        "                 WHERE t_balance NOT LIKE '%ОВП%'"
                    +"\n"+        "                   AND t_chapter = " + chapter 
                    +"\n"+        "                   AND t_inumplan = 0"
                    +"\n"+        "                   AND LENGTH(t_balance) = 5"
                    +"\n"+        "                   AND INSTR(t_type_balance, 'T') = 0"
                    +"\n"+        "                   AND (t_kind_account = '0' OR t_kind_account = 'А')"
                    +"\n"+        "              GROUP BY SUBSTR(t_balance, 1, 3)) da"
                    +"\n"+        "         WHERE bal.t_chapter = " + chapter 
                    +"\n"+        "           AND bal.t_balance NOT LIKE '%ОВП%'"
                    +"\n"+        "           AND bal.t_inumplan = 0"
                    +"\n"+        "           AND (LENGTH(bal.t_balance) = 5)"
                    +"\n"+        "           AND INSTR(bal.t_type_balance, 'T') = 0"
                    +"\n"+        "           AND bal.t_balance = dall.t_balance(+)"                                       
                    +"\n"+        "           AND bal.t_balance = da.t_balance(+))"
                    +"\n"+        "ORDER BY CASE"
                    +"\n"+        "             WHEN INSTR(t_balance, " + getSqlString(m_normalizer.getChapter().getName()) + ") != 0 THEN 999999"
                    +"\n"+        "             ELSE LENGTH(t_balance)"
                    +"\n"+        "         END,"
                    +"\n"+        "         t_balance");


        
        initProgress(-1, "Загрузка значений б/с. Глава " + m_normalizer.getChapter().getChapter(), "Загрузка значений б/с. Глава " + m_normalizer.getChapter().getChapter());
        var i = 0;
        var isExist = false;

        m_normalizer.setIsTotal(true);
        while (dataSet.moveNext())            
            if (isExistsBalanceData(m_normalizer, dataSet.balance, dataSet.kindaccount))                                
                balanceList.insert(BalanceInfo(m_normalizer.getChapter().getChapter(), dataSet.balance, dataSet.kindaccount, dataSet.getRecord()));
                loadBalance(m_normalizer, dataSet, true);
                isExist = true;
            end;
            useprogress(i = i + 1);
        end;

        if (isExist)
            if (chapter == 3) 
                m_normalizer.addRelationsForLoroAccounts()
            end;
            /*Добавляем ограничения по главе*/
            m_normalizer.addBalance(m_normalizer.getChapter().getName(), null, true);
       end;

        
        remProgress();

        message("нормализация итоговых значений главы " + m_normalizer.getChapter().getChapter());

        if (isOptimal == false)
            m_normalizer.setIsOptimalDecision(false);
        end;

        if (not IS_OPTIMAL_DECISION) 
            m_normalizer.setMaxNumberOfDecision(ACCOUNT_PERMISSIBLE_DESICIONS);
            m_normalizer.setIsOptimalDecision(false);
        end;

        if (isNormalizeByGroup)
            m_normalizer.setIsNormalizeByGroup(true);
        end;

        m_normalizer.setTimeLimit(MAX_TIME_OF_DESICIONS);

        m_normalizer.normalize();
        var iterator;

        if (not m_normalizer.isNormalized() and not m_normalizer.isErrorExact()) 

            m_protocolView.printLine("ВНИМАНИЕ!Нормализация по главе " + chapter + " производится c отнесением погрешности на исходящие остатки (алгоритм СЧЕТА С МАКСИМАЛЬНОЙ ПОГРЕШНОСТЬЮ)");
            
            iterator = balanceList.createIterator();
            
            iterator.moveFirst();

            while (not iterator.isDone())
                setMaxError(iterator.getCurrentItem().getRecord());
                                    
                iterator.moveNext();
            end;    

            m_normalizer.normalize();
        end;

        m_protocolView.printLine("НОРМАЛИЗАЦИЯ ГЛАВЫ " + chapter);

        m_protocolView.printLine("Период отчета:" + m_report.context.period.beginDate + " - " + m_report.context.period.endDate);

        m_protocolView.printLine("Количество переменных = " + m_normalizer.count);

        if (not m_normalizer.isNormalized())
            
            global.isCalculateDependencies = false;

            if (m_normalizer.isErrorExact())
                m_protocolView.printLine("Ошибки на неокругленных значениях!");
            end;

            m_protocolView.printLine("Не удалось выполнить нормализацию по главе " + chapter + "(смотри лог-файл:" + m_normalizer.getLogFilePath() + ").");

            if(m_isRecalculateIfNotNormalized)

                iterator = balanceList.createIterator();

                iterator.moveFirst();
                                
                while (not iterator.isDone())
                    saveBalance(m_normalizer, iterator.getCurrentItem());
                                        
                    iterator.moveNext();
                end;    

                RcbApplication.TransactionManager.commit();
            end;

            return;
        end;

        m_protocolView.printLine("\nНормализация итоговых значений выполнена");
        m_protocolView.printLine("лог-файл:" + m_normalizer.getLogFilePath());
        m_protocolView.printHeadTable();

        iterator = balanceList.createIterator();

        iterator.moveFirst();
                
        initProgress(-1, "Сохранение итоговых значений переменных. Глава " + m_normalizer.getChapter().getChapter(), "Сохранение итоговых значений переменных. Глава " + m_normalizer.getChapter().getChapter());
        i = 0;
        while (not iterator.isDone())
            saveBalance(m_normalizer, iterator.getCurrentItem(), true);

            useprogress(i = i + 1);
            
            iterator.moveNext();
        end;
        remProgress();

        m_protocolView.printBottomTable(chapter);
        m_protocolView.printLine("");


        initProgress(-1, "Обработка отнесения погрешностей на нулевые обороты. Глава " + m_normalizer.getChapter().getChapter(), "Обработка отнесения погрешностей на нулевые обороты. Глава " + m_normalizer.getChapter().getChapter());

        m_protocolView.printLine("\Обработка отнесения погрешностей на нулевые обороты");
        m_protocolView.printHeadTable();

        iterator = balanceList.createIterator();

        iterator.moveFirst();

        i = 0;
        while (not iterator.isDone())

            processTurnsZero(iterator.getCurrentItem());

            useprogress(i = i + 1);
            
            iterator.moveNext();
        end;
        
        m_protocolView.printBottomTable(chapter);
        m_protocolView.printLine("");

        remProgress();

                
        initProgress(-1, "Нормализация значений по отдельным балансовым счетам. Глава " + m_normalizer.getChapter().getChapter(), "Нормализация значений по отдельным балансовым счетам. Глава " + m_normalizer.getChapter().getChapter());

        m_protocolView.printLine("\nНормализация значений по отдельным балансовым счетам");
        m_protocolView.printHeadTable();

        iterator = balanceList.createIterator();

        iterator.moveFirst();

        i = 0;
        while (not iterator.isDone())

            if (not normalizeOneBalance(iterator.getCurrentItem()))
                global.isCalculateDependencies = false;
            end;

            useprogress(i = i + 1);
            
            iterator.moveNext();
        end;
        remProgress();

        m_protocolView.printBottomTable(chapter);
        m_protocolView.printLine("");

        
        RcbApplication.TransactionManager.commit();
    end;

    macro execute()
        if((m_chapter == 0)or(m_chapter == ""))
            normilizeChapterByParts(1, true, false);
            normilizeChapterByParts(2, true, false);
            normilizeChapterByParts(3, true, false);
            normilizeChapterByParts(4, true, false);
            normilizeChapterByParts(5, true, false);
        else
            normilizeChapterByParts(m_chapter, true, false);        
	    end;    
	end;
end;

//Расчет по списку составляющих
private macro calculateDependencies(protocolView : Object)
    if (global.isCalculateDependencies)
        var oldDialogFlag = SetDialogFlag(0);

        ExecuteSystemOperation(18004);

        SetDialogFlag(oldDialogFlag);
    else
        protocolView.printLine("\n!!!Нормализация значений по отдельным балансовым счетам прошла с ошибками!");
        protocolView.printLine("\n!!!После корректировки результата по ненормализованным счетам выполните операцию \"18004 Расчет значений по списку составляющих\"");
    end;
end;


private macro showBalanceProtocol()
    const DESCRIPTION_LABEL = "-desc:";

    var descriptionLabelIndex = index(cmdArgs, DESCRIPTION_LABEL);

    if (descriptionLabelIndex == 0)
        return;
    end;

    var chapter = substr(cmdArgs, descriptionLabelIndex + strlen(DESCRIPTION_LABEL));

    var protocol = TSummaryProtocolView();

    if (chapter == 0)
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 1 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 2 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 3 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 4 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 5 ГЛАВЫ"));
    else
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ " + String(chapter) + " ГЛАВЫ"));
    end;

    protocol.show();        
end;

private macro executeNormalization(chapter : Integer)
    var profiler = TSQLProfiler(getTxtFileName("!BalanceNormilizeChapter" + chapter + "Profile"));
    profiler.clear();
    profiler.on();

    RcbApplication.currentReport.reload();
    TNormalizeBalanceController(chapter, true).execute();

    calculateDependencies(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ " + chapter + " ГЛАВЫ"));
end;

private macro executeNormalizationAndShowProtocol()
    if (rcbApplication.currentReport.normalizationAlgorithm == RCB_NA_MMB) 
        var profiler = TSQLProfiler(getTxtFileName("!BalanceNormilizeProfile"));
        profiler.clear();
        profiler.on();

        /*Нормализация всех глав*/
        RcbApplication.currentReport.reload();


        RcbApplication.currentReport.reload();
        TNormalizeBalanceController(0, true).execute();
                               
        var protocol = TSummaryProtocolView();

        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 1 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 2 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 3 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 4 ГЛАВЫ"));
        protocol.add(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 5 ГЛАВЫ"));

        calculateDependencies(TProtocolView("ПРОТОКОЛ ПРОЦЕДУРЫ НОРМАЛИЗАЦИИ 5 ГЛАВЫ"));

        protocol.show();
    end;    
end;
