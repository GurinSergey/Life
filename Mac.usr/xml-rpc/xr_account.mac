// -------------------------------------------------------------------------------------------------
// @filename: xr_account.mac v.1
// @author  : 2013-05-01 zip_z. 
// @desc    : ТК Life - лицевые счета
// @changes : none
// -------------------------------------------------------------------------------------------------
import bankinter;
import xr_core;

/*** ЛИЦЕВЫЕ СЧЕТА (usr_create_account; usr_update_account; usr_close_account) ***/

// @desc  : создать лицевой счёт
// @return: V_OBJECT (TXReturnValueStruct, определена в xr_core.mac)
macro usr_create_account (p_account       :string   // номер л/счета 
                         ,p_chapter       :integer  // глава 
                         ,p_department    :integer  // филиал 
                         ,p_branch        :integer  // ВСП 
                         ,p_client        :integer  // partyId клиента по л/счету 
                         ,p_oper          :integer  // операционист из карточки л/счета 
                         ,p_acc_type      :string   // системный тип счета 
                         ,p_acc_user_type :string   // пользовательский тип счета 
                         ,p_acc_name      :string   // наименование счета 
                         ,p_open_date     :date     // дата открытия 
                         ,p_planid        :integer  // ID тарифного плана из Фронта
                         ):TXReturnValueStruct;
    
    private const ERR_NO_SFPLAN = 1; 
    var ret = TXReturnValueStruct (p_account, null, null);
    
    // проверка параметров, оставлена для примера (в хозяйстве пригодится)
    /****
    if (isnull (p_account    )) ret.stat = EXIT_LOGICAL_ERROR; ret.errm = ret.errm + "Отсутствует обязательный параметр p_account. ";       end;
    if (isnull (p_oper       )) ret.stat = EXIT_LOGICAL_ERROR; ret.errm = ret.errm + "Отсутствует обязательный параметр p_oper. ";          end;
    if (isnull (p_department )) ret.stat = EXIT_LOGICAL_ERROR; ret.errm = ret.errm + "Отсутствует обязательный параметр p_department. ";    end;
    if (isnull (p_branch     )) ret.stat = EXIT_LOGICAL_ERROR; ret.errm = ret.errm + "Отсутствует обязательный параметр p_branch. ";        end;
    if (isnull (p_client     )) ret.stat = EXIT_LOGICAL_ERROR; ret.errm = ret.errm + "Отсутствует обязательный параметр p_client. ";        end;
    ****/
    
    // до реализации запроса
    if (notnull (p_account) and (getKey (p_account, {mfo_bank}) != p_account))
        ret.stat = EXIT_LOGICAL_ERROR; 
        ret.errm = ret.errm + "Ключ счёта неверен";
    end;
    
    if (ret.stat != EXIT_SUCCESS) return ret; end;
    
    // проверки пройдены, инициализируемся 
    record daccount_dbt ("account.dbt"); clearrecord (daccount_dbt);
    record daccblnc_dbt ("accblnc.dbt"); clearrecord (daccblnc_dbt);
    
    daccount_dbt.code_currency   = Acc_GetFiidByAccount (p_account);
    daccount_dbt.kind_account    = Acc_GetKindByAccount (p_account);
    
    daccount_dbt.balance         = daccblnc_dbt.balance0 = Acc_GetBalanceByAccount (p_account); 
    daccount_dbt.account         = daccblnc_dbt.account  = p_account;
    daccount_dbt.chapter         = daccblnc_dbt.chapter  = nvl_ex (p_chapter, Acc_GetChapterByAccount (p_account));
    
    daccount_dbt.oper            = nvl_ex (p_oper         , {oper}         );
    daccount_dbt.department      = nvl_ex (p_department   , {operdprt}     );
    daccount_dbt.branch          = nvl_ex (p_branch       , {operdprtnode} );
    daccount_dbt.client          = nvl_ex (p_client       , {ourbank}      );
    daccount_dbt.type_account    = nvl_ex (p_acc_type     , EMPTY_STRING   );
    daccount_dbt.usertypeaccount = nvl_ex (p_acc_user_type, EMPTY_STRING   );
    daccount_dbt.nameaccount     = nvl_ex (p_acc_name     , EMPTY_STRING   );
    daccount_dbt.open_date       = nvl_ex (p_open_date    , {curdate}      );
    
    // открытие счёта (bankinter::create_account)
    var stat :integer = EXIT_SUCCESS, errm :string = EMPTY_STRING;
    if (stat = Create_Account(daccount_dbt, daccblnc_dbt, errm)) // здесь ПРИСВАИВАНИЕ; stat != 0 означает вход внутрь ветки
        ret.stat = stat;
        ret.errm = errm;
        return ret;
    end;
    
    // если нужно использовать выгруженный тарифный план (C-6046), пытаемся это сделать
    if (notNull (p_planid))
        var parm = makeArray (SQLParam ("p_client"     , p_client     ),
                              SQLParam ("p_planfrontid", p_planid     ),
                              SQLParam ("p_department" , p_department ),
                              SQLParam ("p_open_date"  , p_open_date  ));
        ret.stat = execStoredFunc ("sf_connectfrontcontrplan", V_INTEGER, parm);
        if (ret.stat == ERR_NO_SFPLAN) 
            ret.errm = "Счёт открыт без выгрузки ТП. Отсутствует привязка ТП Фронт (" + p_planid + ") к ТП RS"; 
        end;
    end;
    return ret;
end;

// @desc  : закрыть лицевой счёт
// @return: V_OBJECT (TXReturnValueStruct, определена в xr_core.mac)
macro usr_close_account (p_account    :string   // номер л/счета 
                        ,p_chapter    :integer  // глава 
                        ,p_close_date :date     // дата закрытия 
                        ):TXReturnValueStruct
    
    var stat :integer = EXIT_SUCCESS, errm :string = EMPTY_STRING;
    stat = CB_CloseAccount(p_chapter, Acc_GetFiidByAccount (p_account), p_account, p_close_date, errm);
    return TXReturnValueStruct (p_account, stat, errm);
end;

// @desc  : обновить параметры лицевого счёта
// @return: V_OBJECT (TXReturnValueStruct, определена в xr_core.mac)
macro usr_update_account (p_account           :string   // номер л/счета 
                         ,p_chapter           :integer  // глава 
                         ,p_overdraft_action  :string   // вид действия с овердрафтом
                         ,p_limit             :money    // лимит
                         ,p_valid_date        :date     // дата действия
                         ):TXReturnValueStruct
    
    /** действия внешней системы над овердрафтом **/
    private const OVERDRAFT_ACTION_SET = "SET";
    private const OVERDRAFT_ACTION_CLR = "CLEAR";
    
    /** системные типы счетов **/
    private const ACC_TYPE_OVERDRAFT        = "О";
    private const ACC_TYPE_OVERDRAFT_CREDIT = "V"; // ныне установка этого типа не используется

    // инициализация
    var ac = RSL_Account (p_account);
    var v_type_account : string = EMPTY_STRING;
    
    // установка признака лимита овердрафта
    if   ( strupr (p_overdraft_action) == OVERDRAFT_ACTION_SET )
        if ( index (ac.rec.type_account, ACC_TYPE_OVERDRAFT) == 0)
            v_type_account = ac.rec.type_account + ACC_TYPE_OVERDRAFT;
        end;
    
    // очистка признака лимита овердрафта
    elif ( strupr (p_overdraft_action) == OVERDRAFT_ACTION_CLR )
        v_type_account = strsubst (ac.rec.type_account, ACC_TYPE_OVERDRAFT       , EMPTY_STRING);
        v_type_account = strsubst (ac.rec.type_account, ACC_TYPE_OVERDRAFT_CREDIT, EMPTY_STRING);
    end;
    
    // обновление параметров счёта (bankinter::Update_Account)
    var stat = Update_Account (ac.rec.chapter, ac.rec.code_currency, ac.rec.account, ac.rec.oper, null, null, p_limit, v_type_account, p_valid_date);
    return TXReturnValueStruct (p_account, stat, getErrMsg ());
end;