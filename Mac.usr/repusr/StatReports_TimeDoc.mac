/************************************************************************/
/* ОТЧЕТ "Показатели обработки документов РКО по затратам времени"      */
/*                                                                      */
/* Юшманов Дмитрий                                                      */
/* Начато 09.08.2013                                                    */
/*                                                                      */
/* C-22357 (C-19151-6)                                                  */
/*                                                                      */
/* 10.02.2015 VDN C-33290                                               */
/************************************************************************/

import bankinter, RsbDataSet, rsexts, globals, RsbFormsInter, rslx;
import "KeyCodes.mac";

private const
    TYPE_INTEGER = 1, //типы полей формы
    TYPE_STRING = 7,
    TYPE_DATE = 9,
    TYPE_TIME = 10,
    RES_SIZE = 12,//размер структуры массива результатов:
                  //0 - код вида документа
                  //1 - наименование вида документа
                  //2 - код источника поступления
                  //3 - наименование источника поступления
                  //4 - признак исполнителя
                  //5 - количество обраб. документов
                  //6 - среднее время обработки
                  //7 - макс. время обработки
                  //8 - мин. время обработки
                  //9 - paymentid документов
                  //10- paymentid документа с макс. временем обработки
                  //11- paymentid документа с мин. временем обработки
    DOCKIND_SIZE = 4, //размер структуры массива видов документов
    SOURCE_SIZE = 3,  //размер структуры массива источников документов
    SCHEME_SIZE = 3,  //размер структуры массива схем расчетов
    CIPHER_SIZE = 3,  //размер структуры массива шифров документов
    TYPE_SIZE = 3,    //размер структуры массива типов исполнителей
    OP_ROBOT = 0,     //документ проведён автоматически
    OP_MAN = 1,       //документ проведён вручную
    OP_MIXED = 2,     //документ проведён смешанно
    CONST_ROBOLIST = "10000,10001,20000,20001,20002,20003,20004,20005,20006,20007,20008,20009,20010,20011,20012,20013,20014,20050,20201,22222,13666,20015",
    CONST_ORIGLIST = "15,16,17,18,27,70,201,202,203,400,410,420,430", //виды документов, обрабатываемые процедурой ea.getOrigin
    REP_NAME = "Показатели обработки документов РКО по затратам времени",
    REP_NAME_UPPER = "ПОКАЗАТЕЛИ ОБРАБОТКИ ДОКУМЕНТОВ РКО ПО ЗАТРАТАМ ВРЕМЕНИ";

private var 
    aDockind = TArray(),
    aSource = TArray(),
    aScheme = TArray(),
    aCipher = TArray(),
    aType = TArray(),
    aResult = TArray(),
    startDate : Date = {curdate} - 30,
    endDate : Date = {curdate},
    startTime : Time = "00:00:00",
    endTime : Time = "23:59:59",
    minExecTime : Time = "00:00:01",
    maxExecTime : bool = false, /*10.02.2015 VDN C-33290*/
    strDayExists : string = "",
    formRun : bool = false,
    debugMode : bool = false,
    debugNumDocs : integer = 10;

//диалоговая панель с параметрами фильтра
private class (TRsbPanel) RslPanel(caption: string)
/*----------------------------------------------------------------------------*/
var endOfMultiSelect : bool = false,
    ctrlName : string = "";
/*----------------------------------------------------------------------------*/
    //добавление на панель текстовой метки
    macro addLabelField(name: string, x: integer, y: integer)
    var m_label: TRSBLabel;

        m_label = TRSBLabel(x, y, name);
        addLabel(m_label);
    end;
/*----------------------------------------------------------------------------*/
    //добавление на панель поля ввода
    macro addEditField(name: string, dataType: integer, val: variant, textLen: integer, editFlag: bool, 
                       focusFlag: bool, posX: integer, posY: integer, sizeX: integer, sizeY: integer)
    var m_edit: TRSBEditField = TRsbEditField(dataType);

        m_edit.name = name;
        m_edit.setPosition(posX, posY);
        m_edit.setSize(sizeX, sizeY);
        m_edit.textLength = textLen;
        m_edit.editable = editFlag;
        m_edit.focusable = focusFlag;
        m_edit.value = val;
        addControl(m_edit);
    end;
/*----------------------------------------------------------------------------*/
    //добавление на панель чекбокса
    macro addCheckBox(name: string, posX: integer, posY: integer)
    var m_checkbox: TRSBCheckBox = TRSBCheckBox();

        m_checkbox.name = name;
        m_checkbox.setPosition(posX, posY);
        m_checkbox.checked = false;
        addControl(m_checkbox);
    end;
/*----------------------------------------------------------------------------*/
    //обработка выбора элемента скроллинга
    macro scrollElement (ctrlName, rs, pArray, structSize, offset, cmpStr)
    var i : integer = 0;

        for (i, 0, pArray.size/structSize)
            if (pArray[structSize*i+offset] == rs.value(cmpStr))
                pArray[structSize*i] = (pArray[structSize*i] == false); //инвертируем флаг выбора элемента
            end;
        end;

        return pArray;

    end;
/*----------------------------------------------------------------------------*/
    //обработчик событий скроллингов
    macro scrollEvent (rs, cmd, id, key)
    var i : integer = 0;

        if (cmd == DLG_INIT)
            endOfMultiSelect = false;
            addMultiAction(rs, KEY_ENTER);

        elif (cmd == DLG_MSEL)
            if   (ctrlName == "formDockindEdit")
                aDockind = scrollElement(ctrlName, rs, aDockind, DOCKIND_SIZE, 1, "t_dockind");
            elif (ctrlName == "formSourceEdit")
                aSource = scrollElement(ctrlName, rs, aSource, SOURCE_SIZE, 2, "srcname");
            elif (ctrlName == "formCipherEdit")
                aCipher = scrollElement(ctrlName, rs, aCipher, CIPHER_SIZE, 1, "t_shifr_oper");
            elif (ctrlName == "formSchemeEdit")
                aScheme = scrollElement(ctrlName, rs, aScheme, SCHEME_SIZE, 1, "csnumber");
            elif (ctrlName == "formTypeEdit")
                aType = scrollElement(ctrlName, rs, aType, TYPE_SIZE, 2, "usr");
            end;
            return CM_MSEL_CONT_CLEAR;

        elif (cmd == DLG_MSELEND)
            endOfMultiSelect = true;

        elif ((cmd == DLG_KEY) and (endOfMultiSelect))
            return CM_CANCEL;

        elif ((cmd == DLG_KEY) and (key == KEY_ENTER))
            if   (ctrlName == "formDockindEdit")
                aDockind = scrollElement(ctrlName, rs, aDockind, DOCKIND_SIZE, 1, "t_dockind");
            elif (ctrlName == "formSourceEdit")
                aSource = scrollElement(ctrlName, rs, aSource, SOURCE_SIZE, 2, "srcname");
            elif (ctrlName == "formCipherEdit")
                aCipher = scrollElement(ctrlName, rs, aCipher, CIPHER_SIZE, 1, "t_shifr_oper");
            elif (ctrlName == "formSchemeEdit")
                aScheme = scrollElement(ctrlName, rs, aScheme, SCHEME_SIZE, 1, "csnumber");
            elif (ctrlName == "formTypeEdit")
                aType = scrollElement(ctrlName, rs, aType, TYPE_SIZE, 2, "usr");
            end;
            return CM_SELECT;
        end;

    end;
/*----------------------------------------------------------------------------*/
    //вспомогательное заполнение массива для построения скроллинга
    macro addCol (ar, ind, fld, head, width, rdonly)
        ar.value (ind * 6) = fld;
        ar.value (ind * 6 + 1) = head;
        ar.value (ind * 6 + 2) = width;
        ar.value (ind * 6 + 3 ) = 2;  // fldType
        ar.value (ind * 6 + 4 ) = -1; // decPoint
        ar.value (ind * 6 + 5 ) = 0;  // reserv
    end;
/*----------------------------------------------------------------------------*/
    //общие для скроллингов действия
    macro quickScroll(rs, col, numCols, pArray, structSize, ctrlName)
    var tempstr : string = "",
        moreThanOne : bool = false,
        i : integer = 0;

        RunScroll(rs, numCols, col, Null, R2M(this, "scrollEvent"));

        //пересчёт содержимого "подвала" для выбранного фильтра
        for (i, 0, pArray.size/structSize)
            if (pArray[structSize*i])
                if (tempstr == "")
                    tempstr = pArray[structSize*i+2];
                else
                    moreThanOne = true;
                end;
            end;
        end;
        if (tempstr == "") tempstr = "ВСЕ" end;
        if (moreThanOne) tempstr = "Несколько" end;

        getControl(ctrlName).value = tempstr;

    end;
/*----------------------------------------------------------------------------*/
    //обработчик события "нажатие клавиши" для всей экранной формы
    macro onKeyPress (RsbEvent: object)
    var i : integer = 0;

        //сброс выбранного параметра фильтра
        if (RsbEvent.KeyCode == KEY_F4)

            ctrlName = RsbEvent.source.name;

            if   (ctrlName == "formDockindEdit")
                for (i, 0, aDockind.size/DOCKIND_SIZE) aDockind[DOCKIND_SIZE*i] = false; end;
                getControl(ctrlName).value = "ВСЕ";
            elif (ctrlName == "formSourceEdit")
                for (i, 0, aSource.size/SOURCE_SIZE) aSource[SOURCE_SIZE*i] = false; end;
                getControl(ctrlName).value = "ВСЕ";
            elif (ctrlName == "formSchemeEdit")
                for (i, 0, aScheme.size/SCHEME_SIZE) aScheme[SCHEME_SIZE*i] = false; end;
                getControl(ctrlName).value = "ВСЕ";
            elif (ctrlName == "formCipherEdit")
                for (i, 0, aCipher.size/CIPHER_SIZE) aCipher[CIPHER_SIZE*i] = false; end;
                getControl(ctrlName).value = "ВСЕ";
            elif (ctrlName == "formTypeEdit")
                for (i, 0, aType.size/TYPE_SIZE) aType[TYPE_SIZE*i] = false; end;
                getControl(ctrlName).value = "ВСЕ";
            end;

        //запуск скроллингов для параметров фильтров
        elif (RsbEvent.KeyCode == KEY_F3)
        var col = TArray(),
            tempstr : string = "",
            rs;

            ctrlName = RsbEvent.source.name;

            if (ctrlName == "formDockindEdit")

                addCol(col, 0, "chosen", "Выбор", 5, true);
                addCol(col, 1, "t_dockind", "Код вида документа", 15, true);
                addCol(col, 2, "t_name", "Вид документа", 30, true);

                //добавляем в скроллинг колонку с индикацией записей, которые уже выбраны пользователем
                for (i, 0, aDockind.size/DOCKIND_SIZE-1)
                    if (aDockind[DOCKIND_SIZE*i]) tempstr = tempstr + "," + aDockind[DOCKIND_SIZE*i+1] end;
                end;

                if (tempstr != "")
                    tempstr = "case when t_dockind in (" + substr(tempstr,2) + ") then 'X' else '' end chosen,";
                else
                    tempstr = "'' chosen,";
                end;

                rs = RsdRecordSet(string(
                    "select " + tempstr, 
                    "\n     t_dockind, ",
                    "\n     t_name, ",
                    "\n     substr(t_strorigin, ",
                    "\n            length(t_strorigin) + 2 - instr(REVERSE(t_strorigin),'/')) t_origin ",
                    "\n from ",
                    "\n ( select t.t_dockind, ",
                    "\n          t.t_name, ",
                    "\n          replace(SYS_CONNECT_BY_PATH(t.t_origin, '/'),  '/0', null) t_strorigin ",
                    "\n     from doprkdoc_dbt t ",
                    "\n    where CONNECT_BY_ISLEAF = 1 ",
                    "\n      and t_dockind != 320 ", //у 320-ого документа нет справочника происхождений, исправлено ниже
                    "\n    start with t.t_dockind = 29 ",
                    "\n  connect by prior t_dockind = t_parentdockind ",
                    "\n    UNION ",
                    "\n   select w.t_dockind, w.t_name, '/1660' t_strorigin ",
                    "\n     from doprkdoc_dbt w ",
                    "\n    where w.t_dockind = 200 ",
                    "\n    UNION ",
                    "\n   select w.t_dockind, w.t_name, '/1660' t_strorigin ",
                    "\n     from doprkdoc_dbt w ",
                    "\n    where w.t_dockind = 320) ",
                    "\n order by t_dockind " ),
                    RSDVAL_CLIENT, RSDVAL_STATIC);

                quickScroll(rs, col, 3, aDockind, DOCKIND_SIZE, ctrlName);

            elif (ctrlName == "formSchemeEdit")

                addCol(col, 0, "chosen", "Выбор", 5, true);
                addCol(col, 1, "csnumber", "Номер корсхемы", 15, true);
                addCol(col, 2, "csname", "Корсхема", 30, true);

                //добавляем в скроллинг колонку с индикацией записей, которые уже выбраны пользователем
                for (i, 0, aScheme.size/SCHEME_SIZE-1)
                    if (aScheme[SCHEME_SIZE*i]) tempstr = tempstr + "," + aScheme[SCHEME_SIZE*i+1] end;
                end;

                if (tempstr != "")
                    tempstr = "case when csnumber in (" + substr(tempstr,2) + ") then 'X' else '' end chosen,";
                else
                    tempstr = "'' chosen,";
                end;

                rs = RsdRecordSet(string(
                  "select " + tempstr + " a1.* from ( ",
                  " SELECT '-1' csnumber, ",
                  "        '(без корсхемы)' csname ",
                  " FROM dual ",
                  "    UNION ",
                  " SELECT to_char(cs.t_number) csnumber, ",
                  "        cs.t_name csname ",
                  " FROM dcorschem_dbt cs ",
                  " WHERE cs.t_dogclosedate = '01.01.0001' ) a1 ",
                  " ORDER BY to_number(csnumber) " ),
                    RSDVAL_CLIENT, RSDVAL_STATIC);

                quickScroll(rs, col, 3, aScheme, SCHEME_SIZE, ctrlName);

            elif (ctrlName == "formCipherEdit")

                addCol(col, 0, "chosen", "Выбор", 5, true);
                addCol(col, 1, "t_shifr_oper", "Код шифра документа", 15, true);
                addCol(col, 2, "t_comment", "Шифр документа", 60, true);

                //добавляем в скроллинг колонку с индикацией записей, которые уже выбраны пользователем
                for (i, 0, aCipher.size/CIPHER_SIZE-1)
                    if (aCipher[CIPHER_SIZE*i]) tempstr = tempstr + ",''" + aCipher[CIPHER_SIZE*i+1] + "''" end;
                end;

                if (tempstr != "")
                    tempstr = "case when t_shifr_oper in (" + substr(tempstr,2) + ") then 'X' else '' end chosen,";
                else
                    tempstr = "'' chosen,";
                end;

                rs = RsdRecordSet(string(
                    "select " + tempstr + " t.* from ("
                    " SELECT '''' || to_char(t_shifr_oper) || '''' t_shifr_oper, t_comment FROM dcipher_dbt",
                    " UNION ",
                    " SELECT ''' ''' t_shifr_oper, '(Шифр не проставлен)' t_comment FROM dual ) t "),
                    RSDVAL_CLIENT, RSDVAL_STATIC);

                quickScroll(rs, col, 3, aCipher, CIPHER_SIZE, ctrlName);

            elif (ctrlName == "formTypeEdit")

                addCol(col, 0, "chosen", "Выбор", 5, true);
                addCol(col, 1, "usr", "Признак исполнителя", 20, true);

                //добавляем в скроллинг колонку с индикацией записей, которые уже выбраны пользователем
                for (i, 0, aType.size/TYPE_SIZE-1)
                    if (aType[TYPE_SIZE*i]) tempstr = tempstr + ",'" + aType[TYPE_SIZE*i+2] + "'" end;
                end;

                if (tempstr != "")
                    tempstr = "case when usr in (" + substr(tempstr,2) + ") then 'X' else '' end chosen,";
                else
                    tempstr = "'' chosen,";
                end;

                rs = RsdRecordSet(string(
                    "select " + tempstr + " t.* from ("
                    " SELECT to_char(rownum-1) t_typeid, decode(rownum, 1, 'Вручную', 2, 'Смешанно', 'Автоматически') usr ",
                    " FROM dual connect by level <= 3 ) t "),
                    RSDVAL_CLIENT, RSDVAL_STATIC);

                quickScroll(rs, col, 2, aType, TYPE_SIZE, ctrlName);

            elif (ctrlName == "formSourceEdit")
                var strDockind : string = "";

                for (i, 0, aDockind.size/DOCKIND_SIZE)
                    if (aDockind[DOCKIND_SIZE*i] == true)
                        strDockind = strDockind + "," + aDockind[DOCKIND_SIZE*i+1];
                    end;
                end;

                if (strDockind != "")
                    strDockind = " and t.t_dockind in (" + substr(strDockind,2) + ") ";
                end;

                addCol(col, 0, "chosen", "Выбор", 5, true);
                addCol(col, 1, "srcname", "Источник документа", 30, true);

                //добавляем в скроллинг колонку с индикацией записей, которые уже выбраны пользователем
                for (i, 0, aSource.size/SOURCE_SIZE-1)
                    if (aSource[SOURCE_SIZE*i]) tempstr = tempstr + ",'" + aSource[SOURCE_SIZE*i+2] + "'"; end;
                end;

                if (tempstr != "")
                    tempstr = "case when big.srcname in (" + substr(tempstr,2) + ") then 'X' else '' end chosen,";
                else
                    tempstr = "'' chosen,";
                end;

                rs = RsdRecordSet(string(
                  "select distinct ",
                  "\n " + tempstr,
                  "\n       big.* ",
                  "\n  from ( ",
                  "\n       select lval.t_name srcname ",
                  "\n         from ( ",
                  "\n              select t_dockind, ",
                  "\n                     t_name, ",
                  "\n                     substr(t_strorigin, length(t_strorigin) + 2 - instr(REVERSE(t_strorigin),'/')) t_origin ",
                  "\n                from ( ",
                  "\n                     select t.t_dockind, ",
                  "\n                            t.t_name, ",
                  "\n                            replace(SYS_CONNECT_BY_PATH(t.t_origin, '/'),  '/0', null) t_strorigin ",
                  "\n                       from doprkdoc_dbt t ",
                  "\n                      where CONNECT_BY_ISLEAF = 1 ",
                  "\n                        and t.t_dockind != 320 ", //у 320-ого документа нет справочника происхождений, исправлено ниже
                  "\n                      start with t.t_dockind = 29 ",
                  "\n                    connect by prior t_dockind = t_parentdockind ",
                  "\n                     UNION ",
                  "\n                     select w.t_dockind, ",
                  "\n                            w.t_name, ",
                  "\n                            '/1660' t_strorigin ",
                  "\n                       from doprkdoc_dbt w ",
                  "\n                      where w.t_dockind = 200 ",
                  "\n                     UNION ",
                  "\n                     select w.t_dockind, ",
                  "\n                            w.t_name, ",
                  "\n                            '/1660' t_strorigin ",
                  "\n                       from doprkdoc_dbt w ",
                  "\n                      where w.t_dockind = 320 ) ",
                  "\n              ) t, ",
                  "\n              dllvalues_dbt lval ",
                  "\n        where t.t_origin = lval.t_list ",
                  "\n " + strDockind,
                  "\n       ) big "),
                    RSDVAL_CLIENT, RSDVAL_STATIC);

                quickScroll(rs, col, 2, aSource, SOURCE_SIZE, ctrlName);

            end;

        //запуск отчёта
        elif (RsbEvent.KeyCode == KEY_F2)
            startDate = getControl("formDateStart").value;
            endDate   = getControl("formDateEnd").value;
            startTime = getControl("formTimeStart").value;
            endTime   = getControl("formTimeEnd").value;
            minExecTime = getControl("formMinExecTime").value;
            maxExecTime = getControl("formMaxExecTime").checked; /*10.02.2015 VDN C-33290*/
            debugMode = getControl("formIDsCheckBox").checked;
            debugNumDocs = int(getControl("formIDsEdit").value);
            formRun = true;
            close(1);
        end;

    end;
/*----------------------------------------------------------------------------*/
//заполнение экранной формы
    macro init(caption: string)
    var formDockindArr = TArray(),
        formSourceArr = TArray(),
        formSchemeArr = TArray(),
        formCipherArr = TArray(),
        editString = 9000,
        editLength = 25,
        editHeight = 1,
        dateLen = 9,
        alLeft = 4, 
        Line = 2,
        alStartDate = alLeft + 20,
        alFinDate = alLeft + 32,
        alCombo = alLeft + 16;

        setCaption(caption);
        setposition(15,5);
        setsize(48,14);
        addEventHandler(RSB_EV_KEY_PRESSED, R2M(this, "onKeyPress"));
        setStatus("F2: Запуск отчёта, F3: Список значений, F4: Сброс поля");

        //инициализация массивов параметров фильтра:
        //вид первичного документа
        var rs = RsdRecordSet(string(
        "   select t_dockind, ",
        "\n        t_name, ",
        "\n        substr(t_strorigin, ",
        "\n               length(t_strorigin) + 2 - instr(REVERSE(t_strorigin),'/')) t_origin ",
        "\n from ",
        "\n ( select t.t_dockind, ",
        "\n          t.t_name, ",
        "\n          replace(SYS_CONNECT_BY_PATH(t.t_origin, '/'),  '/0', null) t_strorigin ",
        "\n     from doprkdoc_dbt t ",
        "\n    where CONNECT_BY_ISLEAF = 1 ",
        "\n      and t.t_dockind != 320 ",
        "\n    start with t.t_dockind = 29 ",
        "\n  connect by prior t_dockind = t_parentdockind ",
        "\n    UNION ",
        "\n   select w.t_dockind, w.t_name, '/1660' t_strorigin ",
        "\n     from doprkdoc_dbt w ",
        "\n    where w.t_dockind = 200 ",
        "\n    UNION ",
        "\n   select w.t_dockind, w.t_name, '/1660' t_strorigin ",
        "\n     from doprkdoc_dbt w ",
        "\n    where w.t_dockind = 320 )" ));
        var i : integer = 0;
        while (rs.moveNext)
            aDockind[DOCKIND_SIZE*i]   = false;
            aDockind[DOCKIND_SIZE*i+1] = rs.value("t_dockind");
            aDockind[DOCKIND_SIZE*i+2] = rs.value("t_name");
            aDockind[DOCKIND_SIZE*i+3] = rs.value("t_origin");
            i = i + 1;
        end;

        //происхождение документа
        rs = RsdRecordSet(string(
        "   SELECT distinct lval.t_element, ",
        "\n                 lval.t_name srcname ",
        "\n   FROM dllvalues_dbt lval, ",
        "\n        doprkdoc_dbt kdoc ",
        "\n  WHERE lval.t_list = kdoc.t_origin "));
        i = 0;
        while (rs.moveNext)
            aSource[SOURCE_SIZE*i]   = false;
            aSource[SOURCE_SIZE*i+1] = rs.value("t_element");
            aSource[SOURCE_SIZE*i+2] = rs.value("srcname");
            i = i + 1;
        end;

        //корсхемы
        rs = RsdRecordSet(string(
          " SELECT '-1' csnumber ",
          "       ,'(без корсхемы)' csname ",
          " FROM dual ",
          "    UNION ",
          " SELECT to_char(cs.t_number) csnumber ",
          "       ,cs.t_name csname ",
          " FROM dcorschem_dbt cs ",
          " WHERE cs.t_dogclosedate = '01.01.0001' ",
          " ORDER BY csnumber" ));
        i = 0;
        while (rs.moveNext)
            aScheme[SCHEME_SIZE*i]   = false;
            aScheme[SCHEME_SIZE*i+1] = rs.value("csnumber");
            aScheme[SCHEME_SIZE*i+2] = rs.value("csname");
            i = i + 1;
        end;

        //шифры
        rs = RsdRecordSet(string(
          " SELECT '''' || to_char(t_shifr_oper) || '''' t_shifr_oper, t_comment FROM dcipher_dbt ",
          " UNION ",
          " SELECT ''' ''', '(Шифр не проставлен)' FROM dual "));
        i = 0;
        while (rs.moveNext)
            aCipher[CIPHER_SIZE*i]   = false;
            aCipher[CIPHER_SIZE*i+1] = rs.value("t_shifr_oper");
            aCipher[CIPHER_SIZE*i+2] = rs.value("t_comment");
            i = i + 1;
        end;

        //признак исполнителя
        rs = RsdRecordSet(string(
          " SELECT rownum-1 t_typeid, decode(rownum, 1, 'Вручную', 2, 'Смешанно', 'Автоматически') usr ",
          " FROM dual CONNECT BY LEVEL <= 3 "));
        i = 0;
        while (rs.moveNext)
            aType[TYPE_SIZE*i]   = false;
            aType[TYPE_SIZE*i+1] = rs.value("t_typeid");
            aType[TYPE_SIZE*i+2] = rs.value("usr");
            i = i + 1;
        end;

        //создание элементов экранной формы
        addLabelField("Дата окончания обработки:", alLeft, Line);
        addLabelField("с", alStartDate-2, Line);
        addEditField("formDateStart", TYPE_DATE, startDate, 10, true, true, alStartDate, Line, dateLen, editHeight);
        addLabelField("по", alFinDate-2, Line);
        addEditField("formDateEnd", TYPE_DATE, endDate, 10, true, true, alFinDate, Line, dateLen, editHeight);
        Line = Line + 1;

        addLabelField("Время поступления:", alLeft, Line);
        addLabelField("с", alStartDate-2, Line);
        addEditField("formTimeStart", TYPE_TIME, startTime, 10, true, true, alStartDate, Line, dateLen, editHeight);
        addLabelField("по", alFinDate-2, Line);
        addEditField("formTimeEnd", TYPE_TIME, endTime, 10, true, true, alFinDate, Line, dateLen, editHeight);
        Line = Line + 1;

        addLabelField("Мин. время обработки шага:", alLeft, Line);
        addEditField("formMinExecTime", TYPE_TIME, minExecTime, 10, true, true, alStartDate, Line, dateLen, editHeight);
        Line = Line + 2;

        addLabelField("Вид документа:", alLeft, Line);
        addEditField("formDockindEdit", TYPE_STRING, "ВСЕ", editString, true, true, alCombo, Line, editLength, editHeight);
        Line = Line + 1;

        addLabelField("Источник поступления:", alLeft, Line);
        addEditField("formSourceEdit", TYPE_STRING, "ВСЕ", editString, true, true, alCombo, Line, editLength, editHeight);
        Line = Line + 1;

        addLabelField("Схема расчетов:", alLeft, Line);
        addEditField("formSchemeEdit", TYPE_STRING, "ВСЕ", editString, true, true, alCombo, Line, editLength, editHeight);
        Line = Line + 1;

        addLabelField("Шифр документа:", alLeft, Line);
        addEditField("formCipherEdit", TYPE_STRING, "ВСЕ", editString, true, true, alCombo, Line, editLength, editHeight);
        Line = Line + 1;

        addLabelField("Признак исполнителя:", alLeft, Line);
        addEditField("formTypeEdit", TYPE_STRING, "ВСЕ", editString, true, true, alCombo, Line, editLength, editHeight);
        Line = Line + 1;

        /*10.02.2015 VDN C-33290*/
        addLabelField("Макс.время обработки (15 часов):", alLeft, Line);
        addCheckBox("formMaxExecTime", 27, Line);
        Line = Line + 1;

        addLabelField("Со списком id документов", alLeft, Line);
        addCheckBox("formIDsCheckBox", alStartDate + 3, Line);
        addLabelField("Количество id:", alCombo + 12, Line);
        addEditField("formIDsEdit", TYPE_STRING, "10", editString, true, true, alFinDate + 5, Line, 4, editHeight);
                                                                                                                            
    end;
/*----------------------------------------------------------------------------*/    
    InitTRsbPanel();
    init(caption);
/*----------------------------------------------------------------------------*/
end;


/*----------------------------------------------------------------------------*/
//проверка массива параметра фильтра на наличие выбранных элементов
private macro arrIsEmpty(pArr:TArray, pStr:integer)
var isEmpty : bool = true,
    i : integer = 0;
    while ((i < pArr.size/pStr) and isEmpty)
        isEmpty = (not pArr[pStr*i]);
        i = i + 1;
    end;
    return isEmpty;
end;
/*----------------------------------------------------------------------------*/
//простейшая сортировка для массива результатов
private macro sortme(pArr:TArray, pStr:integer)
var t, i, j, k;
    for (j, 1, pArr.size/pStr-1)
        for (i, 1, pArr.size/pStr-1)
            if ((pArr[pStr*(i)+0] < pArr[pStr*(i-1)+0])
            or  ((pArr[pStr*(i)+0] == pArr[pStr*(i-1)+0]) and (pArr[pStr*(i)+2] < pArr[pStr*(i-1)+2])))
                for (k, 0, pStr-1)
                    t = pArr[pStr*(i)+k];
                    pArr[pStr*(i)+k] = pArr[pStr*(i-1)+k];
                    pArr[pStr*(i-1)+k] = t;
                end;
            end;
        end;
    end;
    return pArr;
end;
/*----------------------------------------------------------------------------*/
//подготовка строки для вставки в запрос
private macro strFill (arr, structSize, pos, compl_table, isString)
var i : integer = 0,
    str : string = "";

    for (i, 0, arr.size/structSize-1)
        if (arr[structSize*i] == true)
            if (isString)
                str = str + ",'" + arr[structSize*i+pos] + "'";
            else 
                str = str + "," + arr[structSize*i+pos];
            end;
        end;
    end;

    if (substr(str,1,1) == ",")
        str = substr(str,2);
    end;

    if (str != "")
        str = "\n and " + compl_table + " in (" + str + ") ";
    end;

    return str;

end;
/*----------------------------------------------------------------------------*/
//подготовка строки для вставки в запрос (для массива источников)
private macro strFillSource (arr, cmpStr1, cmpStr2)
var i : integer = 0,
    str : string = "",
    rs;

    if (arrIsEmpty(aDockind,DOCKIND_SIZE) and arrIsEmpty(aSource,SOURCE_SIZE))

        //если виды документов И источники не выбраны, указываем все виды документов
        for (i, 0, aDockind.size/DOCKIND_SIZE-1)
            str = str + ","+ aDockind[DOCKIND_SIZE*i+1];
        end;
        return("\n and pm.t_dockind in (" + substr(str,2) + ") ");

    elif (arrIsEmpty(aSource,SOURCE_SIZE))

        //если только источники не выбраны, в запросе достаточно указать виды документов
        return strFill(aDockind, DOCKIND_SIZE, 1, "pm.t_dockind", false);

    else

        rs = RsdRecordSet(string(
            " select distinct t.t_dockind dockind, ",
            "\n      t.t_name dkndname, ",
            "\n      lval.t_element element, ",
            "\n      lval.t_name srcname ",
            "\n from (select t_dockind, ",
            "\n              t_name, ",
            "\n              substr(t_strorigin, length(t_strorigin) + 2 - instr(REVERSE(t_strorigin),'/')) t_origin ",
            "\n          from ",
            "\n           (SELECT t.t_dockind, ",
            "\n                   t.t_name, ",
            "\n                   replace(SYS_CONNECT_BY_PATH(t.t_origin, '/'),  '/0', null) t_strorigin ",
            "\n              FROM doprkdoc_dbt t ",
            "\n              WHERE CONNECT_BY_ISLEAF = 1 ",
            "\n                AND t.t_dockind != 320 ", //заглушка до выяснения
            "\n              START WITH t.t_dockind = 29 ",
            "\n              CONNECT BY PRIOR t_dockind = t_parentdockind)) t, ",
            "\n      dllvalues_dbt lval ",
            "\n where t.t_origin = lval.t_list ",
            strFill(aDockind, DOCKIND_SIZE, 1, "t.t_dockind", false),
            strFill(aSource, SOURCE_SIZE, 1, "lval.t_element", false),
            "\n order by t.t_dockind, lval.t_element " ));

        while (rs.moveNext)
            str = str + "or (" + cmpStr1 + " = " + rs.value("dockind") + 
                       " and " + cmpStr2 + " = " + rs.value("element") + ") ";
        end;

        if (substr(str,1,2) == "or")
            str = substr(str,3);
        end;

        if (str != "")
            str = "\n and (" + str + ") ";
        end;

        return str;

    end;

end;
/*----------------------------------------------------------------------------*/
//конвертация времени из десятичного количества секунд в строку вида "hh:mi:ss"
private macro timeString(n)
var hh, mi, ss;
    
    mi = int(n / 60);
    ss = int(n - 60 * mi);
    hh = int(mi / 60);
    mi = int(mi - 60 * hh);

    mi = mkstr("0",2-strlen(string(mi))) + string(mi);
    ss = mkstr("0",2-strlen(string(ss))) + string(ss);
    hh = mkstr("0",2-strlen(string(hh))) + string(hh);

    return(hh + ":" + mi + ":" + ss);

end; /* End Of TimeString */
/*----------------------------------------------------------------------------*/
//основные расчёты статистики: подготовка и выполнение запроса, заполнение массива результатов
private macro core()
    var rs,
        cmd,
        query,
        j : integer = 0,
        i : integer = 0,
        dayExists : bool = false,
        resultSize : integer = 0,
        progressCounter : integer = 0,
        curDate : Date = startdate,
        strDockind : string = "",
        strCipher : string = "",
        strSource : string = "",
        strScheme : string = "",
        strType : string = "",
        strMaxExecHours: string = "", 
        minExecHours,
        minExecMins,
        minExecSecs,        
        roboList,
        errCode : integer = 0;

    //в случае неверного ввода меняем даты местами
    if (startDate > endDate)
        curDate = startDate;
        startDate = endDate;
        endDate = curDate;
        curDate = startDate;
    end;

    //подготовка строки с параметром "схема расчетов" для вставки в запрос
    strScheme = strFill(aScheme, SCHEME_SIZE, 1, "pr.t_corschem", false);

    //подготовка строки с параметром "шифр документа" для вставки в запрос
    strCipher = strFill(aCipher, CIPHER_SIZE, 1, "rm.t_shifroper", true);

    //подготовка строки с параметром "признак исполнителя" для вставки в запрос
    strType = strFill(aType, TYPE_SIZE, 1, "st.type_op", false);

    //подготовка строки с параметром "происхождение документа" для вставки в запрос
    strSource = strFillSource(aSource, "pm.t_dockind", "pm.origin");

    /*10.02.2015 VDN C-33290*/
    //проверка настройки максимального времени исполнения
    if(maxExecTime)
      strMaxExecHours = " and (ssd - op.t_syst_date + to_date('01.01.0001 ' || to_char(sst, 'hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') - op.t_syst_time) * 24 <= 15 ";
    end;

    //подготовка параметра "минимальное время исполнения"
    timeSplit(minExecTime, minExecHours, minExecMins, minExecSecs);

    //промежуточное окно для этапа подсчёта документов
    InitProgress(1, "Идёт подсчёт документов...", REP_NAME);

    //массив инициализируется с ненулевым размером, хотя по факту он пуст. Исправляем.
    aResult.size = 0;

    //считываем список операционистов-роботов
    if (not getRegistryValue("PRBB\\МОНИТОР ОБРАБОТЧИКОВ\\ROBOTS", V_STRING, roboList, errCode, false))
        msgbox("Значение настройки реестра 'PRBB\\МОНИТОР ОБРАБОТЧИКОВ\\ROBOTS' не задано. Будет использовано значение по умолчанию.");
        roboList = CONST_ROBOLIST;
    end;

    //подсчитываем количество документов согласно параметрам фильтра, полученное значение используется в прогрессбаре
    rs = RsdRecordSet(string(
    "select count(distinct pm.t_paymentid) pid ",
    "\n from  (select s.t_id_operation, max(s.t_syst_date) ssd, max(s.t_syst_time) sst, ",
    "\n               decode(sum(case when (s.t_oper in (" + roboList + ") ",
    "\n                                     or r.t_is_robot_step = chr(88) ",
    "\n                                     or r.t_program = 'ate.exe') ",
    "\n                               then 1 else 0 end), ",
    "\n                      count(s.t_number_step), " + OP_ROBOT + ", 0, " + OP_MAN + ", " + OP_MIXED + ") type_op ",
    "\n          from doprstep_dbt s, usr_doprstep_robot_dbt r ",
    "\n         where s.t_id_operation = r.t_id_operation(+) ",
    "\n           and s.t_number_step = r.t_number_step(+) ",
    "\n         group by s.t_id_operation) st, ",
    "\n       (select ",
    "\n          pm.t_paymentid, pm.t_dockind, pm.t_paymstatus, pm.t_closedate, pm.t_creationtime, ",
    "\n          case when (pm.t_dockind in (" + CONST_ORIGLIST + ")) ",
    "\n               then decode( user_ea.getOrigin(pm.t_docKind, pm.t_paymentID), ",
    "\n                            9999, decode( pm.t_primdocorigin, 9999, pm.t_origin, pm.t_primdocorigin ), ",
    "\n                            user_ea.getOrigin(pm.t_docKind, pm.t_paymentID) ) ",
    "\n               else decode( pm.t_primdocorigin, 9999, pm.t_origin, pm.t_primdocorigin ) end origin ",
    "\n       from dpmpaym_dbt pm) pm, ",
    "\n       doproper_dbt op, ",
    "\n       dpmrmprop_dbt rm, ",
    "\n       dpmprop_dbt pr ",
    "\n where lpad(pm.t_paymentid, 34, '0') = op.t_documentid ",
    "\n   and pm.t_dockind = op.t_dockind ",
    "\n   and op.t_id_operation = st.t_id_operation ",
    "\n   and pm.t_paymentid = rm.t_paymentid ",
    "\n   and pm.t_paymentid = pr.t_paymentid ",
    "\n   and pm.t_paymstatus in (100,32000) ",
    "\n   and pm.t_closedate between '" + startDate + "' and '" + endDate + "'",
    "\n   and (ssd - op.t_syst_date + to_date('01.01.0001 ' || to_char(sst, 'hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') ",
    "\n      - op.t_syst_time)*24*60*60 >= ",
        minExecSecs + minExecMins*60 + minExecHours*60*60,
    strMaxExecHours,
    "\n   and op.t_syst_time between to_date('01.01.0001 " + startTime + "') and to_date('01.01.0001 " + endTime + "') ",
    strSource,
    strScheme,
    strCipher,
    strType
    ));

    rs.moveNext;
    j = rs.value("pid");

    RemProgress();
    InitProgress( j, "Идёт обработка документов...", REP_NAME);

    query = string(
        "select distinct ",
        "\n     pm.t_paymentid, ",
        "\n     pm.t_dockind, ",
        "\n     pm.origin, ",
        "\n     st.type_op, ",
        "\n     (ssd - op.t_syst_date + to_date('01.01.0001 '||to_char(sst, 'hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') - op.t_syst_time)*24*60*60 time_op ",
        "\n from  (select s.t_id_operation, max(s.t_syst_date) ssd, max(s.t_syst_time) sst, ",
        "\n               decode(sum(case when (s.t_oper in (" + roboList + ") ",
        "\n                                     or r.t_is_robot_step = chr(88) ",
        "\n                                     or r.t_program = 'ate.exe') ",
        "\n                               then 1 else 0 end), ",
        "\n                      count(s.t_number_step), " + OP_ROBOT + ", 0, " + OP_MAN + ", " + OP_MIXED + ") type_op ",
        "\n          from doprstep_dbt s, usr_doprstep_robot_dbt r ",
        "\n         where s.t_id_operation = r.t_id_operation(+) ",
        "\n           and s.t_number_step = r.t_number_step(+) ",
        "\n         group by s.t_id_operation) st, ",
        "\n       (select ",
        "\n          pm.t_paymentid, pm.t_dockind, pm.t_paymstatus, pm.t_closedate, pm.t_creationtime, ",
        "\n          case when (pm.t_dockind in (" + CONST_ORIGLIST + ")) ",
        "\n               then decode( user_ea.getOrigin(pm.t_docKind, pm.t_paymentID), ",
        "\n                            9999, decode( pm.t_primdocorigin, 9999, pm.t_origin, pm.t_primdocorigin ), ",
        "\n                            user_ea.getOrigin(pm.t_docKind, pm.t_paymentID) ) ",
        "\n               else decode( pm.t_primdocorigin, 9999, pm.t_origin, pm.t_primdocorigin ) end origin ",
        "\n       from dpmpaym_dbt pm) pm, ",
        "\n       doproper_dbt op, ",
        "\n       dpmrmprop_dbt rm, ",
        "\n       dpmprop_dbt pr ",
        "\n where lpad(pm.t_paymentid, 34, '0') = op.t_documentid ",
        "\n   and pm.t_dockind = op.t_dockind ",
        "\n   and op.t_id_operation = st.t_id_operation ",
        "\n   and pm.t_paymentid = rm.t_paymentid ",
        "\n   and pm.t_paymentid = pr.t_paymentid ",
        "\n   and pm.t_paymstatus in (100,32000) ",
        "\n   and pm.t_closedate = ? ",
        "\n   and (ssd - op.t_syst_date + to_date('01.01.0001 '||to_char(sst, 'hh24:mi:ss'), 'dd.mm.yyyy hh24:mi:ss') - op.t_syst_time)*24*60*60 >= ",
            minExecSecs + minExecMins*60 + minExecHours*60*60,
        strMaxExecHours,
        "\n   and op.t_syst_time between to_date('01.01.0001 " + startTime + "','dd.mm.yyyy hh24:mi:ss') ",
        "\n                          and to_date('01.01.0001 " + endTime + "','dd.mm.yyyy hh24:mi:ss') ",
        strSource,
        strScheme,
        strCipher,
        strType,
        "\n ORDER BY pm.t_dockind, pm.origin, st.type_op "
        );

    //запрос выполняется для каждого дня в отдельности, т.к. нужна статистика по дням с отсутствующими платежами
    while (curDate != endDate + 1)

        cmd = RSDCommand(query);
        cmd.addParam("currentDate", RSDBP_IN, curDate);
        rs = RSDRecordset(cmd);

        dayExists = false;

        while (rs.moveNext)
            dayExists = true;
            i = 0;
            resultSize = aResult.size/RES_SIZE;

            useProgress(progressCounter);
            progressCounter = progressCounter + 1;

            //ищем существующую запись с соответствующими параметрами
            while (not (
                ((aResult[RES_SIZE*i] == rs.value("t_dockind")) and 
                 (aResult[RES_SIZE*i+2] == rs.value("origin"))  and
                 (aResult[RES_SIZE*i+4] == rs.value("type_op")))
                or (i == resultSize) ))
                    i = i + 1;
            end;

            //Инициализация структуры, если встретился следующий тип документа или источника
            if (i == resultSize)

                aResult[RES_SIZE*i] = rs.value("t_dockind"); //вид документа

                j = 0; //поиск наименования
                while (aDockind[DOCKIND_SIZE*j+1] != rs.value("t_dockind"))
                    j = j + 1;
                end;
                aResult[RES_SIZE*i+1] = aDockind[DOCKIND_SIZE*j+2]; //наименование вида документа

                j = 0; //поиск происхождения
                while (aSource[SOURCE_SIZE*j+1] != rs.value("origin"))
                    j = j + 1;
                end;
                aResult[RES_SIZE*i+2] = aSource[SOURCE_SIZE*j+1]; //происхождение документа
                aResult[RES_SIZE*i+3] = aSource[SOURCE_SIZE*j+2]; //наименование происхождения документа

                aResult[RES_SIZE*i+4] = rs.value("type_op"); //признак исполнителя
                aResult[RES_SIZE*i+5] = 0;  //количество обраб. документов
                aResult[RES_SIZE*i+6] = 0;  //среднее время обработки в секундах
                aResult[RES_SIZE*i+7] = rs.value("time_op");  //макс. время обработки
                aResult[RES_SIZE*i+8] = rs.value("time_op");  //мин. время обработки
                aResult[RES_SIZE*i+9] = ""; //paymentid документов
                aResult[RES_SIZE*i+10] = rs.value("t_paymentid"); //paymentid документа с макс. вр. обработки
                aResult[RES_SIZE*i+11] = rs.value("t_paymentid"); //paymentid документа с мин. вр. обработки

            end;

            aResult[RES_SIZE*i+5] = aResult[RES_SIZE*i+5] + 1;

            aResult[RES_SIZE*i+6] = aResult[RES_SIZE*i+6] + rs.value("time_op");

            if (rs.value("time_op") > aResult[RES_SIZE*i+7])
                aResult[RES_SIZE*i+7] = rs.value("time_op");
                aResult[RES_SIZE*i+10] = rs.value("t_paymentid");
            end;

            if (rs.value("time_op") < aResult[RES_SIZE*i+8])
                aResult[RES_SIZE*i+8] = rs.value("time_op");
                aResult[RES_SIZE*i+11] = rs.value("t_paymentid");
            end;

            if (aResult[RES_SIZE*i+5] < debugNumDocs + 1)
                aResult[RES_SIZE*i+9] = aResult[RES_SIZE*i+9] + "," + rs.value("t_paymentid");
            end;

        end;

        if (not dayExists)
            strDayExists = strDayExists + ", " + curDate;
        end;

        curDate = curDate + 1;
    end;

    //перегруппируем массив результатов: может возникнуть ситуация, когда запись с новым значением источника 
    //для существующего значения вида документа оторвана от группы предыдущих записей с этим видом документа
    if (aResult.size >= RES_SIZE+1) aResult = sortme(aResult, RES_SIZE); end;

    if (strDayExists != "")
        strDayExists = "За следующие дни платежи отсутствуют: " + substr(strDayExists,3);
    end;

    //преобразование признака исполнителя (код -> наименование), расчет средней продолжительности шага и конвертация значений времени
    if (aResult.size >= RES_SIZE)
        for (i, 0, aResult.size/RES_SIZE-1)
            if       (aResult[RES_SIZE*i+4] == 0) aResult[RES_SIZE*i+4] = "Робот";
                elif (aResult[RES_SIZE*i+4] == 1) aResult[RES_SIZE*i+4] = "Операционист";
                else aResult[RES_SIZE*i+4] = "Смешанная";
            end;
            aResult[RES_SIZE*i+6] = aResult[RES_SIZE*i+6] / aResult[RES_SIZE*i+5];
            aResult[RES_SIZE*i+6] = timeString(aResult[RES_SIZE*i+6]);
            aResult[RES_SIZE*i+7] = timeString(aResult[RES_SIZE*i+7]);
            aResult[RES_SIZE*i+8] = timeString(aResult[RES_SIZE*i+8]);
            aResult[RES_SIZE*i+9] = substr(aResult[RES_SIZE*i+9],2);
        end;
    end;

    RemProgress();
    Message("Формирование Excel-файла...");
end;
/*----------------------------------------------------------------------------*/
//x - строка, y - столбец

private macro Put_Cell_Border(Lst, x, y, string, al)
    if (valtype(al) == V_UNDEF) al = 3 end;
    Lst.Cells(x, y).Value = string;
    Lst.Cells(x, y).HorizontalAlignment = al;
    Lst.Cells(x, y).Borders.LineStyle = 1;
end; /*End Of Put_Cell_Border*/

private macro Put_Cell(Lst, x, y, string, al)
    if (valtype(al) == V_UNDEF) al = 3 end;
    Lst.Cells(x, y).Value = string;
    Lst.Cells(x, y).HorizontalAlignment = al;
end; /*End Of Put_Cell*/

private macro ExcelRep(ComObj)
    var i : integer = 0,
        rs,
        List = ComObj.Sheets(1),
        tempstr : string = "",
        alLeft = 2,
        alRight = 4,
        alCenter = 3;
    
    if (debugMode)
        List.Columns("A:A").ColumnWidth = 11;
        List.Columns("B:B").ColumnWidth = 28;
        List.Columns("C:C").ColumnWidth = 30;
        List.Columns("D:J").ColumnWidth = 15;
        List.Columns("K:K").ColumnWidth = 25;
    else
        List.Columns("A:A").ColumnWidth = 11;
        List.Columns("B:B").ColumnWidth = 28;
        List.Columns("C:C").ColumnWidth = 30;
        List.Columns("D:H").ColumnWidth = 15;
        List.Columns("I:I").ColumnWidth = 25;
    end;

    List.Range("A2:G2").Merge;
    List.Range("A2:G2").Font.Bold = True;
    Put_Cell(List, 2, 1, REP_NAME_UPPER);

    List.Range("A4:C4").Merge;
    List.Range("A4:C4").Value = string("Подразделение (Банк): " + {Name_Bank});

    List.Range("D4:G4").Merge;
    List.Range("D4:G4").Value = string("За период с " + startDate + " по " + endDate);

    List.Range("A6:C6").Merge;
    List.Range("A6:C6").Value = string("Дата, время формирования отчёта: " + date + " " + time);

    List.Range("D6:G6").Merge;
    List.Range("D6:G6").Value = "Параметры фильтра:";

    rs = RsdRecordSet(string("select t_name from dperson_dbt where t_oper = " + {oper}));
    rs.movenext;

    List.Range("A8:C8").Merge;
    List.Range("A8:C8").Value = string("Исполнитель: {" + {oper} + "} " + rs.value("t_name"));

    tempstr = "";
    for (i, 0, aDockind.size/DOCKIND_SIZE)
        if (aDockind[DOCKIND_SIZE*i] == true) tempstr = tempstr + ", " + aDockind[DOCKIND_SIZE*i+2] end;
    end;
    if (substr(tempstr,1,1) == ",") tempstr = substr(tempstr,2) end;
    if (tempstr == "") tempstr = "ВСЕ" end;
    
    List.Range("D8:H8").Merge;
    List.Range("D8:H8").Value = string("Вид документа:" + tempstr);

    tempstr = "";
    for (i, 0, aSource.size/SOURCE_SIZE)
        if (aSource[SOURCE_SIZE*i] == true) tempstr = tempstr + ", " + aSource[SOURCE_SIZE*i+2] end;
    end;
    if (substr(tempstr,1,1) == ",") tempstr = substr(tempstr,2) end;
    if (tempstr == "") tempstr = "ВСЕ" end;

    List.Range("D9:H9").Merge;
    List.Range("D9:H9").Value = string("Источник поступления: " + tempstr);

    List.Range("D10:H10").Merge;
    List.Range("D10:H10").Value = string("Время поступления: " + startTime + " - " + endTime);

    tempstr = "";
    for (i, 0, aType.size/TYPE_SIZE)
        if (aType[TYPE_SIZE*i] == true) tempstr = tempstr + ", " + aType[TYPE_SIZE*i+2] end;
    end;
    if (substr(tempstr,1,1) == ",") tempstr = substr(tempstr,2) end;
    if (tempstr == "") tempstr = "ВСЕ" end;

    List.Range("D11:H11").Merge;
    List.Range("D11:H11").Value = string("Признак исполнителя: " + tempstr);

    tempstr = "";
    for (i, 0, aScheme.size/SCHEME_SIZE)
        if (aScheme[SCHEME_SIZE*i] == true) tempstr = tempstr + ", " + aScheme[SCHEME_SIZE*i+2] end;
    end;
    if (substr(tempstr,1,1) == ",") tempstr = substr(tempstr,2) end;
    if (tempstr == "") tempstr = "ВСЕ" end;

    List.Range("D12:H12").Merge;
    List.Range("D12:H12").Value = string("Схема расчетов: " + tempstr);

    tempstr = "";
    for (i, 0, aCipher.size/CIPHER_SIZE)
        if (aCipher[CIPHER_SIZE*i] == true) tempstr = tempstr + ", " + aCipher[CIPHER_SIZE*i+2] end;
    end;
    if (substr(tempstr,1,1) == ",") tempstr = substr(tempstr,2) end;
    if (tempstr == "") tempstr = "ВСЕ" end;

    List.Range("D13:H13").Merge;
    List.Range("D13:H13").Value = string("Шифр документа: " + tempstr);

    List.Range("D14:H14").Merge;
    List.Range("D14:H14").Value = string("Минимальное время обработки: " + minExecTime);

    //заголовки столбцов результатов
    if (debugMode) //с ID документов
        List.Range("A16:K16").Interior.Color = #B5B5B5;
        List.Range("A16:K16").WrapText = True;
        Put_Cell_Border(List, 16, 1, string("Код вида документа"));
        Put_Cell_Border(List, 16, 2, string("Наименование вида документа"));
        Put_Cell_Border(List, 16, 3, string("Источник поступления"));
        Put_Cell_Border(List, 16, 4, string("Признак исполнителя"));
        Put_Cell_Border(List, 16, 5, string("Количество документов (всего)"));
        Put_Cell_Border(List, 16, 6, string("Среднее время обработки"));
        Put_Cell_Border(List, 16, 7, string("Максимальное время обработки"));
        Put_Cell_Border(List, 16, 8, string("ID документа"));
        Put_Cell_Border(List, 16, 9, string("Минимальное время обработки"));
        Put_Cell_Border(List, 16,10, string("ID документа"));
        Put_Cell_Border(List, 16,11, string("ID платежей"));
    else           //без ID документов
        List.Range("A16:H16").Interior.Color = #B5B5B5;
        List.Range("A16:H16").WrapText = True;
        Put_Cell_Border(List, 16, 1, string("Код вида документа"));
        Put_Cell_Border(List, 16, 2, string("Наименование вида документа"));
        Put_Cell_Border(List, 16, 3, string("Источник поступления"));
        Put_Cell_Border(List, 16, 4, string("Признак исполнителя"));
        Put_Cell_Border(List, 16, 5, string("Количество документов (всего)"));
        Put_Cell_Border(List, 16, 6, string("Среднее время обработки"));
        Put_Cell_Border(List, 16, 7, string("Максимальное время обработки"));
        Put_Cell_Border(List, 16, 8, string("Минимальное время обработки"));
    end;

    //заполнение блока результатов
    if (debugMode)
        if (aResult.size/RES_SIZE != 0)
            for (i, 0, aResult.size/RES_SIZE-1)
                Put_Cell(List, 17+i, 1, aResult[RES_SIZE*i   ], alRight); //код вида
                Put_Cell(List, 17+i, 2, aResult[RES_SIZE*i+ 1], alLeft);  //наим. вида
                Put_Cell(List, 17+i, 3, aResult[RES_SIZE*i+ 3], alLeft);  //источник
                Put_Cell(List, 17+i, 4, aResult[RES_SIZE*i+ 4], alLeft);  //признак исполнителя
                Put_Cell(List, 17+i, 5, aResult[RES_SIZE*i+ 5], alRight); //кол-во документов (всего)
                Put_Cell(List, 17+i, 6, aResult[RES_SIZE*i+ 6], alRight); //среднее время обраб.
                Put_Cell(List, 17+i, 7, aResult[RES_SIZE*i+ 7], alRight); //макс. время обраб.
                Put_Cell(List, 17+i, 8, aResult[RES_SIZE*i+10], alRight); //ID документа с макс. вр. обраб.
                Put_Cell(List, 17+i, 9, aResult[RES_SIZE*i+ 8], alRight); //мин.  время обраб.
                Put_Cell(List, 17+i,10, aResult[RES_SIZE*i+11], alRight); //ID документа с мин. вр. обраб.
                Put_Cell(List, 17+i,11, aResult[RES_SIZE*i+ 9], alRight); //id платежей
            end;
        end;
    else
        if (aResult.size/RES_SIZE != 0)
            for (i, 0, aResult.size/RES_SIZE-1)
                Put_Cell(List, 17+i, 1, aResult[RES_SIZE*i  ], alRight); //код вида
                Put_Cell(List, 17+i, 2, aResult[RES_SIZE*i+1], alLeft);  //наим. вида
                Put_Cell(List, 17+i, 3, aResult[RES_SIZE*i+3], alLeft);  //источник
                Put_Cell(List, 17+i, 4, aResult[RES_SIZE*i+4], alLeft);  //признак исполнителя
                Put_Cell(List, 17+i, 5, aResult[RES_SIZE*i+5], alRight); //кол-во документов (всего)
                Put_Cell(List, 17+i, 6, aResult[RES_SIZE*i+6], alRight); //среднее время обраб.
                Put_Cell(List, 17+i, 7, aResult[RES_SIZE*i+7], alRight); //макс.  время обраб.
                Put_Cell(List, 17+i, 8, aResult[RES_SIZE*i+8], alRight); //мин.  время обраб.
            end;
        end;
    end;

    List.Cells(17+aResult.size/RES_SIZE+2,1).Value = strDayExists;
end; /*End Of ExcelRep*/

Macro OpenExcel()
    var ExObj;
    var ComObj;
      
    ExObj  = CreateObject ("rsax","TRsAxServer","RsAxServer",IsStandAlone());
    ComObj = ExObj.CreateComObject ("Excel.Application", False);
    ComObj.Application.DisplayAlerts = True;
    ComObj.Workbooks.Add();

    ExcelRep(ComObj);
    
    ComObj.Visible = True;
    
End; /* End Of OpenExcel */



macro main();
    var form: TRsbPanel = RslPanel(REP_NAME);
    form.run();
    if (formRun)
        Message("Обработка результатов запроса...");
        core();
        Message("Формирование Excel-файла...");
        OpenExcel();
    end;
end;
                               
main();
exit(1);