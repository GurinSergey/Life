/*
Version 6.10 от 24.12.2012
/* Добавлена поддержка OpenOffice org*/ 
*/

/*╔═══════════════════════════════════════════════════════════════════════════╗*/
/*║           Автоматизированная банковская система RS-Bank v5.1              ║*/
/*║               Copyright (c) R-Style Software Lab 2001-2004                ║*/
/*║                                                                           ║*/
/*║ Имя файла     or_exl_h.mac                                                ║*/
/*║                                                                           ║*/
/*║ Описание      Общие классы, константы и функции для работы с Excel        ║*/
/*║                                                                           ║*/
/*║ Программист   Зуев С.В.                                                   ║*/
/*║                                                                           ║*/
/*║ Создан        03.01.2002                                                  ║*/
/*║                                                                           ║*/
/*╚═══════════════════════════════════════════════════════════════════════════╝*/
//zmp 29.11.2012 #188699 убран private
Import rslx, rcw ;
Import "trlocale.d32"; /* Утилитные функции написанные на СИ   */
Import "or_set_h.mac"; // Настройки, применяемые в инструменте
Import "or_const.mac"; /* Константы, применяемые в инструменте */
Import "or_worm.mac" ;

/* Текущие глобализмы, для компиляции и работы функций вызываемых из ExecStr и ExecuteMacro */
VAR iBook              :object  = NULL;  /* Объект Excel - "Книга" */
VAR iApplication       :object  = NULL;  /* Объект Excel - "Приложение" */
VAR iSheet             :object  = NULL;  /* Объект Excel - "Лист" */
VAR iRange             :object  = NULL;  /* Объект Excel - "Диапазон ячеек" */
VAR iChart             :object  = NULL;  /* Объект Excel - "Мастер диаграмм" */

/* Текущие глобализмы, для компиляции и работы функций вызываемых из ExecStr и ExecuteMacro для Word*/
VAR WordDocument       :object  = NULL;  // Объект Word  - "Документ"
VAR WordApplication    :object  = NULL;  // Объект Word  - "Приложение"

/* Настройки для форматов в Excel (не HTML) */ 
VAR DoubleFormat       :string  = "# ##0"+GetLocaleDecimalSeparator()+"00"; /* Формат представления дробных чисел */
VAR DateFormat         :string  = ""; /* Формат представления дат (алгоритм формирования ниже, при необходимости можно отключить) */
VAR TimeFormat         :string  = ""; /* Формат представления времени (алгоритм формирования ниже, при необходимости можно отключить) */         
VAR DefaultBorderWeight:integer = 2;  /* Толщина бордюра по умолчанию */

/* Функция возвращающая наименование столбца по его номеру */
MACRO _Col( Col:integer):string /* A - 65 */
   if( Col < 26 )  return StrFor(65+Col);
   else            return StrFor(65+(Int(Col/26)-1)) + StrFor(65+Mod(Col,26));
   end;
END; /* _Col */

/* Метод для преобразования координат строка + столбец в строку */
MACRO _SplitCoord( Row:integer,Col:integer ):string /* A - 65 */
   return _Col(Col) + String(Row+1);
END; /* _SplitCoord */

/**** Добавка к имени файла для получения уникальности */
macro GetUniqAdd(FileName:string) : string
      var Day :integer = 0, Month :integer = 0, Year:integer = 0;
      var hour:integer = 0, minute:integer = 0, sec :integer = 0;
      var Dir :string  ="", Name  :string  ="", ext :string  ="";

      macro Norm(Value:integer) : string
            if( Value < 10 ) return string("0",Value);
            else             return string(    Value);
            end;
      end;

      DateSplit( Date(), Day , Month , Year );
      TimeSplit( time(), hour, minute, sec  );
      Dir = SplitFile( FileName, Name, ext );

      return String( Dir, Name,"_", 
                     Year, Norm(Month), Norm(Day),               // дата
                     Norm(hour), Norm(minute), Norm(sec), ext ); // время
end;

/**** Метод формирует сообщение об ошибке */
macro ErrorMessage( ObjError:object, Title:string )

          if(ObjError.Code != 17)
               if(NOT valtype(Title)) 
                   Title = "Ошибка!";
                end;

                MsgBox( Title, 
                        "|Code    :",  ObjError.Code   :260:l,
                        "|Message :",  ObjError.Message:260:l,
                        "|Module  :",  ObjError.Module :260:l,
                        "|Line    :",  ObjError.Line   :260:l,
                        "|AxCode  :",  ObjError.AxCode :260:l,
                        "|Err     :",  ObjError.Err    :260:l,
                        "|AxMes   :",  ObjError.AxMes  :260:l);
          else 
                MsgBox("Прерывание пользователя!"); // прерывание пользователя
          end;       
end;



/**** Объект "Адрес ячейки" */
class CAddress( _Address:string )
      private var m_Address:string  = ""; // Адрес ячейки (диапазона)
      private var m_bRow   :integer = ""; // Строка  начала    ячейки (диапазона)
      private var m_eRow   :integer = ""; // Строка  окончания ячейки (диапазона)
      private var m_bCol   :integer = ""; // Колонка начала    ячейки (диапазона)   
      private var m_eCol   :integer = ""; // Колонка окончания ячейки (диапазона)

      // Получить код символа по названию колонки
      private macro MyCodeFor( Col:string ) : integer
            var Symbol1   :string  = "";
            var Symbol2   :string  = "";
            var NumbS     :integer = StrLen( Col );
            var i         :integer = 1;
            var RetCodeFor:integer = 0;

            if( NumbS == 1 )
                RetCodeFor = CodeFor(Col) - 65;
            else
                Symbol1 = SubStr(Col, 1, 1);
                Symbol2 = SubStr(Col, 2, 1);

                RetCodeFor = (CodeFor(Symbol1)-65+1)*26;
                RetCodeFor = RetCodeFor + (CodeFor(Symbol2)-65);

            end;
            return RetCodeFor;
      end;

      // Получить адрес ячейки (диапазона)
      macro Get_Address() : string
            return m_Address;
      end;

      macro Get_bRow() : integer
            return m_bRow;
      end;
      macro Get_eRow() : integer
            return m_eRow;
      end;
      macro Get_bCol() : integer
            return m_bCol;
      end;
      macro Get_eCol() : integer
            return m_eCol;
      end;

      macro MergeAddress()
            m_Address = string(_SplitCoord(m_bRow, m_bCol),":", _SplitCoord(m_eRow, m_eCol));
      end;

      // Разбить на составляющие
      macro SplitAddress()
            var Pos     :integer = 0;
            var bAddress:string = "";
            var eAddress:string = "";
            if( (Pos=Index(m_Address, ":")) != 0 )
                bAddress = SubStr(m_Address, 1, Pos-1);
                eAddress = SubStr(m_Address,    Pos+1);
            end;

            if( (Pos = index(bAddress, "$")) != 0 )
                bAddress = SubStr(bAddress, Pos+1);
                if( (Pos = index(bAddress, "$")) != 0 )
                    m_bCol = Int(MyCodeFor(SubStr(bAddress, 1, Pos-1)));
                    m_bRow = Int(          SubStr(bAddress,    Pos+1));
                    m_bRow = m_bRow - 1;
                end;
            end;

            if( (Pos = index(eAddress, "$")) != 0 )
                eAddress = SubStr(eAddress, Pos+1);
                if( (Pos = index(eAddress, "$")) != 0 )
                    m_eCol = Int(MyCodeFor(SubStr(eAddress, 1, Pos-1)));
                    m_eRow = Int(          SubStr(eAddress,    Pos+1));
                    m_eRow = m_eRow - 1;
                end;
            end;
      end;

      macro DebugPrint()
            println(" m_Address-", m_Address);
            println(" m_bRow   -", m_bRow   );
            println(" m_eRow   -", m_eRow   );
            println(" m_bCol   -", m_bCol   );
            println(" m_eCol   -", m_eCol   );
      end;

      // Инициализация объекта строкой адреса l_Address
      macro Init( l_Address:string )
            m_Address = l_Address;
            SplitAddress();
      end;

      // Конструктор
      if( ValType(_Address) ) Init( _Address ); end;
end;

/**** Объект "Адрес Диапазона" */
class (CAddress) CAddressDiapazon( _Address:string )

/* Методы объекта
   GetRow()        - Получить адрес диапазона строки с номером NumbCol
   GetColumn()     - Получить адрес диапазона колонки с номером NumbCol
   GetCell()       - Получить ссылку на ячейку
   GetNumbRow()    - Получить количество строк диапазона
   GetNumbColumn() - Получить количество столбцов диапазона
   OffSet_Top   () - Смещение верхней границы диапазона
   OffSet_Bottom() - Смещение нижней границы диапазона
   OffSet_Row   () - Смещение всего диапазона вверхи или вниз
   OffSet_Left  () - Смещение левой границы диапазона
   OffSet_Right () - Смещение правой границы диапазона
   OffSet_TL()     - Смещение верхней левой границы диапазона
   OffSet_BR()     - Смещение нижней правой границы диапазона
*/

      InitCAddress( _Address );  // Конструктор базового класса

      // Получить адрес диапазона строки с номером NumbCol
      macro GetRow( NumbRow:integer ) : string
            return String( _Col(m_bCol), m_bRow+NumbRow+1, ":", _Col(m_eCol), m_bRow+NumbRow+1 );
      end;

      // Получить адрес диапазона колонки с номером NumbCol
      macro GetColumn( NumbCol:integer ) : string
            return String( _SplitCoord(m_bRow, m_bCol+NumbCol), ":", _SplitCoord(m_eRow, +m_bCol+NumbCol) );
      end;

      // Получить ссылку на ячейку
      macro GetCell( NumbRow:integer, NumbCol:integer )
            return String( _Col(m_bCol+NumbCol), m_bRow+NumbRow+1 );
      end;

      // Получить количество строк диапазона
      macro GetNumbRow() : integer
            return m_eRow - m_bRow + 1;
      end;

      // Получить количество столбцов диапазона
      macro GetNumbColumn() : integer
            return m_eCol - m_bCol + 1;
      end;

      // Смещение верхней границы диапазона
      macro OffSet_Top   ( RowOffset:integer    )
            m_bRow = m_bRow + RowOffset   ;
            MergeAddress();
      end;
      // Смещение нижней границы диапазона
      macro OffSet_Bottom( RowOffset:integer    )
            m_eRow = m_eRow + RowOffset   ;
            MergeAddress();
      end;
      // Смещение всего диапазона на RowOffset вверих(-) или вниз(+)
      macro OffSet_Row( RowOffset:integer       )
            m_bRow = m_bRow + RowOffset   ;
            m_eRow = m_eRow + RowOffset   ;
            MergeAddress();
      end;
      // Смещение левой границы диапазона
      macro OffSet_Left  ( ColumnOffset:integer )
            m_bCol = m_bCol + ColumnOffset;
            MergeAddress();
      end;
      // Смещение правой границы диапазона
      macro OffSet_Right ( ColumnOffset:integer )
            m_eCol = m_eCol + ColumnOffset;
            MergeAddress();
      end;

      // Смещение верхней левой границы диапазона
      macro OffSet_TL( RowOffset:integer, ColumnOffset:integer )
            OffSet_Top ( RowOffset    );
            OffSet_Left( ColumnOffset );
      end;

      // Смещение нижней правой границы диапазона
      macro OffSet_BR( RowOffset:integer, ColumnOffset:integer )
            OffSet_Bottom( RowOffset    );
            OffSet_Right ( ColumnOffset );
      end;
end;

/* Класс для свойств шрифта */
CLASS CFontProp(_Name:string, _Size:integer, _Bold:bool, _Italic:bool, _Underline:integer, _FrColor:integer, _BkColor:integer)

  VAR Name     :string  = DefaultStringFont;     /* Наименование шрифта */
  VAR Size     :integer = DefaultFontSize;       /* Размер шрифта */
  VAR Bold     :bool    = False;                 /* Признак жирного шрифта */
  VAR Italic   :bool    = False;                 /* Признак курсивного шрифта */
  VAR Underline:integer = FONTSTYLE_UNDERLINENO; /* Признак подчеркнутого шрифта */
  VAR FrColor  :integer = DefaultFontColor;      /* Цвет символов */
  VAR BkColor  :integer = DefaultBkGrColor;      /* Цвет фона */

  /* Инициализация класса */
  Macro Init(l_Name:string, l_Size:integer, l_Bold:bool, l_Italic:bool, l_Underline:integer, l_FrColor:integer, l_BkColor:integer)

     if(ValType(l_Name     ))  this.Name      = l_Name     ;  end;
     if(ValType(l_Size     ))  this.Size      = l_Size     ;  end;
     if(ValType(l_Bold     ))  this.Bold      = l_Bold     ;  end;
     if(ValType(l_Italic   ))  this.Italic    = l_Italic   ;  end;
     if(ValType(l_Underline))  this.Underline = l_Underline;  end;
     if(ValType(l_FrColor  ))  this.FrColor   = l_FrColor  ;  end;
     if(ValType(l_BkColor  ))  this.BkColor   = l_BkColor  ;  end;

  End; /* Init */

  /* Конструктор */
  this.Init(_Name, _Size, _Bold, _Italic, _Underline, _FrColor, _BkColor);
  /**/

END; /* CFontProp */

/* Класс для свойств обрамления */
CLASS CBorderProp(_Left:integer, _Top:integer, _Bottom:integer, _Right:integer,
                  _InSideVertical:integer, _InSideHorizont:integer, _Weight:integer)

  VAR Left          :integer = BORDERLINE_UNDEF;    /* Вид линии обрамления слева */
  VAR Top           :integer = BORDERLINE_UNDEF;    /* Вид линии обрамления слева */
  VAR Bottom        :integer = BORDERLINE_UNDEF;    /* Вид линии обрамления снизу */
  VAR Right         :integer = BORDERLINE_UNDEF;    /* Вид линии обрамления справа */
  VAR InSideVertical:integer = BORDERLINE_UNDEF;    /* Вид вертикальных разделителей между ячейками диапазона */
  VAR InSideHorizont:integer = BORDERLINE_UNDEF;    /* Вид горизонтальных разделителей между ячейками диапазона */
  VAR Weight        :integer = DefaultBorderWeight; /* Толщина обрамления по умолчанию */

  /* Инициализация класса */
  Macro Init(l_Left:integer, l_Top:integer, l_Bottom:integer, l_Right:integer,
             l_InSideVertical:integer, l_InSideHorizont:integer, l_Weight:integer)

     if(ValType(l_Left          ))    this.Left           = l_Left;               end;
     if(ValType(l_Top           ))    this.Top            = l_Top;                end;
     if(ValType(l_Bottom        ))    this.Bottom         = l_Bottom;             end;
     if(ValType(l_Right         ))    this.Right          = l_Right;              end;
     if(ValType(l_InSideVertical))    this.InSideVertical = l_InSideVertical;     end;
     if(ValType(l_InSideHorizont))    this.InSideHorizont = l_InSideHorizont;     end;
     if(ValType(l_Weight        ))    this.Weight         = l_Weight;             end;

  End; /* Init */

  /* Конструктор */
  this.Init(_Left, _Top, _Bottom, _Right, _InSideVertical, _InSideHorizont, _Weight);
  /**/

END; /* CBorderProp */


/* Функция временно заменяющая отвалившуюся функцию StrSubst */
Macro LocStrSubst(Str:string, FindStr:string, ReplaceStr:string):string

  return StrSubst( Str, FindStr, ReplaceStr );
/*
  var RetStr :string  = "";  /* Возвращаемая строка */ 
  var Pos    :integer = "";  /* Позиция очередной найденной подстроки */
  var TempStr:string  = Str; /* Временная строка, которую будем крамсать */

  Pos = Index(TempStr, FindStr);
  while( Pos )
     RetStr  = RetStr + SubStr(TempStr, 1, Pos - 1) + ReplaceStr;
     TempStr = SubStr(TempStr, Pos + StrLen(FindStr) );
     Pos     = Index(TempStr, FindStr);
  end;
  return RetStr + TempStr;
*/
End; /* LocStrSubst */


/**** Обойдем ошибку RSL-я. Проблемы следующие:
      функция ExistFile() - не ищет файлы на терминале, работает очень оригинально
                            ExistFile("$"+ FileName) - ВСЕГДА возвращает TRUE
      функция GetFileInfo() - ищет файлы и на сервере и на терминале, НО
                              её нет в терминальной части RSL-я, WR-падает при компиляции.
      Чтобы избежать всех этих проблем, используем следующее извращение                   */
macro OR_ExistFile( _FileName_:string ) : bool
      var FindFileName:string = _FileName_;

      // Если запуск производится в 3-х звенке, то нужно при поиске к имени файла добавлять "$"
      if( NOT isStandalone() )
          FindFileName = "$"+ _FileName_;
          return ExecExp( "GetFileInfo((FindFileName))" );
      else
          return ExistFile(FindFileName);
      end;
end;

/**** Обойдем ошибку RSL-я. Проблемы следующие:
      функция DelFile()    - не удяляет файл на терминале
      функция RemoveFile() - удялет файлы и на сервере и на терминале, НО
                             её нет в терминальной части RSL-я, WR-падает при компиляции.
      Чтобы избежать всех этих проблем, используем следующее извращение                   */
macro OR_DeleteFile( _FileName_:string ) : bool
      var FindFileName:string = _FileName_;

      // Если запуск производится в 3-х звенке, то нужно к имени файла добавлять "$"
      if( NOT isStandalone() )
          FindFileName = "$"+ _FileName_;
          return ExecExp( "RemoveFile(toANSI(FindFileName))" );
      else
          return DelFile(toANSI(FindFileName));
      end;
end;
/*zmp 29.11.2012 #188699 убран private*/
class CDAOMS_Base( _RegimNewApp_:bool ) // Режим создания приложения, true  - новое приложение, 
                                                //                            false - используем существующее

   //****** Public. Публичные члены класса
   var Application:object = NULL;         // Объект - "Приложение" (Excel, Word, InternetExplorer)

   //***** Приватные члены класса
   private var m_RegimNewApp:bool = _RegimNewApp_; // Режим создания приложения

   /**** Метод проверки создания приложения. Возвращает 
                                             true - если приложение уже создано
                                             false- если приложение ещё не создано */

   /**** Метод проверки существования приложения */
   macro CheckApplication() : bool
         var stat   :bool = false;
         var Visible:bool = false;

         // Проверим тип объекта, если не ноль, то скорее всего объект существует
         if( ValType(this.Application) )
             stat = true;
         end;

         // Если объект не ноль (проверили в предыдущем условии), то не факт, 
         // что объект существует, поробуем постучаться к любому его св-ву, например к Visible
         if( stat )
             Visible = this.Application.Visible;
         end;
         return stat;

         OnError( Err )
            return false;
   end;

   /**** Метод для создания приложения Excel
         Если в конструктор объекта передали флаг запуска приложения m_RegimNewApp, то используем его,
         если не передали, то по умолчанию, false, т.е. грузить новое приложение            */
   macro CreateApplication( NameApplication:string ) : bool
       var axServer:object = NULL;
       var Regim   :bool   = false; // Запускать новое приложение, true - использовать уже запущенное
       var RetVal;

       if( NOT this.CheckApplication() ) // Проверяем приложение на существование

           if( ValType(m_RegimNewApp) )
               Regim = (NOT m_RegimNewApp);
           end;

           // Запускаем в локали
           if( isStandalone() )
               this.Application = ActiveX(NameApplication, NULL, Regim);
           // Запускаем в 3-х звенке
           else
               if( (axServer = CreateObject("rsax", "TRsAxServer", "RsAxServer", isStandalone())) )
                   this.Application = axServer.CreateComObject(NameApplication, Regim);
               end;
           end;
       end;
       return true;

       OnError( ObjError )
          MsgBox("Для получения отчета в формате "+ NameApplication +"|необходимо установить соответствующее приложение! " );
          return FALSE;

   end; /* CreateApplication */

   /**** Загрузить соответсвующее приложение */
   macro vrt_CreateApplicationExcel()
         return CreateApplication( "Excel.Application" );
   end;
   macro vrt_CreateApplicationWord()
         return CreateApplication( "Word.Application" );
   end;
   macro vrt_CreateApplicationIE()
         return CreateApplication( "InternetExplorer.Application" );
   end;

   /* Метод записывает изменения в файле */
   macro Check_SaveAs( FileName:string ) : bool

      var Flag_Delete:bool = TRUE;

      if( OR_ExistFile(FileName) )
          if( FLAG_ASK_DELETEFILE )
              Flag_Delete = GetTRUE(TRUE, "Файл <"+ FileName+ ">\n уже существует в данном месте! Заменить?")
          end;
          if( Flag_Delete )
              if( NOT OR_DeleteFile(FileName) )
                  // Не смогли удалить прибавляем к имени файла уникальный префикс
                  FileName = GetUniqAdd( FileName );
                  SetParm(1, FileName);
              end;
          else
              return FALSE;
          end;
      end;
      return true;
   end;

   /**** Метод просмотра открытого документа
         Если передан FlagShow, то используем его: true-показать, false-скрыть;
         иначе считаем, что true, т.е. показать */
   macro Show( FlagShow:bool )
      if( ValType(this.Application) )
          if( ValType(FlagShow) )
              this.Application.visible = FlagShow;
          else
              this.Application.visible = TRUE;
          end;
          if(this.Application.visible == true)
              Application.UserControl =  true; // чтобы при закрытии документа приложение не закрывалось 
          end;  
      end;
      OnError( Err )
         return false;
   end; /* Show */

end;

/* Класс для работы с файлами Excel */
class (CDAOMS_Base) CDAOMSExcel( FileName     :string,   // Имя открываемого файла
                                 _RegimNewApp_:bool    ) // Режим создания приложения, true  - новое приложение, 
                                                         //                            false - используем существующее
   // Конструктор базового объекта
   InitCDAOMS_Base( _RegimNewApp_ );
                                           
   //****** Public. Публичные члены класса
   var Book       :object = NULL;         // Объект Excel - "Книга"
   var Sheet      :object = NULL;         // Объект Excel - "Лист"
   var Range      :object = NULL;         // Объект Excel - "Диапазон ячеек"
   var Chart      :object = NULL;         // Объект Excel - "Мастер диаграмм"

   var ExcelLanguageInterface:integer = EXCEL_INTERFACE_RUS; // Язык интерфейса MS Excel
   private var  Save_DisplayAlerts = NULL;
   /* Список методов:
        Destructor            - Деструктор класса;
        Create                - Создание новой книги и получение основных ссылок для членов класса;
        Open                  - Открытие новой книги на основе сохраненного файла;
        Close                 - Закрытие книги;
        Show                  - Показ Excel;
        Delete                - Удаление листа;
        GetValue              - Получение строки из ячейки;
        GetVariant            - Получение форматированного значения из ячейки;
        ColWidth              - Установка, получение ширины столбца;
        Merge                 - Объединение ячеек;
        RowHeight             - Установка высоты ячейки;
        Save                  - Запись текущей книги в файл;
        SaveAs                - Запись текущей книги в новый файл;
        SetAlign              - Установка выранивания для ячеек;
        SetBkColor            - Установка цвета фона ячеек;
        SetSheetColor         - Устанавливает цвет ярлычка листа (вкладки)
        SetFrColor            - Установка цвета символов ячеек;
        SetFont               - Установка шрифта ячеек;
        SetDiapazon           - Установка диапазона ячеек;
        SetValue              - Устанвка форматированного значения;
        SheetCount            - Получение количества листов;
        SheetAdd              - Добавление листа;
        SheetChange           - Установка активного листа;
        SheetClear            - Очистка текущего листа;
        SheetDelete           - Удаление листа;
        SheetName             - Установка, получение имени листа;
        WrapText              - Установка свойства Wrap для ячеек;
        SetBorder             - Установка обрамления для ячеек;
        ChartAdd              - Добавление листа диаграмм;
        SetChartData          - Установка источника данных для диаграмм;
        SetChartLegend        - Установка наличия легенды;
        SetChartTitle         - Установка заголовка диаграммы;
        SetChartAxesTitle     - Установка заголовков осей диаграммы;
        SetChartLegendItemName- Установка значений элементов легенды;
        ChartName             - Установка, получение наименования листа диаграмм;
        ChartWizard           - Быстрое формирование диаграммы;
        ChartObjMove          - Перемещение по листу диаграммы расположенной на листе;
        ChartObjResize        - Изменение размеров диаграммы расположенной на листе;
        GetStandartSize       - Получение стандартных размеров;
        SetFixedRow           - Установка строк, которые будут выводится на каждой странице отчета при печати на принтере;
        SetPrintOrder         - Установка направления вывода страниц на печать (вниз-вправо или вправо-вниз)
        SetGrid               - Установка, снятие разделительной сетки на текущем листе 
        SetZoom               - Установка масштаба отображения в окне и при печати
        GetExcelLanguage      - Определения языка в Excel
        SetMarginText         - Работа с колантитулами
        SetMarginSizeVert
        SetMarginSizeHor
        SetMarginSize
*/


   /* Конструктор */
   if( ValType(FileName) )
       this.Open( FileName );
   end;

   macro CreateApplication( NameApplication:string ) : bool
         var RetValue:bool = vrt_CreateApplicationExcel(); // Вызовем метод базовго объекта

         if( RetValue )
             /* Установка формата представления дат и времени */
             if ( ExcelLanguage == LANGUAGE_ENG )
                  DateFormat = "DD" + GetLocaleDateSeparator() + "MM" + GetLocaleDateSeparator() + "YY"; /* Формат представления дат для английского MSOffice */          
                  TimeFormat = "h"  + GetLocaleTimeSeparator() + "mm" + GetLocaleTimeSeparator() + "ss"; /* Формат представления времени для английского MSOffice */                   

             elif(ExcelLanguage == LANGUAGE_RUS)
                  DateFormat = "ДД" + GetLocaleDateSeparator() + "ММ" + GetLocaleDateSeparator() + "ГГ"; /* Формат представления дат для русского MSOffice */          
                  TimeFormat = "ч"  + GetLocaleTimeSeparator() + "мм" + GetLocaleTimeSeparator() + "сс"; /* Формат представления времени для русского MSOffice */                   
             else 
                  DateFormat = GetLocaleDateFormat();
                  TimeFormat = GetLocaleTimeFormat();
             end;

             // Определим язык интерфейса
             this.ExcelLanguageInterface = Application.LanguageSettings.LanguageID(msoLanguageIDUI);
         end;

         return RetValue;
   end;

   /* Деструктор */
   Macro Destructor()
   
      if( this != NULL )
          if((this.Application != NULL) and (NOT this.Application.Visible) )
              this.Application.DisplayAlerts = false;
              if( this.Application.Workbooks.Count AND Valtype(Book) )
                  this.Book   .Close(FALSE);
              end;
              this.Application.Quit;

              this.Book        = NULL;
              this.Application = NULL;
          else
              if(ValType(Save_DisplayAlerts))
                  Application.DisplayAlerts = Save_DisplayAlerts;
              end;
          end;
      end;
      OnError( Err )
         return FALSE;

   End; /* Destructor */

   /* Метод создает новую книгу, в случае успеха возвращает TRUE, иначе FALSE */
   macro Create() : bool

      /* Если язык в Excel изначально не установлен, определим его */
      if( ExcelLanguage == LANGUAGE_AUTO )
          ExcelLanguage = this.GetExcelLanguage();
      end;

      if( NOT this.vrt_CreateApplicationExcel() )
          return false; 
      end;
      this.Application.Workbooks.Add();
      this.Book  = this.Application.Workbooks.Item(this.Application.Workbooks.Count);
      this.Sheet = this.Book.Sheets(1);

      return true;
      OnError( Err )
         ErrorMessage(Err,"Ошибка создания новой книги"); 
         return FALSE;

   end; /* Create */

   macro Show( FlagShow:bool )

      this.Show( FlagShow ); // Вызовем метод базового класса

      if( this != NULL )
          if( (Application) AND (Application.visible == true) )
              Application.UserControl = true; // чтобы при закрытии документа приложение не закрывалось 
          end;
      end;  

      OnError( Err )
         return false;
   end; /* Show */

   /* Метод открывает файл с именем FileName, в случае успеха возвращает TRUE, иначе FALSE */
   macro Open( FileName:string ):bool

      if( OR_ExistFile(FileName) )

          if( NOT this.vrt_CreateApplicationExcel() )
              return FALSE; 
          end;
          Save_DisplayAlerts  = Application.DisplayAlerts;
          Application.DisplayAlerts = false;

          this.Book = this.Application.Workbooks.Open(FileName);

          if( NOT this.Book )
              this.Destructor();
              return FALSE;
          end;

          this.Sheet= this.Book.Sheets(1);
          return TRUE;
      else
          MsgBox("Не найден файл \"" + FileName + "\"");
          return FALSE;
      end;

      OnError( Err )
         ErrorMessage(Err,"Ошибка открытия файла \"" + FileName + "\"");
         this.Destructor();
         return FALSE;

   end; /* Open */


   /* Метод открывает CSV файл с именем FileName                                   */
   /* (текстовый файл с данными, которые разделены разделителем, по умолчанию ";") */
   macro OpenTxt( FileName       :string , // Имя CSV файла
                  SymbolDelimiter:string , // Символ разделитель десятичных
                  Coding         :integer, // Кодировка
                  lsFormat:tarray ):bool   // Массив форматов

      var FindFileName:string = FileName;
      var lsFormatTable:tarray = Tarray(); // Массив форматов
      var lsCol        :tarray = Tarray(); // Формат колонки
      var i            :integer = 0;

      // Получим массив двузэлементников
      lsFormatTable.CvtToSafeArray = true; // Для передачи в COM-объект tarray-я как Array - VBA!!!
      while( i < lsFormat.Size )
         lsCol = Tarray(2, 1);
         lsCol.CvtToSafeArray = true; // Для передачи в COM-объект tarray-я как Array - VBA!!!
         lsCol[0] = i;
         if( lsFormat[i] == "@" )   lsCol[1] = 2; // Текстовый формат
         else                       lsCol[1] = 1; // Стандартное форматирование (Общий формат)
         end;
         lsFormatTable[lsFormatTable.size] = lsCol;
         i = i + 1;
      end;

      // Если запуск производится в 3-х звенке, то нужно при поиске добавлять "$"
      if( NOT isStandalone() )
          FindFileName = "$"+ FileName;
      end;

      if( ExistFile(toANSI(FindFileName)) )
          if( NOT this.vrt_CreateApplicationExcel() )
              return FALSE; 
          end;

          if( NOT SymbolDelimiter )
              SymbolDelimiter = ";";
          end;

          if( NOT Coding )
              Coding = WR_lsEncode[WR_CURRENCODE].csvCoding;
          end;

          this.Application.Workbooks.OpenText(
                           FileName,       // Filename As String
                           Coding,            // [Origin] Кодировка (формат файла)
                           1,              // [StartRow]
                           xlDelimited,    // [DataType]
                           xlDoubleQuote,  // TextQualifier
                           false,          // [ConsecutiveDelimiter]

                           // Разделители данных
                           false,           // [Tab]
                           false,           // [Semicolon]
                           false,           // [Comma]
                           false,           // [Space]
                           true,            // [Other]
                           SymbolDelimiter, // [OtherChar]  ","
                           // END Разделители данных

                           lsFormatTable,              // [FieldInfo]           Описатель колонок
                           xlTextVisualLTR, // [TextVisualLayout]
                           GetLocaleInfo(0,LOCALE_SDECIMAL,(NOT IsStandAlone())),             // [DecimalSeparator]     разделитель десятичных
                           " "/*,             // [ThousandsSeparator]   разделитель тысяч
                           true  */    );     // [TrailingMinusNumbers] Минус в конце значения
          return TRUE;
      else
          MsgBox("Не найден файл \"" + FileName + "\"");
          return false;
      end;

      OnError( ObjectErr )
         ErrorMessage(ObjectErr, "[CDAOMSExcel.OpenTxt] Ошибка!");
         return false;
   end;


   /* Метод закрытия текущей книги */
   Macro Close()

      this.Book.Close(FALSE);
      OnError( Err )
         return FALSE;

   End; /* Close */

   /* Метод удаляет лист с индексом Index, индексация начинается с 1 */
   Macro Delete( Index:integer )

      if( Index <= this.SheetCount() )
          this.Sheet = this.Book.Sheets.Item(Index).Delete;
          if( Index != 1 )
              this.SheetChange(Index-1); 
          end;
      else
          MsgBox("Лист с номером " + String(Index) + " не существует!");
      end;

   End; /* Delete */

   /* Метод возвращает (V_STRING) значение ячейки. Координаты могут быть заданы индексами (2, 0), или названиями "В3" */
   Macro GetValue()

      var Coord; /* Строка с координатами */
      var Row;   /* Номер строки */ 
      var Col;   /* Номер столбца */

      GetParm(1, Coord);
      GetParm(2, Col  );
      if( NOT ValType(Col) )
          return Sheet.Range(Coord).text;
      else
          Row = Coord;
          if( ValType(Row) == V_INTEGER )  return Sheet.Range(_SplitCoord( Row, Col )).text;
          else                             return Sheet.Range( Row + Col             ).text;
          end;
      end;

   End; /* GetValue */

   /* Метод возвращает форматрованное(при возможности) значение ячейки или текст ячейки. Координаты могут быть заданы индексами (2, 0), или названиями "В3" */
   Macro GetVariant():variant

      var Coord;                 /* Строка с координатами */
      var Row   :variant = 0;    /* Номер строки */         
      var Col   :variant ;    /* Номер столбца */        
      var _Range:object  = NULL; /* Объект Excel - диапазон */
      var Value :variant;        /* Возвращаемое значение */

      GetParm(1, Coord);
      GetParm(2, Col  );
      if( ValType(Col) )
           Row = Coord;
           if(ValType(Row) == V_INTEGER)
                Coord = _SplitCoord(Row,Col);
           else Coord = Row + Col;
           end;
      end;
      _Range = this.Sheet.Range(Coord);
      Value = _Range.value;
      if((_Range.NumberFormat=="0")AND(_Range.NumberFormatLocal=="0"))
           return Int(value);
      end;
      if((_Range.NumberFormat==DoubleFormat)AND(_Range.NumberFormatLocal==DoubleFormat))
           return Double(value);
      end;
      if(_Range.NumberFormat=="@")
           if(ValType(Value))
                Value = String(Value);
           else Value = "";
           end;
      end;
      /* Проверяем на дату (только так, и никак больше) */
      if(((_Range.NumberFormat == DateFormat )OR (_Range.NumberFormat == DateFormat)) AND (NOT ValType(Value)))
           Value = date(0,0,0);
      end;
      return value;

   End; /* GetVariant */

   /* Метод возвращает/устанавливает (V_INTEGER) ширину колонки, колонка может быть задана индексом, или названием "В" */
   Macro ColWidth():integer

      var Col;   /* Номер колонки */
      var Width; /* Ширина колонки */

      GetParm(1, Col);
      GetParm(2, Width);
      if(NOT ValType(Width))
           if(ValType(Col) == V_INTEGER)
                return Int(this.Sheet.Range(_Col(Col)+"1").ColumnWidth);
           else return Int(this.Sheet.Range( Col  +   "1").ColumnWidth);
           end;
      else if(ValType(Col) == V_INTEGER)
                this.Sheet.Range(_Col(Col)+"1").ColumnWidth = Double(Width);
           else this.Sheet.Range( Col + "1"   ).ColumnWidth = Double(Width);
           end;
           return 1;
      end;

   End; /* ColWidth */

   /* Метод слияния ячеек диапазона */
   Macro Merge():bool

      this.Range.Merge;
      Return True;
      OnError(Err)
         ErrorMessage(Err,"Объединение ячеек невозможно!");
         Return False;
  
   End; /* Merge */

   /* Метод устанавливает высоту ячейки */
   Macro RowHeight(Row:integer, Height:integer)

      this.Sheet.Range("A"+String(Row+1)).RowHeight = Double(Height);

   End; /* RowHeight */

   /* Метод записывает изменения в файле */
   Macro Save()

      this.Book.Save();
      OnError(Err)
         ErrorMessage(Err,"Неверное имя файла!");         
   End; /* Save */

   /* Метод записывает изменения в файле( для .htm, MSOFFICE >= 2007) */
   Macro Publish(FileName:string)

      var obj = Book.PublishObjects.Add(1,FileName, Book.Sheets(1).Name,"",0).Publish(true);
      OnError(err)  
          ErrorMessage(Err,"Ошибка сохранения в .htm! ");
   end;
   /* Метод записывает изменения*/
   Macro SaveAs(FileName:string, FileFormat:integer)

      var Flag_Delete:bool = Check_SaveAs( @FileName );

      if( NOT Flag_Delete )
          return false;
      end;

      if( Not ValType(FileFormat) )
           this.Book.SaveAs(FileName);
      else this.Book.SaveAs(FileName, FileFormat);
      end;

      return true;

      OnError(ObjErr)
          ErrorMessage(ObjErr, "[CDAOMSExcel.SaveAs] Ошибка!");
          return false;
   End; /* SaveAs */

   /* Метод устанавливает тип горизонтального выравнивания */
   Macro SetAlign()

      var Row;       /* Номер строки */
      var Col;       /* Номер столбца */
      var Alignment; /* Тип выравнивания */

      GetParm(2,Col);
      if(ValType(Col))
           /* Метод устанавливает горизонтальное выравнивание в ячеке Row, Col */
           GetParm(1,Row);
           GetParm(3,Alignment);
           this.Range = this.Sheet.Range(_SplitCoord(Row,Col));
           if(Index(this.Range.MergeArea.Address,":"))
                this.SetDiapazon(this.Range.MergeArea.Address);
           end;
      else /* Метод устанавливает горизонтальное выравнивание в диапазоне ячеек, устанавливаемом методом SetDiapazon */
           GetParm(1, Alignment);
      end;
      if((Alignment == ALIGN_LEFT)or(Alignment == ALIGN_CENTER)or(Alignment == ALIGN_RIGHT))
           this.Range.HorizontalAlignment = Alignment;
      end;
     
   End; /* SetAlign */

   /* Метод устанавливает цвет ярлычка листа (вкладки) */
   macro SetSheetColor( ColorIndex:integer )
         Sheet.Tab.ColorIndex = ColorIndex;
         OnError( Err )
          ; // В 2000-м офисе нет такого св-ва(подсветки вкладок)!!!

   end;

   /* Метод устанавливает цвет фона */
   Macro SetBkColor()

      var Row;                  /* Номер строки */
      var Col;                  /* Номер столбца */
      var Color;                /* Цвет фона диапазона ячеек */
      var _Range:object = NULL; /* Объект Excel - диапазон ячеек */

      GetParm(2,Col);
      if(ValType(Col))
           /* Метод устанвливает цвет фона в ячейке Row, Col */
           GetParm(1,Row);
           GetParm(3,Color);
           _Range = this.Sheet.Range(_SplitCoord(Row,Col));
      else /* Метод устанавливает цвет фона в диапазоне ячеек, устанавливаемом методом SetDiapazon */
           GetParm(1,Color);
           _Range = this.Range
      end;
      _Range.Interior.Color = Color;

   End; /* SetBkColor */

   /* Метод устанавливает цвет символов */
   Macro SetFrColor()

      var Color;                /* Цвет символов диапазона ячеек */
      var Row;                  /* Номер строки */
      var Col;                  /* Номер столбца */
      var _Range:object = NULL; /* Объект Excel - диапазон ячеек */

      GetParm(2,Col);
      if(ValType(Col))
           /* Метод устанвливает цвет символов в ячейке Row, Col */
           GetParm(1,Row);
           GetParm(3,Color);
           _Range = this.Sheet.Range(_SplitCoord(Row,Col));
      else /* Метод устанавливает цвет символов в диапазоне ячеек, устанавливаемом методом SetDiapazon */
           GetParm(1,Color);
           _Range = this.Range
      end;
      _Range.Font.Color = Color;

   End; /* SetBkColor */

   /* Метод устанавливает шрифт в диапазоне ячеек, устанавленном методом SetDiapazon */
   Macro SetFont(ObjFontProp_or_Name, Size:integer, Bold:bool, Italic:bool, UnderLine:integer, FrColor:integer, BkColor:integer)

      /*
      Форматы вызова: 
      "Установка параметров шрифта для диапазона заданного последним вызовом SetDiapazon с помощью
       набора параметров, при этом "пустое" значение любого параметра не устанавливается"
         SetFont(Name, Size, Bold, Italic, UnderLine);
      "Установка параметров шрифта для диапазона заданного последним вызовом SetDiapazon с помощью"
       объекта типа CFontProp" 
         SetFont(ObjFontProp);
      */

      var Font     = this.Range.Font;     /* Объект типа Font */
      var Interior = this.Range.Interior; /* Объект типа Interior (фон) */

      if(ValType(ObjFontProp_or_Name) == V_GENOBJ)
           if(ObjFontProp_or_Name.Name)
                Font.Name = ObjFontProp_or_Name.Name;
           end;
           if(ObjFontProp_or_Name.Size)
                Font.Size = ObjFontProp_or_Name.Size;  
           end;
           Font.Bold      = ObjFontProp_or_Name.Bold;  
           Font.Italic    = ObjFontProp_or_Name.Italic;
           Font.UnderLine = ObjFontProp_or_Name.UnderLine;
           Font.Color     = ObjFontProp_or_Name.FrColor;
           Interior.Color = ObjFontProp_or_Name.BkColor;
      else if(ObjFontProp_or_Name)
                Font.Name = ObjFontProp_or_Name;
           end;
           if(Size)
                Font.Size = Size;  
           end;
           if(ValType(Bold) != V_UNDEF)
                Font.Bold = Bold;  
           end;
           if(ValType(Italic) != V_UNDEF) 
                Font.Italic = Italic;
           end;
           if(ValType(UnderLine) != V_UNDEF) 
                Font.UnderLine = UnderLine;
           end;
           if(ValType(FrColor) != V_UNDEF) 
                Font.Color = FrColor;
           end;
           if(ValType(BkColor) != V_UNDEF) 
                Interior.Color = BkColor;
           end;
      end;

   End; /* SetFont */

   /* Метод устанавливает диапазон ячеек */
   Macro SetDiapazon()

      var Row_TopLeft;          /* Номер строки верхнего левого угла диапазона */
      var Col_TopLeft;          /* Номер столбца верхнего левого угла диапазона */
      var Row_BottomRight;      /* Номер строки нижнего правого угла диапазона */
      var Col_BottomRight;      /* Номер столбца нижнего правого угла диапазона */
      var Diapazon:string = ""; /* Строка диапазона */

      GetParm(1,Row_TopLeft);
      GetParm(2,Col_TopLeft);
      GetParm(3,Row_BottomRight);
      GetParm(4,Col_BottomRight);
      if(ValType(Col_BottomRight))
           Diapazon = _SplitCoord(Row_TopLeft,Col_TopLeft) + ":" + _SplitCoord(Row_BottomRight,Col_BottomRight);
      else /* Если диапазон задается строкой, например "A1:C7" */
           GetParm(1, Diapazon);
      end;
      this.Range = this.Sheet.Range(Diapazon);
      return True;
      OnError(ObjError)
         ErrorMessage(ObjError,"Ошибка выделения диапазона - ", Diapazon);  
         Return False;

   End; /* SetDiapazon */

   /* Метод для выполнения некоторой макрофункции спецформатирования описанной в отдельном макрофайле. 
      При работе в трехзвенке такая макрофункция присылается на терминал в специальном макрофайле */
   Macro ExecuteMacro(MacroFileName:string, Proc:string, Prm:string)
    
      var ExecString:string = ""; /* Строка для исполнения с помощью функции ExecExp */
      var RunMacro  :string = ""; /* Имя, запускаемого с помощью функции ExecMacroFile, макрофайла */
      var flagScreenUpdating:bool = false;

      if( this.CheckApplication() )

          flagScreenUpdating = this.Application.ScreenUpdating;

          /* Если имя макрофайла не задано, сразу сваливаем */
          if(Not StrLen(MacroFileName))
               return;
          end;
          /* Формируем строку для функции ExecMacroFile, для дальнейшего скармливания функции ExecExp */
          RunMacro = "ExecMacroFile";
          if(StrLen(Proc))
               if((ValType(Prm) != V_UNDEF)and(StrLen(Prm)))
                    ExecString = RunMacro + "(\"" + MacroFileName + "\",\"" + Proc + "\"," + Prm + ");";
               else ExecString = RunMacro + "(\"" + MacroFileName + "\",\"" + Proc + "\");";
               end;
          else ExecString = RunMacro + "(\"" + MacroFileName + "\");";
          end;
          /* Вынесем ссылки на основные данные в глобализм, для возможности использования
             их макрофункцией спецформатирования, это позволит ей скомпилится и выполнится */
          iBook        = this.Book;        /* Объект Excel - "Книга" */
          iApplication = this.Application; /* Объект Excel - "Приложение" */
          iSheet       = this.Sheet;       /* Объект Excel - "Лист" */
          iRange       = this.Range;       /* Объект Excel - "Диапазон ячеек" */
          iChart       = this.Chart;       /* Объект Excel - "Мастер диаграмм" */


          /* Выполняем переданную функцию спецформатирования */
          this.Application.ScreenUpdating = FALSE;
          this.Application.StatusBar = "Обработка отчета...";
             ExecExp(ExecString);
          this.Application.StatusBar = "";
          this.Application.ScreenUpdating = flagScreenUpdating;
      end;

      OnError( err )
          this.Application.ScreenUpdating = flagScreenUpdating;
          this.Application.StatusBar = "";
          ErrorMessage(err,"Ошибка постобработки!");
   End; /* ExecuteMacro */
   
   /* Метод для выполнения некоторых макрокоманд спецформатирования. */
   /* Такие команды создаются в специальном массиве строк строке     */
   Macro ExecStr( lsStr:tarray )
      var i:integer = 0;
      var flagScreenUpdating:bool = false;
      var Step    :integer = 0;
      var SizeStep:double  = 0.;

      if( this.CheckApplication() )

          flagScreenUpdating = this.Application.ScreenUpdating;

          /* Вынесем ссылки на основные данные в глобализм, для возможности использования
             их макрофункцией спецформатирования, это позволит ей скомпилится и выполнится */
          iBook        = this.Book;        /* Объект Excel - "Книга" */
          iApplication = this.Application; /* Объект Excel - "Приложение" */
          iSheet       = this.Sheet;       /* Объект Excel - "Лист" */
          iRange       = this.Range;       /* Объект Excel - "Диапазон ячеек" */
          iChart       = this.Chart;       /* Объект Excel - "Мастер диаграмм" */

          this.Application.ScreenUpdating = FALSE;
          this.Application.DisplayStatusBar = TRUE;

          if( lsStr.Size ) 
              InitProgress(lsStr.Size, " Обработка отчета...", "Обработка отчета...");

              /* Т.к. на терминале RSL-ый индикатор не работает,       */
              /* то в статус строке Excel-а выведем сообщение о работе */
              SizeStep = Double(lsStr.Size)/100.;

              this.Application.StatusBar = "Обработка отчета [" + Step + "%]";
          end;

          /* Выполняем все переданные строки */
          while( i < lsStr.Size )

               if( i > Step*SizeStep )
                   this.Application.StatusBar = "Обработка отчета [" + Step + "%]";
                   Step = Step + 1;
               end;
               UseProgress(i);

               if( StrLen(lsStr[i]) )
                   ExecExp(lsStr[i]);
               end;
               i = i + 1;
          end;

          if( lsStr.Size )  RemProgress();  end;

          this.Application.ScreenUpdating = flagScreenUpdating;
          this.Application.StatusBar = "";
      end;

      OnError( err )
         this.Application.ScreenUpdating = flagScreenUpdating;
         this.Application.StatusBar      = "";
         if( lsStr.Size )  RemProgress();  end;
         ErrorMessage(err,"Ошибка постобаботки!");
   End; /* ExecStr */


   /* Возвращает наименование месяца в родительном падеже по его номеру */
   Macro MonNameR(_NumbMon:integer)

     var RetValue:string = ""; /* Возвращаемое значение */

     if( (_NumbMon > 0) and (_NumbMon < 13) )
          if( (_NumbMon == 3) or (_NumbMon == 8) )
              RetValue = SubStr(MonName(_NumbMon), 1, StrLen(MonName(_NumbMon))) + "а";
          else
              RetValue = SubStr(MonName(_NumbMon), 1, StrLen(MonName(_NumbMon)) - 1) + "я";
          end;
     end;
     return StrLwr(RetValue);

   End; /* MonNameR */

   Macro MakeDateStr(_Date:date, _StrSep:string, _FlagTrimZero:bool, _FlagMonName:bool, _CountCharInYear:integer)

     var StrSep  :string  = "-"; /* Разделитель. По умолчанию "-" */
     var StrZeroD:string  = "0"; /* Строка для дней, зависящая от флага отсечения незначащих нулей. По умолчанию "0" */
     var StrZeroM:string  = "0"; /* Строка для месяцев, зависящая от флага отсечения незначащих нулей и 
                                    флага вывода месяца в виде слова. По умолчанию "0" */
     var StrMon  :string  = "";  /* Строка, зависящая от флага вывода месяца в виде слова */
     var StrYear :string  = "";  /* Строка с годом, содержащая заданное число символов */ 
     var CurDay  :integer = 0;   /* День переданной даты */
     var CurMon  :integer = 0;   /* Месяц переданной даты */
     var CurYear :integer = 0;   /* Год переданной даты */
     var RetValue:string  = "";  /* Возвращаемое значение */

     if( ValType(_Date) == V_DATE )
         if( _Date != Date(0, 0, 0) )
             DateSplit(_Date, CurDay, CurMon, CurYear);
             if( ValType(_StrSep) )
                 StrSep = _StrSep;
             end;

             if( ValType(_FlagTrimZero) )
                 if( _FlagTrimZero )
                      StrZeroD = "";
                      StrZeroM = "";
                 end;
             end;

             StrMon = string(CurMon);
             if( ValType(_FlagMonName) )
                 if( _FlagMonName );
                     StrMon = MonNameR(CurMon);
                     StrZeroM = "";
                 end;
             end;

             StrYear = StrSep + String(CurYear);
             if( ValType(_CountCharInYear) )
                 if( (_CountCharInYear > 0)and(_CountCharInYear < 4) )
                     StrYear = StrSep + SubStr(StrYear, (5 - _CountCharInYear));
                 else
                     StrYear = "";
                 end;
             end;

             if( CurMon < 10 )
                 if(CurDay < 10)
                      RetValue = StrZeroD + string(CurDay) + StrSep + StrZeroM + StrMon + StrYear;
                 else RetValue = string(CurDay) + StrSep + StrZeroM + StrMon + StrYear;
                 end;
             else 
                 if( CurDay < 10 )
                      RetValue = StrZeroD + string(CurDay) +  StrSep + StrMon + StrYear;
                 else RetValue = string(CurDay) + StrSep + StrMon + StrYear;
                 end;
             end;
         end;       
     end;
     return RetValue;

   End; /* MakeDateStr */

   /* Метод заносит Value в ячейки. Координаты могут быть заданы индексами (2, 0), или названими "В3"*/
   Macro SetValue()

      var Coord;         /* Строка с координатами */
      var Row;           /* Номер строки */         
      var Col;           /* Номер столбца */        
      var Value:variant; /* Присваиваемое значение */

      GetParm(3,Value);
      if(ValType(Value))
           GetParm(1,Row);
           GetParm(2,Col);
           if(ValType(Row) == V_INTEGER)
                Coord = _SplitCoord(Row,Col);
           else Coord = Row + Col;
           end;
      else GetParm(1,Coord);
           GetParm(2,Value);
      end;
      if(ValType(Value) == V_STRING)
           if(StrLen(Value) < 255)
                this.Sheet.Range(Coord).NumberFormat      = "@";
                this.Sheet.Range(Coord).NumberFormatLocal = "@";
           end;
      elif(ValType(Value) == V_INTEGER )
           this.Sheet.Range(Coord).NumberFormat      = 0;
           this.Sheet.Range(Coord).NumberFormatLocal = 0;
      elif(ValType(Value) == V_DOUBLE )
           this.Sheet.Range(Coord).NumberFormat      = DoubleFormat;
           this.Sheet.Range(Coord).NumberFormatLocal = DoubleFormat;
      elif((ValType(Value) == V_MONEY)or(ValType(Value) == V_MONEYL))
/* !!! Антон А. Бурцев: Деньги не присваиваются с RSScript от 14.01.02
                        поэтому через дабл пока... */
Value = CorrectMoney(Value);
/* !!! */
           this.Sheet.Range(Coord).NumberFormat      = DoubleFormat;
           this.Sheet.Range(Coord).NumberFormatLocal = DoubleFormat;
      elif(ValType(Value) == V_DATE)
/*
           this.Sheet.Range(Coord).NumberFormat      = DateFormat;
           this.Sheet.Range(Coord).NumberFormatLocal = DateFormat;
*/
/* !!! Антон А. Бурцев: Выводим дату в виде строки. Потому что не работает определение
                        региональных настроек (не учитывается язык) */
Value = this.MakeDateStr(Value, ".");
this.Sheet.Range(Coord).NumberFormat      = "@";
this.Sheet.Range(Coord).NumberFormatLocal = "@";
/* !!! */
      elif(ValType(Value) == V_TIME)
           this.Sheet.Range(Coord).NumberFormat      = TimeFormat;
           this.Sheet.Range(Coord).NumberFormatLocal = TimeFormat;
           /* Для времени значение из RSL напрямую подбросить не удается из-за сотых долей секунды */
           this.Sheet.Range(Coord).Value             = String(Value);
           this.Sheet.Range(Coord).VerticalAlignment = -4108;
           return;
      end;
      this.Sheet.Range(Coord).Value             = Value;
      this.Sheet.Range(Coord).VerticalAlignment = -4108;

   End; /* SetValue */

   /* Метод возвращает количество листов в текущей книге */
   Macro SheetCount()

      return this.Book.Sheets.Count();

   End; /* SheetCount */

   /* Метод добавляет новый лист в конец списка */
   Macro SheetAdd( SheetIndex:integer ) // SheetIndex - Номер листа за которым добавлять, если не задан, то в конец списка

      var Count:INTEGER = 0; /* Количество листов */

      if( SheetIndex )
          Count = SheetIndex;
      else
          Count = this.SheetCount(); /* Количество листов */
      end;

      this.Sheet = this.Book.Sheets.Add(this.Book.Sheets(Count));
      this.Book.Sheets(Count + 1).Move( this.Sheet );

   End; /* SheetAdd */

   /* Метод устанавливает текущим лист с индексом(наименованием) _Sheet, индексация начинается с 1 */
   Macro SheetChange(_Sheet:variant, _FlagNoMessage:bool)

      var FlagNoMessage:bool = False; /* Флаг отмены выдачи аварийных сообщений, по умолчанию сообщения есть */

      if(ValType(_FlagNoMessage) == V_BOOL)
           FlagNoMessage = _FlagNoMessage;
      end;

      if(ValType(_Sheet) == V_STRING)
           this.Sheet = this.Book.Sheets(_Sheet);
      else if(_Sheet <= this.SheetCount())
                this.Sheet = this.Book.Sheets.Item(_Sheet);
           else if(Not FlagNoMessage)
                     MsgBox("Лист с номером " + String(_Sheet) + " не существует!");
                end;
                return False;
           end;
      end;
      
      if(int(this.Application.version) < MS_2013)
           this.Sheet.Activate();
      end;  
   
      return True;

      OnError( ObjErr )
         if( Not FlagNoMessage )
             if( ValType(_Sheet) == V_STRING )
                 MsgBox("Лист с именем <" + String(_Sheet) + "> не существует!");
             else
                 MsgBox("Лист с номером " + String(_Sheet) + " не существует!");
             end;
         end;
         return false;

   End; /* SheetChange */

   /* Метод очищает лист с индексом _Index текущей книги */
   Macro SheetClear(_Index:integer)

      this.SheetChange(_Index);
      this.Sheet.ClearArrows();

   End; /* SheetClear */

   /* Метод удаляет лист с индексом _Index текущей книги */
   Macro SheetDelete(_Index:integer)

      if(this.SheetChange(_Index))
           this.Sheet.Delete();
           return True;
      else return False;
      end;

   End; /* SheetDelete */

   /* Метод возвращает/устанавливает (V_STRING) наименование листа */
   Macro SheetName()

      var Name;                   /* Наименование */
      var Count    :string  = ""; /* Количество листов или книг */
      var i        :integer = 1;  /* Счетчик циклов */
      var NumRepeat:integer = 1;  /* Номер дубликата */

      GetParm(1, Name);
      if(ValType(Name))
           if(NOT Name)
                return "";
           end;
           /* Проверим наименование на превышение длины в 31 символ */
           if(StrLen(String(Name)) > 31)
                Name = String(Name:28) + "...";
           end;
           /* Проверим наименование на наличие недопустимых символов ":", "\", "/", "?", "*", "[", "]" */
           if( StrBrk(Name, ":\\/?*[]") )
               Name = LocStrSubst(Name, ":", "-");
               Name = LocStrSubst(Name, "\\", "|");
               Name = LocStrSubst(Name, "/", "|");
               Name = LocStrSubst(Name, "?", "!");
               Name = LocStrSubst(Name, "*", "∙"); /* 249 - символ */
               Name = LocStrSubst(Name, "[", "{");
               Name = LocStrSubst(Name, "]", "}");
           end;
           /* Проверим на дублируемость с уже существующими листами */
           Count = this.SheetCount(); 
           while( i < Count )
                /* Если дубликат нашелся, начинаем все сначала и до победного конца */
                if( this.Book.Sheets.Item(i).Name == Name )
                    Name      = String(NumRepeat) + "~" + Name;
                    /* Проверим наименование на превышение длины в 31 символ */
                    if( StrLen(String(Name)) > 31 )
                        Name = String(Name:28) + "...";
                    end;
                    NumRepeat = NumRepeat + 1;
                    i         = 0;
                end;
                i = i + 1;
           end;
           /* Проверим на дублируемость с уже существующими книгами */
           Count = this.Application.Workbooks.Count; 
           i     = 1;
           while(i < Count)
                /* Если дубликат нашелся, начинаем все сначала и до победного конца */
                if(this.Application.Workbooks.Item(i).Name == Name)
                     Name      = String(NumRepeat) + "~" + Name;
                     /* Проверим наименование на превышение длины в 31 символ */
                     if(StrLen(String(Name)) > 31)
                          Name = String(Name:28) + "...";
                     end;
                     NumRepeat = NumRepeat + 1;
                     i         = 0;
                end;
                i = i + 1;
           end;
           /* Ура! Получили уникальное имя. Вот его и присвоим листу */
           this.Sheet.Name = Name;

      else return this.Sheet.Name;
      end;

   End; /* SheetName */

   /* Метод устанавливает свойство Wrap */ 
   Macro WrapText()

      var Row :integer = 0; /* Номер строки */
      var Col;              /* Номер столбца */
      var Wrap:bool;        /* Свойство Wrap */

      GetParm(2, Col);
      if(ValType(Col))
           GetParm(1,Row);
           GetParm(2,Wrap);
           this.Sheet.Range(_SplitCoord(Row,Col)).WrapText = Wrap;
      else GetParm(1, Wrap);
           this.Range.WrapText = Wrap;
      end;

   End; /* WrapText */

   /* Метод установки обрамления через объект класса CBorderProp */
   Macro SetBorderFromObject(ObjBorderProp)

      var Row;                                           /* Номер строки */
      var Col;                                           /* Номер столбца */
      var OldBorderWeight:integer = DefaultBorderWeight; /* Старое значение толщины обрамления */

      /* Проверим не передана ли нам определенная ячейка */
      GetParm(3,Col);
      if(ValType(Col))
           GetParm(4,Row);
           this.Range = this.Sheet.Range(_SplitCoord(Row,Col));
           if(Index(this.Range.MergeArea.Address,":"))
                this.SetDiapazon(this.Range.MergeArea.Address);
           end;
      end;
      DefaultBorderWeight = ObjBorderProp.Weight;
      this.SetBorder(ObjBorderProp.Left, ObjBorderProp.Top, ObjBorderProp.Bottom, ObjBorderProp.Right,
                     ObjBorderProp.InSideVertical, ObjBorderProp.InSideHorizont);
      DefaultBorderWeight = OldBorderWeight;
     
   End; /* SetBorderFromObject */

   /* Метод установки обрамления и разделителей для диапазона ячеек */
   Macro SetBorder()

      /*
      Форматы вызова: 
      "Установка полного внешнего обрамления и всех разделителей для диапазона заданного последним вызовом SetDiapazon"
         SetBorder();
      "Установка полного внешнего обрамления и всех разделителей для переданного диапазона"
         SetBorder(Diapazon); 
      "Установка внешнего обрамления с указанных сторон и всех разделителей для диапазона заданного последним вызовом SetDiapazon"
         SetBorder(Left, Top, Bottom, Right);
      "Установка внешнего обрамления с указанных сторон и всех разделителей для переданного диапазона"
         SetBorder(Diapazon, Left, Top, Bottom, Right);
      "Установка внешнего обрамления с указанных сторон и указанных разделителей для диапазона заданного последним вызовом SetDiapazon"
         SetBorder(Left, Top, Bottom, Right, InSideVertical, InSideHorizont);
      "Установка внешнего обрамления с указанных сторон и указанных разделителей для переданного диапазона"
         SetBorder(Diapazon, Left, Top, Bottom, Right, InSideVertical, InSideHorizont);
      */
      
      var Diapazon            = "";     /* Диапазон ячеек */
      var ArrSide    :TArray  = TArray; /* Массив сторон обрамления (Left, Top, Bottom,  Right, InSideVertical, InSideHorizont) */
      var j          :integer = 0;      /* Счетчик циклов */
      var OffSet     :integer = 0;      /* Смещение при обработки переданных параметров */
      var BegDiapazon:string  = "";     /* Значение начала диапазона для строки и столбца */
      var EndDiapazon:string  = "";     /* Значение конца диапазона для строки и столбца */
      
      /* Метод для определения значений начала и конца диапазона для строк и столбцов */
      Macro GetRangeParam(Num)
      
         var i       :integer = 0;  /* Счетчик циклов */
         var Pos     :integer = 0;  /* Переменная для определения позиции искомого символа */
         var RetValue:string  = ""; /* Возвращаемое значение */
         var TempStr :string  = ""; /* Временная строка для работы */
      
         if((Num < 1)or(Num > 4))
              Return "";
         end;
         /* Преобразуем строку диапазона.Добавляем в конец адреса значок $ и удаляем двоеточие */
         TempStr = SubStr(this.Range.Address,2) + "$";
         Pos     = Index(TempStr,":");
         TempStr = SubStr(TempStr,1,Pos - 1) + SubStr(TempStr,Pos + 1);
         while(i < Num)
              Pos      = Index(TempStr,"$");
              RetValue = SubStr(TempStr,1,Pos - 1);
              TempStr  = SubStr(TempStr,Pos + 1);
              i = i + 1;
         end;
         Return RetValue;
      
      End; /* GetRangeParam */
      
      GetParm(1, Diapazon);
      if((ValType(Diapazon) == V_STRING)and(Diapazon != ""))
           this.SetDiapazon(Diapazon);
           OffSet = 1;
      else OffSet = 0;
      end;
      if(NOT ValType(this.Range))
           MsgBox("Диапазон не задан или некорректен!");
           return False;
      end; 
      while(j < 6)
           if(Not GetParm(j + 1 + OffSet, ArrSide[j]))
                ArrSide[j] = BORDERLINE_SINGLE;
           end;
           j = j + 1;
      end;
      /* Устанавливаем требуемое внешнее обрамление */
      j = 0;
      while(j < 4)
           if(ArrSide[j] != BORDERLINE_UNDEF)
                this.Range.Borders(j + 7).Weight    = DefaultBorderWeight;
                this.Range.Borders(j + 7).LineStyle = ArrSide[j];
           end;
           j = j + 1;
      end;
      /* Проверяем допустимы ли вертикальные разделители */
      EndDiapazon = GetRangeParam(3);
      /* Если не ячейка */
      if(EndDiapazon)
           BegDiapazon = GetRangeParam(1);
           /* Если не один столбец */
           if(BegDiapazon != EndDiapazon)
                if(ArrSide[4] != BORDERLINE_UNDEF)
                     this.Range.Borders(11).Weight    = DefaultBorderWeight;   
                     this.Range.Borders(11).LineStyle = ArrSide[4];
                end;
           end;
           /* Проверяем допустимы ли горизонтальные разделители */
           EndDiapazon = GetRangeParam(4);
           BegDiapazon = GetRangeParam(2);
           /* Если не одна строка */
           if(BegDiapazon != EndDiapazon)
                if(ArrSide[5] != BORDERLINE_UNDEF)
                     this.Range.Borders(12).Weight    = DefaultBorderWeight;   
                     this.Range.Borders(12).LineStyle = ArrSide[5];
                end;
           end;
      end;
  
   End; /* SetBorder */

   /* Метод добавляет новый лист диаграмм в конец списка */
   Macro ChartAdd(_ChartType:integer)

      var Count = this.SheetCount(); /* Количество листов */

      this.Chart = this.Book.Charts.Add(this.Book.Sheets(Count));
      this.Book.Sheets(Count + 1).Move( this.Chart );
      this.Chart.ChartType = _ChartType;

   End; /* ChartAdd */

   /* Метод установления источника данных */
   Macro SetChartData(_PlotBy:integer)

      if(NOT ValType(this.Range))
           MsgBox("Диапазон не задан или некорректен!");
           return False;
      end; 
      this.Chart.SetSourceData(this.Range,_PlotBy);

      // Удалим, т.к. по умолчанию сразу есть один ряд, но нам он не нужен
      if( this.Chart.SeriesCollection.Count )
          this.Chart.SeriesCollection(1).Delete();
      end;
   End; /* SetChartData */

   /**** Метод добавления нового ряда данных (_Diapazon_), с именем _Name_,
         в текущую диаграмму this.Chart, с расшифровокй по оси XValues */
   Macro AddNewSeries(_Diapazon_, _Name_:string, XValues:string )
      var ns:object = NULL;
      if( this.Chart AND _Diapazon_ )

          ns = this.Chart.SeriesCollection.NewSeries();

          if( this.SetDiapazon(_Diapazon_) )
              ns.Values = this.Range;
              if( _Name_ )
                  ns.Name = _Name_;
              end;

              if( XValues )
                  this.SetDiapazon(XValues);
                  ns.XValues = this.Range;
              end;
          end;
      end;
      return true;

      OnError( ObjectErr )
          ErrorMessage(ObjectErr, "[CDAOMSExcel.AddNewSeries] Ошибка!");
          return false;
   end;

   /* Метод установки(удаления) легенды */
   Macro SetChartLegend(_FlagLegend:Bool)

      this.Chart.HasLegend = _FlagLegend;          

   End; /* SetChartLegend */
   
   /* Метод установки(удаления) заголовка диаграммы */
   Macro SetChartTitle(_Title:string,_ColorTitle:integer)

      if(_Title)   
           this.Chart.HasTitle = True;
           this.Chart.ChartTitle.Characters.Text = _Title;
           this.Chart.ChartTitle.Font.Color      = _ColorTitle;
      else this.Chart.HasTitle = False;    
      end;

   End; /* SetChartTitle */

   /* Метод установки(удаления) цветного заголовка осей X,Y диаграммы */
   Macro SetChartAxesTitle(_TitleX:string,_ColorTitleX:integer,_TitleY:string,_ColorTitleY:integer)

      if(_TitleX)   
           this.Chart.Axes(1,1).HasTitle = True;
           this.Chart.Axes(1,1).AxisTitle.Characters.Text = _TitleX;
           this.Chart.Axes(1,1).AxisTitle.Font.Color      = _ColorTitleX;
      else this.Chart.Axes(1,1).HasTitle = False;    
      end;
      if(_TitleY)   
           this.Chart.Axes(2,1).HasTitle = True;
           this.Chart.Axes(2,1).AxisTitle.Characters.Text = _TitleY;
           this.Chart.Axes(2,1).AxisTitle.Font.Color      = _ColorTitleY;
      else this.Chart.Axes(2,1).HasTitle = False;    
      end;

   End; /* SetChartAxesTitle */

   /* Метод для установки названий разделов легенды. В случае успеха возвращает True */
   Macro SetChartLegendItemName(_Index:integer,_Name:string)
        
      if((_Index < 1)or(_Index > this.Chart.SeriesCollection.Count))
           Return False;
      else this.Chart.SeriesCollection(_Index).Name = _Name;
      end;
      Return True;

   End; /* SetChartLegendItemName */

   /* Метод возвращает/устанавливает (V_STRING) наименование листа диаграмм */
   Macro ChartName()

      var Name; /* Наименование */

      GetParm(1, Name);
      if(ValType(Name))
           if(NOT Name)
                return "";
           end;
           if(StrLen(Name) > 28)
                this.Chart.Name = String(Name:28) + "...";
           else this.Chart.Name = Name;
           end;
      else return this.Chart.Name;
      end;
      OnError( Err )
         ErrorMessage(err,"Ошибка доступа к диаграмме!");         
         Return "";

   End; /* ChartName */

   /* Вызов мастера диаграмм с заданными параметрами */
   Macro ChartWizard(_Type      :integer,_SubType        :integer,_PlotBy   :integer,
                     _CountNameX:integer,_CountNameLegend:integer,_HasLegend:bool,
                     _Title     :string, _TitleX         :string, _TitleY   :string,
                     _TitleZ    :string)

      this.Chart.ChartWizard(this.Range,_Type,_SubType,_PlotBy,_CountNameX,_CountNameLegend,_HasLegend,
                             _Title,_TitleX,_TitleY,_TitleZ);

   End; /* ChartWizard */

   /* Перемещение по листу диаграммы расположенной на листе(доступно только для диаграмм на листах) */
   Macro ChartObjMove(_Num:integer,_dX:double,_dY:double)

      this.Sheet.Shapes(_Num).IncrementLeft(_dX);
      this.Sheet.Shapes(_Num).IncrementTop(_dY);
      Return True;
      OnError( Err )
         ErrorMessage(err,"Ошибка использования функции ChartObjMove!\nФункция доступна только для диаграмм на листах");
         Return "";
     
   End; /* ChartObjMove */

   /* Изменение размеров диаграммы расположенной на листе(доступно только для диаграмм на листах) */
   Macro ChartObjResize(_Num:integer,_KoefX:double,_KoefY:double)

      this.Sheet.Shapes(_Num).ScaleWidth(_KoefX, 0, 0);
      this.Sheet.Shapes(_Num).ScaleHeight(_KoefY, 0, 0);
      OnError(Err)
         ErrorMessage(err,"Ошибка использования функции ChartObjResize!\nФункция доступна только для диаграмм на листах");
         Return "";

   End; /* ChartObjResize */

   /* Метод возвращает стандартные размеры (для строки, столбца и т.п.) */
   Macro GetStandartSize(_Type:integer)

      /* Так как есть возможность случайно обратиться к методу при еще не созданной книге,
         проверим объект Sheet и если данные взять не откуда, вернем наиболее употребимые
         размеры: для высоты строки 12.75, для ширины столбца 8.43 */
      if(Not ValType(this.Sheet))
           if(_Type == ST_SIZE_ROW_HEIGHT) 
                return 12.75;
           else return 8.43;
           end;
      else if(_Type == ST_SIZE_ROW_HEIGHT) 
                return this.Sheet.StandardHeight;
           else return this.Sheet.StandardWidth;
           end;
      end;

   End; /* GetStandartSize */

   /* Метод устанавливает строки, которые будут выводится на каждой странице отчета при печати на принтере */
   Macro SetFixedRow()

      var Coord;  /* Строка с координатами диапазона (будут использоваться только строки) */
      var RowBeg; /* Номер начальной строки */ 
      var RowEnd; /* Номер конечной строки */

      GetParm(1,Coord);
      GetParm(2,RowEnd);
      if(NOT ValType(RowEnd))
           this.Sheet.PageSetup.PrintTitleRows = Coord;
      else RowBeg = Coord;
           if(ValType(RowBeg) == V_INTEGER)
                this.Sheet.PageSetup.PrintTitleRows = _SplitCoord(RowBeg, 1) + ":" + _SplitCoord(RowEnd, 1);
           else this.Sheet.PageSetup.PrintTitleRows = RowBeg + ":" + RowEnd;
           end;
      end;

   End; /* SetFixedRow */

   /* Метод устанавливает направление вывода страниц на печать (вниз-вправо или вправо-вниз) */
   Macro SetPrintOrder(_Order:bool)

      if(Not _Order)
           this.Sheet.PageSetup.Order = ORDER_RIGHT_DOWN;
      else this.Sheet.PageSetup.Order = ORDER_DOWN_RIGHT;
      end;

   End; /* SetPrintOrder */

   /* Метод устанавливает (снимает) разделительную сетку на текущем листе */
   Macro SetGrid(_FlagShowGrid:bool)

      if(Not _FlagShowGrid)
           this.Application.ActiveWindow.DisplayGridlines = False;
      else this.Application.ActiveWindow.DisplayGridlines = True;
      end;

   End; /* SetGrid */

  /* Метод для установки масштаба отображения в окне и при печати */
  Macro SetZoom(_ZoomType:integer, _RepWidth:double, _nPage:integer)

    var Zoom:double = 0.0; /* Масштаб отображения в Excel */
    var DoZoom = true;

    /* Обработаем переданный способ масштабирования */
    if(_ZoomType == ZOOM_TYPE_A4)
         this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
         this.Sheet.PageSetup.Orientation = PAPER_PORTRET;
    elif(_ZoomType == ZOOM_TYPE_A4L)
         this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
         this.Sheet.PageSetup.Orientation = PAPER_LANDSCAPE;
    elif((_ZoomType == ZOOM_TYPE_A3)and(FlagPrinterA3))
         this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A3;
         this.Sheet.PageSetup.Orientation = PAPER_PORTRET; 
    elif((_ZoomType == ZOOM_TYPE_A3L)and(FlagPrinterA3))
         this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A3;
         this.Sheet.PageSetup.Orientation = PAPER_LANDSCAPE; 
    elif(_ZoomType == ZOOM_TYPE_AUTO)
         /* Если не влезло на A4, пробуем вместить на A4 Landscape */
         if(_RepWidth / PAPER_SIZE_A4 / _nPage > MAX_ZOOM_PORTRET)
              /* Если не влезло на A4 Landscape, пробуем вместить на A3 Landscape */        
              if(_RepWidth / PAPER_SIZE_A4L / _nPage > MAX_ZOOM)
                   /* Проверим наличие принтера для A3 */
                   if(FlagPrinterA3)
                        /* Если никуда не влезло, оставляем масштаб без изменения на волю пользователя */  
                        if(_RepWidth / PAPER_SIZE_A3L / _nPage > MAX_ZOOM)
                             DoZoom = false;
                             this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
                             this.Sheet.PageSetup.Orientation = PAPER_PORTRET;
                        else this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A3;
                             this.Sheet.PageSetup.Orientation = PAPER_LANDSCAPE; 
                        end; 
                   else DoZoom = false;
                        this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
                        this.Sheet.PageSetup.Orientation = PAPER_LANDSCAPE;
                   end;   
              else this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
                   this.Sheet.PageSetup.Orientation = PAPER_LANDSCAPE;
              end;
         else this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
              this.Sheet.PageSetup.Orientation = PAPER_PORTRET;
         end;
    else DoZoom = false; 
         this.Sheet.PageSetup.PaperSize   = PAPER_TYPE_A4;
         this.Sheet.PageSetup.Orientation = PAPER_PORTRET;
    end;

    if ( DoZoom )
       this.Sheet.PageSetup.Zoom           = False;
       this.Sheet.PageSetup.FitToPagesWide = _nPage;
       this.Sheet.PageSetup.FitToPagesTall = False;
    end;

  End; /* SetZoom */

    Macro SetMarginText(_MarginType:integer, _MarginText:string)
      if  (_MarginType == MARGIN_TL )
          Sheet.PageSetup.LeftHeader = _MarginText;
      elif(_MarginType == MARGIN_TC)
          Sheet.PageSetup.CenterHeader = _MarginText;
      elif(_MarginType == MARGIN_TR)
          Sheet.PageSetup.RightHeader = _MarginText;
      elif(_MarginType == MARGIN_BL)
          Sheet.PageSetup.LeftFooter = _MarginText;
      elif(_MarginType == MARGIN_BC)
          Sheet.PageSetup.CenterFooter = _MarginText;
      elif(_MarginType == MARGIN_BR)
          Sheet.PageSetup.RightFooter = _MarginText;
      end;  
      OnError( Err )
          ErrorMessage(Err);
  End; /* SetMarginText */


  /* (Public) Пользовательский метод для установки размера отступов вертикальных */
  macro SetMarginSizeVert( _TMarginSize:double, _BMarginSize:double )
      Sheet.PageSetup.TopMargin    = Application.InchesToPoints(_TMarginSize);
      Sheet.PageSetup.BottomMargin = Application.InchesToPoints(_BMarginSize);
      OnError( Err )
          ErrorMessage(Err); 
  end;

  /* (Public) Пользовательский метод для установки размера отступов горизонтальных */
  macro SetMarginSizeHor ( _LMarginSize:double, _RMarginSize:double )
      Sheet.PageSetup.LeftMargin    = Application.InchesToPoints(_LMarginSize);
      Sheet.PageSetup.RightMargin   = Application.InchesToPoints(_RMarginSize); 
  end;

  /* (Public) Пользовательский метод для установки размера отступов всех */
  macro SetMarginSize(_TMarginSize:double, _BMarginSize:double, _LMarginSize:double, _RMarginSize:double )
        this.SetMarginSizeVert( _TMarginSize, _BMarginSize);
        this.SetMarginSizeHor ( _LMarginSize, _RMarginSize);
        OnError( Err )
            ErrorMessage(Err);
  end;

/* Метод автоматического определения языка в Excel (пока примитивно, а затем будет сделано через DLM) */
  macro GetExcelLanguage()

    if( SubStr(GetLocaleEnglishNameLanguage(), 1, 3) == "Rus" )
         return LANGUAGE_RUS;
    else return LANGUAGE_ENG;
    end;

  end; /* GetExcelLanguage */

END; /* CDAOMSExcel */


/*┌───────────────────────────────────────────────────────────────────────────┐*/
/*│                        Класс для работы с файлами IE                      │*/
/*└───────────────────────────────────────────────────────────────────────────┘*/

class (CDAOMS_Base) CDAO_IE( FileName:string,
                             _RegimNewApp_:bool   )  // Режим создания приложения, true  - новое приложение,      
                                                     //                            false - используем существующее

   // Конструктор базового объекта
   InitCDAOMS_Base( _RegimNewApp_ );

   /* Список методов:
        Create            - Создание нового документа;
        Open              - Открытие нового документа на основе сохраненного файла;
        Show              - Показ документа;
   */

   /* Деструктор */
   macro Destructor()

      if( this != NULL )
      if( (this.Application) AND (NOT this.Application.Visible) )
          this.Application.Quit;
          this.Application = Null;
      end;
      end;

      OnError( Err )
         return False;

   end; /* Destructor */

   /* Метод открывает файл с именем FileName, в случае успеха возвращает TRUE, иначе FALSE */
   macro Open( FileName:string ) : bool

      if( OR_ExistFile(FileName) )
          if( NOT this.vrt_CreateApplicationIE() )
              return False; 
          end;

          this.Application.Navigate2( FileName );
          return True;
      else
          MsgBox("Не найден файл \"" + FileName + "\"");
          return False;
      end;

      OnError(Err)
         ErrorMessage(err,"Ошибка открытия файла  \"" + FileName + "\"");
         return False;

   end; /* Open */


   // Установка ориентации листа отчета
   Macro SetOrientation( Orientation:integer )
   end;

   /* Конструктор */
   if( ValType(FileName) )
       this.Open( FileName );
   end;

end; /* End class CDAO_IE( FileName:string ) */


/*┌───────────────────────────────────────────────────────────────────────────┐*/
/*│                        Класс для работы с файлами Word                    │*/
/*└───────────────────────────────────────────────────────────────────────────┘*/
CLASS (CDAOMS_Base) CDAOMSWord( FileName     :string,   // Имя открываемого файла
                                _RegimNewApp_:bool   )  // Режим создания приложения, true  - новое приложение,      
                                                        //                            false - используем существующее
   // Конструктор базового объекта
   InitCDAOMS_Base( _RegimNewApp_ );

   var Document   :object = NULL; /* Объект Word  - "Документ" */

   /* Список методов:
        Destructor        - Деструктор класса;
        Create            - Создание нового документа;
        Open              - Открытие нового документа на основе сохраненного файла;
        Close             - Закрытие документа;
        Show              - Показ Word;
   */

   /* Деструктор */
   Macro Destructor()

      if( this != NULL )
      if( (ValType(this.Document)) and (this.Application!=NULL) and (Not this.Application.Visible) )
          this.Document.Close(False);
          this.Application.Quit;
          this.Document    = Null;
          this.Application = Null;
          end;
      end;

      OnError( Err )
         return False;

   End; /* Destructor */

   /* Метод создает новый документ, в случае успеха возвращает TRUE, иначе FALSE */
   Macro Create():bool

      if( Not this.vrt_CreateApplicationWord() )
          return False; 
      end;
      this.Application.Documents.Add();
      this.Document = this.Application.Documents.Item(this.Application.Documents.Count);
      return True;

      OnError(Err)
         ErrorMessage(err,"Ошибка создания нового документа\n" + Err.Message);
         return False;

   End; /* Create */

   /* Метод открывает файл с именем FileName, в случае успеха возвращает TRUE, иначе FALSE */
   Macro Open(FileName:string, Format:integer):bool

      var ConfirmConversions :bool = false;  /* подтверждать преобразование при открытии */
      if( OR_ExistFile(FileName) )  // Проверим существование файла

          if( NOT this.vrt_CreateApplicationWord() )
              return False; 
          end;
          ConfirmConversions =  Application.Options. ConfirmConversions ;
              if( ValType(Format) AND (Format == WINREP_FORMAT_HTML) )
                  this.Document = this.Application.Documents.Open(FileName, FALSE, FALSE, FALSE, "", "", 
                                                                            FALSE, "", "", wdOpenFormatWebPages);
              else
                  this.Document = this.Application.Documents.Open(FileName);
              end;
          Application.Options. ConfirmConversions = ConfirmConversions; 
          if( NOT this.Document )
              this.Destructor();
              return False;
          end;

          return True;
      else 
          MsgBox("Не найден файл \"" + FileName + "\"");
          return False;
      end;

      OnError(Err)
         ErrorMessage(err,"Ошибка открытия файла \"" + FileName + "\"");
         return False;

   End; /* Open */

   /* Метод закрытия текущей книги */
   Macro Close()

      this.Document.Close(False);

      OnError( Err )
         return False;

   End; /* Close */

   /* Метод записывает изменения в файле */
   Macro SaveAs(FileName:string, FileFormat:integer)

      var Flag_Delete:bool = Check_SaveAs( @FileName );

      if( NOT Flag_Delete )
          return false;
      end;

      if( NOT ValType(FileFormat) )
           this.Document.SaveAs(FileName);
      else this.Document.SaveAs(FileName, FileFormat);
      end;

      return TRUE;

   End; /* SaveAs */

  
   macro SetPageScale(Scale:integer, PaperType, Orientation:integer)
       var PageSetup = Document.PageSetup;
       PageSetup.Zoom        = Scale      ;
       PageSetup.PaperSize   = PaperType  ;
       PageSetup.Orientation = Orientation;
   end;

   // Установка ориентации листа отчета
   // fDirectOrientation  false - Ориентация и размер бумаги
   //                     true  - Ориентация ( "PAPER_PORTRET/PAPER_LANDSCAPE" )
     // Метод для установления шкалы масштаба для закладки SheetName
   
   Macro SetOrientation( Orientation:integer , fDirectOrientation:bool)
             
         var PageSetup = Document.PageSetup;
         if( (Not ValType(fDirectOrientation))  OR  (NOT fDirectOrientation) )
             if  ( Orientation == ZOOM_TYPE_A4  ) PageSetup.PaperSize   = 7;//PAPER_TYPE_A4;
                                                  PageSetup.Orientation = 0;//PAPER_PORTRET;

             elif( Orientation == ZOOM_TYPE_A4L ) PageSetup.PaperSize   = 7;//PAPER_TYPE_A4  ;
                                                  PageSetup.Orientation = 1;//PAPER_LANDSCAPE;

             elif( Orientation == ZOOM_TYPE_A3  ) PageSetup.PaperSize   = 6;//PAPER_TYPE_A3;  
                                                  PageSetup.Orientation = 0;//PAPER_PORTRET;  

             elif( Orientation == ZOOM_TYPE_A3L ) PageSetup.PaperSize   = 6;//PAPER_TYPE_A3  ;
                                                  PageSetup.Orientation = 1;//PAPER_LANDSCAPE;
             end;
         else
             Orientation = Orientation;   
         end;

    end;
    

   
   /* Метод для выполнения некоторых макрокоманд спецформатирования. */
   /* Такие команды создаются в специальном массиве строк строке     */
   Macro ExecStr( lsStr:tarray )
      var i:integer = 0;
      var flagScreenUpdating:bool = false;
      var Step    :integer = 0;
      var SizeStep:double  = 0.;

      if( this.CheckApplication() )

          flagScreenUpdating = this.Application.ScreenUpdating;

          /* Вынесем ссылки на основные данные в глобализм, для возможности использования
             их макрофункцией спецформатирования, это позволит ей скомпилится и выполнится */
          WordDocument    = this.Document;    // Объект Word - "Книга"
          WordApplication = this.Application; // Объект Word - "Приложение"

          this.Application.ScreenUpdating   = FALSE;
          this.Application.DisplayStatusBar = TRUE;

          if( lsStr.Size ) 
              InitProgress(lsStr.Size, " Обработка отчета...", "Обработка отчета...");

              //Т.к. на терминале RSL-ый индикатор не работает,то в статус строке Word-а выведем сообщение о работе
              SizeStep = Double(lsStr.Size)/100.;

              this.Application.StatusBar = "Обработка отчета [" + Step + "%]";
          end;

          /* Выполняем все переданные строки */
          while( i < lsStr.Size )

               if( i > Step*SizeStep )
                   this.Application.StatusBar = "Обработка отчета [" + Step + "%]";
                   Step = Step + 1;
               end;
               UseProgress(i);

               if( StrLen(lsStr[i]) )
                   ExecExp(lsStr[i]);
               end;
               i = i + 1;
          end;

          if( lsStr.Size )  RemProgress();  end;

          this.Application.ScreenUpdating = flagScreenUpdating;
          this.Application.StatusBar = "";
      end;

      OnError( err )
         this.Application.ScreenUpdating = flagScreenUpdating;
         this.Application.StatusBar      = "";
         if( lsStr.Size )  RemProgress();  end;
         ErrorMessage(err,"Ошибка постобработки!");

   End; /* ExecStr */

   /* Метод для выполнения некоторой макрофункции спецформатирования описанной в отдельном макрофайле. 
      При работе в трехзвенке такая макрофункция присылается на терминал в специальном макрофайле */
   Macro ExecuteMacro( MacroFileName:string, Proc:string, Prm:string )
    
      var ExecString:string = ""; /* Строка для исполнения с помощью функции ExecExp */
      var RunMacro  :string = ""; /* Имя, запускаемого с помощью функции ExecMacroFile, макрофайла */
      var flagScreenUpdating:bool = false;

      if( this.CheckApplication() )
          flagScreenUpdating = this.Application.ScreenUpdating;

          /* Если имя макрофайла не задано, сразу сваливаем */
          if( Not StrLen(MacroFileName) )
              return;
          end;
          /* Формируем строку для функции ExecMacroFile, для дальнейшего скармливания функции ExecExp */
          RunMacro = "ExecMacroFile";
          if( StrLen(Proc) )
              if( (ValType(Prm) != V_UNDEF) and (StrLen(Prm)))
                   ExecString = RunMacro + "(\"" + MacroFileName + "\",\"" + Proc + "\"," + Prm + ");";
              else ExecString = RunMacro + "(\"" + MacroFileName + "\",\"" + Proc + "\");";
              end;
          else
              ExecString = RunMacro + "(\"" + MacroFileName + "\");";
          end;

          /* Вынесем ссылки на основные данные в глобализм, для возможности использования
             их макрофункцией спецформатирования, это позволит ей скомпилится и выполнится */
          WordDocument    = this.Document;    // Объект Word - "Книга"
          WordApplication = this.Application; // Объект Word - "Приложение"

          /* Выполняем переданную функцию спецформатирования */
          this.Application.ScreenUpdating = FALSE;
          this.Application.StatusBar = "Обработка отчета...";
             ExecExp(ExecString);
          this.Application.StatusBar = "";
          this.Application.ScreenUpdating = flagScreenUpdating;
      end;

      OnError(err);
          this.Application.ScreenUpdating = flagScreenUpdating;
          this.Application.StatusBar = "";
          ErrorMessage(err,"Ошибка постобработки!");

   End; /* ExecuteMacro */

   /* Конструктор */
   if( ValType(FileName) )
       this.Open( FileName );
   end;

END; /* CDAOMSWord */
