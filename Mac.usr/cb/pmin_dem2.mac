//-----------------------------------------------------------------------------
// Блок     : 29045 - "Картотека требований-поручений"
// Шаг      : 20    - "Изъятие из картотеки требований"
// Описание : Макрос шага
//-----------------------------------------------------------------------------
import globals, PaymInter, FIInter, PTInter, pm_setst, likepy, cbsttls, stwlconf, pm_tools;
import OprInter, oralib; //Jushmanov 2014-02-25 C-19151

var PaymentObj:RsbPayment;

PRIVATE CONST CHOICE_ACCEPT = 0; // Акцептовать
PRIVATE CONST CHOICE_REJECT = 1; // Отказать


// ----------------------------------------------------------------------------
// Обертка для вызова вертикального меню
// ----------------------------------------------------------------------------
PRIVATE MACRO ShowMenu():integer

    ARRAY m;
    m(0) = " Акцептовать";
    m(1) = "  Отказать";

    return Menu( m, "Enter Выбор Esc Отмена", "" );

END;


//------------------------------------------------------------------------------
// Банк в ТС?
//------------------------------------------------------------------------------
PRIVATE MACRO PM_IsBankInTS( BankID:integer, OurCABS:bool ):bool

    var CABSstr:string = "";
    var select :string = "select 1 "
                       +  " from ddp_dep_dbt dp "
                       + " where dp.t_PartyID = :BankID "
                       +   " and dp.t_Status <> 3 ";
    var params:TArray = TArray();
    params[params.size] = SQLParam( "BankID" , BankID );
    var rset:RsdRecordset;

    if( OurCABS == true )
        CABSstr = " and dp.t_ACCESSMODE <> 3 ";
    else
        CABSstr = " and dp.t_ACCESSMODE =  3 ";
    end;

    select = select + CABSstr;
    rset = execSQLselect( select, params, false );

    return ( rset AND rset.moveNext() );
END;


//-----------------------------------------------------------------------------
// Является ли субъект резидентом
//-----------------------------------------------------------------------------
PRIVATE MACRO IsResident( PartyID ):bool
    VAR select:string = " select party.T_NotResident " +
                          " from dparty_dbt party "+
                         " where party.T_PARTYID = :PartyID";
    VAR params:TArray = makeArray( SQLParam( "PartyID", PartyID ) );
    VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

    if( rset and rset.moveNext() )
        if( rset.value(0) == "X" )
            return false;
        end;
    end;     

    return true;
END;


//-----------------------------------------------------------------------------
// Проверка внешних платежей
//-----------------------------------------------------------------------------
PRIVATE MACRO CheckExtPayment( Payment:RsbPayment, err:string ):integer

    var stat   :integer = 0;
    var err_str:string  = "";
    var BankID :integer = Payment.ReceiverBankID, 
        CodeKind:integer = Payment.ReceiverBankCodeKind, 
        AccLen:integer = 0,
        retval:integer = 0;
    var ExtAcc :string  = Payment.ReceiverAccount, 
        BankCode:string = Payment.ReceiverBankCode,
        ExtAccNew :string  = "";
    var params:TArray = NULL;

    // Если банк российский
    if( ( stat == 0 ) and ( BankID > 0 ) and ( IsResident( BankID )) )
        AccLen = strlen( ExtAcc );

        stat = PT_CheckBankControlDate( BankID );
        if( stat > 0 )
            err_str = GetErrMsg();
        end;

        // Проверить длину счета
        if( ( stat == 0 ) and ( AccLen > 0 ) )
            if( AccLen != 20 )
                stat = 1;
                err_str = "Длина счета должна быть равна 20 символам";
            else // Проверить ключ счета
                if( CodeKind != PTCK_BIC )
                    params = makeArray( SQLParam( "p_PartyID"    , BankID               ),
                                        SQLParam( "p_CodeKind"   , PTCK_BIC             ),
                                        SQLParam( "p_Code"       , V_STRING , RSDBP_OUT ),
                                        SQLParam( "p_CodeOwnerID", V_INTEGER, RSDBP_OUT )
                                      );
                    retval = execStoredFunc( "RSBPARTY.PT_GetPartyCodeEx", V_INTEGER, params );
                    if( retval == 0 )
                        BankCode = params.Value(2).value;
                    end;
                end;
                ExtAccNew = GetKey( ExtAcc, BankCode );
                if( ExtAccNew != ExtAcc )
                    err_str = "В номере счета " + ExtAcc + " неверно значение ключа.|Должно быть " + ExtAccNew;
                    stat = 1;
                end;
            end;
        end;
    end;

    SetParm( 1, err_str );
    return stat;
END;


//-----------------------------------------------------------------------------
// Некоторые проверки требования
//-----------------------------------------------------------------------------
PRIVATE MACRO ControlCheck( Payment:RsbPayment, err_msg:string ):integer

    // Номер документа не задан
    if( StrLen( Payment.Number ) == 0 ) 
        err_msg = "Неверно задан номер документа";
        SetParm( 1, err_msg );
        return 1;
    end;

    if( Payment.BaseAmount <= 0 )
        err_msg = "Неверно задана сумма требования";
        SetParm( 1, err_msg );
        return 1;
    end;

    // Проверить валютe требования
    if( CheckFIID( Payment.BaseFIID ) != 0 )
        err_msg = "Не найдена валюта требования";
        SetParm( 1, err_msg );
        return 1;
    end;

    // Проверить курс всех валют
    if( (Payment.BaseFIID != 0/*NATCUR*/ ) AND (CheckRateForDate( Payment.BaseFIID, {curdate} ) != 0) )
        err_msg = "Не найден курс валюты требования";
        SetParm( 1, err_msg );
        return 1;
    end;

    if( Payment.PayerBankID == Payment.ReceiverBankID  )
        err_msg = "Банк плательщика не должен совпадать|с банком получателя";
        SetParm( 1, err_msg );
        return 1;
    end;

    // Проверка плательщика              
    if( ПолучитьСубъекта( Payment.PayerBankID ) )
        err_msg = "Неверно задан банк плательщика";
        SetParm( 1, err_msg );
        return 1;
    end;

    // Банк получателя входит в ЦАБС
    if( ( ( Payment.PayerGroup == PAYMENTS_GROUP_EXTERNAL ) and (PM_IsBankInTS(Payment.PayerBankID, false) ) )
    or  ( ( Payment.PayerGroup != PAYMENTS_GROUP_EXTERNAL ) and (PM_IsBankInTS(Payment.PayerBankID, true ) ) ) )
        err_msg = "";
    else
        err_msg = "Банк получателя не является узлом ТС";
        SetParm( 1, err_msg );
        return 1;
    end;

    // Банк получателя задан и открыт
    if( ПолучитьСубъекта( Payment.ReceiverBankID ) )
        err_msg = "Неверно задан банк плательщика";
        SetParm( 1, err_msg );
        return 1;
    end;

    if( Payment.ReceiverAccount != "" )
        if( AccountIsMask( Payment.ReceiverAccount ) )
            err_msg = "Счет получателя не должен быть маской";
            SetParm( 1, err_msg );
            return 1;
        end;
        if( CheckExtPayment( Payment, err_msg ) )
            SetParm( 1, err_msg );
            return 1;
        end;
    end;

    return 0;
END;


// ----------------------------------------------------------------------------
// Макроса шага
// ----------------------------------------------------------------------------
MACRO ExecuteStep( doc, paymDoc )

    var stat:integer = 0;
    var BankClaimObj:object = null;

    RECORD  wlconf( wlconf );

    if( PaymentObj.EndDepartment != {OperDprt} )
        msgbox( "Шаг может быть выполнен только из филиала,|в который направлено требование" ); 
        return 1;
    end;

    if( IsOprMultiExec() )
        msgbox( "Массовое выполнение данного шага недопустимо" );
        return 1;
    end;

    var Choice:integer = ShowMenu();
    var err_msg:string = "";

    if( Choice == CHOICE_ACCEPT )

        // Платеж Входящий - выполнить следующие проверки
        if( ( not (    ( PaymentObj.PayerGroup  == PAYMENTS_GROUP_EXTERNAL )
                   and ( PaymentObj.ReceiverGroup == PAYMENTS_GROUP_EXTERNAL ) ) )
        and PaymentObj.IsExternalIncoming )

            if( ControlCheck( PaymentObj, err_msg ) )
                msgbox( "Требование не может быть акцептовано. Причина: |" + err_msg );
                return 1;
            end;
        end;

        if( УстановитьСтатусыПлатежа( OPR_PAYM_ACCEPT, OPR_PAYM_ST_ACPT_ACCEPTED,
                                      OPR_PAYM_DO,     OPR_PM_ST_ENTER ) )
            msgbox("Ошибка при установке сегментов статуса экземпляра операции");
            return 1;
        end;

        PaymentObj.DemandAccept = PM_DEMAND_ACCEPT_ACCEPT;
        PaymentObj.DemandAcceptDate = {curdate};
        PaymentObj.DemandIndexExitDate = {curdate};

        // Заполнить примечание
        if( PaymentObj.Notes.AddNote( PM_NOTEKIND_DENIALGROUND, "" ) != 0 )
            msgbox( "Ошибка при вставке примечания платежа" );
            return 1;
        end;

        return 0;

    elif( Choice == CHOICE_REJECT )

        // Выдать панель ввода отказа от акцепта платежа
        if( NOT PM_DenialPanel( PaymentObj, PAYMENTS_INDEX_DEMAND, true ) )
            msgbox( "Пользователь прервал выполение" );
            return 1;
        end;

        // Установить примечание "Причина отказа (возврата)" равным причине отказа 
        // от акцепта, введенной в панели отказа от акцепта
        if( PaymentObj.Notes.AddNote( PM_NOTEKIND_DENIALGROUND, PaymentObj.DenialGround() ) != 0 )
            msgbox( "Ошибка при вставке примечания платежа" );
            return 1;
        end;

        // Платеж входящий
        if( ( not (    ( PaymentObj.PayerGroup  == PAYMENTS_GROUP_EXTERNAL )
                   and ( PaymentObj.ReceiverGroup == PAYMENTS_GROUP_EXTERNAL ) ) )
        and PaymentObj.IsExternalIncoming )

            // Сформировать сообщение об отказе от акцепта входящего требования;
            // Сообщение должно быть отправлено по тому же транспорту, по которому было сформировано входящее требование.
            ClearRecord( wlconf );
            FillConfirmationParamObj( PaymentObj, wlconf );

            wlconf.Cancel      = "X";
            wlconf.Description = PaymentObj.DenialGround();
            if( CreateConfirmation(wlconf, TRUE) == FALSE )
                msgbox("Ошибка при создании подтверждения по проводке");
                return 1;
            end;
        end;

        if( УстановитьСтатусыПлатежа( OPR_PAYM_STATE,  OPR_PM_ST_CLOSE,
                                      OPR_PAYM_DO,     OPR_PM_ST_ENTER,
                                      OPR_PAYM_ACCEPT, OPR_PAYM_ST_ACPT_REJECTED ) )
            msgbox("Ошибка при установке сегментов статуса экземпляра операции");
            return 1;
        end;

        // Установить статус первичного документа = $(Закрыт);
        PM_SetPrimDocumentState( PaymentObj, DOCUMENT_ST_CLOSED );

        PaymentObj.DemandAccept = PM_DEMAND_ACCEPT_REJECTED;
        PaymentObj.DemandIndexExitDate = {curdate};

        return 0;
    else
        msgbox("Выполнение процедуры прервано пользователем");
        return 1;
    end;

    return 0;
END;


//Jushmanov 2014-02-25 C-19151
macro PostStepAction( message,      /* 1 - выполнение шага; 2 - откат шага;   */
                      errTrn,       /* статус выполнения шага. 0 - ошибки нет */
                      FirstDoc,     /* указатель на первичный документ        */
                      ID_Oper,      /* внутренний идентификатор операции      */
                      Number_Step,  /* Номер шага операции (из настроек)      */
                      KindOper,     /* номер вида операции                    */
                      KindDoc,      /* номер вида первичного документа        */
                      KindStep,     /* вид шага операции                      */
                      ID_Step )     /* внутренний идентификатор шага операции */
    private var logquery, idStep = ID_Step, idOper = ID_Oper;

    if(( message == OP_EXECUTE_STEP ) and (errTrn == 0) and (IsOprMultiExec))
        if ((valtype(idOper) != V_INTEGER) and (valtype(idOper) != V_STRING)) idOper = 0; end;
        if ((valtype(idStep) != V_INTEGER) and (valtype(idStep) != V_STRING)) idStep = 0; end;

        logquery = "UPDATE usr_doprstep_robot_dbt SET t_is_robot_step = chr(88)" +
                   " WHERE t_id_operation = " + idOper + " AND t_id_step = " + idStep;
        ExecSQL(logquery, null, false);
    end;

    return 0;
end;