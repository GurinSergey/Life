//-----------------------------------------------------------------------------
// Блок     : Вне блока
// Шаг      : Вне шага
// Описание : Общие функции и переменные для макросов шагов
//-----------------------------------------------------------------------------
// KS 22.11.2013 Предварительная адаптация под 31ю сборку
// RR 28.11.2015 Исправил ошибку при отзыве картотеки ОР
IMPORT BankInter, PaymInter, CashInter, PSInter, OprInter, CTInter, pm_const, FIInter, CurrInter, PTInter, globals;
import oralib, likepy, pm_opr, pm_note, stwlconf;

//Seleznev
import FrontRoute;

private const RegPath_Receiver:string = "PS\\ОВЕРДРАФТ\\ЗАПРЕТЫ_ОПЛАТЫ\\СЧЕТА_ПОЛУЧАТЕЛЯ";
private const RegPath_Ground  :string = "PS\\ОВЕРДРАФТ\\ЗАПРЕТЫ_ОПЛАТЫ\\НАЗНАЧЕНИЯ_ПЛАТЕЖА";
private const RegPath_Client  :string = "PS\\REQOPENACC\\Счета клиентов";

//-----------------------------------------------------------------------------
//  Проверить, существует ли счет в базе
//-----------------------------------------------------------------------------
macro СчетСуществуетИОткрыт( FIID:integer, Account:string, Chapter:integer, Department:integer, Type_Account:string, Client:integer, DateNoChange:date ):bool
  
VAR select:string = " select acc.t_department, acc.t_type_account, acc.t_client, acc.t_DateNoChange " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account "+
                      "   and acc.T_Open_Close = chr(0)";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapter ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    if( ValType(Department) != V_UNDEF )
      SetParm( 3, rset.value(0) );
    end;

    if( ValType(Type_Account) != V_UNDEF )
      SetParm( 4, rset.value(1) );
    end;

    if( ValType(Client) != V_UNDEF )
      SetParm( 5, rset.value(2) );
    end;

    if( ValType(DateNoChange) != V_UNDEF )
      SetParm( 6, rset.value(3) );
    end;

    return true;
  end;     
  return false;
  
ONERROR(x)
  MsgBox( x.Message );
  return false;
end;

//-----------------------------------------------------------------------------
// Счет существует и закрыт
//-----------------------------------------------------------------------------
macro СчетСуществуетИЗакрыт( FIID:integer, Account:string, Chapter:integer, Department:integer ):bool
  
  VAR select:string = " select acc.t_Department " +
                      " from daccount_dbt acc " +
                      " where acc.T_CHAPTER = :chapter " +
                      "   and acc.T_CODE_CURRENCY = :fiid " +
                      "   and acc.T_ACCOUNT = :account "+
                      "   and acc.T_Open_Close > chr(0)";
  VAR params:TArray = makeArray(SQLParam( "chapter", Chapter ),     
                                SQLParam( "fiid", FIID ),     
                                SQLParam( "account", Account ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );
  if( rset and rset.moveNext() )
    if( ValType(Department) != V_UNDEF )
      SetParm( 3, rset.value(0) );
    end;
    return true;
  end;     
  return false;
  
ONERROR(x)
  MsgBox( x.Message );
  return false;
end;

//-----------------------------------------------------------------------------
// Определить реального плательщика платежа
//-----------------------------------------------------------------------------
macro ОпределитьРеальногоПлательщика( Payment:RsbPayment ):integer
  if( Payment.PayerGroup == PAYMENTS_GROUP_EXTERNAL )
    if( PM_FindBalanceInReg_117( RegPath_Client, Payment.PayerAccount, 1 ) )
      return Payment.Payer;
    else
      return Payment.PayerBankID;
    end;
  else
    if( MFR_IsOurBank( Payment.Payer ) )
      return Payment.Payer;
    elif( PM_FindBalanceInReg_117( RegPath_Client, Payment.PayerAccount, 1 ) )
      return Payment.Payer;
    else
      return Payment.PayerBankID;
    end;
  end;
end;

//-----------------------------------------------------------------------------
// Определить реального получателя платежа
//-----------------------------------------------------------------------------
macro ОпределитьРеальногоПолучателя( Payment:RsbPayment ):integer

  if( Payment.ReceiverGroup == PAYMENTS_GROUP_EXTERNAL )
    if( PM_FindBalanceInReg_117( RegPath_Client, Payment.ReceiverAccount, 1 ) )
      return Payment.Receiver;
    else
      return Payment.ReceiverBankID;
    end;
  else
    if( MFR_IsOurBank( Payment.Receiver ) )
      return Payment.Receiver;
    elif( PM_FindBalanceInReg_117( RegPath_Client, Payment.ReceiverAccount, 1 ) )
      return Payment.Receiver;
    else
      return Payment.ReceiverBankID;
    end;
  end;

  return 0;
end;

//-----------------------------------------------------------------------------
// Функции определения видов платежей
//-----------------------------------------------------------------------------
macro ПлатежВнутренний( Payment:RsbPayment ):bool
  return ( ( Payment.PayerGroup    == PAYMENTS_GROUP_INTERNAL ) and
           ( Payment.ReceiverGroup == PAYMENTS_GROUP_INTERNAL ) )
end;

macro ПлатежВнешний( Payment:RsbPayment ):bool
  return ( ( Payment.PayerGroup    == PAYMENTS_GROUP_EXTERNAL ) or
           ( Payment.ReceiverGroup == PAYMENTS_GROUP_EXTERNAL ) )
end;

macro ПлатежТранзитный( Payment:RsbPayment ):bool
  return ( ( Payment.PayerGroup    == PAYMENTS_GROUP_EXTERNAL ) and
           ( Payment.ReceiverGroup == PAYMENTS_GROUP_EXTERNAL ) )
end;

macro ПлатежВходящий( Payment:RsbPayment ):bool
  return ( ( not ПлатежТранзитный( Payment ) ) and Payment.IsExternalIncoming )
end;

macro ПлатежИсходящий( Payment:RsbPayment ):bool
 return ( ((Payment.PayerGroup == PAYMENTS_GROUP_EXTERNAL) AND (Payment.PayerIsSender != "X") AND (Payment.ReceiverGroup != PAYMENTS_GROUP_EXTERNAL)) OR
          ((Payment.ReceiverGroup == PAYMENTS_GROUP_EXTERNAL) AND (Payment.ReceiverIsSender != "X") AND (Payment.PayerGroup != PAYMENTS_GROUP_EXTERNAL)) );
end;


//-----------------------------------------------------------------------------
// Функции для работы со счетами  
//-----------------------------------------------------------------------------

// Cчет плательщика клиентский?
// Account - можно передать счет из разноски
macro IsClientPayerAccount( Payment:RsbPayment, Account):bool
  if( ( Payment.PayerGroup != PAYMENTS_GROUP_EXTERNAL ) and MFR_IsOurBank( Payment.Payer ) )
    return false;
  elif( PM_FindBalanceInReg_117( "PS\\REQOPENACC\\Счета клиентов", IfThenElse(ValType(Account) == V_UNDEF, Payment.PayerAccount, Account), 1 ) )
    return true;
  else
    return false;
  end;
  
 // return (not PM_IsBankAccount(IfThenElse(ValType(Account) == V_UNDEF, Payment.PayerAccount, Account), Payment.PayerFIID));
end;

// Cчет получателя клиентский?
// Account - можно передать счет из разноски
macro CчетПолучателяКлиентский( Payment:RsbPayment, Account ):bool
  if( ( Payment.ReceiverGroup != PAYMENTS_GROUP_EXTERNAL ) and MFR_IsOurBank( Payment.Receiver ) )
    return false;
  elif( PM_FindBalanceInReg_117( "PS\\REQOPENACC\\Счета клиентов", IfThenElse(ValType(Account) == V_UNDEF, Payment.ReceiverAccount, Account), 1 ) )
    return true;
  else
    return false;
  end;

  //return (not PM_IsBankAccount(IfThenElse(ValType(Account) == V_UNDEF, Payment.ReceiverAccount, Account), Payment.ReceiverFIID));
end;

macro ManualProcessing( Payment:RsbPayment ):bool
  var err, TypeVal;
  var AccountregValue:string = "";

  TypeVal = GetRegistryValue( "CB\\PAYMENTS\\MANUAL_PROCESSING\\RECEIVERACCOUNTS", V_STRING, AccountregValue, err );
  if( ( TypeVal == V_STRING ) and ( err == 0 ) )
    return (CompareStrWithMasks( AccountregValue, Payment.ReceiverAccount ) == 0);
  end;
  return false;
end;

macro PM_CheckAccount_Kind( Account:string, Chapter:integer, FIID:integer, AccKind:string ):bool

var SelectStr:string;
  var params:TArray;
  var rs:object;

  SelectStr = "select count(1) from daccount_dbt acc " +
              "where  acc.t_Account       = :Account " +  
              "  and  acc.t_Chapter       = :Chapter " + 
              "  and  acc.t_Code_Currency = :FIID    " +
              "  and  acc.t_Kind_Account  = :AccKind ";

  params = makeArray( SQLParam( "Account", Account ),
                      SQLParam( "Chapter", Chapter ),
                      SQLParam( "FIID"   , FIID    ),
                      SQLParam( "AccKind", AccKind ));

  rs = execSQLselect( SelectStr, params, FALSE );

  if( rs AND rs.moveNext() )
    if( rs.value(0) > 0 )
      return true;
    end;
  end;

  return false;
end;

macro ЕстьПарныйСчет( Account:string, Chapter:integer, FIID:integer ):bool

  var SelectStr:string;
  var params:TArray;
  var rs:object;
  var PairAccount:string;

  SelectStr = "select acc.t_PairAccount from daccount_dbt acc " +
              "where  acc.t_Account       = :Account " +  
              "  and  acc.t_Chapter       = :Chapter " + 
              "  and  acc.t_Code_Currency = :FIID    " ;

  params = makeArray( SQLParam( "Account", Account ),
                      SQLParam( "Chapter", Chapter ),
                      SQLParam( "FIID"   , FIID    ));

  rs = execSQLselect( SelectStr, params, FALSE );

  if( rs AND rs.moveNext() )
    PairAccount = rs.value(0);
    if( strlen(PairAccount) > 0 )
      return true;
    else
      return false;
    end;
  end;

  return false;
end;

macro СчетПассивный( Account, Chapter, Code_Currency ):bool
  return PM_CheckAccount_Kind( Account, Chapter, Code_Currency, "П" );
end;

macro СчетАктивный( Account, Chapter, Code_Currency ):bool
  return PM_CheckAccount_Kind( Account, Chapter, Code_Currency, "А" );
end;

macro ПолучитьОстаток( Account, Chapter, Code_Currency )
  if( Code_Currency )
    return RestAC( Account, Code_Currency, NULL, NULL, Chapter );
  else
    return RestA( Account, NULL, NULL, Chapter );
  end;
end;

macro ПолучитьОстатокНаДату( Account, Chapter, Code_Currency, ProcDate )
  if( Code_Currency )
    return RestAC( Account, Code_Currency, ProcDate, NULL, Chapter );
  else
    return RestA( Account, ProcDate, NULL, Chapter );
  end;
end;

//-----------------------------------------------------------------------------
// Проверить основание платежа по значению настройки в реестре
//-----------------------------------------------------------------------------
private macro CheckPaymentGround( PaymGround:string ):bool

  var err:integer = 0;
  var i  :integer = 0;
  var RegGround:string = "";
  var RegStr:TArray;
  var Result:bool = false;

  GetRegistryValue( RegPath_Ground, V_STRING, RegGround, err );
  if( ( err != 0 ) )
    RegGround = "";
  end;

  RegGround = replace( RegGround, " ", "" ); // Убрать пробелы

  if( RegGround == "" )
    return Result;
  end;

  RegStr = split( RegGround, "," );

  while( i < RegStr.Size )
    if( Index( PaymGround, RegStr.Value(i) ) > 0 )
      Result = true;
    end;

    i = i + 1;
  end;

  return Result;
end;

//-----------------------------------------------------------------------------
// Проверить наличие договора обслуживания
//-----------------------------------------------------------------------------
private macro GetSfContrID( Payment:RsbPayment ):integer
  var fSfContr = Tbfile ("sfcontr.dbt", "r", 1);

  ClearRecord (fSfContr.rec);
  fSfContr.rec.ServKind   = 3;                          // РКО
  fSfContr.rec.ObjectType = 1;                          // SF_ACCOUNT
  fSfContr.rec.FIID       = Payment.PayerFIID;          // код валюты
//  fSfContr.rec.Object     = Payment.FuturePayerAccount; // номер счета
  fSfContr.rec.Object     = Payment.PayerAccount; // номер счета
  if( fSfcontr.getEQ () ) // найден договор обслуживания
    if ( (fSfContr.rec.DateBegin <= Payment.ValueDate) and
         (   (fSfContr.rec.DateClose >= Payment.ValueDate) 
          or (fSfContr.rec.DateClose == date(0, 0, 0)) 
         )
       )
      return fSfContr.rec.ID;
    //RR 28.11.2015 временное решение для исправления ошибки при отзыве картотеки ОР
    //суть ошибки в буфере Payment не заполнены даты ValueDate и DateClose из-за этого ID договора не возвращается
    elif (StrLen(Payment.ValueDate) == 0)
      return fSfContr.rec.ID;
    end;
  end;

  return 0;
end;

macro PM_GetSfContrID(Payment:RsbPayment)
  return GetSfContrID( Payment );
end;

//-----------------------------------------------------------------------------
// Проверки для интегрированного режима
//-----------------------------------------------------------------------------
private macro ExistLoansCredit( PaymentID:integer, ValueDate:date, SfID:integer, IsPrep:bool, Sum, accLimit, err )

  var select:string;
  var params:TArray;
  var rs:object;
  var Slim = $0, Slim_full = $0;
  var stat:integer = 0;

  select = "SELECT cred.t_CreditNumber "
           "FROM   dcredit_c_dbt cred, dovc_sfc_dbt ovc " +
           "WHERE  cred.t_CreditNumber = ovc.t_CreditNumber_Ref "   +  
           "  AND  ovc.t_ID            = :SfID ";
        
  params = makeArray( SQLParam( "SfID", SfID ) );

  rs = execSQLselect( select, params, FALSE );

  if( (not rs) or (not rs.moveNext()) )
    return false;
  end;

  if( OV_LimitSumControl( AccLimit, SfID, PaymentID, ValueDate, true ) )
    msgbox("Сумма лимита на счете не соответствует сумме лимита по договору Loans");
    stat = 1;
    SetParm( 6, stat );
    return false;
  end;

  // Если вызывается из блока предобработки
  if( IsPrep )
    OV_DefineLimitAccount( PaymentID, SfID, ValueDate, true, Slim, Slim_full );
    if( Slim < Sum )
      return false;
    end;
  end;

  return true;
end;

//-----------------------------------------------------------------------------
// Получить буфер счета
//-----------------------------------------------------------------------------
private macro GetAccountRecord( accRec ):bool
  file acc ("account.dbt" ) key 0;
  
  acc.Chapter       = accRec.Chapter;
  acc.Account       = accRec.Account;
  acc.Code_Currency = accRec.Code_Currency;
  if( getEQ( acc ) )
    Copy( accRec, acc );
    return true;
  end;
  return false;
end;


macro PM_GetAccountRecord( Account, Code_Currency, Chapter, Rec_Account:TRecHandler ):bool

  RECORD rec_acc("account.dbt");
  rec_acc.Account       = Account;
  rec_acc.Code_Currency = Code_Currency;
  rec_acc.Chapter       = Chapter;

  if(GetAccountRecord( rec_acc ))
    Copy(Rec_Account, rec_acc);
    return true;
  end;
  
  Rec_Account.Clear();
  return false;
end;

//-----------------------------------------------------------------------------
// Проверить возможность использования лимита
//-----------------------------------------------------------------------------
MACRO PM_CanUseLimit( Payment:RsbPayment, FreeAmount, IsPrep:bool, err:integer ):bool

  record AccRec("account.dbt");
  record LinkAccRec("account.dbt");
  record NotBalAccRec("account.dbt");

  var AccType:string = "";
  var AccLimit = $0;
  var AccDep:integer = 0;
  var SfContrID:integer = 0;
  var Sum = $0;
  var stat:integer = 0;

  var select:string;
  var params:TArray;
  var rs:object;

  if( FreeAmount > 0 )
    Sum = Payment.FuturePayerAmount - FreeAmount;
  else
    Sum = Payment.FuturePayerAmount;
  end;

// Осуществляем поиск счета
//  select = "SELECT acc.t_Type_Account, acc.t_Limit, acc.t_Department FROM daccount_dbt acc " + 
  select = "SELECT acc.t_Type_Account, rsi_rsb_account.GetAccLimit(acc.t_account,acc.t_chapter,acc.t_code_currency,?) t_Limit, acc.t_Department FROM daccount_dbt acc " + 
           "WHERE acc.t_Code_Currency  = :FIID "   +  
           "  AND acc.t_Account        = :Account " + 
           "  AND acc.t_Chapter        = 1 ";
        
  params = makeArray( SQLParam( "bankdate", {curdate}                  ),
                      SQLParam( "FIID"    , Payment.PayerFIID          ),
                      SQLParam( "Account" , Payment.FuturePayerAccount ));

  rs = execSQLselect( select, params, FALSE );

  if( rs AND rs.moveNext() )
    AccType  = rs.value(0);
    AccLimit = rs.value(1);
    AccDep   = rs.value(2);
  end;

  // Проверяем тип счета
  //!!! Seleznev достаточно "О"
  //if( Index( AccType, "V" ) <= 0 )
  if( Index( AccType, "О" ) <= 0 )
    return false;
  end;

  // Проверяем лимит
  //!!!Seleznev т.к. лимит не уменьшается, надо учитывать свободный остаток
  //if( AccLimit < Sum )
  if( AccLimit+FreeAmount < Payment.FuturePayerAmount )
    return false;
  end;

  // Проверяем реального получателя
/*  if( PM_FindBalanceInReg_117( RegPath_Receiver, Payment.ReceiverAccount, 1 ) )
    return false;
  end;*/

 /* Kozina теперь это проверяется процедурой контроля целевого использования
  // Проверяем основание платежа
  if( CheckPaymentGround( Payment.Ground ) )
    return false;
  end;*/

  // Проверяем наличие договора обслуживания
//!!!Seleznev не понятно зачем...
/*  SfContrID = GetSfContrID( Payment );
  if( SfContrID == 0 )
    return false;
  end;*/

  // Проверка по режимам
  //!!!Seleznev режим - не Лоанс не интегрированный а Фронт и все делается там
/*  if( OV_GetOverdraftProcMode() == RBOV_MODE_INTEGRATED )
    // Проверить договора Loans
    if( not ExistLoansCredit( Payment.PaymentID, Payment.ValueDate, SfContrID, IsPrep, Sum, AccLimit, stat ) )
      SetParm( 3, stat );
      return false; 
    end;
  else
    // Проверить связанные счета
    AccRec.Account       = Payment.FuturePayerAccount;
    AccRec.Code_Currency = Payment.PayerFIID;
    AccRec.Chapter       = CHAPT1;
  
    // Счет овердрафта
    if( GetLinkedObject( OBJROLE_ACC_OVERACC, OBJTYPE_ACCOUNT, UniID( AccRec, OBJTYPE_ACCOUNT ), OBJTYPE_ACCOUNT, LinkAccRec) == 0 )
      if( not GetAccountRecord( LinkAccRec ) )
        return false;
      end;
      if( ( LinkAccRec.Open_Close == "X" ) or ( LinkAccRec.Department != AccDep ) )
        return false;
      end;
    else
      return false;
    end;

    // Внебалансовый счет неиспользованного лимита
    if( GetLinkedObject( OBJROLE_ACC_OVEROBACC, OBJTYPE_ACCOUNT, UniID( AccRec, OBJTYPE_ACCOUNT ), OBJTYPE_ACCOUNT, NotBalAccRec) == 0 )
      if( not GetAccountRecord( NotBalAccRec ) )
        return false;
      end;
      if( ( NotBalAccRec.Open_Close == "X" ) or ( NotBalAccRec.Department != AccDep ) )
        return false;
      end;
    else
      return false;
    end;
  end;*/

  return true;
END;

//-----------------------------------------------------------------------------------------
// Последний выполненный шаг == "Помещение на незавершенные" 
//-----------------------------------------------------------------------------------------
MACRO PM_PrevStepIsAccUnclosed(payment:RsbPayment, id_operation:@integer, id_step:@integer, fact_date:@date):bool
  var rset:object;
  var select:string;
  var params:TArray = TArray();
  var sDocumentID:string = PM_MakeDocumentID( payment.DocKind, payment.DocumentID );

  select = "select step.T_ID_OPERATION, step.t_id_step, step.t_Fact_Date " +
             "from doproper_dbt opr, " +
                  "doprstep_dbt step " +
            "where opr.T_DOCKIND = :DocKind " +
              "and opr.T_DOCUMENTID = :DocumentID " +
              "and step.T_ID_OPERATION = opr.T_ID_OPERATION " +
              "and step.T_ISEXECUTE = 'X'    " +
              "and step.t_Kind_action = :Kind_action "+
              "and step.T_COUNTNUM = ( select max(step_2.T_COUNTNUM) " +
                                        "from doprstep_dbt step_2 " +
                                       "where step_2.T_ID_OPERATION = opr.T_ID_OPERATION )";

  params[params.size] = SQLParam( "DocKind", payment.DocKind );
  params[params.size] = SQLParam( "DocumentID", sDocumentID );
  params[params.size] = SQLParam( "Kind_action", 312/*PM_OPR_KA_TOACCUNCLOSED*/ );

  rset = execSQLselect( select, params, TRUE );
 
  if( rset and rset.moveNext() )
    if( ValType(id_operation) != V_UNDEF)
     id_operation = rset.value(0);
    end;
    if( ValType(id_step) != V_UNDEF)
      id_step = rset.value(1);
    end;
    if( ValType(fact_date) != V_UNDEF)
      fact_date = rset.value(2);
    end;
    return TRUE;
  end;

  return FALSE;
END;

//Получить буфер корсхемы по буферу подтверждения
macro GetCorsByConf(rec_wlconf, rec_cors)

  FILE Corschem( corschem ) key 0;
  FILE Acc( account ) key 0;
  FILE FI ( fininstr ) key 0;

  ClearRecord( Corschem );
  ClearRecord( Acc );
  ClearRecord( FI );

  FI.FIID = rec_wlconf.FIID;
  getEQ( FI );

  if(rec_wlconf.Account != "")
     KeyNum(Corschem, 3);
     Corschem.Account    = rec_wlconf.Account;
     Corschem.FIID       = rec_wlconf.FIID;
     Acc.Account         = rec_wlconf.Account;
     Acc.Code_Currency   = rec_wlconf.FIID;
     Acc.Chapter         = 1;
     if(getEQ(Acc))
       Corschem.Department = Acc.Department;
     else 
       Corschem.Department = {OperDprt};
     end;
  elif(rec_wlconf.Corschem != -1)
     Corschem.Number = rec_wlconf.Corschem;
     Corschem.FIID   = rec_wlconf.FIID;
     Corschem.FI_Kind= FI.FI_Kind;
  end;

  if(getEQ(Corschem))
    copy(rec_cors, Corschem);
    return 0;
  end;

  return 1;

end;

macro CreateConfFlagForCorschem(rec_wlconf)

  FILE Corschem( corschem ) key 0;
  FILE Acc( account ) key 0;
  FILE FI ( fininstr ) key 0;

  ClearRecord( Corschem );
  ClearRecord( Acc );
  ClearRecord( FI );

  FI.FIID = rec_wlconf.FIID;
  getEQ( FI );

  if(rec_wlconf.Account == "")
     Corschem.Number = rec_wlconf.Corschem;
     Corschem.FIID   = rec_wlconf.FIID;
     Corschem.FI_Kind= FI.FI_Kind;
  elif(rec_wlconf.Corschem == -1)
     KeyNum(Corschem, 3);
     Corschem.Account    = rec_wlconf.Account;
     Corschem.FIID       = rec_wlconf.FIID;
     Acc.Account         = rec_wlconf.Account;
     Acc.Code_Currency   = rec_wlconf.FIID;
     Acc.Chapter         = 1;
     if(getEQ(Acc))
       Corschem.Department = Acc.Department;
     else 
       Corschem.Department = {OperDprt};
     end;
  else
     return false;
  end;

  if(getEQ(Corschem))
   if((Corschem.IsNostro == "") and (Corschem.CreateConfirmation == "X"))
     return true;
   end;
  end;

  return false;

end;

//------------------------------------------------------------------------------------------
MACRO GetNodeList( ParentNode, Mode, List )
  var select;
  var params:TArray = TArray();
  VAR rs:RsdRecordset;

  List[List.size] = ParentNode;
  if( Mode == 1 )
    select = " select T_Code" +
             " from ddp_dep_dbt" +
             " where  t_NodeType = 2" +     // тип узла - ВСП
               " and  t_Status = 2" +       // статус - активен
               " and  t_AccessMode = 1"+    // ЦАБС
               " and  t_ParentCode = :ParentCode";
    params = makeArray(SQLParam( "ParentCode", ParentNode ));
    
    rs = execSQLselect( select, params, TRUE );
    
    while( rs.moveNext() )
       GetNodeList(rs.value(0), Mode, List);
    end;
  end;
END;

//Есть ли арест на дебет у счета?
macro IsArestDebetAcc(Account, FIID):bool
  record AccRec("account.dbt");
  
  AccRec.Chapter       = 1;
  AccRec.Account       = Account;
  AccRec.Code_Currency = FIID;

  if( GetAccountRecord( AccRec ) and Index(AccRec.Type_Account, "Т"))
    return true;
  end;
  return false;
end;


// Направление в картотеку ожидания разрешения
// Проверка для одного счета
private macro CheckAccount_IWP( Account:string, FIID:integer, ClaimID:integer, ValueDate:date, Priority:integer, 
                                PayType:integer, IsAfterCheckAccRest:integer )
  
  return execStoredFunc( "RSI_PM_PREPRO.CheckAccount_IWP", V_STRING, MakeArray( SQLParam( "p_Account"  , Account   ),
                                                                            SQLParam( "p_FIID"     , FIID      ),
                                                                            SQLParam( "p_Claim"    , ClaimID   ),
                                                                            SQLParam( "p_ValueDate", ValueDate ),
                                                                            SQLParam( "p_Priority" , Priority  ),
                                                                            SQLParam( "p_PayType"  , PayType   ),
                                                                            SQLParam( "p_IsAfterCheckAccRest", IsAfterCheckAccRest )
                                                                          ) ) == "X";
end;

// Направление в картотеку ожидания разрешения
macro IsGotoIWP( Payment:RsbPayment, IsAfterCheckAccRest:bool )
  
  var cmd, rs;
  var IsArest : bool = false;
  var IsNext = 0;
  var _IsAfterCheckAccRest : integer;

  if( IsAfterCheckAccRest )
    _IsAfterCheckAccRest = 1;
  else
    _IsAfterCheckAccRest = 0;
  end;
  
  var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );

  if( (Payment.DocKind != PS_PAYORDER) and (Payment.DocKind != DLDOC_BANKORDER) )
    return false;
  end;

  if( (Payment.PIList(PRT_Debet).Size > 0) and (Payment.PIList(PRT_Debet).First() == 0) )
    while( (not IsArest) and (IsNext == 0) and (Payment.PIList(PRT_Debet).Current(pi) == 0) )
      IsArest = CheckAccount_IWP( pi.rec.Account, pi.rec.FIID, Payment.ClaimID, Payment.ValueDate, Payment.Priority, Payment.PayType, _IsAfterCheckAccRest );
      IsNext = Payment.PIList(PRT_Debet).Next;
    end;
  else
    IsArest = CheckAccount_IWP( Payment.PayerAccount, Payment.PayerFIID, Payment.ClaimID, Payment.ValueDate, Payment.Priority, Payment.PayType, _IsAfterCheckAccRest );
  end;

  return IsArest;
end;
  
/* Найти привязку платежа к ТО */
macro FindSfInvLnkByPaymentID( PaymentID:integer, InvoiceID:@integer ):integer

  var stat = 1;

  var select:string  = "SELECT  DISTINCT sf.t_InvoiceID          "+
                       "  FROM dsfinvlnk_dbt sf,                 "+
                       "       dpmpaym_dbt   paym                "+
                       " WHERE sf.t_PaymentID = :PaymentID       "+
                       "   AND sf.t_PaymentID = paym.t_PaymentID ";

  var params:TArray  = makeArray( SQLParam("PaymentID", PaymentID) );

  var rs:object = execSQLselect( select, params, FALSE );

  if( rs AND rs.moveNext() ) 

    InvoiceID = rs.value(0);
    if( not rs.moveNext() ) /* привязка должна быть только одна */
      stat = 0; 
    end;

  end;
  return stat;

end;

// Документ имеет привязку к ТО или связан с единовременной комиссией
macro IsSfCommPayment( Payment:RsbPayment ):bool
  
  var InvoiceId = 0;

  return ( (Payment.DefComID != 0) and 
           ( (Payment.FeeType == 1) or (Payment.FeeType == 3) or (Payment.FeeType == 6) or (Payment.FeeType == 9) )) 
         or 
         ( (FindSfInvLnkByPaymentID(Payment.PaymentID, @InvoiceId) == 0) and (InvoiceId != 0) );
end;

//-----------------------------------------------------------------------------
// Получить сумму, зарезервированную на счете для данного платежа
//-----------------------------------------------------------------------------
macro GetClaimSum( Payment:RsbPayment )

  var select:string;
  var params:TArray;
  var rs    :object;
  var result = $0;

  select = " select COALESCE( SUM( state.t_currentamount ), 0 ) AS Summa  " +
           " from   dacclaimstate_dbt  state,  " +
           "        dacclaim_dbt       claim,  " +
           "        dacclmdoc_dbt      cldoc   " +
           " where  cldoc.t_DocKind    =  :DocKind " +
           "   and  cldoc.t_DocumentID =  :DocumentID " +
           "   and  claim.t_ClaimID    =  cldoc.t_ClaimID " +
           "   and  claim.t_Account    =  :Account " +
           "   and  claim.t_FIID       =  :FIID    " +
           "   and  claim.t_Chapter    =  :Chapter " +
           "   and  claim.t_ClaimKind  =  3 " +
           "   and  claim.t_StartDate  <= :StartDate " +
           "   and  ( claim.t_FinishDate = to_date('01-01-0001', 'DD-MM-YYYY') " +
           "        or claim.t_FinishDate <= :FinishDate ) " +
           "   and  state.t_ClaimID    =  claim.t_ClaimID " +
           "   and  state.t_State      =  1 " +
           "   and  state.t_StateDate  <= :StateDate ";

  params = makeArray( SQLParam( "DocKind"   , Payment.DocKind      ),
                      SQLParam( "DocumentID", Payment.PaymentID    ),
                      SQLParam( "Account"   , Payment.FuturePayerAccount ),
                      SQLParam( "FIID"      , Payment.PayerFIID    ),
                      SQLParam( "Chapter"   , Payment.Chapter      ),
                      SQLParam( "StartDate" , {curdate}            ),
                      SQLParam( "FinishDate", {curdate}            ),
                      SQLParam( "StateDate" , {curdate}            ));
  rs     = execSQLselect( select, params, FALSE );
  
  if( rs AND rs.moveNext() ) 
    result = rs.value(0);
  else
    result = $0;
  end;

  return result;
end;
  
//-----------------------------------------------------------------------------
// Счет является корсчетом из корсхемы ЛОРО ?
//-----------------------------------------------------------------------------
macro IsLoroAccount( Корсчет, Валюта ):bool
  var rs:object;
  var select:string;
  var params:TArray;

  select = "select cors.t_Number " + 
             "from dcorschem_dbt cors " +
            "where cors.t_Account = :CorAccount " +
              "and cors.t_FIID = :FIID " +
              "and cors.t_IsNostro = chr(0) ";

  params = makeArray( SQLParam("CorAccount", Корсчет), SQLParam("FIID", Валюта) );

  if( existsSQLselect(select, params) )
    return true;
  end;

  return false;
end;

//-----------------------------------------------------------------------------
// Определить лимиты корсчета по корсхеме
//-----------------------------------------------------------------------------
macro GetLimits( Корсчет:string, Валюта:integer, МинЛимит:@money, МаксЛимит:@money ):bool
  var rs:object;
  var select:string;
  var params:TArray;

  select = "select cors.t_MinLimit, cors.t_MaxLimit " + 
             "from dcorschem_dbt cors " +
            "where cors.t_Account = :CorAccount " +
              "and cors.t_FIID = :FIID ";

  params = makeArray( SQLParam("CorAccount", Корсчет), SQLParam("FIID", Валюта) );

  rs = execSQLselect( select, params, false );
  
  if( rs AND rs.moveNext() )
    МинЛимит  = rs.value(0);
    МаксЛимит = rs.value(1);
    return true;
  else
    МинЛимит  = 0;
    МаксЛимит = 0;
    return false;
  end;
end;

//------------------------------------------------------------------------------
// Является ли документ дочерним транзитного
//------------------------------------------------------------------------------
macro IsChildTranzitOrigin( Payment:RsbPayment ):bool
  var obj:object = NULL;
  
  if( ( Payment.DocKind == DLDOC_BANKPAYMENT ) or ( Payment.DocKind == DLDOC_BANKCLAIM ) )
    if( Payment.DocKind == DLDOC_BANKPAYMENT )
      obj = GenObject( "RsbBankPayment", Payment.DocumentID );
    else
      obj = GenObject( "RsbBankClaim", Payment.DocumentID );
    end;
    return (obj.Origin == MEMORDER_FDOC_TRANZIT);
  elif( Payment.DocKind == BBANK_CPORDER )
    obj = GenObject( "RsbBbCpOrder", Payment.DocumentID );
    return (obj.Origin == CP_OR_TRANZIT);
  end;

  return false;
end;

//----------------------------------------------------------------------------
// Проверить наличие документов в очереди и в картотеку ЛОРО
//----------------------------------------------------------------------------
macro ДокументВочередь( Account:string ):bool
  var SelectStr:string;
  var params   :TArray;
  var rs       :object;

  SelectStr = "select pm.t_PaymentID " +
              "  from dpmpaym_dbt pm, "
                    " doproper_dbt opr, "
                    " doprcurst_dbt curst," +
                    " doprstep_dbt step" +
              " where opr.t_DocumentID = lpad(pm.t_PaymentID, 34, '0') " +
                " and curst.t_ID_Operation = opr.t_ID_Operation " +
                " and (curst.t_StatusKindID = :StatusKindID_1 and curst.t_NumValue = :Value_1 or" +
                "      curst.t_StatusKindID = :StatusKindID_2 and curst.t_NumValue = :Value_2 ) " +
                " and pm.t_FuturePayerAccount = :FuturePayerAccount " +
                " and opr.t_DocKind in (:DocKind_1, :DocKind_2, :DocKind_3, :DocKind_4) " +
                " and step.t_ID_Operation = opr.t_ID_Operation " +
                " and step.t_IsExecute = 'R' " +
                " and step.t_Symbol in ('Л', 'd') ";

  params = makeArray( SQLParam("StatusKindID_1", OPR_PAYM_DO),
                      SQLParam("Value_1", OPR_PM_ST_PRIORITY),
                      SQLParam("StatusKindID_2", OPR_PAYM_INDEX),
                      SQLParam("Value_2", OPR_PAYM_ST_INDEX_LORO),
                      SQLParam("FuturePayerAccount", Account),
                      SQLParam("DocKind_1", WL_INDOC),
                      SQLParam("DocKind_2", DLDOC_MEMORIALORDER),
                      SQLParam("DocKind_3", CB_MULTYDOC),
                      SQLParam("DocKind_4", DLDOC_SUMMARY_MEMORDER)
                    );

  if( existsSQLselect(SelectStr, params) )
    return true;
  end;

  return false;
end;

// Платеж создан в модуле "Проценты"
macro IsPrcPayment( PaymentObj:RsbPayment ):bool

  var objFDoc;

  if( PaymentObj.PrimDocOrigin == PD_OR_PERCENT )
    return true;
  end;

  if( ( PaymentObj.DocKind == DLDOC_MEMORIALORDER ) )                  /* Мемордера                   */

    objFDoc = GenObject( "RsbMemorialOrder", PaymentObj.DocumentID );
    return ( objFDoc.Origin == CB_DOC_ORIGIN_PERCENT );

  elif( ( PaymentObj.DocKind == CB_MULTYDOC       ) )                  /* Мультивалютные документы    */

    objFDoc = GenObject( "RsbMultyDoc", PaymentObj.DocumentID );
    return ( objFDoc.Origin == MULTYDOC_ORIGIN_PERCENT );

  elif( ( PaymentObj.DocKind == DLDOC_BANKPAYMENT ) )                  /* Рублевые платежи ББ         */

    objFDoc = GenObject( "RsbBankPayment", PaymentObj.DocumentID );
    return ( objFDoc.Origin == MEMORDER_FDOC_PERCENT );

  elif( ( PaymentObj.DocKind == BBANK_CPORDER     ) )                  /* Валютные платежи ББ         */

    objFDoc = GenObject( "RsbBbCpOrder", PaymentObj.DocumentID );
    return ( objFDoc.Origin == CP_OR_PERCENT );

  elif( ( PaymentObj.DocKind == PS_PAYORDER       ) )                  /* Рублевые платежи РКО        */

    objFDoc = GenObject( "RsbPsPayOrder", PaymentObj.DocumentID );
    return ( objFDoc.Origin == CP_OR_PERCENT );

  elif( ( PaymentObj.DocKind == PS_CPORDER        ) )                  /* Валютные платежи РКО        */

    objFDoc = GenObject( "RsbPSCpOrder", PaymentObj.DocumentID );
    return ( objFDoc.Origin == PSPO_OR_PERCENT );

  end;      

  return false;
end;  

//Копирует все примечания платежа из одного платежа в другой
macro CopyPaymentNotes(PaymentDest :RsbPayment, PaymentSrc :RsbPayment)
  var notes = TRecHandler( "notetext" );
  var note_val = null;
  if(not PaymentSrc.Notes.GetFirst(date(0, 0, 0), notes))
    note_val = PaymentSrc.Notes.ReadNote(notes.rec.NoteKind, {curdate});
    PaymentDest.Notes.AddNote(notes.rec.NoteKind, note_val);
    while(not PaymentSrc.Notes.GetNext(notes))
      PaymentDest.Notes.AddNote(notes.rec.NoteKind, PaymentSrc.Notes.ReadNote(notes.rec.NoteKind, {curdate}));
    end;
  end;
end;

//Копирует все категории платежа из одного платежа в другой
macro CopyPaymentCategories(PaymentDest :RsbPayment, PaymentSrc :RsbPayment)
  var cats = TRecHandler( "objattr" );
  if(not PaymentSrc.Categories.GetFirst(0, date(0, 0, 0), cats))
    PaymentDest.Categories.ConnectAttr(cats.rec.GroupID, cats.rec.AttrID, NULL, NULL, {curdate});
    while(not PaymentSrc.Categories.GetNext(cats))
      PaymentDest.Categories.ConnectAttr(cats.rec.GroupID, cats.rec.AttrID, NULL, NULL, {curdate});
    end;
  end;
end;

// Проверка даты старта операции (должна быть меньше либо равна текущему опердню)
macro CheckDateStartOpr(ID_Operation)
  
  var q = "select od.t_Date "
            "from doprdates_dbt od "
            "where OD.T_ID_OPERATION = :ID_Operation "
              "and OD.T_DATEKINDID = 29000000 ";
  var params:TArray = makeArray( SQLParam( "ID_Operation", ID_Operation ) );

  var rs = execSQLselect( q, params, false );

  if( rs and rs.moveNext())
    if(rs.value(0) > {curdate})
      msgbox("Шаг должен выполняться операционным днем не ранее " + date(rs.value(0)));
      return 1;
    end;
  else
    msgbox("Ошибка получения даты старта операции");
    return 1;
  end;

  return 0;
end;

// Изменялся ли документ?
macro PM_WasChanged( PaymentID:integer ):bool

  VAR select:string = " select hist.T_PAYMENTID " +
                      " from  DPMINHIST_DBT hist " +
                      " where hist.T_PAYMENTID = :PaymentID ";
  VAR params:TArray = makeArray( SQLParam( "PaymentID", PaymentID ));
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    return true;
  end;     

  return false;
end;

macro ПолучитьСуммуПретензии( ClaimID )

  VAR query:string = "SELECT clstate.t_CurrentAmount  " +
                     "  FROM dacclaimstate_dbt clstate" +
                     " WHERE clstate.t_ClaimID   = :ClaimID " + 
                     "   AND clstate.t_StateDate = (SELECT max(t.t_StateDate)  " +
                     "                                FROM dacclaimstate_dbt t " +
                     "                               WHERE t.t_ClaimID    =  :ClaimID_t " + 
                     "                                 AND t.t_StateDate <=  :StartDate ) ";

  VAR params:TArray = makeArray( SQLParam( "ClaimID", ClaimID     ),
                                 SQLParam( "ClaimID_t", ClaimID   ),
                                 SQLParam( "StartDate", {curdate} ));

  VAR rs:RsdRecordset = execSQLselect( query, params, TRUE );

  IF( rs and rs.moveNext() )
    return rs.value(0);
  ELSE
    return $0;
  END;

ONERROR(x)
  
  MsgBox( "Ошибка при поиске документа претензии|" + x.Message );
  return $0;

end;

// изменен любой из реквизитов, которые редактируются в панели изменения реквизитов (реквизиты плательщика, 
// реквизиты получателя, номер, основание, реквизиты банка плательщика, реквизиты банка получателя, 
// но не параметры позиционирования)
macro IsEditFields_PmInHist( Pmpaym, OldPmpaym, Pmprop, OldPmprop, Pmrmprop, OldPmrmprop ) 
  
  if( not PM_WasChanged(Pmpaym.PaymentID) )
    return false;
  end;
  
  if( (Pmrmprop.Number != OldPmrmprop.Number) or
      (Pmrmprop.Ground != OldPmrmprop.Ground) or
      (Pmpaym.PayerAccount != OldPmpaym.PayerAccount) or
      (Pmpaym.Payer != OldPmpaym.Payer) or
      (Pmpaym.PayerCodeKind != OldPmpaym.PayerCodeKind) or
      (Pmpaym.PayerCode != OldPmpaym.PayerCode) or
      (Pmrmprop.PayerINN != OldPmrmprop.PayerINN) or
      (Pmrmprop.PayerName != OldPmrmprop.PayerName) or
      (Pmpaym.PayerBankID != OldPmpaym.PayerBankID) or
      (Pmrmprop.PayerBankName != OldPmrmprop.PayerBankName) or
      (Pmpaym.PayerMesBankID != OldPmpaym.PayerMesBankID) or
      (Pmrmprop.ReceiverCorrAccNostro != OldPmrmprop.ReceiverCorrAccNostro) or
      (Pmpaym.ReceiverAccount != OldPmpaym.ReceiverAccount) or
      (Pmpaym.Receiver != OldPmpaym.Receiver) or
      (Pmpaym.ReceiverCodeKind != OldPmpaym.ReceiverCodeKind) or
      (Pmpaym.ReceiverCode != OldPmpaym.ReceiverCode) or
      (Pmpaym.ReceiverCode != OldPmpaym.ReceiverCode) or
      (Pmrmprop.ReceiverINN != OldPmrmprop.ReceiverINN) or
      (Pmrmprop.ReceiverName != OldPmrmprop.ReceiverName) or
      (Pmpaym.ReceiverBankID != OldPmpaym.ReceiverBankID) or
      (Pmpaym.ReceiverMesBankID != OldPmpaym.ReceiverMesBankID) or
      (Pmprop.CodeKind != Pmprop.CodeKind) or
      (Pmprop.BankCode != Pmprop.BankCode) or
      (Pmrmprop.ReceiverBankName != OldPmrmprop.ReceiverBankName) or
      (Pmrmprop.ReceiverCorrAccNostro != OldPmrmprop.ReceiverCorrAccNostro) or
      (Pmrmprop.ReceiverCorrBankName != OldPmrmprop.ReceiverCorrBankName) or
      (Pmrmprop.ReceiverCorrBankName != OldPmrmprop.ReceiverCorrBankName)
    )
    return true;
  end;

  return false;
end;

//Лавренов, перенес из 2029 для совместимости пользовательских макросов
// Проверить наличие более приоритетных документов в КОР и К2
// Возвращает true - есть более приоритетные в Amount сумма
// false - нет
// PaymStatus - определяет картотеку (ОР или 2)
macro IsExistsIndexPaymentWithLargerPriority(PaymStatus:integer, PaymentID:integer, NDate:date, Amount:money )
  
  var Payment:RsbPayment = RsbPayment(PaymentID);
  var IAmount;
  var from = " from dpmpaym_dbt pm, dpmrmprop_dbt rm ";   

  var Priority = 0;
  var PriorityWhere = "";

  PriorityWhere = " rm.t_Priority ";
  Priority = Payment.Priority;

  var where = "where rm.t_PaymentID = pm.t_PaymentID "
                "and pm.t_DocKind in ( 201, 203 ) "
                "and pm.t_PaymStatus = :status "
                "and pm.t_FuturePayerAccount = :acc "
                "and pm.t_FIID_FuturePayAcc = :fiid "
                "and (     " + PriorityWhere + " < :pr1 "
                       "or " + PriorityWhere + " = :pr2 and pm.t_ValueDate < :Date1 "
                       "or " + PriorityWhere + " = :pr3 and pm.t_ValueDate = :Date2 and pm.t_PaymentID < :PaymentID  ) ";
  
  var params:TArray = makeArray( SQLParam( "status"      , PaymStatus                 ), 
                                 SQLParam( "acc"         , Payment.FuturePayerAccount ),
                                 SQLParam( "fiid"        , Payment.FuturePayerFIID    ),
                                 SQLParam( "pr1"         , Priority                   ),
                                 SQLParam( "pr2"         , Priority                   ),
                                 SQLParam( "Date1"       , Payment.ValueDate          ),
                                 SQLParam( "pr3"         , Priority                   ),
                                 SQLParam( "Date2"       , Payment.ValueDate          ),
                                 SQLParam( "PaymentID"   , Payment.PaymentID          ) );
  
  
  // Для К2 не надо учитывать приостановленые документы
  if(PaymStatus == PM_I2PLACED)
    from = from + ", dnotetext_dbt nt ";

    where = where + "and nt.t_DocumentID(+) = lpad(pm.t_PaymentId, 10, '0') " +
                    "and nt.t_ObjectType(+) = 501 " +
                    "and nt.t_notekind(+) = 40 " +
                    "and nt.t_ValidToDate(+) = to_date('31.12.9999') " +
                    "and (    decode(nt.t_text, NULL, to_date('01.01.0001'), rsb_struct.getdate(nt.t_text)) > :Date3 " +
                          "or decode(nt.t_text, NULL, to_date('01.01.0001'), rsb_struct.getdate(nt.t_text)) = to_date('01.01.0001')) ";

    params[params.size] = SQLParam( "NDate" , NDate );
  end;

  var rs = execSQLselect( "select NVL(sum(pm.t_FuturePayerAmount), 0)  " + from + where, params, false );
  
  if( rs and rs.moveNext() and (rs.value(0) > 0))
    SetParm( 3, rs.value(0) );
    return true;
  end;
  return false;
  
end;



/* EVG 26/07/2011 Добавил новые функции из дистрибутивного pm_common.mac */



// Проверить наличие в КОР документов с тем же счетом плательщика и с 
// такой же или более высокой очередностью 
macro CheckPmIWPPlaced( Account, FIID, Priority, ValueDate, Strong )

  var  params:TArray;
  var  rs:object;
  var  i;
  array str1, str2, str3, str4;

  params = makeArray( SQLParam( "p_FIID"     , FIID        ),
                      SQLParam( "p_Account"  , Account     ),
                      SQLParam( "p_Priority" , Priority    ),
                      SQLParam( "p_Date"     , ValueDate   ),
                      SQLParam( "p_Strong"   , Strong      )
                    );

  if(execStoredFunc( "PM_RESTFUN.CheckIndexWPWithPriority", V_INTEGER, params ) > 0)
    return true;
  end;

  return false;

end;

macro CheckPmIWPPlaced_ByObj( Payment:RsbPayment, Strong )

  var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );
  var IsExist = false;
  var IsNext = 0;
  var Priority = 0;
  var CheckDate = IfThenElse( Payment.PayerBankEnterDate == date(0,0,0), Payment.ValueDate, Payment.PayerBankEnterDate );
   
  if({ResidentCountryCode} == "RUS")
    Priority = IfThenElse(Payment.Priority == 3, 4, Payment.Priority);
  else
    Priority = Payment.Priority;
  end;

  if( (Payment.PIList(PRT_Debet).Size > 0) and (Payment.PIList(PRT_Debet).First() == 0) )
    while( (not IsExist) and (IsNext == 0) and (Payment.PIList(PRT_Debet).Current(pi) == 0) )
      IsExist = CheckPmIWPPlaced( pi.rec.Account, pi.rec.FIID, Priority,  CheckDate, Strong );
      IsNext = Payment.PIList(PRT_Debet).Next;
    end;
  else
    IsExist = CheckPmIWPPlaced( Payment.PayerAccount, Payment.PayerFIID, Priority, CheckDate, Strong );
  end;
  
  return IsExist;

end;


// Проверить наличие в Картотеке №2 документов с тем же счетом плательщика и с 
// такой же или более высокой очередностью 
macro CheckPmI2Placed( Account, FIID, Priority, ValueDate, Strong )

  var  params:TArray;
  var  rs:object;
  var  i;
  array str1, str2, str3, str4;

  params = makeArray( SQLParam( "p_FIID"      , FIID         ),
                      SQLParam( "p_Account"   , Account      ),
                      SQLParam( "p_Priority"  , Priority     ),
                      SQLParam( "p_ValueDate" , ValueDate    ),
                      SQLParam( "p_Strong"    , Strong       )
                    );

  if(execStoredFunc( "PM_RESTFUN.CheckIndex2WithPriority", V_INTEGER, params ) > 0)
    return true;
  end;

  return false;

end;

macro CheckPmI2Placed_ByObj( Payment:RsbPayment, Strong )

  var pi:TRecHandler = TRecHandler( "pmaddpi.dbt" );
  var IsExist = false;
  var IsNext = 0;
  var Priority = 0;
  var CheckDate = IfThenElse( Payment.PayerBankEnterDate == date(0,0,0), Payment.ValueDate, Payment.PayerBankEnterDate );
   
  if({ResidentCountryCode} == "RUS")
    Priority = IfThenElse(Payment.Priority == 3, 4, Payment.Priority);
  else
    Priority = Payment.Priority;
  end;

  if( (Payment.PIList(PRT_Debet).Size > 0) and (Payment.PIList(PRT_Debet).First() == 0) )
    while( (not IsExist) and (IsNext == 0) and (Payment.PIList(PRT_Debet).Current(pi) == 0) )
      IsExist = CheckPmI2Placed( pi.rec.Account, pi.rec.FIID, Priority,  CheckDate, Strong );
      IsNext = Payment.PIList(PRT_Debet).Next;
    end;
  else
    IsExist = CheckPmI2Placed( Payment.PayerAccount, Payment.PayerFIID, Priority, CheckDate, Strong );
  end;
  
  return IsExist;

end;

macro IsSetPsBCNumber( Payment:RsbPayment )
  var ReqOrder;
  if( Payment.DocKind == PS_INRQ )
    ReqOrder = GenObject( "RsbRequestOrder", Payment.PaymentID );
    return ReqOrder.PsBCNumber != "";
  end;
  return false;
end;

// Получить вид документа из списка параметров, к которому относится DocKind
// (равен или подчинен)
// Если DocKind не относится ни к одному виду из списка параметров, вернет 0
macro GetParentOrEqualDocKindFromList(DocKind):integer
  var ParentDocKind = 0;

  var query = "SELECT t_DocKind " +
              "  FROM doprkdoc_dbt " +
              " WHERE t_DocKind IN ( ";
  var parm : integer, i = 1;
  while( GetParm(i, parm) )
    if( i > 1 )
      query = query + ", ";
    end;
    query = query + string(parm);
    i = i + 1;
  end;
  query = query + "                ) " +
              "START WITH t_DocKind = " + DocKind + " " +
              "CONNECT BY t_DocKind = PRIOR t_ParentDocKind ";
  var rs = execSQLselect(query);
  if( rs and rs.moveNext() )
    ParentDocKind = rs.value("t_DocKind");
  end;

  return ParentDocKind;
end;

// Существует запись в curdate.dbt, где t_CurDate = Day, t_Branch = Department ?
// да  - возвращает true, t_IsBalance, t_IsClosed
// нет - возвращает false
macro existsOperDay(Day:date, Department:integer, IsBalance:@string, IsClosed:@string):bool
  var rs = execSQLselect( "select t_IsBalance, t_IsClosed " +
                          "  from dcurdate_dbt            " +
                          " where t_CurDate = :Day        " +
                          "   and t_Branch  = :Department ",
                          makeArray( SQLParam("Day",        Day ),
                                     SQLParam("Department", Department) ) 
                        );
  if( rs and rs.moveNext )
    IsBalance = rs.value("t_IsBalance");
    IsClosed = rs.value("t_IsClosed");
    return true;
  end;

  return false;
end;

//определить является ли вид документа дочерним для другого,
//так же возвращает true если DocKind == ParentDocKind
macro IsDocKindChild(DocKind: integer, ParentDocKind: integer): bool
  var sql = "SELECT * FROM (SELECT t_DocKind FROM doprkdoc_dbt "+
                           "CONNECT BY PRIOR t_DocKind = t_ParentDocKind " +
                           "START WITH t_DocKind = "+ParentDocKind+") " +
                    "WHERE t_DocKind = "+DocKind;
  var cmd = execSQLselect(sql);
  return cmd.moveNext();
end;

//определить есть ли претензия резервирования (0 - есть)
macro IsExistsClaimReserve(DocKind: integer, DocumentID: integer): integer
  var params: TArray = makeArray( SQLParam("p_DocKind"   , DocKind),
                                  SQLParam("p_DocumentID", DocumentID )
                                );

  return execStoredFunc( "PM_RESTFUN.IsExistsClaimReserve", V_INTEGER, params);
end;

macro GetPurposeName( Purpose: integer ): string
  var params:TArray = TArray();
  VAR rs:RsdRecordset;
  VAR select = " select t_shortName " +
               " from DPMPURP_DBT " + 
               " where t_purpose = :Purpose ";

  params = makeArray( SQLParam( "Purpose", Purpose ) );
  rs = execSQLselect( select, params, TRUE );

  if( rs and rs.moveNext)
    return rs.value(0);
  end;
  return "";
end;
