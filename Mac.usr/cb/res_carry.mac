/*
$Name: res_carry.mac
$Module: Ядро ГКБО
$Description: Создание проводок при формировании резерва
*/
// KS 03.12.2013 Адаптация под 31ю сборку
// Gurin S. 07.12.2015 HotFix 2031.19.25 (Life_1 1.3)_6
// Gurin S. 07.12.2015 HotFix 2031.19.25 (Life_1 1.3)_7

Import BankInter, InsCarryDoc, "acc_cls.mac", "case_cls.mac", "res_lib.mac", "res_const.mac", rsd;

private const ReserveCatCode = "Резерв, л/с";
private const IncomeCatCode  = "+РС";
private const OutlayCatCode  = "-РС";

/* Документ сервисной операции лицевого счета */
record AccOprServDoc( "accopsrv.dbt" );

/* Рассчитанные резервы */
var ReserveLoss     : money; /* РВП  */
var ReserveLoans    : money; /* РВПС */
var ReserveOffshore : money; /* РОФШ */

/* Порядковый номер проводки */
var Numb_Document : integer;

/* Данные протокола */
var CarryLog : TArray;
var OpenResAccountsLog : TArray;
var CloseResAccountsLog : TArray;

/* порядковый номер проводки */
private macro SetNumbDocument()
  Numb_Document = Numb_Document + 1;
  return string( Numb_Document );
end;

/* пачка проводок резерва */
private macro ReserveCarry_NumberPack()
  var NumberPack = 0;
  GetRegistryValue( "CB\\РЕЗЕРВЫ\\НОМЕР ПАЧКИ", V_INTEGER, NumberPack, null );
  return NumberPack;
end;

/* добавить запись об открытии счета резерва в протокол */
private macro AddToLogOpenResAccount( NameObject : string, ReserveAccount : string )
  var LogRecord = TArray;

  LogRecord[0] = NameObject;
  LogRecord[1] = ReserveAccount;

  OpenResAccountsLog[OpenResAccountsLog.Size()] = LogRecord;

end;

/* добавить запись о закрытии счета резерва в протокол */
private macro AddToLogCloseResAccount( NameObject : string, ReserveAccount : string )
  var LogRecord = TArray;

  LogRecord[0] = NameObject;
  LogRecord[1] = ReserveAccount;

  CloseResAccountsLog[CloseResAccountsLog.Size()] = LogRecord;

end;

/* добавить запись об открытии счета резерва в протокол */
private macro AddToLogCarry( accTrn : RsbAccTransaction )
  var LogRecord = TArray;

  LogRecord[0] = accTrn.Numb_Document;
  LogRecord[1] = accTrn.AccountPayer;
  LogRecord[2] = accTrn.AccountReceiver;
  LogRecord[3] = accTrn.Sum;

  CarryLog[CarryLog.Size()] = LogRecord;

end;

/*удалить проводку на счет резерва*/
macro _DeleteCarryAndSubCarry(AccTrnID, SubSumArhDoc : @money)
  file accsubdc("accsubdc.dbt") key 0;
  record accsubdc_old("accsubdc.dbt");
  var query, rs;
  var params : TArray;
  var stat = true;
  SubSumArhDoc = $0;
  query =         "SELECT dc.t_subcarryid, an.t_account, pay.t_subaccountcode, rec.t_subaccountcode ";
  query = query + "  FROM daccsubdc_dbt dc ";
  query = query + "  JOIN daccvanl_dbt an ON (dc.t_accanaliticsid = an.t_accanaliticsid) ";
  query = query + "  JOIN daccsub_dbt pay ON (dc.t_accanaliticsid = pay.t_accanaliticsid AND dc.t_subaccountpayerid = pay.t_subaccountid) ";
  query = query + "  JOIN daccsub_dbt rec ON (dc.t_accanaliticsid = rec.t_accanaliticsid AND dc.t_subaccountreceiverid = rec.t_subaccountid) ";
  query = query + " WHERE dc.t_AccTrnID = :AccTrnID ";
  params = makeArray(SQLParam("AccTrnID", AccTrnID)
                    );
  rs = execSQLselect(query, params, true);
  while(rs and rs.moveNext() and stat)
    accsubdc.SubCarryID = rs.value(0);
    if(getEQ(accsubdc))
      Copy(accsubdc_old, accsubdc);
      if((rs.value(2) == RsvCreditSubAccName) or (rs.value(2) == RsvDebetSubAccName))
        SubSumArhDoc = SubSumArhDoc + accsubdc_old.Sum;
      else
        SubSumArhDoc = SubSumArhDoc - accsubdc_old.Sum;
      end;
    end;
  end;                         
  if(stat)
    stat = Opr_DeleteCarry(AccTrnID);
  end;
  return stat;
end;

/*удалить проводку на счет резерва*/
macro _DeleteCarry( Chapter, DateCarry, Currency, AccPayer, AccReceiver, SumArhDoc : @money )
  var query, rs;
  var params : TArray;
  SumArhDoc = $0;
  query =         "SELECT t_AccTrnID, t_Sum_Payer ";
  query = query + "  FROM dacctrn_dbt ";
  query = query + " WHERE t_State = 1 ";
  query = query + "   AND t_Account_Receiver = :AccountReceiver ";
  query = query + "   AND t_FIID_Receiver = :FIIDReceiver ";
  query = query + "   AND t_Account_Payer = :AccountPayer ";
  query = query + "   AND t_FIID_Payer = :FIIDPayer ";
  query = query + "   AND t_Chapter = :Chapter ";
  query = query + "   AND t_Date_Carry = :DateCarry ";
  query = query + "   AND t_Result_Carry = :ResultCarry ";
  params = makeArray(SQLParam("AccountReceiver", AccReceiver)
                    ,SQLParam("FIIDReceiver", Currency)
                    ,SQLParam("AccountPayer", AccPayer)
                    ,SQLParam("FIIDPayer", Currency)
                    ,SQLParam("Chapter", Chapter)
                    ,SQLParam("DateCarry", DateCarry)
                    ,SQLParam("ResultCarry", INPCARRY)
                    );
  rs = execSQLselect(query, params, true);
  while(rs and rs.moveNext())
    SumArhDoc = SumArhDoc + money(rs.value(1));
    if( not Opr_DeleteCarry(rs.value(0)))
      return false;
    end;
  end;                         
  return true;
end;

/*удалить проводку на счет резерва*/
macro _DeleteCarryStep( Chapter, DateCarry, Currency, AccPayer, AccReceiver, BlockID, SumArhDoc : @money, SubSumArhDoc : @money )
  var query, rs;
  var params : TArray;
  SumArhDoc = $0;
  SubSumArhDoc = $0;
  query =         "SELECT t_AccTrnID, t_Sum_Payer ";
  query = query + "  FROM dacctrn_dbt ";
  query = query + " WHERE t_State = 1 ";
  query = query + "   AND t_Account_Receiver = :AccountReceiver ";
  query = query + "   AND t_FIID_Receiver = :FIIDReceiver ";
  query = query + "   AND t_Account_Payer = :AccountPayer ";
  query = query + "   AND t_FIID_Payer = :FIIDPayer ";
  query = query + "   AND t_Chapter = :Chapter ";
  query = query + "   AND t_Date_Carry = :DateCarry ";
  query = query + "   AND t_Result_Carry = :ResultCarry ";
  query = query + "   AND t_AccTrnID IN ( ";
  query = query + "          SELECT t_AccTrnID ";
  query = query + "            FROM doprdocs_dbt ";
  query = query + "           WHERE (t_ID_Operation, t_ID_Step) IN ( ";
  query = query + "                    SELECT t_ID_Operation, t_ID_Step ";
  query = query + "                      FROM doprstep_dbt ";
  query = query + "                     WHERE t_BlockID = :BlockID ";
  query = query + "                    ) ";
  query = query + "             AND t_DocKind = :DocKind ";
  query = query + "          ) ";
  params = makeArray(SQLParam("AccountReceiver", AccReceiver)
                    ,SQLParam("FIIDReceiver", Currency)
                    ,SQLParam("AccountPayer", AccPayer)
                    ,SQLParam("FIIDPayer", Currency)
                    ,SQLParam("Chapter", Chapter)
                    ,SQLParam("DateCarry", DateCarry)
                    ,SQLParam("ResultCarry", INPCARRY)
                    ,SQLParam("BlockID", BlockID)
                    ,SQLParam("DocKind", DLDOC_CARRY)
                    );
  rs = execSQLselect(query, params, true);
  while(rs and rs.moveNext())
    SumArhDoc = SumArhDoc + money(rs.value(1));
    if( not _DeleteCarryAndSubCarry(rs.value(0), @SubSumArhDoc))
      return false;
    end;
  end;                         
  return true;
end;


/* открытие счета через категории учета */
macro _OpenAccount( objPrimDoc : ReservePrimdoc, CodeCat : string, DateReserve : date ) : string

  var Account : string;

  Account = objPrimDoc.FindAndOpenAccount( CodeCat, DateReserve );

  if( Trim(Account) == "" )
    msgbox( "Ошибка при открытии счета" );
    return "";
  end;

  return Account;

end;


/*
 * Открытие счета резерва
 */
macro OpenReserveAccount( objPrimDoc : ReservePrimdoc, DateReserve : date ) : string

  var IsOpen : integer;
  var ReserveAccount : string;

  ReserveAccount = objPrimDoc.FindAndOpenAccount( ReserveCatCode, DateReserve, @IsOpen );

  if( Trim(ReserveAccount) == "" )
    msgbox( "Ошибка при определении счета резерва" );

    return "";
  end;

  if( IsOpen )
    AddToLogOpenResAccount( objPrimDoc.NameObject(), ReserveAccount );
  end;

  return ReserveAccount;

end;

/*
 * Поиск счета резерва
 */
macro FindReserveAccount( objPrimDoc : ReservePrimdoc, DateReserve : date ) : string
  return objPrimDoc.FindAccount( ReserveCatCode, DateReserve );
end;

/*
 * Закрытие счета резерва
 */
macro CloseReserveAccount( objPrimDoc : ReservePrimdoc, DateReserve : date ) : string
  var IsClose : integer;
  var ReserveAccount : string;

  ReserveAccount = objPrimDoc.FindAndCloseAccount( ReserveCatCode, DateReserve, @IsClose );

  if( Trim(ReserveAccount) == "" )
    msgbox( "Ошибка при определении счета резерва" );
    return "";
  end;

  if( IsClose )
    AddToLogCloseResAccount( objPrimDoc.NameObject(), ReserveAccount );
  end;

  return ReserveAccount;
end;

/* Открытие одного субсчета */
private macro _OpenSubAccount( SubAccountCode, Chapter, FIID, Account )

  record accsub(accsub);

  ClearRecord( accsub );
  accsub.SubAccountCode = SubAccountCode;
  accsub.SubAccountID   = ACCSUB_SPECTYPE_NONE;
  accsub.SpecialType    = ACCSUB_SPECTYPE_NONE;
  accsub.Status         = ACCSUB_STATE_OPENED;

  if( not Opr_InsertAccSub(SYS_ANL_ACCRESERVE, Account, FIID, Chapter, null, accsub) )
    msgbox( "Ошибка при открытии субсчета " + "\"" + SubAccountCode + "\"");

    return false;
  end;

  return true;

end;

/*
 * Открытие субсчетов на счете резерва
 */
macro OpenSubAccounts( ReserveAccount : string, RsvLossClass : string, RsvLoansClass : string ) : bool

  var stat = true;

  if( stat and RsvLossClass  ) _OpenSubAccount( RsvSubAccName     , BalanceChapter, NATCUR, ReserveAccount ); end;
  if( stat and RsvLoansClass ) _OpenSubAccount( RsvLoansSubAccName, BalanceChapter, NATCUR, ReserveAccount ); end;
  
  if( stat ) _OpenSubAccount( RsvOffshoreSubAccName, BalanceChapter, NATCUR, ReserveAccount ); end;

  return stat;

end;

/*
 * Открытие субсчетов на счете резерва
 */
macro OpenSubAccountsEx( ReserveAccount : string, RsvLossClass : integer, RsvLoansClass : integer ) : bool

  var stat = true;

  if( stat and RsvLossClass and RsvLoansClass ) 
    _OpenSubAccount( RsvSubAccName     , BalanceChapter, NATCUR, ReserveAccount );
    _OpenSubAccount( RsvLoansSubAccName, BalanceChapter, NATCUR, ReserveAccount ); 
  end;
  
  return stat;

end;

/* выполнить проводку */
private macro _RunCarry( accTrn : RsbAccTransaction, ReserveAccount : string, Department :integer ) : bool

  if( (accTrn.AccountPayer == "") or (accTrn.AccountReceiver == "") )
    return false;
  end;

  accTrn.Numb_Document = SetNumbDocument();
  accTrn.Number_Pack   = ReserveCarry_NumberPack();
  accTrn.Department    = Department;
  //Тихомиров. Доработка для ПРББ
  
  accTrn.Kind_Oper     = " 6"; //добавить эту строку
  accTrn.Shifr_Oper    = "09"; //эту строку не обязательно добавлять

  if( not accTrn.Carry() )
    msgbox( "Ошибка при выполнении проводки" );
    return false;
  end;

  AddToLogCarry( accTrn );

  return true;

end;

/* выполнить проводку по субсчетам */
private macro _RunSubCarry( accTrn : RsbAccTransaction, ReserveAccount : string, SubAccName : string ) : bool

  record accsubdc( "accsubdc.dbt" );

  ClearRecord( accsubdc );
  accsubdc.AccTrnID   = accTrn.AccTrnID;
  accsubdc.Date_Carry = accTrn.Date_Carry;
  accsubdc.Sum        = accTrn.Sum;
  accsubdc.Status     = ACSDC_FACT;

  if( not Opr_InsertAccSubDocumentEx(null, SYS_ANL_ACCRESERVE, ReserveAccount, SubAccName, accsubdc) )
    msgbox( "Ошибка при выполнении проводки по субсчетам" );

    return false;
  end;

  return true;

end;

private macro _RunSubCarryEx( Date_Carry : date, Sum : money, Account : string, Code_Currency : integer, Chapter : integer, SubAccPay : string, SubAccRec : string ) : bool
  var _SubAccPay = SubAccPay;
  var _SubAccRec = SubAccRec;

  record accsubdc( "accsubdc.dbt" );

  ClearRecord( accsubdc );
  accsubdc.Date_Carry       = Date_Carry;
  accsubdc.Sum              = abs(Sum);
  accsubdc.Status           = ACSDC_FACT;
  if(Sum < $0)
    _SubAccPay = SubAccRec;
    _SubAccRec = SubAccPay;
  end;
  if( not Opr_InsertAccSubDocument(null, SYS_ANL_ACCRESERVE, Account, Code_Currency, Chapter, _SubAccPay, _SubAccRec, accsubdc) )
    msgbox( "Ошибка при выполнении проводки по субсчетам" );

    return false;
  end;

  return true;

end;

/* сформировать основание для проводки РВП */
private macro GetAddGroundReserveLoss( objPrimDoc : ReservePrimdoc, DateReserve : date )
  var GroupRisk : string;
  var ReserveProcent : double;
  var AddGround : string;

  AddGround = "по " + objPrimDoc.GetObjParam();
  
  GroupRisk = objPrimDoc.GetGroupRisk();
  if( GroupRisk )
    AddGround = AddGround + ", группа риска " + GroupRisk;
  end;

  ReserveProcent = objPrimDoc.GetReserveProcent();
  if( ReserveProcent )
    AddGround = AddGround + ", процент резервирования " + ReserveProcent + "%";
  end;

  return AddGround;

end;

/* сформировать основание для проводки РВПС */
private macro GetAddGroundReserveLoans( objPrimDoc : ReservePrimdoc, DateReserve : date )
  var GroupRisk : string;
  var ReserveProcent : double;
  var AddGround : string;

  AddGround = "по " + objPrimDoc.GetObjParam();
  
  GroupRisk = objPrimDoc.GetGroupRisk();
  if( GroupRisk )
    AddGround = AddGround + ", группа риска " + GroupRisk;
  end;

  ReserveProcent = objPrimDoc.GetReserveProcent();
  if( ReserveProcent )
    AddGround = AddGround + ", процент резервирования " + ReserveProcent + "%";
  end;

  return AddGround;

end;

/* сформировать основание для проводки РВПС */
private macro GetAddGroundReserveLoansOffshore( objPrimDoc : ReservePrimdoc, DateReserve : date )
  var GroupRisk : string;
  var ReserveProcent : double;
  var AddGround : string;

  AddGround = "по " + objPrimDoc.GetObjParam();
  
  ReserveProcent = objPrimDoc.GetReserveProcent();
  if( ReserveProcent )
    AddGround = AddGround + ", процент резервирования " + ReserveProcent + "%";
  end;

  return AddGround;

end;


/* сформировать основание для проводки РОФШ */
private macro GetAddGroundReserveOffshore( objPrimDoc : ReservePrimdoc, DateReserve : date )
  var GroupRisk : string;
  var ReserveProcent : double;
  var AddGround : string;

  AddGround = "по " + objPrimDoc.GetObjParam();
  
  ReserveProcent = objPrimDoc.GetReserveProcentOffshore();
  if( ReserveProcent )
    AddGround = AddGround + ", процент резервирования " + ReserveProcent + "%";
  end;

  return AddGround;

end;

/*
 * Создание проводок резерва на возможные потери
 */
macro CreateReserveLossCarry( objPrimDoc : ReservePrimdoc, DateReserve : date, ReserveAccount : string, IncomeCatCodePrm : string, OutlayCatCodePrm : string )
  var RestReserveAccount : money;
  var accTrn : RsbAccTransaction;
  var stat : bool;
  var Department : integer;

  var SumOutlayCat : money;
  var SumIncomeCat : money;

  stat = true;

  /* Остаток на счете резерва */
  RestReserveAccount = GetAbsAccRest( ReserveAccount, DateReserve, BalanceChapter );
  
  if(( RestReserveAccount > $0 ) and ( ReserveLoss != RestReserveAccount ))
    
    stat = _DeleteCarry( BalanceChapter, DateReserve, NATCUR, _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve ), ReserveAccount, @SumOutlayCat );
    if( not stat ) return stat; end;
    stat = _DeleteCarry( BalanceChapter, DateReserve, NATCUR, ReserveAccount, _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve ), @SumIncomeCat );
    if( not stat ) return stat; end;

    RestReserveAccount = RestReserveAccount - SumOutlayCat + SumIncomeCat;
  end;

  accTrn = RsbAccTransaction;

  accTrn.Chapter    = BalanceChapter;
  accTrn.FIID       = NATCUR;
  accTrn.Date_Carry = DateReserve;
  accTrn.Sum        = $0;
  Department = objPrimDoc.GetDepartment();

  if( (RestReserveAccount == $0) and (ReserveLoss > $0) ) /* формирование РВП */

    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoss;
    accTrn.Ground = "Формирование резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);

  elif( (RestReserveAccount > $0) and (ReserveLoss == $0) ) /* восстановление РВП */

    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveAccount;
    accTrn.Ground = "Восстановление резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);

  elif( (RestReserveAccount > $0) and (ReserveLoss > RestReserveAccount) ) /* доначисление РВП */

    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoss - RestReserveAccount;
    accTrn.Ground = "Доначисление резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);

  elif( (RestReserveAccount > $0) and (ReserveLoss < RestReserveAccount) ) /* списание РВП */

    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveAccount - ReserveLoss;
    accTrn.Ground = "Списание резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);

  end;

  /* Если указали сумму проводки, то проводим */
  if( Round(accTrn.Sum) )
    stat = _RunCarry( accTrn, ReserveAccount, Department );
  end;

  return stat;

end;

/*
 * Создание проводок резерва на возможные потери по счетам
 */
macro CreateReserveLossCarryAcc( objPrimDoc : ReservePrimdoc, DateReserve : date, ReserveAccount : string, IncomeCatCodePrm : string, OutlayCatCodePrm : string )
  var RestReserveAccount            : money;
  var RestReserveSubAccount         : money;
  var RestReserveLoansSubAccount    : money;
  var RestReserveOffshoreSubAccount : money;
  var accTrn : RsbAccTransaction;
  var stat : bool;
  var Department : integer;
  var SumOutlayCat : money; //Сумма удаленных проводок по счету
  var SumIncomeCat : money; //Сумма удаленных проводок по счету
  var SubSumOutlayCat : money; //Сумма удаленных проводок по субсчету
  var SubSumIncomeCat : money; //Сумма удаленных проводок по субсчету
  stat = true;
  /* Остаток на счете резерва и его субсчетах */
  RestReserveAccount            = GetAbsAccRest( ReserveAccount, DateReserve, BalanceChapter );
  RestReserveSubAccount         = GetAbsRestSubAccount( RsvSubAccName, ReserveAccount, DateReserve );
  RestReserveLoansSubAccount    = GetAbsRestSubAccount( RsvLoansSubAccName, ReserveAccount, DateReserve );
  RestReserveOffshoreSubAccount = GetAbsRestSubAccount( RsvOffshoreSubAccName, ReserveAccount, DateReserve );
  /*Если до DateReserve уже были сформированы резервы, но разноска по субсчетам была другой,
    то спишем резерв на сумму остатка на субсчете прежднего вида резерва на субсчет неразнесенных сумм*/
  if(RestReserveLoansSubAccount > $0)
    stat = _RunSubCarryEx( DateReserve, RestReserveLoansSubAccount, ReserveAccount, NATCUR, BalanceChapter, RsvLoansSubAccName, RsvSubAccName );
    if( not stat ) return stat; end;
    RestReserveSubAccount = RestReserveSubAccount + RestReserveLoansSubAccount;
    RestReserveLoansSubAccount = 0;
  end;
  /* удаляем проводку в текущем опердне по формированию РВП */
  if((RestReserveAccount > $0) and (ReserveLoss != RestReserveSubAccount))
    stat = _DeleteCarryStep( BalanceChapter, DateReserve, NATCUR, _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve ), ReserveAccount, BlockIdAccReserveLoss, @SumOutlayCat, @SubSumOutlayCat );
    if( not stat ) return stat; end;
    stat = _DeleteCarryStep( BalanceChapter, DateReserve, NATCUR, ReserveAccount, _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve ), BlockIdAccReserveLoss, @SumIncomeCat, @SubSumIncomeCat );
    if( not stat ) return stat; end;
    RestReserveAccount = RestReserveAccount - SumOutlayCat + SumIncomeCat;
    RestReserveSubAccount = RestReserveSubAccount - SubSumOutlayCat + SubSumIncomeCat;
  end;
  /*Если до DateReserve уже были сформированы резервы, но без учета разноски по субсчетам,
    то зачислим на субсчет вида резерва сумму остатка со субсчета неразнесенных сумм*/
  /*Если при удалении проводок по счетам и субсчетам в текущем дне суммы этих проводок различны,
    то зачислим на субсчет вида резерва сумму остатка со субсчета неразнесенных сумм*/
  if((RestReserveAccount - RestReserveSubAccount - RestReserveOffshoreSubAccount) != $0)
    stat = _RunSubCarryEx( DateReserve, RestReserveAccount - RestReserveSubAccount - RestReserveOffshoreSubAccount, ReserveAccount, NATCUR, BalanceChapter, RsvCreditSubAccName, RsvSubAccName );
    if( not stat ) return stat; end;
    RestReserveSubAccount = RestReserveAccount - RestReserveOffshoreSubAccount;
  end;
  accTrn = RsbAccTransaction;
  accTrn.Chapter    = BalanceChapter;
  accTrn.FIID       = NATCUR;
  accTrn.Date_Carry = DateReserve;
  accTrn.Sum        = $0;
  Department = objPrimDoc.GetDepartment();
  if((RestReserveSubAccount == $0) and (ReserveLoss > $0)) /* формирование РВП */
    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoss;
    accTrn.Ground = "Формирование резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);
  elif((RestReserveSubAccount > $0) and (ReserveLoss == $0)) /* восстановление РВП */
    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveSubAccount;
    accTrn.Ground = "Восстановление резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);
  elif((RestReserveSubAccount > $0) and (ReserveLoss > RestReserveSubAccount)) /* доначисление РВП */
    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoss - RestReserveSubAccount;
    accTrn.Ground = "Доначисление резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);
  elif((RestReserveSubAccount > $0) and (ReserveLoss < RestReserveSubAccount)) /* списание РВП */
    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveSubAccount - ReserveLoss;
    accTrn.Ground = "Списание резерва на возможные потери " + GetAddGroundReserveLoss(objPrimDoc, DateReserve);
  end;
  /* Если указали сумму проводки, то проводим */
  if( Round(accTrn.Sum) )
    stat = _RunCarry( accTrn, ReserveAccount, Department );
    /* выполняем проводку по субсчетам */
    if( stat )
      stat = _RunSubCarry( accTrn, ReserveAccount, RsvSubAccName );
    end;
  end;
  return stat;
end;

/*
 * Создание проводок резерва по операциям с резидентами офшорных зон
 */
macro CreateReserveOffshoreCarry( objPrimDoc : ReservePrimdoc, DateReserve : date, ReserveAccount : string )
  var RestSubAccount : money;
  var Ground : string;
  var accTrn : RsbAccTransaction;
  var stat : bool;
  var Department : integer;
  stat = true;

  /* Остаток на субсчете */
  RestSubAccount = GetAbsRestSubAccount( RsvOffshoreSubAccName, ReserveAccount, DateReserve );

  accTrn = RsbAccTransaction;

  accTrn.Chapter    = BalanceChapter;
  accTrn.FIID       = NATCUR;
  accTrn.Date_Carry = DateReserve;
  accTrn.Sum        = $0;
  Department  = objPrimDoc.GetDepartment();

  if( (RestSubAccount == $0) and (ReserveOffshore > $0) ) /* формирование РОФШ */

    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCode, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveOffshore;
    accTrn.Ground = "Формирование резерва по операциям с резидентами офшорных зон "
                   + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);

  elif( (ReserveOffshore == $0) and (RestSubAccount != $0) ) /* восстановление РОФШ */

    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCode, DateReserve );
    accTrn.Sum             = RestSubAccount;
    accTrn.Ground = "Восстановление резерва по операциям с резидентами офшорных зон "
                   + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);

  elif( (RestSubAccount > $0) and (ReserveOffshore > RestSubAccount) ) /* доначисление РОФШ */

    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCode, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveOffshore - RestSubAccount;
    accTrn.Ground = "Доначисление резерва по операциям с резидентами офшорных зон "
                   + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);

  elif( (RestSubAccount > $0) and (ReserveOffshore < RestSubAccount) ) /* списание РОФШ */

    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCode, DateReserve );
    accTrn.Sum             = RestSubAccount - ReserveOffshore;
    accTrn.Ground = "Списание резерва по операциям с резидентами офшорных зон "
                   + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);

  end;

  /* Если указали сумму проводки, то проводим */
  if( Round(accTrn.Sum) )
    stat = _RunCarry( accTrn, ReserveAccount, Department );
  end;
  
  return stat;

end;

/*
 * Создание проводок резерва по операциям с резидентами офшорных зон
 */
macro CreateReserveOffshoreCarryAcc( objPrimDoc : ReservePrimdoc, DateReserve : date, ReserveAccount : string, IncomeCatCodePrm : string, OutlayCatCodePrm : string )
  var RestReserveAccount            : money;
  var RestReserveSubAccount         : money;
  var RestReserveLoansSubAccount    : money;
  var RestReserveOffshoreSubAccount : money;
  var Ground : string;
  var accTrn : RsbAccTransaction;
  var stat : bool;
  var Department : integer;
  var SumOutlayCat : money; //Сумма удаленных проводок по счету
  var SumIncomeCat : money; //Сумма удаленных проводок по счету
  var SubSumOutlayCat : money; //Сумма удаленных проводок по субсчету
  var SubSumIncomeCat : money; //Сумма удаленных проводок по субсчету
  stat = true;
  /* Остаток на счете резерва и его субсчетах */
  RestReserveAccount            = GetAbsAccRest( ReserveAccount, DateReserve, BalanceChapter );
  RestReserveSubAccount         = GetAbsRestSubAccount( RsvSubAccName, ReserveAccount, DateReserve );
  RestReserveLoansSubAccount    = GetAbsRestSubAccount( RsvLoansSubAccName, ReserveAccount, DateReserve );
  RestReserveOffshoreSubAccount = GetAbsRestSubAccount( RsvOffshoreSubAccName, ReserveAccount, DateReserve );
  /* удаляем проводку в текущем опердне по формированию РОФШ */
  if((RestReserveAccount > $0) and (ReserveOffshore != RestReserveOffshoreSubAccount))
    stat = _DeleteCarryStep( BalanceChapter, DateReserve, NATCUR, _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve ), ReserveAccount, BlockIdAccReserveOffshore, @SumOutlayCat, @SubSumOutlayCat );
    if( not stat ) return stat; end;
    stat = _DeleteCarryStep( BalanceChapter, DateReserve, NATCUR, ReserveAccount, _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve ), BlockIdAccReserveOffshore, @SumIncomeCat, @SubSumIncomeCat );
    if( not stat ) return stat; end;
    RestReserveAccount = RestReserveAccount - SumOutlayCat + SumIncomeCat;
    RestReserveOffshoreSubAccount = RestReserveOffshoreSubAccount - SubSumOutlayCat + SubSumIncomeCat;
  end;
  /*Если до DateReserve уже были сформированы резервы, но без учета разноски по субсчетам,
    то зачислим на субсчет вида резерва сумму остатка со субсчета неразнесенных сумм*/
  /*Если при удалении проводок по счетам и субсчетам в текущем дне суммы этих проводок различны,
    то зачислим на субсчет вида резерва сумму остатка со субсчета неразнесенных сумм*/
  if((RestReserveAccount - RestReserveSubAccount - RestReserveLoansSubAccount - RestReserveOffshoreSubAccount) != $0)
    stat = _RunSubCarryEx(DateReserve, RestReserveAccount - RestReserveSubAccount - RestReserveLoansSubAccount - RestReserveOffshoreSubAccount, ReserveAccount, NATCUR, BalanceChapter, RsvCreditSubAccName, RsvOffshoreSubAccName);
    if( not stat ) return stat; end;
    RestReserveOffshoreSubAccount = RestReserveAccount - RestReserveSubAccount - RestReserveLoansSubAccount;
  end;
  accTrn = RsbAccTransaction;
  accTrn.Chapter    = BalanceChapter;
  accTrn.FIID       = NATCUR;
  accTrn.Date_Carry = DateReserve;
  accTrn.Sum        = $0;
  Department  = objPrimDoc.GetDepartment();
  if((RestReserveOffshoreSubAccount == $0) and (ReserveOffshore > $0)) /* формирование РОФШ */
    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveOffshore;
    accTrn.Ground = "Формирование резерва по операциям с резидентами офшорных зон " + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);
  elif((RestReserveOffshoreSubAccount > $0) and (ReserveOffshore == $0)) /* восстановление РОФШ */
    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveOffshoreSubAccount;
    accTrn.Ground = "Восстановление резерва по операциям с резидентами офшорных зон " + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);
  elif((RestReserveOffshoreSubAccount > $0) and (ReserveOffshore > RestReserveOffshoreSubAccount)) /* доначисление РОФШ */
    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveOffshore - RestReserveOffshoreSubAccount;
    accTrn.Ground = "Доначисление резерва по операциям с резидентами офшорных зон " + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);
  elif((RestReserveOffshoreSubAccount > $0) and (ReserveOffshore < RestReserveOffshoreSubAccount)) /* списание РОФШ */
    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveOffshoreSubAccount - ReserveOffshore;
    accTrn.Ground = "Списание резерва по операциям с резидентами офшорных зон " + GetAddGroundReserveOffshore(objPrimDoc, DateReserve);
  end;
  /* Если указали сумму проводки, то проводим */
  if( Round(accTrn.Sum) )
    stat = _RunCarry( accTrn, ReserveAccount, Department );
    /* выполняем проводку по субсчетам */
    if( stat )
      stat = _RunSubCarry( accTrn, ReserveAccount, RsvOffshoreSubAccName );
    end;
  end;
  return stat;
end;

/*
 * Создание проводок резерва на возможные потери по ссудам
 */
macro CreateReserveLoansCarry( objPrimDoc : ReservePrimdoc, DateReserve : date, ReserveAccount : string, IncomeCatCodePrm : string, OutlayCatCodePrm : string )
  var RestReserveAccount : money;
  var Ground : string;
  var accTrn : RsbAccTransaction;
  var stat : bool;
  var Department : integer;

  var SumOutlayCat : money;
  var SumIncomeCat : money;

  Ground = "";

  stat = true;

  /* Остаток на счете резерва */
  RestReserveAccount = GetAbsAccRest( ReserveAccount, DateReserve, BalanceChapter );

  if(( RestReserveAccount > $0 ) and ( ReserveLoans != RestReserveAccount ))
    
    stat = _DeleteCarry( BalanceChapter, DateReserve, NATCUR, _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve ), ReserveAccount, @SumOutlayCat );
    if( not stat ) return stat; end;
    stat = _DeleteCarry( BalanceChapter, DateReserve, NATCUR, ReserveAccount, _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve ), @SumIncomeCat );
    if( not stat ) return stat; end;

    RestReserveAccount = RestReserveAccount - SumOutlayCat + SumIncomeCat;
  end;

  accTrn = RsbAccTransaction;

  accTrn.Chapter    = BalanceChapter;
  accTrn.FIID       = NATCUR;
  accTrn.Date_Carry = DateReserve;
  accTrn.Sum        = $0;
  Department = objPrimDoc.GetDepartment();

  if( (RestReserveAccount == $0) and (ReserveLoans > $0) ) /* формирование РВПС */

    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoans;
    accTrn.Ground = "Формирование резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);

  elif( (RestReserveAccount > $0) and (ReserveLoans == $0) ) /* восстановление РВПС */

    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveAccount;
    accTrn.Ground = "Восстановление резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);

  elif( (RestReserveAccount > $0) and (ReserveLoans > RestReserveAccount) ) /* доначисление РВПС */

    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoans - RestReserveAccount;
    accTrn.Ground = "Доначисление резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);

  elif( (RestReserveAccount > $0) and (ReserveLoans < RestReserveAccount) ) /* списание РВПС */

    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveAccount - ReserveLoans;
    accTrn.Ground = "Списание резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);

  end;

  /* Если указали сумму проводки, то проводим */
  if( Round(accTrn.Sum) )
    stat = _RunCarry( accTrn, ReserveAccount, Department );
  end;

  return stat;

end;

/*
 * Создание проводок резерва на возможные потери по ссудам по счетам
 */
macro CreateReserveLoansCarryAcc( objPrimDoc : ReservePrimdoc, DateReserve : date, ReserveAccount : string, IncomeCatCodePrm : string, OutlayCatCodePrm : string )
  var RestReserveAccount            : money;
  var RestReserveSubAccount         : money;
  var RestReserveLoansSubAccount    : money;
  var RestReserveOffshoreSubAccount : money;
  var accTrn : RsbAccTransaction;
  var stat : bool;
  var Department : integer;
  var SumOutlayCat : money; //Сумма удаленных проводок по счету
  var SumIncomeCat : money; //Сумма удаленных проводок по счету
  var SubSumOutlayCat : money; //Сумма удаленных проводок по субсчету
  var SubSumIncomeCat : money; //Сумма удаленных проводок по субсчету
  stat = true;
  /* Остаток на счете резерва и его субсчетах */
  RestReserveAccount            = GetAbsAccRest( ReserveAccount, DateReserve, BalanceChapter );
  RestReserveSubAccount         = GetAbsRestSubAccount( RsvSubAccName, ReserveAccount, DateReserve );
  RestReserveLoansSubAccount    = GetAbsRestSubAccount( RsvLoansSubAccName, ReserveAccount, DateReserve );
  RestReserveOffshoreSubAccount = GetAbsRestSubAccount( RsvOffshoreSubAccName, ReserveAccount, DateReserve );
  /*Если до DateReserve уже были сформированы резервы, но разноска по субсчетам была другой,
    то спишем резерв на сумму остатка на субсчете прежднего вида резерва на субсчет неразнесенных сумм*/
  if(RestReserveSubAccount > $0)
    stat = _RunSubCarryEx( DateReserve, RestReserveSubAccount, ReserveAccount, NATCUR, BalanceChapter, RsvSubAccName, RsvLoansSubAccName );
    if( not stat ) return stat; end;
    RestReserveLoansSubAccount = RestReserveLoansSubAccount + RestReserveSubAccount;
    RestReserveSubAccount = 0;
  end;
  /* удаляем проводку в текущем опердне по формированию РВП */
  if((RestReserveAccount > $0) and (ReserveLoans != RestReserveLoansSubAccount))
    stat = _DeleteCarryStep( BalanceChapter, DateReserve, NATCUR, _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve ), ReserveAccount, BlockIdAccReserveLoans, @SumOutlayCat, @SubSumOutlayCat );
    if( not stat ) return stat; end;
    stat = _DeleteCarryStep( BalanceChapter, DateReserve, NATCUR, ReserveAccount, _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve ), BlockIdAccReserveLoans, @SumIncomeCat, @SubSumIncomeCat );
    if( not stat ) return stat; end;
    RestReserveAccount = RestReserveAccount - SumOutlayCat + SumIncomeCat;
    RestReserveLoansSubAccount = RestReserveLoansSubAccount - SubSumOutlayCat + SubSumIncomeCat;
  end;
  /*Если до DateReserve уже были сформированы резервы, но без учета разноски по субсчетам,
    то зачислим на субсчет вида резерва сумму остатка со субсчета неразнесенных сумм*/
  /*Если при удалении проводок по счетам и субсчетам в текущем дне суммы этих проводок различны,
    то зачислим на субсчет вида резерва сумму остатка со субсчета неразнесенных сумм*/
  if((RestReserveAccount - RestReserveLoansSubAccount - RestReserveOffshoreSubAccount) != $0)
    stat = _RunSubCarryEx( DateReserve, RestReserveAccount - RestReserveLoansSubAccount - RestReserveOffshoreSubAccount, ReserveAccount, NATCUR, BalanceChapter, RsvCreditSubAccName, RsvLoansSubAccName );
    if( not stat ) return stat; end;
    RestReserveLoansSubAccount = RestReserveAccount - RestReserveOffshoreSubAccount;
  end;
  accTrn = RsbAccTransaction;
  accTrn.Chapter    = BalanceChapter;
  accTrn.FIID       = NATCUR;
  accTrn.Date_Carry = DateReserve;
  accTrn.Sum        = $0;
  Department = objPrimDoc.GetDepartment();
  if((RestReserveLoansSubAccount == $0) and (ReserveLoans > $0)) /* формирование РВПС */
    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoans;
    accTrn.Ground = "Формирование резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);
  elif((RestReserveLoansSubAccount > $0) and (ReserveLoss == $0)) /* восстановление РВПС */
    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveLoansSubAccount;
    accTrn.Ground = "Восстановление резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);
  elif((RestReserveLoansSubAccount > $0) and (ReserveLoss > RestReserveSubAccount)) /* доначисление РВПС */
    accTrn.AccountPayer    = _OpenAccount( objPrimDoc, OutlayCatCodePrm, DateReserve );
    accTrn.AccountReceiver = ReserveAccount;
    accTrn.Sum             = ReserveLoans - RestReserveLoansSubAccount;
    accTrn.Ground = "Доначисление резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);
  elif((RestReserveLoansSubAccount > $0) and (ReserveLoss < RestReserveSubAccount)) /* списание РВПС */
    accTrn.AccountPayer    = ReserveAccount;
    accTrn.AccountReceiver = _OpenAccount( objPrimDoc, IncomeCatCodePrm, DateReserve );
    accTrn.Sum             = RestReserveLoansSubAccount - ReserveLoans;
    accTrn.Ground = "Списание резерва на возможные потери по ссудам " + GetAddGroundReserveLoans(objPrimDoc, DateReserve);
  end;
  /* Если указали сумму проводки, то проводим */
  if( Round(accTrn.Sum) )
    stat = _RunCarry( accTrn, ReserveAccount, Department );
    /* выполняем проводку по субсчетам */
    if( stat )
      stat = _RunSubCarry( accTrn, ReserveAccount, RsvLoansSubAccName );
    end;
  end;
  return stat;
end;

private macro _CaseAdditionalCarry( accBuff, DateCarry : date, ID_Operation : integer, DateReserve : date )
  record accReserveBuff("account.dbt");
  var ReserveAccount : string;
  var RestAcc : money;
  var accPD : AccountPrimdoc;
  var accTrn : RsbAccTransaction;
  var stat = true;
  var Department : integer; 

  accPD = AccountPrimdoc( accBuff, ID_Operation );

  ReserveAccount = CB_GetAccountReserve( accBuff );
  if( Trim(ReserveAccount) != "" )

    if( GetAccountRecord(accReserveBuff, 1, ReserveAccount, NATCUR) )
      
      RestAcc = GetAbsAccRest( accReserveBuff.Account, DateReserve, accReserveBuff.Chapter );
      if( RestAcc )
        
        accTrn = RsbAccTransaction;

        accTrn.Chapter         = 1;
        accTrn.FIID            = NATCUR;
        accTrn.Date_Carry      = DateReserve;
        accTrn.Sum             = RestAcc;
        accTrn.AccountPayer    = ReserveAccount;
        accTrn.AccountReceiver = _OpenAccount( accPD, IncomeCatCode,  DateReserve );
        accTrn.Ground          = "Восстановление резерва " + GetAddGroundReserveLoss(accPD, DateReserve);
        Department = accBuff.Department;

        stat = _RunCarry( accTrn, NULL, Department );

      end;
    
    end;

  end;

  return stat;

end;

/* Дополнительные проводки */
macro CreateCaseAdditionalCarry( accase, ID_Operation : integer, DateReserve : date )
  record accBuff(account);
  var accArray : TArray;
  var i, N;
  var stat = true;

  accArray = TArray;

  CreateCaseAccountArray( accase, accArray, DateReserve );

  N = accArray.Size();
  i = 0;

  while( (stat) and (i < N) )

    if( GetAccountRecord(accBuff, accArray(i).Chapter, accArray(i).Account, accArray(i).Code_Currency) )
      stat = _CaseAdditionalCarry( accBuff, accArray(i).DateInclude, ID_Operation, DateReserve );
    end;

    i = i + 1;
  
  end;

  return stat;

end;
