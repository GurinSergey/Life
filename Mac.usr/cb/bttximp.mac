/*========================================================================*/
/*         Автоматизированная банковская система RS-Bank                  */
/*                 Copyright (c) R-Style Software Lab 2004                */
/*  Имя файла        : bttximp.mac                                        */
/*  Описание         : Макрос импорта кодов классификаторов               */
/*  Программист      : Смирнов С., Копачев Д.                             */
/*  Создан           : 11.11.2004                                         */
/*  Изменен          : Gurin S. 19.03.2013 возможность загрузки с локала  */
/*========================================================================*/

import likepy, oralib;
import FIInter;                                                                                                                                            
import globals, rsexts, BankInter, rcw, rsd;
import "lib_registry.mac";

/*---------------- переменные -----------------------------*/

private var ErrMes:string = ""; /* Сюда пишем сообщения об ошибках */
var temppath  = RSL_GetRegistryValue ("BANK_INI/ОБЩИЕ ПАРАМЕТРЫ/ДИРЕКТОРИИ/TEXTDIR");
var fullPath, directory, fileExtension, NameFile, synchr, tmp;

/*
 Уровень детализации протокола.
 Возможные значения:
   0 - выводить только ошибки
   1 - выводить ошибки и предуреждения 
   2 - выводить всё
*/
private var LevelDetailedProtocol:integer = 2; /* по умолчанию */

private file ImpFile() txt;     /* Исходный текстовый файл   */

private const BT_TXY_TAG_TI = "TI", 
              BT_TXY_TAG_LIB = "LIB";       


/*========================================================================================*/
/* Получить первый пользовательский номер                                                                                       */
/*========================================================================================*/
MACRO GetFirstUserNumber( tag:string ):integer
  var query:string = "SELECT txy.t_firstusernumber FROM dbt_txy_dbt txy WHERE txy.t_tag = :tag";
  var params:TArray = makeArray( SQLParam("tag", tag) );

  var rs:RsdRecordset = execSQLselect( query, params, true );
  if( rs and rs.moveNext() )
    return int(rs.value(0));
  end;
  return 0;
END;


/*========================================================================================*/
/* Получить последнее максимальное значение ID из bt_tx.dbt                               */
/*========================================================================================*/
MACRO GetBttxMaxID( tag:string ):integer
  var BttxMaxID:integer = 0; /* Последнее максимальное значение ID из bt_tx.dbt */
  var firstusernumber:integer = 0;
  var strcmd:string = "select coalesce(max(t.t_id),0) from dbt_tx_dbt t ";
  
  firstusernumber = GetFirstUserNumber(tag);
  
  if( firstusernumber != 0 )
    strcmd = strcmd + " WHERE t.t_id <= :firstusernumber";
  end;

  var query:string = strcmd;
  var params:TArray = TArray();
  
  if( firstusernumber != 0 )
    params = makeArray( SQLParam("firstusernumber", firstusernumber) );
  end;

  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and rs.moveNext )
     BttxMaxID = int(rs.value(0));
  end;

  BttxMaxID = (BttxMaxID + 1);
  
  return BttxMaxID;
END;

/*========================================================================================*/
/* Запись системная                                                                       */
/*========================================================================================*/
MACRO IsSystemID( ID:integer, tag:string ):BOOL
   var firstusernumber:integer = 0;

   firstusernumber = GetFirstUserNumber(tag);
   
   if( (firstusernumber == 0) or (ID<firstusernumber) ) return TRUE; 
   else                                                 return FALSE; 
   end;
   
END;

/*========================================================================================*/
/* Получить идентификатор классификатора                                                  */
/*========================================================================================*/
MACRO GetTaxonomy( tag:string ):integer
  var query:string = "SELECT t.t_id FROM dbt_txy_dbt t WHERE t.t_tag = :tag ";
  var params:TArray = makeArray( SQLParam("tag", tag) );
  var rs:RsdRecordset = execSQLselect( query, params, true );

  if( rs and  rs.moveNext )
     return int(rs.value(0));
  end;

  return 0;
end;

/*========================================================================================*/
/* Удалить все системные записи классификатора TI, у которых нет подчиненных              */
/* пользовательских записей любого уровня вложенности.                                    */
/*========================================================================================*/
MACRO DeleteAllSystemTI( )
  var strcmd:string;
  var firstusernumber:integer = 0;
  
  // Найдем первый пользовательский номер
  firstusernumber = GetFirstUserNumber( BT_TXY_TAG_TI );
  
  // Удали дерево
  if( firstusernumber == 0 )
    strcmd = "delete from( " +
             " select * from dbt_tx_dbt tx1 " +
             " where tx1.T_TAXONOMY = " + GetTaxonomy(BT_TXY_TAG_TI) + ")"; 
  else
    strcmd = "delete from( " +
             " select * from dbt_tx_dbt tx1 " +
             " where tx1.T_TAXONOMY = " + GetTaxonomy(BT_TXY_TAG_TI) + " and tx1.t_ID < 1000001 " +
             " and not exists (select * " +
             "                 from dbt_tx_dbt tx2 " +
             "                 where tx2.T_ID >= 1000001"+
             "                 connect by prior tx2.T_ID = tx2.t_Superior"+
             "                 start with tx2.t_Superior = tx1.T_ID))";
  end;

  execSQL(strcmd);

END;


/*========================================================================================*/
/* Поиск вышестоящей записи классификатора по первым N символам кода                      */
/*========================================================================================*/
MACRO FindUpRecordBttx(Taxonomy:integer, Code:string):integer
  var fbttx1:TBFile = TBFile( "bt_tx.dbt", "W", 1 );
  var Superior:integer = 0;
  var ok:bool;
  /*
  1. Найти вышестоящую запись классификатора по первым N символам кода.
    1.1. Если вышестоящая запись не найдена, то создать ее автоматически с искомым кодом 
         и пустым наименованием, подчиненной записи более верхнего уровня в соответствии с кодом. 
         Алгоритм создания вышестоящей записи должен быть рекурсивным до самого верхнего уровня. 
         Для каждой автоматичести созданной записи вывести в протокол предупреждение 
         "Запись с кодом %s создана автоматически.".
  2.  Добавить новую запись классификатора, как подчиненную найденной. В протокол выдать 
      сообщение "Добавлена новая запись классификатора TI".
  */
  var hierarchy_level:integer = strlen(Code);
  var LenCode:integer = 0;
  var UpCode:string = "";

  if  ( hierarchy_level == 20 ) LenCode = 6;      
  elif( hierarchy_level == 6  ) LenCode = 4;
  elif( hierarchy_level == 4  ) LenCode = 3;
  else                          return Superior;
  end;
  if( LenCode == 0 ) return Superior; end;
  
  UpCode = SubStr(Code, 1, LenCode);
  if( UpCode == "" ) return Superior; end;

  fbttx1.rec.Taxonomy = Taxonomy;
  fbttx1.rec.Code     = UpCode;
  if( fbttx1.GetEQ( ) ) /* найдена */
    Superior = fbttx1.rec.ID;
  else /* не найдена */
    Superior = FindUpRecordBttx(Taxonomy, UpCode);
    /* создать */
    fbttx1.Clear();
    fbttx1.rec.ID       = GetBttxMaxID(BT_TXY_TAG_TI);
    fbttx1.rec.Taxonomy = Taxonomy;
    fbttx1.rec.Code     = UpCode;
    fbttx1.rec.Note     = "";
    fbttx1.rec.Superior = Superior;
    ok = fbttx1.Insert( );
    if( ok )
      if( (LevelDetailedProtocol == 1) or (LevelDetailedProtocol == 2) )
        ErrMes = ErrMes + "Внимание! Запись с кодом " + UpCode + " создана автоматически. ";
      end;
      Superior = fbttx1.rec.ID;
    else
      ErrMes = ErrMes + "Ошибка! Запись с кодом " + UpCode + " автоматически не создана. ";
      Superior = 0;
    end;
  end;

  return Superior;
END;

/*========================================================================================*/
/* Обработка строки импортируемого файла                                                  */
/*========================================================================================*/
MACRO ProcessRecord(str_line, NameCode:@string, Taxonomy:integer)

  var fbttx1:TBFile = TBFile( "bt_tx.dbt", "W", 1 );
  var ok:bool;                      
  var words:TArray = filter( split( replace(str_line, "\t", " "), " " ) );
  var Code = words[0]; /* код доходов */
  var Note = join(subArray(words,1), " "); /* наименование видов доходов */
  var hierarchy_level:integer = StrLen(Code); /* уровень иерархии */
  var Superior:integer = 0;
  NameCode = Code;
  
/*
  1.  Определить уровень иерархии для текущей записи по длине кода: 
  1.1.  Длина кода==3 - Администратор доходов (1 уровень)
  1.2.  Длина кода==4 - Группа доходов (2 уровень)
  1.3.  Длина кода==6 - Подгруппа доходов (3 уровень)
  1.4.  Длина кода==20  - Вид доходов (4 уровень)
  1.5.  Иначе выдать в протокол ошибку "Неверная длина кода." и перейти к следующей строке файла.
*/    
  if( (hierarchy_level != 3) and (hierarchy_level != 4) and 
      (hierarchy_level != 6) and (hierarchy_level != 20) )
    ErrMes = ErrMes + "Ошибка! Неверная длина кода.";
    return;
  end;

  /* Найти в базе запись классификатора с текущим кодом */
  fbttx1.rec.Taxonomy = Taxonomy;
  fbttx1.rec.Code     = Code;
  if( fbttx1.GetEQ( ) ) /* запись существует */
    /* запись системная, обновить ее название */
    if( IsSystemID(fbttx1.rec.ID, BT_TXY_TAG_TI) )
      fbttx1.rec.Note = Note;
      ok = fbttx1.Update( );
      if( ok )
        if( LevelDetailedProtocol == 2 )
          ErrMes = ErrMes + "Обновлена запись классификатора TI. ";
        end;
      else
        ErrMes = ErrMes + "Ошибка! Запись классификатора TI не обновлена. ";
      end;
    else
      if( (LevelDetailedProtocol == 1) or (LevelDetailedProtocol == 2) )
        /* запись пользовательская, выдать предупреждение */
        ErrMes = ErrMes + "Внимание! Классификатор содержит такую запись, введенную пользователем. ";
      end;
    end;

  else /* записи в базе нет */
                     
    Superior = FindUpRecordBttx(Taxonomy, Code);
    fbttx1.Clear( );
    fbttx1.rec.ID       = GetBttxMaxID(BT_TXY_TAG_TI);
    fbttx1.rec.Taxonomy = Taxonomy;
    fbttx1.rec.Code     = Code;
    fbttx1.rec.Note     = Note;
    fbttx1.rec.Superior = Superior;
    
    ok = fbttx1.Insert( );
    if( ok )
      if( LevelDetailedProtocol == 2 )
        ErrMes = ErrMes + "Добавлена новая запись классификатора TI. ";
      end;
    else
      ErrMes = ErrMes + "Ошибка! Новая запись классификатора TI не добавлена. ";
    end;
    
  end;
END;                                    

MACRO ОбработкаИсходногоФайла()
  var numstr:integer = 1;
  var str_line:string = "";
  var Code;
  
  ReWind(ImpFile);
  InitProgress(NRecords(ImpFile), "Пожалуйста подождите...", "Импорт классификатора TI");
  while( Next(ImpFile) )

    str_line = ImpFile.str;
    ErrMes = "";
    
    ProcessRecord(str_line, @Code, GetTaxonomy(BT_TXY_TAG_TI));

    
    [║ ######## ║ #################### ║ ########################################## ║] 
    ( numstr, Code:l:z, ErrMes:w);                             

    numstr = numstr + 1;
    UseProgress(numstr);
  end;
  RemProgress();

END;


MACRO SynchronizeRecLIB( Taxonomy:integer, Code, Note:string )
  var fbttx:TBFile = TBFile( "bt_tx.dbt", "W", 6 );
  
  ErrMes = "";
  fbttx.rec.Taxonomy = Taxonomy;
  fbttx.rec.Superior = 0;
  fbttx.rec.Code     = Code;
  var ok:bool = fbttx.GetEQ( );
  if( ok )
    // обновить название в соответствии с названием текущей записи
    fbttx.rec.Note = Note;
    ok = fbttx.Update( );
    if( ok )
      if( LevelDetailedProtocol == 2 )
        ErrMes = "Обновлена запись классификатора LIB. ";
      end;
    else
      ErrMes = "Ошибка! Запись классификатора LIB не обновлена. ";
    end;
  else
    // вставим ее в соответствии с атрибутами текущей записи
    fbttx.Clear( );
    fbttx.rec.ID       = GetBttxMaxID(BT_TXY_TAG_LIB);
    fbttx.rec.Taxonomy = Taxonomy;
    fbttx.rec.Code     = Code; 
    fbttx.rec.Note     = Note;
    fbttx.rec.Superior = 0;
    ok = fbttx.Insert( );
    if( ok )
      if( LevelDetailedProtocol == 2 )
        ErrMes = "Добавлена новая запись классификатора LIB. ";
      end;
    else
      ErrMes = "Ошибка! Новая запись классификатора LIB не добавлена. ";
    end;
  end;
END;


/*========================================================================================*/
/* Синхронизировать перечень прямых получателей                                           */
/*========================================================================================*/
MACRO SynchronizeLIB( Taxonomy:integer )
  var fbttx6:TBFile = TBFile( "bt_tx.dbt", "R", 6 );

  fbttx6.rec.Taxonomy = Taxonomy;
  fbttx6.rec.Superior = 0;
  fbttx6.rec.Code     = "";
  var ok:bool = fbttx6.GetGE( ) AND (fbttx6.rec.Taxonomy == Taxonomy) AND (fbttx6.rec.Superior == 0);
  while( ok )
    SynchronizeRecLIB( GetTaxonomy(BT_TXY_TAG_LIB), fbttx6.rec.Code, fbttx6.rec.Note );
   
    [║ ### ║ ################################# ║ ################################## ║]
    ( fbttx6.rec.Code, fbttx6.rec.Note, ErrMes:w);   

    ok = fbttx6.Next( ) AND (fbttx6.rec.Taxonomy == Taxonomy) AND (fbttx6.rec.Superior == 0);
  end;

END;


/*========================================================================================*/
/* Процедура импорта кодов классификаторов                                                */
/*========================================================================================*/
MACRO bttx_import(nameimpfile:string, synchronize:integer):integer

 var stat:integer = 0;
 var str_synchr:string = "Да", str_nameimpfile:string = "Загрузка классификатора доходов из файла:";
 if( synchronize == 0 ) str_synchr = "Нет"; end;
 
 if( Open( ImpFile, nameimpfile ) == FALSE ) 
   MsgBox("Ошибка открытия файла: " +  nameimpfile); 
   stat = 1;
   return stat;
 end;
 
 /* Удаление системных записей классификатора TI */
 DeleteAllSystemTI( );

 [ ];
 [############################################# #####################################] (str_nameimpfile, nameimpfile:w);
 [Синхронизировать перечень прямых получателей: ###] (str_synchr);
 [╔══════════╦══════════════════════╦════════════════════════════════════════════╗];
 [║ № строки ║ Код                  ║ Результат обработки                        ║];
 [╠══════════╬══════════════════════╬════════════════════════════════════════════╣];
 /* Обработка импортируемого файла */
 ОбработкаИсходногоФайла();
 [╚══════════╩══════════════════════╩════════════════════════════════════════════╝];

 if( synchronize != 0 )
    [ ];
    [Синхронизация перечня прямых получателей:];
    [╔═════╦═══════════════════════════════════╦════════════════════════════════════╗];
    [║ Код ║ Название                          ║ Результат обработки                ║];
    [╠═════╬═══════════════════════════════════╬════════════════════════════════════╣];
    /* Синхронизировать перечень прямых получателей */
    SynchronizeLIB(GetTaxonomy(BT_TXY_TAG_TI));
    [╚═════╩═══════════════════════════════════╩════════════════════════════════════╝];
 end;

 Close( ImpFile );

 return stat;
END;

// @return: true - файл на СП ,false - файл на машине
macro StrPath (str)
    if (substr(trim(str),1,1) == "\\")
        return true;
    else 
        return false;
    end;
end;

macro FileCopy () 
    var retVal = True, copy; 
    temppath = temppath + "\\" + NameFile + fileExtension;
       if (not StrPath(fullPath))
           fullPath ="$" + fullPath;                                   
           if ( not CopyFile( fullPath, temppath))
               retVal = False;
           end;
       else
           if (substr(fullPath,1,8) == substr(temppath,1,8))
               copy = run (GetEnv("COMSPEC"),"/c copy "+ fullPath  +","+ temppath);
               if (copy == 0)
                   retVal = True;    
               end;
           else
               fullPath ="$" + fullPath;
               if ( not CopyFile( fullPath, temppath))
                   retVal = False;
               end;
           end;

       end;
       directory = splitFile (temppath, NameFile, fileExtension);
       if (not retVal) return ""; else return temppath; end;
end;

var ob = CreateObject ("rsax","TRsAxServer","RsAxServer",false);
var ex = ob.CreateComObject ("Excel.Application");
    if (fullPath = ex.application.GetOpenFileName ("Файлы (*.txt),*.txt", null, "Выберите файл для загрузки"));
        directory = splitFile (fullPath, NameFile, fileExtension);
    end;    

tmp = FileCopy();

if (tmp == "") msgbox("Ошибка копирования файла в ..\txtfile "); exit(); else fullPath = tmp; end;
if (GetTrue(true,"Синхронизировать перечень прямых получателей?")) synchr = 1; else synchr = 0; end;

bttx_import(fullPath, synchr);

OnError
    msgbox("Файл не выбран. Процедура импорта прервана");