 /*╔═══════════════════════════════════════════════════════════════════════════╗*/
/*║           Автоматизированная банковская система RS-Bank v5.1              ║*/
/*║               Copyright (c) R-Style Software Lab 2001-2004                ║*/
/*║                                                                           ║*/
/*║ Имя файла     or_class.mac                                                ║*/
/*║                                                                           ║*/
/*║ Описание      Инструмент для создания универсальных отчетов (классы)      ║*/
/*║                                                                           ║*/
/*║ Программист   Зуев С.В.                                                   ║*/
/*║                                                                           ║*/
/*║ Создан        18.08.2003                                                  ║*/
/*║                                                                           ║*/
/*╚═══════════════════════════════════════════════════════════════════════════╝*/
// KS 02.12.2013 Перенос пользовательских доработок в 31ю сборку

/* Список классов: 
  *C_HTML_Report      - Вспомогательный класс для работы с html-ным представлением отчета
  *ClsTemplate        - Вспомогательный Объект с данными шаблонов разделителей
  *ClsSheet           - Список закладок отчета
  *CSeparator         - Вспомогательный класс для разделителей ячеек
  *CParamPrintCell    - Вспомогательный класс для заполнения данных по одной выводимой ячейке или части строки
  *CParamHeaderCell   - Вспомогательный класс для заполнения данных по одной выводимой ячейке для заголовка (для режимов отличных от DOS) 
  *CMargin            - Вспомогательный класс для колонтитулов
  *CDocProperty       - Вспомогательный класс для Свойств документов
  *CPrinterOptions    - Вспомогательный класс для формирования наиболее важных опций принтера (для работы через HTML-файл)
  *CSheetProp         - Вспомогательный класс для свойств листа Excel (для работы через HTML-файл)
  *CScanData          - Вспомогательный класс для отсканированых данных из квадратных скобок

  *ClsTemplateDocument- Вспомогательный Объект с данными для формирования документа слияния
  *CTemplateDocument  - Вспомогательный Объект с данными одного документа слияния (закладки)

  *CComment           - Вспомогательный объект с данными одного комментаря к ячейкам
  *ClsComment         - Вспомогательный объект с данными комментариев к ячейкам
*/
import  fileop;         /* Объект для работы с файлами на сервере и терминале   */
Import  "or_set_h.mac"; /* Настройки, применяемые в инструменте */
Import  "or_tools.mac"; /* Общие, часто применяемые, инструментальные функции */
Import  "or_srt_h.mac"; /* Функции для сортировки */

private CONST KEY_STRBREAK   :string = "/STRBREAK";    /* Обозначает принудительный разрыв страницы */

var EMPTY_TARRAY:tarray = tarray(1,5);

class _OR_BaseObject()

      /* Копирование списка */
      macro _CopyTarray( lsDest:tarray, lsSource:tarray )
            var i:integer = 0;
            lsDest.Size = 0;
            while( i < lsSource.Size)
               lsDest[i] = lsSource[i];
               i = i + 1;
            end;
      end;

      /**** Копирование всех данных объекта в себя (Конструктор копирования) */
      macro Copy( Obj:object )
            var i   :integer = 0;
            var Size:integer = GenNumProps( Obj );

            while( i < Size )
                if( ValType(Obj[i]) == V_GENOBJ )
                    if( StrUpr(GenClassName(Obj[i])) == "TARRAY" )   /* Массивы tarray */
                        _CopyTarray( this[i], Obj[i] );
                    else
                        this[i].Copy(Obj[i]);
                    end;
                else
                    this[i] = Obj[i];
                end;
                i = i + 1;
            end;
      end;
end;

/****** Объект хранящий элемент списка форматов */
private class (_OR_BaseObject) CFormat( _NumbFract:integer, _Modif_z:bool, _Modif_a:bool )
      var m_NumbFract :integer = _NumbFract; // Кол-во знаков после запятой
      var m_Modif_z   :bool    = _Modif_z  ; // Наличие спецификатора форматирования "z"
      var m_Modif_a   :bool    = _Modif_a  ; // Наличие спецификатора форматирования "a"
      var m_FormatName:string  =         ""; // Имя класса формата
      var m_FormatStr :string  =         ""; // Строка формата

      macro SetFormatName( _FormatName:string )
            m_FormatName = _FormatName;
      end;
      macro CreateFormatStr_M():string
            var FormatStr:string = "   mso-number-format:\"\\";
            var TmpFormat:string ="#\\";

            if( m_Modif_a )
                TmpFormat = TmpFormat + ",\\#\\";
            end;

            if( m_NumbFract )
                TmpFormat = TmpFormat + "#0\\."+MkStr("0",m_NumbFract)+"\\0022\\0022";
            else
                TmpFormat = TmpFormat + "#0";
            end;
            FormatStr = FormatStr + TmpFormat + ";\\-"+ TmpFormat +  ";";
            if( m_Modif_z )
                FormatStr = FormatStr + "\\;";
            else
                FormatStr = FormatStr + TmpFormat +  ";";
            end;
            FormatStr = FormatStr + "\"";

            m_FormatStr = FormatStr + ";";
            return m_FormatStr;
      end;

      macro CreateFormatStr_D():string
            var FormatStr:string = "   mso-number-format:\"\\";
            var TmpFormat:string ="#\\";
            if( m_Modif_a )
                TmpFormat = TmpFormat + ",\\#\\";
            end;

            if( m_NumbFract )
            TmpFormat = TmpFormat + "#0\\."+MkStr("0",m_NumbFract);
            else
                TmpFormat = TmpFormat + "#0";
            end;

 
            FormatStr = FormatStr + TmpFormat + ";\\-"+ TmpFormat +  ";";
           
            if( m_Modif_z )
                FormatStr = FormatStr + "\\;";
            else
                FormatStr = FormatStr + TmpFormat +  ";";
            end;

            m_FormatStr = FormatStr + "\";";
            return m_FormatStr;
      end;

      macro CreateFormatStr_I():string
            m_FormatStr = "   mso-number-format:";

            if  ( (NOT m_Modif_a) AND (NOT m_Modif_z) ) m_FormatStr = m_FormatStr + "0;"
            elif( (    m_Modif_a) AND (    m_Modif_z) ) m_FormatStr = m_FormatStr + "\"\\#\\,\\#\\#0\\;\\-#\\,\\#\\#0\\;\\;\";";
            elif( (    m_Modif_a)                     ) m_FormatStr = m_FormatStr + "\"\\#\\,\\#\\#0\";";
            elif( (    m_Modif_z)                     ) m_FormatStr = m_FormatStr + "\"\\#\\;\\-#\\;\\;\";";
            end;
            return m_FormatStr;
      end;

      macro CreateFormatStr_S():string
          m_FormatStr = "mso-number-format:\\@;"; 
          return m_FormatStr;
      end;  
      
end;


/****** Объект хранящий список форматов */
private class (_OR_BaseObject) ClsFormat()
      private var ls:tarray = Tarray(100,10); // список форматов на листе

      macro Add( PrintCell:object) //CParamPrintCell )//NumbFract:integer, Modif_z:bool, Modif_a:bool )
           var i:integer = 0;
           var NumbFract:integer = PrintCell.StrModif_Fract; 
           var Modif_z  :bool    = PrintCell.CheckSymbolStandartLexem("z");
           var Modif_a  :bool    = PrintCell.CheckSymbolStandartLexem("a");

           while( i < ls.Size )
               if( (ls[i].m_NumbFract == NumbFract) AND
                   (ls[i].m_Modif_z   == Modif_z  ) AND
                   (ls[i].m_Modif_a   == Modif_a  )     )
                   return;
               end;
               i = i + 1;
           end;
           ls[ls.Size] = CFormat(NumbFract, Modif_z, Modif_a);
      end;

      macro PrintDebug()
           var i:integer = 0;
           println("Печать списка форматов");
           while( i < ls.Size )
               println( ls[i].m_NumbFract:3:l, ls[i].m_Modif_z:6, ls[i].m_Modif_a );
               i = i + 1;
           end;
      end;

      macro GetFormatName( NumbFract:integer, Modif_z:bool, Modif_a:bool ):string
           var i:integer = 0;
           while( i < ls.Size )
               if( (ls[i].m_NumbFract == NumbFract) AND
                   (ls[i].m_Modif_z   == Modif_z  ) AND
                   (ls[i].m_Modif_a   == Modif_a  )     )
                   return  ls[i].m_FormatName;
               end;
               i = i + 1;
           end;
           return "";
      end;

      macro Size() : integer
            return ls.Size;
      end;

      macro Get(Pos:integer) : CFormat
            return ls[Pos];
      end;
end;

/****  Класс для колонтитулов */
CLASS (_OR_BaseObject) CMargin( _TLMarginText:string, _TCMarginText:string, _TRMarginText:string,
                                _BLMarginText:string, _BCMarginText:string, _BRMarginText:string )

  VAR TLMarginText:string = ""; /* Текст верхнего левого колонтитула */
  VAR TCMarginText:string = ""; /* Текст верхнего центрального колонтитула */
  VAR TRMarginText:string = ""; /* Текст верхнего правого колонтитула */
  VAR BLMarginText:string = ""; /* Текст нижнего левого колонтитула */
  VAR BCMarginText:string = ""; /* Текст нижнего центрального колонтитула */
  VAR BRMarginText:string = ""; /* Текст нижнего правого колонтитула */

  VAR TMarginSize :double = 2.5; /* Размер отступа В САНТИМЕТРАХ!!! */
  VAR BMarginSize :double = 2.5; /* Размер отступа */
  VAR LMarginSize :double = 2.0; /* Размер отступа */
  VAR RMarginSize :double = 2.0; /* Размер отступа */

  /* Инициализация класса */
  Macro Init(l_TLMarginText:string, l_TCMarginText:string, l_TRMarginText:string,
             l_BLMarginText:string, l_BCMarginText:string, l_BRMarginText:string)

     if( ValType(l_TLMarginText) )   this.TLMarginText = l_TLMarginText;   end;
     if( ValType(l_TCMarginText) )   this.TCMarginText = l_TCMarginText;   end;
     if( ValType(l_TRMarginText) )   this.TRMarginText = l_TRMarginText;   end;
     if( ValType(l_BLMarginText) )   this.BLMarginText = l_BLMarginText;   end;
     if( ValType(l_BCMarginText) )   this.BCMarginText = l_BCMarginText;   end;
     if( ValType(l_BRMarginText) )   this.BRMarginText = l_BRMarginText;   end;

  End; /* Init */

  /* Метод для установки текста конкретного колонтитула */
  Macro SetMarginText(_MarginType:integer, _MarginText:string)

     if( (ValType(_MarginType) != V_UNDEF) and (ValType(_MarginText) != V_UNDEF) )
          if( (_MarginType >= 0) and (_MarginType < 6) )
              this(_MarginType) = _MarginText;
          end;
     else this.Init("", "", "", "", "", "");
     end;
   
  End; /* SetMarginText */

  /* Метод для установки размера отступов вертикальных */
  macro SetMarginSizeVert( _TMarginSize:double, _BMarginSize:double )
        this.TMarginSize = _TMarginSize;
        this.BMarginSize = _BMarginSize;
  end;

  /* Метод для установки размера отступов горизонтальных */
  macro SetMarginSizeHor ( _LMarginSize:double, _RMarginSize:double )
        this.LMarginSize = _LMarginSize;
        this.RMarginSize = _RMarginSize;
  end;

  /* Метод для установки размера отступов всех */
  macro SetMarginSize(_TMarginSize:double, _BMarginSize:double, _LMarginSize:double, _RMarginSize:double)
        SetMarginSizeVert( _TMarginSize, _BMarginSize );
        SetMarginSizeHor ( _LMarginSize, _RMarginSize );
  end;

  macro GetSizeInch( value:double ) : double
        return (value/2.54)
  end;

  macro Normalization()
        var i:integer = 0;
        while( i < 6 ) // Обращаться к полям будем по индексам
           if( Index(this(i), "\n") )   this(i) = TrStrSubst(this(i), "\n", "\\000A");  end;   // - перевод строки
           if( Index(this(i), "\"") )   this(i) = TrStrSubst(this(i), "\"", "\\0022");  end;   // - кавычка
           i = i + 1;
        end;
  end;

  /* Конструктор */
  this.Init(_TLMarginText, _TCMarginText, _TRMarginText, _BLMarginText, _BCMarginText, _BRMarginText);

END; /* CMargin */
class CDocProperty(iDocName:string,iUserName:string,iOrgName:string)

    var DocName :String = ""; // Название документа
    var UserName:String = ""; // Автор документа
    var OrgName :String = ""; // Организация
    
    Macro Init(iDocName,iUserName,iOrgName)
        if(ValType(iDocName))   DocName  = iDocName ;
        end;
        if(ValType(iUserName))  UserName = iUserName;
        end; 
        if(ValType(iOrgName))   OrgName = iOrgName ;
        end;   
    end;
   Init(iDocName,iUserName,iOrgName);
END;//class CDocProp */
class CTitle( Text:string,  Color:integer )
      var m_Text :string  = "";
      var m_Color:integer = 0;  // Черный

      if( ValType(Text ) ) m_Text  = Text ;   end;
      if( ValType(Color) ) m_Color = Color;   end;

      macro Set( Text:string,  Color:integer )
            m_Text  = Text ;
            m_Color = Color;
      end;
end;

/**** Объект "Серия данных диаграммы" */
class CSeries(Diapazon:string, Name:string, XValues:string)
      var m_Diapazon:string = "";   // Диапазон отвечающий за исходные данные ряда диаграммы
      var m_Name    :string = "";   // Название ряда
      var m_XValues :string = "";   // Подпись оси

      if( ValType(Name    ) ) m_Name     = Name    ; end;
      if( ValType(Diapazon) ) m_Diapazon = Diapazon; end;
      if( ValType(XValues ) ) m_XValues  = XValues ; end;
end;

/**** Список объектов "Серия данных диаграммы" */
class (tarray) ClsSeries()
      macro Add(Diapazon:string, Name:string, XValues:string)
            this[this.Size] = CSeries(Diapazon, Name, XValues);
      end;
end;

/**** Объект "Диаграмма" добавляет новый лист диаграммы в конец списка */
class (_OR_BaseObject) CChart( ChartType:integer, PlotBy:integer )

   // Общие параметры диаграммы
   private var m_Name     :string    = "";                    // Название диаграммы
   private var m_ChartType:integer   = CHART_ColumnClustered; // Диаграмма в виде простых столбцов
   private var m_PlotBy   :integer   = CHART_PlotByColumn   ; // Диаграмма строится по столбцам)
   private var m_HasLegend:bool      = true;                  // Флаг легенды

   // Диапазон данных для диаграммы
   private var m_Diapazon:string     = ""; // Строка диапазона

   // Заголовок
   private var m_ChartTitle:CTitle   = CTitle("", RGB(255,0,0));

   // Оси
   private var m_AxisTitle_X:CTitle  = CTitle("", RGB(0,0,255)),
               m_AxisTitle_Y:CTitle  = CTitle("", RGB(0,0,255));

   // Серии данных
   private var lsSeries   :ClsSeries = ClsSeries;

   if( ValType(ChartType) ) m_ChartType = ChartType; end;
   if( ValType(PlotBy   ) ) m_PlotBy    = PlotBy   ; end;

   /**** Метод установления источника данных для диаграммы */
   macro SetSourceData( Diapazon:string )
         m_Diapazon = Diapazon;
   end;

   /**** Метод добавления нового ряда данных (_Diapazon_), с именем _Name_ */
   macro AddNewSeries( Diapazon:string, Name:string, XValues:string )
         lsSeries.Add( Diapazon, Name, XValues );
   end;

   /**** Метод установки(удаления) легенды */
   macro SetChartLegend( HasLegend:bool )
         m_HasLegend = HasLegend;
   end;

   /**** Метод установки заголовка диаграммы */
   macro SetChartTitle( Title:string, ColorTitle:integer )
         if( Title )
             m_ChartTitle.Set( Title, ColorTitle );
         end;
   end;

   /**** Метод установки(удаления) цветного заголовка осей X,Y диаграммы */
   macro SetChartAxesTitle( TitleX:string, ColorTitleX:integer,
                            TitleY:string, ColorTitleY:integer )

      if( TitleX )  m_AxisTitle_X.Set( TitleX, ColorTitleX );   end;
      if( TitleY )  m_AxisTitle_Y.Set( TitleY, ColorTitleY );   end;
   end;

   /**** Метод  установки названий разделов легенды. В случае успеха возвращает True */
   macro SetChartLegendItemName( _Index:integer, Name:string )
      if( _Index >= lsSeries.Size )
           Return False;
      end;
      lsSeries[_Index].Name = Name;
      Return True;
   end;

   /**** Метод возвращает/устанавливает (V_STRING) наименование листа диаграмм */
   macro SetChartName( Name:string )
         if( StrLen(Name) > 28 )  m_Name = String(Name:28) + "...";
         else                     m_Name = Name;
         end;
   end;

   /**** Основной метод формирования списка управляющих строк для построения диаграммы */
   macro Create() : tarray
         var i       :integer = 0;
         var ls      :tarray  = Tarray();

         macro AddStr(/*...*/)
               var ii    :integer = 0;
               var Result:string  = "";
               var Value :variant = NULL;
               while( GetParm(ii, Value) )
                   Result = Result + String(Value);
                   ii = ii + 1;
               end;
               ls[ls.size] = Result;
         end;

         macro PrintDebug()
               var i:integer = 0;
               while( i < ls.Size )
                   println("[",i,"]->", ls[i]);
                   i = i + 1;
               end;
         end;

         AddStr( "ChartAdd(", m_ChartType, ")" );
         if( m_Name )
             AddStr( "ChartName(\"",m_Name, "\")" );
         end;
         AddStr( "SetDiapazon(\"", m_Diapazon, "\")" );
         AddStr( "SetChartData(", m_PlotBy , ")" );

         i = 0;
         while( i < lsSeries.Size )
              AddStr( "AddNewSeries(\"", lsSeries[i].m_Diapazon, "\", \"",
                                         lsSeries[i].m_Name    , "\", \"",
                                         lsSeries[i].m_XValues , "\")");
              i = i + 1;
         end;

         if( m_ChartTitle.m_Text )
             AddStr( "SetChartTitle(\"",m_ChartTitle.m_Text ,"\"" ,", ",
                                        m_ChartTitle.m_Color,")" );
         end;

         if( m_AxisTitle_X.m_Text OR m_AxisTitle_Y.m_Text )
             AddStr( "SetChartAxesTitle(\"",m_AxisTitle_X.m_Text,"\"",",",m_AxisTitle_X.m_Color, ", ",
                                       "\"",m_AxisTitle_Y.m_Text,"\"",",",m_AxisTitle_Y.m_Color,")" );
         end;

         return ls;
   end;

end;

/* (HTML) Класс для свойств листа Excel */
CLASS (_OR_BaseObject) CSheetProp(_SheetNumber:integer, _SheetName:string, _SheetStrHeader:string, _FlagShowGrid:bool, _FlagShowZeroValue:bool )

  /* Public members */
  var SheetNumber      :integer = 1;                 // Номер листа
  var SheetName        :string  = "";                // Имя листа
  var SheetStrHeader   :string  = "";                // Заголовок таблицы (линейка разбиения) на листе
  var FlagShowGrid     :bool    = FALSE;             // Флаг отображения сетки на листе
  var FlagShowZeroValue:bool    = TRUE ;             // Флаг отображения нулевых значений на листе
  var NumPageWidth     :integer = 1;                 // Количество страниц в ширину при масштабировании
  var ZoomType         :integer = ZOOM_TYPE_AUTO;    // Вид масштабирования
  var FontSize         :integer = DefaultFontSize;   // Размер шрифта в Windows
  var FontName         :string  = DefaultStringFont; // Наименование шрифта  в Windows
  var CountStrHeader   :integer = 0;                 // Количество строк заголовка

  // Расширенные св-ва таблицы
  var hd_BkGrColor     :string  = COLOR_GRAY      ;  // Цвет фона
  var hd_FS            :string  = "B";               // Стиль шрифта, По умолчанию жирный шрифт
  var hd_Align         :integer = ALIGN_CENTER;      // Выравнивание, По умолчанию по центру

  var ExcelKoefWidth   :double  = DefExcelKoefWidth; // Эмпирический коэффициент для соотношения количества символов и ширины ячеек в Excel
  var WordKoefWidth    :double  = DefWORDKoefWidth ; // Эмпирический коэффициент для соотношения количества символов и ширины ячеек в Word
  var HtmlKoefWidth    :double  = DefHTMLKoefWidth ; // Эмпирический коэффициент для соотношения количества символов и ширины ячеек в HTML

  var FlagShowFixedRow    :bool = True;               // Флаг показа фиксированных строк заголовка таблицы на каждой странице в Excel
  var FlagShowMidSeparator:bool = True;               // Флаг печати межстрочных разделителей таблицы
  var FlagMarginTextUsed  :bool = False;              // Флаг пользовательского изменения колонтитулов в Excel

  var FlagPrintFullHeader :bool = TRUE ; // Флаг печати полного заголовка на следующих листах
  var FlagPrintFirstHeader:bool = FALSE; // Флаг печати полного заголовка (это значит, что мы уже распечатали заголовок)

  var lsFormat_D:ClsFormat = ClsFormat; // Список используемых форматов для Double на листе
  var lsFormat_M:ClsFormat = ClsFormat; // Список используемых форматов для Money  на листе
  var lsFormat_I:ClsFormat = ClsFormat; // Список используемых форматов для Integer на листе
  var lsFormat_S:ClsFormat = ClsFormat; // Список используемых форматов для String на листе
  /* Private members */
  private var ObjMargin           :CMargin= CMargin();    // Объект класса CMargin

  private var m_Chart             :object = NULL;         // Диаграмма листа (т.к. на листе может быть одна таблица, то будет и одна диаграмма)

  private var FileNameTXT         :string = ""; // Имя текстового файла с данными закладки
  private var FileNameHTML        :string = ""; // Имя html-ного  файла с данными закладки 
    
  private var ArrPrintStr         :tarray = tarray(1000,1000);  // Массив для строк информационных отчета, каждая из которых является массивом объектов типа CParamPrintCell
  private var PrevArrParamPrintStr:tarray = tarray();           // Массив объектов типа CParamPrintCell для предыдущей строки
  private var ArrColWidth         :tarray = tarray(100,10);     // Массив с размерами колонок отчета
  private var ArrColWidthTable    :tarray = tarray();           // Массив с размерами колонок таблицы отчета
  private var ArrHeaderStr        :tarray = tarray();           // Массив для строк заголовка таблицы, каждая из которых является массивом объектов типа CParamHeaderCell
  private var ArrSubHeaderStr     :tarray = tarray(2,10);       // Массив для строк заголовка таблицы, каждая из которых является массивом объектов типа CParamHeaderCell

  private var CurAddRow:integer = 0; // Текущая добавляемая строка, нужна для того, чтобы отследить ограничение в 65000 строк на лист

  /**** Инициализация класса */
  private macro Init( l_SheetNumber:integer, l_SheetName:string, l_SheetStrHeader:string,
                      l_FlagShowGrid:bool, l_FlagShowZeroValue:bool )
        var Str:string = "";
        if( ValType(l_SheetNumber   ) )
            Str = TrStrSubst( String((l_SheetNumber):5:r), " ", "0" );
            FileNameTXT  = "sheet" + Str + ".txt";
            FileNameHTML = "sheet" + Str + ".htm";
            this.SheetNumber = l_SheetNumber;
        end;
        if( ValType(l_SheetName        ) )   this.SetSheetName( l_SheetName );              end;
        if( ValType(l_SheetStrHeader   ) )   this.SheetStrHeader   = l_SheetStrHeader   ;   end;
        if( ValType(l_FlagShowGrid     ) )   this.FlagShowGrid     = l_FlagShowGrid     ;   end;
        if( ValType(l_FlagShowZeroValue) )   this.FlagShowZeroValue= l_FlagShowZeroValue;   end;
  end; /* Init */

  /**** Добавить в массив строк строку (пустой массив ячеек )*/
  macro AddArrPrintStr()
        ArrPrintStr[ArrPrintStr.Size] = tarray();
  end;

  /**** Добавить в массив строк заголовка (пустой массив ячеек, или объект)*/
  macro AddArrHeaderStr( Obj:tarray )
        if( ValType(Obj) ) ArrHeaderStr[ArrHeaderStr.Size] = Obj;
        else               ArrHeaderStr[ArrHeaderStr.Size] = tarray();
        end;
  end;

  /**** Добавить в массив ширин колонок (пустой массив ячеек, или объект)*/
  macro AddArrColWidth( Obj:tarray )
        if( ValType(Obj) ) ArrColWidth[ArrColWidth.Size] = Obj;
        else               ArrColWidth[ArrColWidth.Size] = tarray(100,10);
        end;
  end;

  /**** Добавить диаграмму по текущему листу */
  macro AddChart( ChartType:integer, PlotBy:integer ) : CChart
        m_Chart = CChart( ChartType, PlotBy );
        return m_Chart;
  end;

  /**** Метод возвращает диаграмму листа */
  macro GetChart() : object
        return m_Chart;
  end;

  /**** Метод возвращает массив строк, а если передан Pos, то массив ячеек строки Pos */
  macro GetArrPrintStr( Pos:integer )
        if( ValType(Pos) )  return ArrPrintStr[Pos];
        else                return ArrPrintStr     ;
        end;
  end;

  /**** Метод возвращает массив строк, а если передан Pos, то массив ячеек строки Pos */
  macro GetPrevArrParamPrintStr( Pos:integer )
        if( ValType(Pos) )  return PrevArrParamPrintStr[Pos];
        else                return PrevArrParamPrintStr     ;
        end;
  end;

  /**** Метод возвращает массив с размерами колонок таблицы закладки, а если передан Pos, то значение */
  macro GetArrColWidthTable( Pos:integer )
        if( ValType(Pos) )  return ArrColWidthTable[Pos];
        else                return ArrColWidthTable     ;
        end;
  end;

  /**** Метод возвращает массив с размерами колонок таблицы закладки, а если передан Pos, то значение */
  macro GetArrSubHeaderStr( Pos:integer )
        if( ValType(Pos) )  return ArrSubHeaderStr[Pos];
        else                return ArrSubHeaderStr     ;
        end;
  end;

  /**** Метод возвращает mассив с размерами колонок отчета, а если передан Pos, то значение */
  macro GetArrColWidth( Pos:integer )
        if( ValType(Pos) )  return ArrColWidth[Pos];
        else                return ArrColWidth     ;
        end;
  end;

  /**** Метод возвращает Массив для строк заголовка таблицы, а если передан Pos, то значение */
  macro GetArrHeaderStr( Pos:integer )
        if( ValType(Pos) )  return ArrHeaderStr[Pos];
        else                return ArrHeaderStr     ;
        end;
  end;

  /**** Метод возвращает закрытое свойство объекта ObjMargin */
  macro GetObjMargin() : CMargin
        return ObjMargin;
  end;

  /**** Метод возвращает закрытое свойство объекта FileNameTXT */
  macro GetFileNameTXT() : string
        return FileNameTXT;
  end;

  /**** Метод возвращает закрытое свойство объекта FileNameTXT */
  macro GetFileNameHTML() : string
        return FileNameHTML;
  end;

  macro CopyCalcData( Obj:CSheetProp )
        this._CopyTarray( GetArrColWidthTable, Obj.GetArrColWidthTable() );
        this.SheetStrHeader = Obj.SheetStrHeader;
        this.CountStrHeader = Obj.CountStrHeader;
  end;

  macro ClearData()
        ArrPrintStr         .Size = 0;  // Массив для строк информационных отчета, каждая из которых является массивом объектов типа CParamPrintCell
        ArrColWidth         .Size = 0;  // Массив с размерами колонок отчета
//        ArrColWidthTable    .Size = 0;  // Массив с размерами колонок таблицы отчета
        ArrHeaderStr        .Size = 0;  // Массив для строк заголовка таблицы, каждая из которых является массивом объектов типа CParamHeaderCell
        ArrSubHeaderStr     .Size = 0;  // Массив для строк заголовка таблицы, каждая из которых является массивом объектов типа CParamHeaderCell
        PrevArrParamPrintStr.Size = 0;  // Массив объектов типа CParamPrintCell для предыдущей строки
  end;

  macro m_AddCurRow()
        CurAddRow = CurAddRow + 1;
  end;

  macro m_GetAddCurRow() : integer
        return CurAddRow;
  end;

  /**** Установить имя закладки */
  macro SetSheetName( l_SheetName:string )
        var TmpSheetName:string = /*ToAnsi*/(l_SheetName);
        if( StrLen(TmpSheetName) > MAX_LENGTH_NAME_SHEET )
           TmpSheetName = SubStr(TmpSheetName, 1, (MAX_LENGTH_NAME_SHEET - 2)) + "_" + string(SheetNumber); /*полагаем, что больше 99 листов не будет*/
        end;
        this.SheetName = string(TmpSheetName);
  end;

  /**** Установить строку шапки таблицы */
  macro SetHeaderStr( l_SheetStrHeader:string )
        if( ValType(l_SheetStrHeader) )
            this.SheetStrHeader = l_SheetStrHeader;
        end;
  end;
  /**** Установить свойства шапки таблицы */
  macro SetHeader( l_SheetStrHeader:string, l_hd_BkGrColor:string, l_hd_FS:string, l_hd_Align:integer )
        SetHeaderStr(l_SheetStrHeader);       
        if( ValType(l_hd_BkGrColor) )  this.hd_BkGrColor = l_hd_BkGrColor;  end;
        if( ValType(l_hd_FS       ) )  this.hd_FS        = l_hd_FS       ;  end;
        if( ValType(l_hd_Align    ) )  this.hd_Align     = l_hd_Align    ;  end;
  end;

  // Установка стиля шапки
  macro Get_hd_FS():string

      var  RetStr:string ="";

      if( Index(strUpr(this.hd_FS),"B")) RetStr = RetStr + " font-weight: bold;" ; end;
      if( Index(strUpr(this.hd_FS),"I")) RetStr = RetStr + " font-style: italic;"; end;
      if( Index(strUpr(this.hd_FS),"U")) RetStr = RetStr + " text-decoration: underline; text-underline-style: single;"; end;      
    
      return RetStr;  

  end;
  
  // Установка выравнивания шапки
  macro Get_hd_Align()
          if  ( this.hd_Align == ALIGN_CENTER ) return "center";
          elif( this.hd_Align == ALIGN_LEFT   ) return "left"  ;
          elif( this.hd_Align == ALIGN_RIGHT  ) return "right" ;
          end;
  end;

  /**** Метод предназначенный для отладочной печати всех свойств объекта */
  macro PrintDebug()
        var i   :integer = 0;
        var Size:integer = GenNumProps( this );
        println("   Свойства объекта CSheetProp:");
        while( i < Size )
            println("     [",i,"] : ", this[i] );
            i = i + 1;
        end;
  end;

  /**** (Public) Деструктор */
  macro Destructor()
       lsFormat_D           = NULL;  // Список используемых форматов для Double на листе
       lsFormat_M           = NULL;  // Список используемых форматов для Money  на листе
       lsFormat_I           = NULL;  // Список используемых форматов для Integer на листе
       lsFormat_S           = NULL;  // Список используемых форматов для String на листе
       ObjMargin            = NULL;  // Объект класса CMargin
       FileNameTXT          = NULL;  // Имя текстового файла с данными закладки
       FileNameHTML         = NULL;  // Имя html-ного  файла с данными закладки 
       ArrPrintStr          = NULL;  // Массив для строк информационных отчета, каждая из которых является массивом объектов типа CParamPrintCell
       PrevArrParamPrintStr = NULL;  // Массив объектов типа CParamPrintCell для предыдущей строки
       ArrColWidth          = NULL;  // Массив с размерами колонок отчета
       ArrColWidthTable     = NULL;  // Массив с размерами колонок таблицы отчета
       ArrHeaderStr         = NULL;  // Массив для строк заголовка таблицы, каждая из которых является массивом объектов типа CParamHeaderCell
       ArrSubHeaderStr      = NULL;  // Массив для строк заголовка таблицы, каждая из которых является массивом объектов типа CParamHeaderCell
  end;

  /* Конструктор */
  Init(_SheetNumber, _SheetName, _SheetStrHeader, _FlagShowGrid, _FlagShowZeroValue);
   
END; /* CSheetProp */

/**** Список закладок */
class ClsSheet()

   private var ls:tarray = tarray(10,10); // Основной объект список закладок

   /**** Получить размер списка закладок */
   macro Size() : integer
         return ls.Size;
   end;

   /**** Взять закладку с номером Pos */
   macro Get( Pos:integer ) : CSheetProp
         return ls[Pos];
   end;

   /**** Добавить новую закладку */
   macro AddNewSheet( SheetName:string, SheetStrHeader:string,  FlagShowGrid:bool, FlagShowZeroValue:bool)
         ls[this.Size] = CSheetProp(this.Size+1, SheetName, SheetStrHeader, FlagShowGrid, FlagShowZeroValue);
   end;

   /**** Перемещение закладок */
   macro MoveSheet( NumSheetSource:integer, NumSheetDesc:integer ) : bool
         var Obj:object = CSheetProp;
         if( (NumSheetSource >= ls.Size) OR (NumSheetDesc >= ls.Size) )
             MsgBox("ClsSheet:MoveSheet()|Ошибка перемещения закладок!|Номер перемещаемой закладки превышает их количество!");
             return FALSE;
         end;

         Obj.Copy( ls[NumSheetDesc] );

         ls[NumSheetDesc  ] = ls[NumSheetSource];
         ls[NumSheetSource] = Obj;

         ls[NumSheetDesc  ].SheetNumber = NumSheetDesc   + 1;
         ls[NumSheetSource].SheetNumber = NumSheetSource + 1;
         return TRUE;
   end;

   /**** Установить имя SheetName для закладки с номером Pos */
   macro SetSheetName( Pos:integer, SheetName:string )
         ls[Pos].SetSheetName( SheetName );
   end;

  /**** Метод предназначенный для отладочной печати данных всех закладок объекта */
   macro PrintDebug( Str:string )
         var i   :integer = 0;
         println("Данные списка закладок: ",  Str);
         while( i < ls.Size )
             println(" Закладка №-",i );
             this.Get(i).PrintDebug();
             i = i + 1;
         end;
   end;

  /**** (Public) Деструктор */
  macro Destructor()
        ls.Size = 0;
  end;
end;

/* (HTML) Класс для формирования наиболее важных опций принтера */
CLASS CPrinterOptions()

  VAR PaperSize  :string = ""; /* Размер страницы */
  VAR Orientation:string = ""; /* Ориентация листа */
  VAR FitWidth   :string = ""; /* Число листов по ширине */

  /* Устанавливаем вид масштабирования */
  Macro CalcPrinterOptions(_ZoomType:integer, _RepWidth:double, _CountPageWidth:integer)

     var DoZoom = true;

     /* Обработаем переданный способ масштабирования */
     if( _ZoomType == ZOOM_TYPE_A4 )
         PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";

     elif( _ZoomType == ZOOM_TYPE_A4L )
         PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";
         Orientation = "mso-page-orientation:landscape;"

     elif( (_ZoomType == ZOOM_TYPE_A3)and(FlagPrinterA3) )
         PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A3) + "</x:PaperSizeIndex>";

     elif( (_ZoomType == ZOOM_TYPE_A3L)and(FlagPrinterA3) )
         PaperSize= "<x:PaperSizeIndex>"  + String(PAPER_TYPE_A3) + "</x:PaperSizeIndex>";
         Orientation = "mso-page-orientation:landscape;"

     elif( _ZoomType == ZOOM_TYPE_AUTO )
         /* Если не влезло на A4, пробуем вместить на A4 Landscape */
         if( _RepWidth / PAPER_SIZE_A4 / _CountPageWidth > MAX_ZOOM_PORTRET )
             /* Если не влезло на A4 Landscape, пробуем вместить на A3 Landscape */        
             if( _RepWidth / PAPER_SIZE_A4L / _CountPageWidth > MAX_ZOOM )
                 /* Проверим наличие принтера для A3 */
                 if( FlagPrinterA3 )
                     /* Если никуда не влезло, оставляем масштаб без изменения на волю пользователя */  
                     if(_RepWidth / PAPER_SIZE_A3L / _CountPageWidth > MAX_ZOOM)
                          DoZoom = false;
                          PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";
                     else PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A3) + "</x:PaperSizeIndex>";
                          Orientation = "mso-page-orientation:landscape;";
                     end; 
                 else
                     DoZoom = false;
                     PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";
                     Orientation = "mso-page-orientation:landscape;";
                 end;   
             else PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";
                  Orientation = "mso-page-orientation:landscape;";
             end;
         else PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";
         end;
     else DoZoom = false; 
          PaperSize = "<x:PaperSizeIndex>" + String(PAPER_TYPE_A4) + "</x:PaperSizeIndex>";
     end;
     if( DoZoom )
         FitWidth = "<x:FitWidth>" + String(_CountPageWidth) + "</x:FitWidth>";
     end;
    
  End; /* CalcPrinterOptions */

END; /* CPrinterOptions */
     
/* Класс для разделителей ячеек */
CLASS CSeparator(_StrSeparator:string)

  /* Разделительные линии таблицы */
  VAR VertLine :string = "│"; /* Вертикальная линия */
  VAR HorizLine:string = "─"; /* Горизонтальная линия */                                  
  /* Узлы верхней части таблицы */                                                        
  VAR TopLeft  :string = "┌"; /* Верхний левый угол */                                    
  VAR TopCenter:string = "┬"; /* Разделитель столбцов на верхней линии */   
  VAR TopRight :string = "┐"; /* Верхний правый угол */
  /* Узлы средней части таблицы */                          
  VAR MidLeft  :string = "├"; /* Разделитель строк на левой стороне таблицы */
  VAR MidCenter:string = "┼"; /* Разделитель строк и столбцов */
  VAR MidRight :string = "┤"; /* Разделитель строк на правой стороне таблицы */
  /* Узлы нижней части таблицы */
  VAR BotLeft  :string = "└"; /* Нижний левый угол */
  VAR BotCenter:string = "┴"; /* Разделитель столбцов на нижней линии */   
  VAR BotRight :string = "┘"; /* Нижний правый угол */

  var StrSeparator:string = ""; /* Строка содержащая все разделители */

  /* Инициализация класса */
  Macro Init(l_StrSeparator:string)

     var i     :integer = 0; /* Счетчик циклов */
     var LenStr:integer = 0; /* Длина переданной строки разделителей */
 
     if( ValType(l_StrSeparator) )
         if( l_StrSeparator != "" )
             this.StrSeparator = l_StrSeparator;

             LenStr = Max(11, StrLen(l_StrSeparator)); /* 11 - число членов класса CSeparator */
             while( i < LenStr )
                  this(i) = SubStr(l_StrSeparator, i + 1, 1);
                  i = i + 1;
             end;
         else
             while( i < 11 )
                this(i) = "";
                i = i + 1;
             end;
         end;
     end; 

  End; /* Init */

  /* Конструктор */
  this.Init(_StrSeparator);
  /**/

END; /* CSeparator */


/* Класс для заполнения данных по одной выводимой ячейке или части строки */
CLASS CParamPrintCell(_StrValue, _StrModif_Whole:integer, _StrModif_Fract:integer, _StrModif_Advan:string, _FlagStr:integer)

  VAR StrValue         :variant;                // Содержимое ячейки
  VAR StrModif_Whole   :integer = 25;           // Модификатор количества символов
  VaR StrModif_WholeE  :integer = 25;           // Модификатор количества символов для Windows предстовления
  VAR StrModif_Fract   :integer = 0;            // Модификатор количества символов в дробной части (для дробных чисел и денег)
  VAR StandartLexem    :string  = "l";          // Дополнительные стандартные модификаторы (типа ":z")
  VAR ArrExtendedLexems:tarray  = NULL;         // Дополнительные модификаторы расширенного форматирования (типа ":ex_")
  VAR FlagStr          :integer = REP_ELEM_TABL;// Вид передаваемой информации
  var NumberTemplate   :integer = -1;           // Номер шаблона (-1 нет шаблона)
  Var NumCell          :integer =  1;           // количество ячеек которые объеденены  для получения данной ячейки
  Var FlagPrint        :bool    = true;         // признак печати ячейки в Windows  представлении
  // Вернуть копию массива расширенного форматирования
  macro GetExtendedLexems() : tarray
        if( ArrExtendedLexems ) return this.ArrExtendedLexems;
        else                    return EMPTY_TARRAY;
        end;
  end;

  /* (Private) Внутренний метод для разделения стандартных и расширенных параметров форматирования */
  Macro CatExtendedLexems( _StrModif_Advan:string )

     var StrModif_Advan:string  = _StrModif_Advan;              // Переданная строка параметров форматирования
     var Pos           :integer = StrBrk(StrModif_Advan, "(:"); // Позиция найденного символа
     var TmpStr        :string  = "";                           // Вспомогательная строка
     var NumBegBrackets:integer = 0;                            // Счетчик открывающихся скобок
     var NumEndBrackets:integer = 0;                            // Счетчик открывающихся скобок
     var Symbol        :string  = "";                           // Переменная для хранения символа
     var Lexem         :string  = "";

     this.StandartLexem = "";
     while( Pos )
         Symbol = SubStr(StrModif_Advan, Pos, 1);
         if( Symbol == ":" )   // Если нашли двоеточие, то все нормально
             TmpStr = SubStr(StrModif_Advan, 1, Pos - 1);
             /* Если не расширенные, то добавляем в строку стандартных параметров форматирования */
             if( TmpStr )
                 if( Not Index(TmpStr, "ex_") )
                     if( this.StandartLexem )  this.StandartLexem = this.StandartLexem + ":" + TmpStr;
                     else                      this.StandartLexem = TmpStr;
                     end;
                 end;
             end;
             StrModif_Advan = SubStr(StrModif_Advan, Pos + 1);

         // Если нашли скобку, то будем искать её завершение
         elif( Symbol == "(" )
             Lexem          = "";
             NumBegBrackets = 0;
             NumEndBrackets = 0;

             while( Pos )
                 Symbol         = SubStr(StrModif_Advan, Pos, 1);
                 Lexem          = Lexem + SubStr(StrModif_Advan, 1, Pos);
                 StrModif_Advan = SubStr(StrModif_Advan, Pos + 1);

                 if( Symbol == ")" ) // Закрывающая скобка
                     NumEndBrackets = NumEndBrackets + 1;
                     if( NumEndBrackets == NumBegBrackets )
                         Pos = 0;
                     end;
                 else                // Открывающая скобка
                     NumBegBrackets = NumBegBrackets + 1;
                 end;

                 if( Pos )
                     Pos = StrBrk(StrModif_Advan, "()");
                 end;
             end;
             if( Lexem )
                 this.AddExtendedLexems( Lexem );
             end;
         else
             MsgBox("Ошибка в строке модификатора форматирования!|", "<",_StrModif_Advan,">");
             Exit(1);
         end;
         Pos = StrBrk(StrModif_Advan, "():");
     end;

     /* Проверим хвост строки параметров, если он существует */
     if( StrModif_Advan )
         if( this.StandartLexem )  this.StandartLexem = this.StandartLexem + ":" + StrModif_Advan;
         else                      this.StandartLexem = StrModif_Advan;
         end;
     end;

     // Проверим корректность стандарных символов форматирования
     if( ___FlagDebug___ )
         this.CheckStandartLexem( this.StandartLexem );
     end;
  End; /* CatExtendedLexems */

  macro CheckSymbolStandartLexem( Symbol:string ) : bool
        return (Index(strupr(StandartLexem), strupr(Symbol)) > 0 );
  end;

  // Метод проверки строки стандартных модификаторов печати на допустимые символы
  macro CheckStandartLexem( _StandartLexem ) : bool
        var i     :integer = 1;
        var Size  :integer = 0;
        var Symbol:string  = "";                           // Переменная для хранения символа
        var TmpStr:string  = _StandartLexem;

        TmpStr = StrSubst(TmpStr, ":", ""); // Вычистим ":"
        Size   = StrLen(TmpStr);
        while( i <= Size )
           Symbol = SubStr(TmpStr, i, 1);
           if( NOT StrBrk(Symbol, STANDART_MODIFIER) )
               MsgBox("Ошибка в строке модификатора форматирования!|", "<",_StandartLexem,">",
                      "|Используется недопустимый символ <", Symbol,">");
               return FALSE;
           end;
           i = i + 1;
        end;
        return TRUE;
  end;

  // Добавить в массив расширенных параметров форматирования ещё один элемент
  macro AddExtendedLexems( _StrModif_Advan:string )
        if( NOT ArrExtendedLexems )
            this.ArrExtendedLexems = tarray(2, 5);
        end;
        this.ArrExtendedLexems[this.ArrExtendedLexems.Size] = _StrModif_Advan;
  end;

  // Добавить в массив расширенных параметров форматирования данные из списка
  macro AddExtendedLexemsLs( ls:tarray )
        var i:integer = 0;

        if( NOT ArrExtendedLexems )
            this.ArrExtendedLexems = tarray(2, 5);
        end;

        while( i < ls.Size )
           this.ArrExtendedLexems[this.ArrExtendedLexems.Size] = ls[i];
           i = i + 1;
        end;
  end;

  // Вернуть копию массива расширенного форматирования
  macro CopyExtendedLexems() : tarray
        var ls:tarray  = tarray(2,5);
        var i :integer = 0;
        var lsTemp:tarray = GetExtendedLexems();
        while( i < lsTemp.Size )
           ls[i] = lsTemp[i];
           i = i + 1;
        end;
        return ls;
  end;
  
  /* Инициализация класса */
  Macro Init(l_StrValue, l_StrModif_Whole:integer, l_StrModif_Fract:integer, l_StrModif_Advan:string, l_FlagStr:integer)

     var ValTypeValue:integer = ValType(l_StrValue);  // Тип значения

     if( ValTypeValue       )  this.StrValue = l_StrValue;   end;
     if( ValType(l_FlagStr) )  this.FlagStr  = l_FlagStr ;   end;

     if( ValType(l_StrModif_Whole) )
         this.StrModif_Whole = l_StrModif_Whole;
     else
         if  ( ValTypeValue == V_INTEGER )   this.StrModif_Whole =  9;
         elif( ValTypeValue == V_DOUBLE  )   this.StrModif_Whole = 12;
         elif( ValTypeValue == V_MONEY   )   this.StrModif_Whole = 16;
         elif( ValTypeValue == V_DATE    )   this.StrModif_Whole = 10;
         elif( ValTypeValue == V_TIME    )   this.StrModif_Whole =  8;
         end;
     end;
     if( ValType(l_StrModif_Fract) )
         this.StrModif_Fract = l_StrModif_Fract;
     else
         if( (ValTypeValue == V_DOUBLE) or (ValTypeValue == V_MONEY) )
             this.StrModif_Fract = 2;
         end;
     end;
      
     if( ValType(l_StrModif_Advan) )
         this.CatExtendedLexems( l_StrModif_Advan );
     else
           
         if  ( (ValTypeValue == V_INTEGER) or (ValTypeValue == V_DOUBLE) or (ValTypeValue == V_MONEY )or (ValTypeValue == V_TIME  ) )
             this.StandartLexem = "r";
         elif( (ValTypeValue == V_DATE   )  )
             this.StandartLexem = "l";
         end;
     end;

  End; /* Init */

  /* Конструктор */
  this.Init(_StrValue, _StrModif_Whole, _StrModif_Fract, _StrModif_Advan, _FlagStr);

END; /* CParamPrintCell */

/* Класс для заполнения данных по одной выводимой ячейке для заголовка (для режимов отличных от DOS) */
CLASS CParamHeaderCell(_StrValue,            _StrModif_Whole:integer, _Border_Up   :integer, 
                       _Border_Down:integer, _Border_Left   :integer, _Border_Right:integer)

  VAR StrValue      :variant;      /* Содержимое ячейки */
  VAR StrModif_Whole:integer = 25; /* Модификатор количества символов */
  VAR Border_Up     :integer = 1;  /* Наличие верхнего бордюра ячейки */
  VAR Border_Down   :integer = 1;  /* Наличие нижнего бордюра ячейки */
  VAR Border_Left   :integer = 1;  /* Наличие левого бордюра ячейки */
  VAR Border_Right  :integer = 1;  /* Наличие правого бордюра ячейки */
  
  /* Инициализация класса */
  Macro Init(l_StrValue    :variant, l_StrModif_Whole:integer, l_Border_Up   :integer, 
             l_Border_Down:integer,  l_Border_Left   :integer, l_Border_Right:integer);

     if( ValType(l_StrValue) )
         this.StrValue = l_StrValue;
     end;

     if( ValType(l_StrModif_Whole) )
         this.StrModif_Whole = l_StrModif_Whole;
     else 
         if  ( ValType(l_StrValue) == V_INTEGER)   this.StrModif_Whole =  9;
         elif( ValType(l_StrValue) == V_DOUBLE )   this.StrModif_Whole = 12;
         elif( ValType(l_StrValue) == V_MONEY  )   this.StrModif_Whole = 16;
         elif( ValType(l_StrValue) == V_DATE   )   this.StrModif_Whole = 10;
         elif( ValType(l_StrValue) == V_TIME   )   this.StrModif_Whole =  8;
         end;
     end;
     if( ValType(l_Border_Up   ) )   this.Border_Up    = l_Border_Up   ;   end;
     if( ValType(l_Border_Down ) )   this.Border_Down  = l_Border_Down ;   end;
     if( ValType(l_Border_Left ) )   this.Border_Left  = l_Border_Left ;   end;
     if( ValType(l_Border_Right) )   this.Border_Right = l_Border_Right;   end;

  End; /* Init */

  /* Конструктор */
  this.Init(_StrValue, _StrModif_Whole, _Border_Up, _Border_Down, _Border_Left, _Border_Right);

END; /* CParamHeaderCell */


/* Класс для отсканированых данных из квадратных скобок */
CLASS CScanData(_ScanData:variant, _StrModif:string, _Flag_statData:bool,_Whole:integer)

   VAR ScanData:variant;        /* Отсканированные данные */
   VAR StrModif:string    = ""; /* Строка модификаторов */ 
   VAR Whole   :integer   = 0 ;
   VAR Flag_statData:bool = TRUE; /* Флаг статических данных, 
                                    т.е. параметры в круглых скобках Flag_statData=TRUE, 
                                    за скобками                      Flag_statData=FALSE */
   
   /* Инициализация класса */
   Macro Init(l_ScanData:variant, l_StrModif:string, l_Flag_statData:bool,_Whole:integer)

      if( ValType(l_ScanData     ) )  this.ScanData      = l_ScanData;      end;
      if( ValType(l_StrModif     ) )  this.StrModif      = l_StrModif;      end; //this.StrModif = SubStr(l_StrModif, 1, StrLen(l_StrModif)); end; // Обход ошибки в инструменте RSL
      if( ValType(l_Flag_statData) )  this.Flag_statData = l_Flag_statData; end;
      if( ValType(_Whole         ) )  this.Whole         = _Whole;          end;
   End; /* Init */

   /* Конструктор */
   this.Init(_ScanData, _StrModif, _Flag_statData,_Whole:integer);

   /* Внутренний метод для разделения стандартных и расширенных параметров форматирования */
   Macro CatExtendedLexems( _StrModif_Advan:string, _ArrExtendedLexems:@tarray ) : string

      var StrModif_Advan   :string  = _StrModif_Advan;              // Переданная строка параметров форматирования
      var Pos              :integer = StrBrk(StrModif_Advan, "(:"); // Позиция найденного символа
      var TmpStr           :string  = "";                           // Вспомогательная строка
      var NumBegBrackets   :integer = 0;                            // Счетчик открывающихся скобок
      var NumEndBrackets   :integer = 0;                            // Счетчик открывающихся скобок
      var Symbol           :string  = "";                           // Переменная для хранения символа
      var Lexem            :string  = "";
      var StandartLexem    :string  = "";                           // Возвращаемая строка со стандартными параметрами форматирвоания */
      var ArrExtendedLexems:tarray  = tarray;                       // Массив расширенных параметров форматирования */
      
      while( Pos )
          Symbol = SubStr(StrModif_Advan, Pos, 1);
          if( Symbol == ":" )   // Если нашли двоеточие, то все нормально
              TmpStr = SubStr(StrModif_Advan, 1, Pos - 1);
              /* Если не расширенные, то добавляем в строку стандартных параметров форматирования */
              if( TmpStr )
                  if( Not Index(TmpStr, "ex_") )
                      if( StandartLexem )  StandartLexem = StandartLexem + ":" + TmpStr;
                      else                 StandartLexem = TmpStr;
                      end;
                  end;
              end;
              StrModif_Advan = SubStr(StrModif_Advan, Pos + 1);

          // Если нашли скобку, то будем искать её завершение
          elif( Symbol == "(" )
              Lexem          = "";
              NumBegBrackets = 0;
              NumEndBrackets = 0;

              while( Pos )
                  Symbol         = SubStr(StrModif_Advan, Pos, 1);
                  Lexem          = Lexem + SubStr(StrModif_Advan, 1, Pos);
                  StrModif_Advan = SubStr(StrModif_Advan, Pos + 1);

                  if( Symbol == ")" ) // Закрывающая скобка
                      NumEndBrackets = NumEndBrackets + 1;
                      if( NumEndBrackets == NumBegBrackets )
                          Pos = 0;
                      end;
                  else                // Открывающая скобка
                      NumBegBrackets = NumBegBrackets + 1;
                  end;

                  if( Pos )
                      Pos = StrBrk(StrModif_Advan, "()");
                  end;
              end;
              if( Lexem )
                  ArrExtendedLexems[ArrExtendedLexems.Size()] = Lexem;
              end;
          else
              MsgBox("Ошибка в строке модификатора форматирования!|", "<",_StrModif_Advan,">");
              Exit(1);
          end;
          Pos = StrBrk(StrModif_Advan, "():");
      end;

      /* Проверим хвост строки параметров, если он существует */
      if( StrModif_Advan )
          if( StandartLexem )  StandartLexem = StandartLexem + ":" + StrModif_Advan;
          else                 StandartLexem = StrModif_Advan;
          end;
      end;

      _ArrExtendedLexems = ArrExtendedLexems;
      
      return StandartLexem; // Вернем строку стандартных параметров
   End; /* CetExtendedLexems */
   
   // Возращает кол-во знаков после запятой

   Macro GetArrStandartLexems():Tarray
        var ExtStr         :string  = CatExtendedLexems(this.StrModif),//строка из которой получаем кол-во знаков после запятой
        Pos1          :integer          ,                              //длинна блока между : :
        Tmp           :String       = "";
        var ArrStandartLexems:tarray  = tarray(5,1);
        While(ExtStr)
           pos1   = Index(ExtStr,":");
           if(Not pos1)
             pos1 = 2;
           end;
           Tmp    = Substr(ExtStr,1,Pos1-1);
           if(Tmp)
              ArrStandartLexems[ArrStandartLexems.Size] = Tmp;
              ExtStr = Substr(ExtStr,Pos1 + 1);
           else
              ExtStr = "";
           end;
       end; 
       return  ArrStandartLexems;
   End;//GetArrStandartLexems()

   Macro GetFloatPoint() :integer
   
       var i              :integer =  1; //счёсчик цикла начиная с конца строки т.к учитывается последний модификатор
       var  whole         :integer = -1;
       var  FloatPoint    :integer = -1;//-1 - по умолчанию для double и money
       var  ArrStr        :Tarray  = GetArrStandartLexems();       
       i = ArrStr.Size-1;

       while( i >= 0 )
           //сначала идёт модификатор длинны который не обрабатывается(только для поддержки старого кода)
           //потом идёт кол-во точек после запятой
           if(int(ArrStr[i]) OR ((ArrStr[i]) == "0"))
               if  (FloatPoint == -1 )  FloatPoint = int(ArrStr[i]);
               elif(whole == -1)        whole      = int(ArrStr[i]);
               else
                   if(whole!=-1)                       
                       return     FloatPoint;
                   else                      
                       break;
                   end;
               end;
           end;
       i = i - 1;
       end;

       if( whole == -1)   
           FloatPoint = -1;
       end; 
 
       if(FloatPoint == -1 )
           if(ValType(ScanData) != V_INTEGER )  return 2; 
           else                                 return 0; 
           end              
       end;
       return FloatPoint;
   end;//GetFloatPoint    
   
END; /* CScanData */

/**** Объект с данными шаблонов разделителей */
class ClsTemplate()

      private var lsTemplate:tarray = tarray(10,10);   // массив для хранения шаблонных строк разделителей

      // Взять значение шаблона номер NumTemplate для закладки Sheet
      macro Get( Sheet:integer, NumTemplate:integer ) : string
            return lsTemplate.Value(Sheet).Value(NumTemplate);
      end;

      // Присвоить значение шаблона номер NumTemplate для закладки Sheet
      macro Set( Sheet:integer, NumTemplate:integer, Value:string )
            if( Sheet >= lsTemplate.Size )
                lsTemplate[Sheet] = tarray;
            end;
            lsTemplate.Value(Sheet).Value(NumTemplate) = Value;
      end;

      // Присвоить значение шаблона номер NumTemplate для закладки Sheet
      macro Add( Sheet:integer, Value:string )
            if( Sheet >= lsTemplate.Size )
                lsTemplate[Sheet] = tarray;
            end;
            lsTemplate.Value(Sheet).Value(lsTemplate.Value(Sheet).Size) = Value;
      end;

      // Очистить значение всех шаблонов
      macro Clear()
            lsTemplate = tarray;
      end;

      // Вернуть кол-во закладок для которых установлены шаблоны
      macro CountSheet() : integer
            return lsTemplate.Size;
      end;
end;


class CComment( _Row:integer, _Col:integer, _Value:string )
      var Row  :integer = _Row  ; // Координаты ячейки,
      var Col  :integer = _Col  ; // к которой привязано примечание
      var Value:string  = _Value; // Текст примечания
end;

/**** Объект с данными комментариев к ячейкам */
class ClsComment()

      private var lsComment:tarray = tarray;   // массив для хранения комментариев

      // Метод возвращает размер массива
      macro Size() : integer
            return lsComment.Size;
      end;

      // Метод очищает объект
      macro Clear()
            lsComment = tarray;
      end;

      // Добавить примечание в список
      macro Add( Row:integer, Col:integer, Value:string )
            lsComment[lsComment.Size] = CComment(Row, Col, Value);
      end;

      // Печать примечаний в файл
      macro PrintComment( HTMLFile )

            var i:integer = 0;

            if( lsComment.Size )
                WR_Insert(HTMLFile, "<div style='mso-element:comment-list'>");
                WR_Insert(HTMLFile, "<div style='mso-element:comment'>"     );
                WR_Insert(HTMLFile, "<div>"                                 );

                WR_Insert(HTMLFile, "<!--[if gte mso 9]><xml>");
                while( i < lsComment.Size )
                   WR_Insert(HTMLFile, " <v:shapetype id=\"_x0000_t202\" coordsize=\"21600,21600\" o:spt=\"202\" path=\"m,l,21600r21600,l21600,xe\">");
                   WR_Insert(HTMLFile, " </v:shapetype><v:shape id=\"_x0000_s102"+String(i)+"\" type=\"#_x0000_t202\" style='position:absolute;");
                   WR_Insert(HTMLFile, "  margin-left:65.25pt;margin-top:1.5pt;width:96pt;height:55.5pt;z-index:1;");
                   WR_Insert(HTMLFile, "  visibility:hidden' fillcolor=\"infoBackground [80]\" o:insetmode=\"auto\">");
                   WR_Insert(HTMLFile, "  <x:ClientData ObjectType=\"Note\">");
                   WR_Insert(HTMLFile, "   <x:Row>"+String(lsComment[i].Row)+"</x:Row>");
                   WR_Insert(HTMLFile, "   <x:Column>"+String(lsComment[i].Col)+"</x:Column>");
                   WR_Insert(HTMLFile, "   <x:Author>R-Style</x:Author>");
                   WR_Insert(HTMLFile, "  </x:ClientData>");
                   WR_Insert(HTMLFile, " </v:shape></xml>");
                   i = i + 1;
                end;
                WR_Insert(HTMLFile, "<![endif]-->");

                i = 0;
                while( i < lsComment.Size )
                   WR_Insert(HTMLFile, " <div v:shape=\"_x0000_s102"+String(i)+"\" class=shape><font class=\"font6\">"
                                      +/*ToAnsi*/(String(lsComment[i].Value))+"</font></div>");
                   i = i + 1;
                end;
            end;

      end;

      // Отладочная печать данных объекта
      macro PrintDebug()
            var i:integer = 0;
            while( i < lsComment.Size )
               println("-----------------------------");
               println("Row  -",lsComment[i].Row  );
               println("Col  -",lsComment[i].Col  );
               println("Value-",lsComment[i].Value);
               i = i + 1;
            end;
            if( lsComment.Size )
               println("-----------------------------");
            end;
      end;
end;


/**** Объект с данными одного документа слияния (закладки) */
class CTemplateDocument( _NameTemplate:string, _NameTemplateDoc:string, _NameOutFile:string )

      var NameTemplate    :string = "";     // Наименование шаблона
      var NameTemplateDoc :string = "";     // Наименование файла шаблона
      var NameTemplatePath:string = "";     // Путь до файла шаблона
      var NameOutFile     :string = "";     // Наименование выходного файла

      private var lsNameFields    :tarray = tarray; // Список Названий полей шаблона
      private var lsValueFields   :tarray = tarray; // Двумерный список значений полей шаблона
                                                    // Первая размерность это документы
                                                    // Вторая размерность значения полей документа
      // Конструктор
      if( ValType(_NameTemplate   ) ) NameTemplate    = _NameTemplate   ; end;
      if( ValType(_NameTemplateDoc) ) NameTemplateDoc = _NameTemplateDoc; end;
      if( ValType(_NameOutFile    ) ) NameOutFile     = _NameOutFile    ; end;

      // Добавить название поля в коллекцию полей
      macro AddFieldsName( Name:string )
            lsNameFields[lsNameFields.Size] = Name;
      end;

      // Добавить значение поля в документ
      macro AddFieldsValue( Pos:integer, Value:variant )
            if( Pos == lsValueFields.Size )
                lsValueFields[lsValueFields.Size] = tarray;
            end;
            lsValueFields.value(Pos).Value(lsValueFields.value(Pos).Size) = Value;
      end;

      macro SetFieldsValue( NDoc:integer, NFields:integer, Value:variant )
            lsValueFields.value(NDoc).Value(NFields) = Value;
      end;

      // Метод возвращает значение поля NumFields документа NumDoc
      macro GetFieldsValue( NumDoc:integer, NumFields:integer )
            return lsValueFields.value(NumDoc).Value(NumFields);
      end;

      // Метод возвращает кол-во документов с данными для данного шаблона
      macro GetCountDoc() : integer
            return lsValueFields.Size;
      end;

      // Метод возвращает наименование шаблона
      macro GetTemplateName() : string
            return NameTemplate;
      end;

      // Метод возвращает наименование файла шаблона
      macro GetNameTemplateDoc( Pos:integer ) : string
            return NameTemplateDoc;
      end;
      // Метод возвращает путь до файла шаблона
      macro GetNameTemplatePath( Pos:integer ) : string
            return NameTemplatePath;
      end;
      // Метод возвращает наименование выходного файла
      macro GetNameOutFile( Pos:integer ) : string
            return NameOutFile;
      end;
      // Метод возвращает кол-во полей у шаблона
      macro GetFieldsNameSize() : integer
            return lsNameFields.Size;
      end;

      // Метод возвращает наименование поля с индексом Pos
      macro GetFieldsName( Pos:integer ) : string
            if( Pos < lsNameFields.Size )
                return lsNameFields[Pos];
            else
                return "ОШИБКА! Выход за пределы массива наименования полей!"
            end;
      end;

      // Метод возвращает номер поля по его наименованию Name
      macro GetNumberFields( Name:string ) : integer
            var i:integer = 0;
            while( i < lsNameFields.Size )
                if( lsNameFields[i] == Name )
                    return i;
                end;
                i = i + 1;
            end;
            MsgBox( "Ошибка!|Не найдено поле с именем <",Name,">!" );
            return -1;
      end;

      // Метод устанавливает путь до шаблона
      macro SetNameTemplatePath( NamePath:string )
            NameTemplatePath = NamePath;
      end;

      // Отладочная печать данных объекта
      macro PrintDebug()
            var i:integer = 0;
            var j:integer = 0;
            println( "--------Шаблон--------<",NameTemplate,">" );
            while( i < lsNameFields.Size )
               print( "   ", GetFieldsName(i) );
               // Печатаем данные документов
               j = 0;
               while( j < lsValueFields.Size )
                  print( MkStr(" ",3), lsValueFields.value(j).Value(i) );
                  j = j + 1;
               end;
               println();
               i = i + 1;
            end;
            println( "---END--Шаблон--------<",NameTemplate,">" );
      end;
end;


/**** Объект с данными для формирования документа слияния */
class ClsTemplateDocument()

      private var lsTemplate  :tarray = tarray(3, 5);   // реестр шаблонов
      private var LastDocument:object = NULL;           // Последний добавленный документ

      // Метод возвращает размер реестра шаблонов
      macro Size() : integer
            return lsTemplate.Size;
      end;

      // Получить шаблон из реестра с номером Pos
      macro Get( Pos:integer ) : CTemplateDocument
            return lsTemplate[Pos];
      end;

      // Метод возвращает наименование шаблона из реестра с номером Pos
      macro GetNameTemplate( Pos:integer ) : string
            return Get(Pos).GetTemplateName();
      end;
      // Метод возвращает наименование файла шаблона из реестра с номером Pos
      macro GetNameTemplateDoc( Pos:integer ) : string
            return Get(Pos).GetNameTemplateDoc();
      end;
      // Метод возвращает наименование выходного файла из реестра с номером Pos
      macro GetNameOutFile( Pos:integer ) : string
            return Get(Pos).GetNameOutFile();
      end;
      // Метод возвращает последний добавленный документ
      macro GetLastDocument() : object
            return LastDocument;
      end;

      // Найти в реестре шаблон с именем NameTemplate
      macro FindTemplate( NameTemplate:string ) : integer
            var i:integer = 0;
            while( i < Size )
               if( Get(i).GetTemplateName() == NameTemplate )
                   return i;
               end;
               i = i + 1;
            end;
            return -1;
      end;

      // Добавить в реестр шаблон с именем NameTemplate
      macro AddTemplate( NameTemplate:string, NameTemplateDoc:string, NameOutFile:string ) : object
            var Obj:object = NULL;

            if( FindTemplate(NameTemplate) == -1 ) // Такого шаблона нет - добавляем
                Obj = CTemplateDocument( NameTemplate, NameTemplateDoc, NameOutFile );
                lsTemplate[lsTemplate.Size] = Obj;
            else                                   // Такой шаблон уже есть - ругаемся
                MsgBox("Ошибка!|Шаблон с именем <"+NameTemplate+"> уже есть в реестре шаблонов!");
            end;
            return Obj;
      end;

      // Отладочная печать данных объекта
      macro PrintDebug()
            var i:integer = 0;
            while( i < Size )
               Get(i).PrintDebug();
               i = i + 1;
            end;
      end;

      // Добавить документ по шаблону с именем NameTemplate
      macro AddDocument( NameTemplate:string ) : object
            var Pos:integer = 0;
            var Obj:object  = NULL;

            if( (Pos=FindTemplate(NameTemplate)) != -1 ) // Такой шаблон уже есть - добавляем в него данные
                Obj = lsTemplate[pos];
                LastDocument = Obj;                      // Запомнили последний
            else                                         // Такого шаблона нет - ругаемся
                MsgBox("Ошибка!|Шаблона с именем <"+NameTemplate+">, нет в реестре шаблонов!");
            end;
            return Obj;
      end;

      // Очистить содержимое регистрации шаблона NameTemplate
      macro ClearRegisterForm( NameTemplate:string )
            var i:integer = FindTemplate(NameTemplate); // Индекс шаблона с названием NameTemplate

            if( i != -1 ) // Такой шаблон есть - чистим его
                while( i < Size-1 )
                   lsTemplate[i] = lsTemplate[i + 1];
                   i = i + 1;
                end;
                lsTemplate[Size-1] = NULL;  // Чистим последний элемент
                lsTemplate.Size = Size - 1; // Уменьшаем размер массива
            else          // Такого шаблона нет - ругаемся
                MsgBox("Ошибка!|Шаблона с именем <"+NameTemplate+">, нет в реестре шаблонов!");
            end;
      end;
end;



/**** Объект для работы с html-ным представлением отчета */
Class C_HTML_Report(__Idention        :integer,  // Отступ
                    _ExlusiveFileName :string ,  // Уникальное имя файла
                    _WorkDir          :string ,  // Рабочая директория со временными файлами
                    _FlagModePrint    :integer,  // Флаг режима печати
                    _FlagShowIndicator:bool   ,     // Флаг вывода внутреннего индикатора
                    _ExecuteStrExcel  :tarray      )
   var ArrStrOnEachPage    :tarray       = tarray;           // Массив адресов строк выводимых на каждой странице
   var ArrComment          :ClsComment      = ClsComment();        // Объект с данными примечаний
   var ObjPrinterOptions   :CPrinterOptions = NULL;                // Объект класса CPrinterOptions для установки опций принтера                                           
   var _Idention           :integer         = __Idention;          // Отступ
   var ExlusiveFileName    :string          = _ExlusiveFileName;   // Уникальное имя файла
   var WorkDir             :string          = _WorkDir;            // Рабочая директория со временными файлами
   var FlagModePrint       :integer         = _FlagModePrint;      // Формат печати строк с псевдографическими разделителями
   var FlagShowIndicator   :bool            = _FlagShowIndicator;  // Флаг показа встроенного индикатора

   var FlagIndexStr        :integer         = STR_INDEX_NONE;      // Признак индексной строки
   var PictStr             :string          = "";                  // Ссылка на картинку в ячейке
   var WidthExcelRep       :double          = 0.0;                 // Ширина отчета в Excel
   var WinRepOutput        :integer         = DefaultWinRepOutput; // Приложение, в которое выводится отчет
   var m_ExecuteStrExcel   :tarray          = _ExecuteStrExcel ;
   
   private var KoefScreenH :double          = 0;                   // коэффициенты для учёта маштаба шрифта (раб.стол->свойства\параметры\дополнительно->общие-> маштаб)   
   private var KoefScreenW :double          = 0;
   var ArrFileHTML         :tarray          = tarray;


   // --------------------------------------------------------------------------
   /* (Private) Метод возвращает стандартные размеры (для строки, столбца и т.п.) */
   private
   macro GetStandartSize( Type:integer )
         if( Type == ST_SIZE_ROW_HEIGHT ) return STD_EXCEL_ROWHEIGHT;
         else                             return STD_EXCEL_COLWIDTH ;
         end;
   end;

   // --------------------------------------------------------------------------
   /* (Private) Внутренний метод для подсчета числа столбцов Excel, на которых будет написана строка */
   private
   macro GetCountExcelCol( _BegCell:integer, _SizeStr:integer, ObjSheet:object ) : integer

      var CurSize  :double  = 0.0;       // Текущий размер
      var CountCell:integer = 0;         // Количество ячеек
      var SizeStr  :double  = _SizeStr;  // Допустимый размер строки

      while( CurSize < SizeStr )
          if( (CountCell + _BegCell) < ObjSheet.GetArrColWidth().Size )
               CurSize = CurSize + Double(ObjSheet.GetArrColWidth(CountCell + _BegCell));
          else 
               CurSize = CurSize + GetStandartSize(ST_SIZE_COL_WIDTH);
          end;
          CountCell = CountCell + 1;
      end;
      return CountCell;

   End; /* GetCountExcelCol */

   // --------------------------------------------------------------------------
   /* (Private) Внутренний метод для подсчета числа колонок таблицы отчета, на которых будет написана строка */
   private
   macro GetCountExcelColTable(_BegCell:integer, _SizeStr:integer, _BegCellTable:integer, ObjSheet:object):integer

      var CurSize       :double  = 0.0;                                // Текущий размер
      var CountCell     :integer = 0;                                  // Количество ячеек
      var SzArr         :integer = ObjSheet.GetArrColWidth().Size;     // Размер массива установленных ширин колонок
      var SizeStr       :double  = _SizeStr;                           // Допустимый размер строки
      var SzArrTable    :integer = ObjSheet.GetArrColWidthTable().Size;// Размер массива с ширинами колонок таблицы отчета
      var CountCellTable:integer = 0;                                  // Возвращаемое количество колонок таблицы отчета

      while( CurSize < SizeStr )
         if( (_BegCell + CountCell) < SzArr )
             CurSize = CurSize + Double(ObjSheet.GetArrColWidth(_BegCell + CountCell));
         else 
             CurSize = CurSize + GetStandartSize(ST_SIZE_COL_WIDTH);
         end;
         CountCell = CountCell + 1;
         if( (_BegCellTable + CountCellTable) < SzArrTable )
             if( CurSize > (CountCellTable + Double(SumAllElementArray(ObjSheet.GetArrColWidthTable(), _BegCellTable, _BegCellTable+CountCellTable))) )
                 CountCellTable = CountCellTable + 1;
             end;
         end;
      end;
      return CountCellTable;

   end; /* GetCountExcelColTable */

   // --------------------------------------------------------------------------
   /* (Private) Внутренний метод для конвертирования заголовка таблицы для вывода в Excel */
   private
   macro ConvertExcelHeaderStr( ObjSheet:object )
      var i                :integer   = 0;     /* Счетчик циклов */
      var j                :integer   = 0;     /* Счетчик циклов */
      var k                :integer   = 0;     /* Счетчик циклов */
      var m                :integer   = 0;     /* Счетчик циклов */
      var Pos1             :integer   = 0;     /* Позиция найденного символа-разделителя */
      var Pos2             :integer   = 0;     /* Позиция найденного символа-разделителя */
      var Pos3             :integer   = 0;     /* Позиция найденного символа-разделителя */
      var WorkStr          :string    = "";    /* Вся обрабатываемая строка */
      var CrntStr          :string    = "";    /* Текущая строка */
      var NextStr          :string    = "";    /* Следующая подстрока */
      var TempStr          :string    = "";    /* Вспомогательная переменная для работы со строками */
      var TempCountCol     :integer   = 0;     /* Число полных колонок, соответствующих надписи */
      var FlagAddStr       :bool      = False; /* Флаг указывающий, нужно ли добавлять строку */
      var StrValue         :string    = "";    /* Значение, которое будет напечатано в текущей ячейке */
      var Border_Up        :integer   = 1;     /* Значение для верхнего разделителя текущей ячейки */
      var Border_Down      :integer   = 1;     /* Значение для нижнего разделителя текущей ячейки */
      var Border_Right     :integer   = 1;     /* Значение для правого разделителя текущей ячейки */
      var Border_Left      :integer   = 1;     /* Значение для левого разделителя текущей ячейки */
      var SzArrHead        :integer   = 0;     /* Текущий размер массива строк заголовка таблицы */
      var SplitStr         :string    = "";    /* Вспомогательная переменная для работы с объединенными строками */
      var TempCountColTable:integer   = 0;     /* Число полных колонок таблицы, соответствующих надписи */    
      var TempArrHeaderCell:tarray = tarray;/* Вспомогательная переменная, используемая при формировании пользователем текущей строки заголовка */
      var ArrSubHeaderStr  :tarray = ObjSheet.GetArrSubHeaderStr(); // Массив строк для сокращенного заголовка
      var ArrHeaderStr     :tarray = ObjSheet.GetArrHeaderStr()   ; // Массив ширин

      /* Пока не вводим лишних проверок, а исходим из того, что по логике в заголовке таблицы не может быть меньше трех строк */
      ArrHeaderStr.Size = 0;

      WorkStr = ObjSheet.SheetStrHeader;
      Pos1    = Index(WorkStr, "\n");
      /* Получим текущую строку */
      CrntStr = SubStr(WorkStr, 1, Pos1 - 1);
      TempStr = SubStr(WorkStr, Pos1 + 1);
      Pos2    = Index(TempStr, "\n");

      /* Получим следующую строку */
      if( Pos2 )
          NextStr = SubStr(TempStr, 1, Pos2 - 1);
      else
          NextStr = TempStr;
      end;
      while( Pos1 )
          /* Работаем с текущей строкой */
          Pos3       = StrBrk(CrntStr, "│├┤");
          j          = 0;
          m          = 0;
          FlagAddStr = False;
          while( Pos3 )
              if( Pos3 > 1 )
                  /* Получим число полных колонок, соответствующих надписи */
                  TempCountCol      = GetCountExcelCol(j, Pos3, ObjSheet);
                  TempCountColTable = GetCountExcelColTable(j, Pos3, m, ObjSheet);
                  i                 = 0;
                  while( i < TempCountCol )
                      if( (Not Index(SubStr(CrntStr, 1, Pos3 - 1), "─"))and(Not i) )
                          StrValue   = Trim(SubStr(CrntStr, 1, Pos3 - 1));
                          FlagAddStr = True;
                      else
                          StrValue   = "";
                      end;

                      /* Определим типы разделителей между ячейками заголовка таблицы */
                      /* Правый разделитель */
                      if( i < (TempCountCol - 1) )
                          Border_Right = 0;
                      end;

                      /* Левый разделитель */
                      if( Not i )
                          Border_Left = 1;
                      else
                          if( Not TempArrHeaderCell[m].Border_Right )  Border_Left = 0;
                          else                                         Border_Left = 1;
                          end;
                      end;
                      /* Нижний разделитель */
                      if( Not Index(SubStr(NextStr, 1, Pos3 - 1), "─") )  Border_Down = 0;
                      else                                                Border_Down = 1;
                      end;
                      /* Верхний разделитель */
                      SzArrHead = ArrHeaderStr.Size();
                      if( Not SzArrHead )
                          Border_Up = 1;
                      else
                          if( Not ArrHeaderStr.Value(SzArrHead - 1).Value(i + j).Border_Down )
                              Border_Up = 0;
                              /* Переносим данные и боковое обрамление в верхнюю из объединяемых ячеек */
                              k = SzArrHead - 1;
                              while( Not ArrHeaderStr.Value(k).Value(i + j).Border_Up )
                                  k = k - 1;
                              end;
                              SplitStr = Trim(ArrHeaderStr.Value(k).Value(i + j).StrValue);
                              if( SplitStr )
                                  if( StrValue )
                                      SplitStr = SplitStr + " " + StrValue;
                                  end;
                              else
                                  if( StrValue )
                                      SplitStr = StrValue;
                                  end;
                              end;
                              ArrHeaderStr.Value(k).Value(i + j).StrValue     = SplitStr;
                              ArrHeaderStr.Value(k).Value(i + j).Border_Left  = Border_Left;
                              ArrHeaderStr.Value(k).Value(i + j).Border_Right = Border_Right;
                              StrValue = "";
                          else
                              Border_Up = 1;
                          end;
                      end;                          
                      /* Формируем ячейку для Excel */
                      TempArrHeaderCell[TempArrHeaderCell.Size] = CParamHeaderCell(StrValue, ObjSheet.GetArrColWidthTable(m), Border_Up, Border_Down, Border_Left, Border_Right);

                      i = i + 1;
                  end;
                  m = m + TempCountColTable;
                  j = j + i;
              end;
              CrntStr = SubStr(CrntStr, Pos3 + 1);
              NextStr = SubStr(NextStr, Pos3 + 1);
              Pos3    = StrBrk(CrntStr, "│├┤");
          end; 
          
          if( FlagAddStr )
              if( TempArrHeaderCell.Size > 0 )
                  ObjSheet.AddArrHeaderStr( TempArrHeaderCell );
                  TempArrHeaderCell = tarray();
              end;
          else
              TempArrHeaderCell = tarray(); /* Если строка содержит только разделители */
          end;
          WorkStr = SubStr(WorkStr, Pos1 + 1);
          Pos1    = Index(WorkStr, "\n");

          /* Получим текущую строку */
          CrntStr = SubStr(WorkStr, 1, Pos1 - 1);
          TempStr = SubStr(WorkStr, Pos1 + 1);
          Pos2    = Index(TempStr, "\n");

          /* Получим следующую строку */
          if( Pos2 )  NextStr = SubStr(TempStr, 1, Pos2 - 1);
          else        NextStr = TempStr;
          end;
      end;

      // Формирование массива ячеек для подзаголовка
      if( NOT ObjSheet.FlagPrintFullHeader )
          ArrSubHeaderStr[0] = ArrHeaderStr[ArrHeaderStr.Size-1];
      end;

   End; /* ConvertExcelHeaderStr */

   // --------------------------------------------------------------------------
   /* (private) Пользовательский метод расчета высоты СКОНВЕРТИРОВАННОГО заголовка таблицы отчета */     
   private
   macro CalcHeaderHeight( ObjSheet:object ):integer

      var ArrParamPrintStr:tarray= NULL;   // Массив для ячеек текущей строки заголовка
      var i               :integer  = 0;      // Счетчик циклов
      var j               :integer  = 0;      // Счетчик циклов
      var CountHeaderStr  :integer  = 0;      // Число строк заголовка

      while( i < ObjSheet.GetArrHeaderStr().Size )
          ArrParamPrintStr = ObjSheet.GetArrHeaderStr(i);
          j = 0;
          while( j < ArrParamPrintStr.Size )
              /* Если хоть одна ячейка в псевдостроке имеет верхнее обрамление, значит это действительно новая строка */
              if( ArrParamPrintStr[j].Border_Up)
                  j              = ArrParamPrintStr.Size;
                  CountHeaderStr = CountHeaderStr + 1;
              else
                  j = j + 1;
              end;
          end;
          i = i + 1;
      end;
      return CountHeaderStr;
   end; /* CalcHeaderHeight */

   // --------------------------------------------------------------------------
   /**** (private) Метод обработки расширенных параметров форматирования для Excel */
   private
   macro HTML_SetExtendedParam( _ArrExtendedLexems:tarray, Repeat1:bool, Repeat2:bool, Repeat3:bool,
                                        CurRow:integer, CurCol:integer,
                                        ArrParamPrintStr:tarray, TempStr:string, ObjSheet:object )
      var k               :integer = 0;  /* Счетчик циклов */
      var ii              :integer = 0;  /* Счетчик циклов */
      var Col             :integer = 0;  /* Искомы номер колонки     */
      var Width           :integer = 0;  /* Ширина до текущей ячейки */
      var TmpWidth        :integer = 0;  /* Ширина до текущей ячейки */
      var Arg             :string  = ""; /* Строка аргументов расширенного параметра форматирования */
      var StrExtendedParam:string  = ""; /* Результирующая строка форматирования */
      var StrHex          :string  = ""; /* Ввиду того, что в Excel и в HTML формат RGB полностью антогонистичен, придется
                                            хитрить, чтобы пользоваться едиными константами */

      /* На всякий случай сразу сбросим признак индексной строки */
      this.FlagIndexStr = STR_INDEX_NONE;

      this.PictStr = ""; // По умолчанию картинки нет

      /* Проверим все параметры расширенного форматирования */
      while( k < _ArrExtendedLexems.Size )

           /* Обработаем обрамление границ */
           if( Index(_ArrExtendedLexems[k], B_LEX) )
               Arg = StrUpr(GetArg(_ArrExtendedLexems[k], B_LEX, LEX_END));

               if( Arg )
                   if( Index(Arg, "L") ) StrExtendedParam = StrExtendedParam + " border-left:"   + HTML_StBorderWeight + " solid windowtext;";
                   else                  StrExtendedParam = StrExtendedParam + " border-left:.none;";
                   end;
                   if( Index(Arg, "T") ) StrExtendedParam = StrExtendedParam + " border-top:"    + HTML_StBorderWeight + " solid windowtext;";
                   else                  StrExtendedParam = StrExtendedParam + " border-top:.none;";
                   end;
                   if( Index(Arg, "R") ) StrExtendedParam = StrExtendedParam + " border-right:"  + HTML_StBorderWeight + " solid windowtext;";
                   else                  StrExtendedParam = StrExtendedParam + " border-right:.none;";
                   end;
                   if( Index(Arg, "B") ) StrExtendedParam = StrExtendedParam + " border-bottom:" + HTML_StBorderWeight + " solid windowtext;";
                   else                  StrExtendedParam = StrExtendedParam + " border-bottom:.none;";
                   end;
               end;

           /* Обработаем стили шрифта */
           elif( Index(_ArrExtendedLexems[k], FS_LEX) )
               Arg = StrUpr(GetArg(_ArrExtendedLexems[k], FS_LEX, LEX_END));
               if( Arg != "" )
                   if( Index(Arg, "B") ) StrExtendedParam = StrExtendedParam + " font-weight: bold;" ;  end;
                   if( Index(Arg, "I") ) StrExtendedParam = StrExtendedParam + " font-style: italic;";  end;
                   if( Index(Arg, "U") ) StrExtendedParam = StrExtendedParam + " text-decoration: underline; text-underline-style: single;";  end;
                   if( Index(Arg, "T") ) FlagIndexStr = STR_INDEX_TOP ;    end;
                   if( Index(Arg, "D") ) FlagIndexStr = STR_INDEX_DOWN;    end;
               end;

           /* Обработаем размеры шрифта */
           elif( Index(_ArrExtendedLexems[k], FZ_LEX) )
               if( (Arg = GetArg(_ArrExtendedLexems[k], FZ_LEX, LEX_END)) )
                   StrExtendedParam = StrExtendedParam + " font-size: " + Trim(Arg) + "pt;";
               end;

           /* Обработаем тип (наименование) шрифта */
           elif( Index(_ArrExtendedLexems[k], FN_LEX) )
               if( (Arg = GetArg(_ArrExtendedLexems[k], FN_LEX, LEX_END)) )
                   StrExtendedParam = StrExtendedParam + " font-family: " + Trim(Arg) + ", monospace;";
               end;

           /* Обработаем цвет шрифта */
           elif( Index(_ArrExtendedLexems[k], FC_LEX) )
               if( (Arg = GetArg(_ArrExtendedLexems[k], FC_LEX, LEX_END)) )
                   StrHex = ToHex(Int(Trim(Arg)), 6);
                   StrExtendedParam = StrExtendedParam + " color: #" + SubStr(StrHex,5,2) + SubStr(StrHex,3,2) + SubStr(StrHex,1,2) + ";";
               end;

           /* Обработаем цвет заливки шрифта */
           elif( Index(_ArrExtendedLexems[k], BC_LEX) )
               if( (Arg = GetArg(_ArrExtendedLexems[k], BC_LEX, LEX_END)) )
                   StrHex = ToHex(Int(Trim(Arg)), 6);
                   StrExtendedParam = StrExtendedParam + " background: #" + SubStr(StrHex,5,2) + SubStr(StrHex,3,2) + SubStr(StrHex,1,2) + ";";
               end;

           /* Обработаем поворот ячеек шрифта */
           elif( Index(_ArrExtendedLexems[k], ROTATE_LEX) )
               if( (Arg = GetArg(_ArrExtendedLexems[k], ROTATE_LEX, LEX_END)) )
                   StrExtendedParam = StrExtendedParam + " mso-rotate:" + Arg + ";";
               end;

           /* Обработаем картинку в ячейке */
           elif( Index(_ArrExtendedLexems[k], PICT_LEX) )
               if( (Arg = GetArg(_ArrExtendedLexems[k], PICT_LEX, LEX_END)) )
                   PictStr = " <img SRC=\""+Arg+"\">;";
               end;

           /* Обработаем комментарии к ячейкам */
           elif( Index(_ArrExtendedLexems[k], COM_LEX) )
               if( Repeat3 OR ((NOT Repeat2) AND (NOT Repeat3)) ) // Если это вторая часть раздвоенной строки, то примечание не нужно
                   if( (Arg = GetArg(_ArrExtendedLexems[k], COM_LEX, LEX_END)) )
                       // Определим номер первой колонки, на которой начнется CurCol-ая ячейка
                       // Определим ширину до CurCol-ой ячейки
                       while( ii < CurCol )
                          if(ArrParamPrintStr[ii].FlagPrint)
                              Width = Width + ArrParamPrintStr[ii].StrModif_WholeE;                           
                          end;
                          
                          ii = ii + 1;
                       end;
                       
                       // Определим номер колонки
                       ii = 0;
                       while( ii < ObjSheet.GetArrColWidth().Size )
                          if( TmpWidth >= Width )
                              Col = ii;
                              ii  = ObjSheet.GetArrColWidth().Size;
                          else
                              TmpWidth = TmpWidth + ObjSheet.GetArrColWidth(ii);
                              ii = ii + 1;
                          end;
                       end;
                       ArrComment.Add(CurRow-1, Col, Arg);
                   end;
               end;
           end;
           k = k + 1;
      end;
      if( StrExtendedParam )
          TempStr = TempStr + " style=\"" + StrExtendedParam + "\"";
      end;

      return TempStr;

   end; /* HTML_SetExtendedParam */

   // --------------------------------------------------------------------------
   /* (private) Метод установки параметров страницы на принтере */
   private
   macro HTML_SetPageOptions( HTMLFile, ObjSheet:object )

      var StrSidePage:string = "";                      // Строка с буквами, характ-ми сторону страницы (слева,по центру,справа)
      var ObjMargin  :object = ObjSheet.GetObjMargin(); // Маржинцы страницы ObjSheet

      /* Пропишем все колонтитулы */
      WR_Insert(HTMLFile, "<style>" );
      WR_Insert(HTMLFile, "@page\n{");

      if( ExcelLanguage == LANGUAGE_RUS )
          StrSidePage = /*ToAnsi*/("ЛЦП");
          /* Если пользователь сам не менял колонтитулы через SetMarginText, то установим их по умолчанию с учетом языка */
          if( Not ObjSheet.FlagMarginTextUsed )
              /* Если текст содержит таблицу, то установим нумерацию страниц по умолчанию */
              if( Index(ObjSheet.SheetStrHeader, "┌") )
                  ObjMargin.SetMarginText(MARGIN_BC, MARGIN_RUS_PAGE_OF_PAGE);
              end;                               
          end;
      else 
          StrSidePage = "LCR";
          /* Если пользователь сам не менял колонтитулы через SetMarginText, то установим их по умолчанию с учетом языка */
          if( Not ObjSheet.FlagMarginTextUsed )
              /* Если текст содержит таблицу, то установим нумерацию страниц по умолчанию */
              if( Index(ObjSheet.SheetStrHeader, "┌") )
                  ObjMargin.SetMarginText(MARGIN_BC, MARGIN_ENG_PAGE_OF_PAGE);
              end;                               
          end;
      end;

      ObjMargin.Normalization();  // Обработаем спецсимволы

      /* Установим тексты колонтитулов */ 
      WR_Insert(HTMLFile, "mso-header-data:\""
                    + "&" + SubStr(StrSidePage, 1, 1) + /*ToAnsi*/(ObjMargin.TLMarginText)
                    + "&" + SubStr(StrSidePage, 2, 1) + /*ToAnsi*/(ObjMargin.TCMarginText)
                    + "&" + SubStr(StrSidePage, 3, 1) + /*ToAnsi*/(ObjMargin.TRMarginText) + "\";");
      WR_Insert(HTMLFile, "mso-footer-data:\""
                    + "&" + SubStr(StrSidePage, 1, 1) + /*ToAnsi*/(ObjMargin.BLMarginText)
                    + "&" + SubStr(StrSidePage, 2, 1) + /*ToAnsi*/(ObjMargin.BCMarginText)
                    + "&" + SubStr(StrSidePage, 3, 1) + /*ToAnsi*/(ObjMargin.BRMarginText) + "\";");

      WR_Insert(HTMLFile, String("margin:"+
             ObjMargin.GetSizeInch(ObjMargin.TMarginSize), "in ",
             ObjMargin.GetSizeInch(ObjMargin.RMarginSize), "in ",
             ObjMargin.GetSizeInch(ObjMargin.BMarginSize), "in ",
             ObjMargin.GetSizeInch(ObjMargin.LMarginSize), "in;"  ) );

      /* Если при расчете получилось, что нужна альбомная ориентация, то сразу ее зададим */
      if( ObjPrinterOptions.Orientation )
          WR_Insert(HTMLFile, ObjPrinterOptions.Orientation);
      end;

      WR_Insert(HTMLFile,"}br\n{mso-data-placement:same-cell;}\n");

      WR_Insert(HTMLFile, "</style>");

   end; /* HTML_SetPageOptions */

   // --------------------------------------------------------------------------
   /* (private) Метод установки настроек печати для листа */
   private
   macro HTML_SetPrinterOptions( HTMLFile, ObjSheet:object )

      WR_Insert(HTMLFile, "<x:WorksheetOptions>");

      /* Если необходимо отключаем показ разделительной сетки на листе */
      if( NOT ObjSheet.FlagShowGrid )
          WR_Insert(HTMLFile, "<x:DoNotDisplayGridlines/>");
      end;
      /* Если необходимо отключаем показ нулевых значений на листе */
      if( NOT ObjSheet.FlagShowZeroValue )
          WR_Insert(HTMLFile, "<x:DoNotDisplayZeros/>");
      end;

      /* Устанавливаем параметры, связанные с печатью на принтере */
      if( Not FlagPrinterAbsent )
          WR_Insert(HTMLFile, "<x:FitToPage/>");
          WR_Insert(HTMLFile, "<x:Print>");
          WR_Insert(HTMLFile, "<x:ValidPrinterInfo/>");
          WR_Insert(HTMLFile, "<x:LeftToRight/>");
          WR_Insert(HTMLFile, ObjPrinterOptions.PaperSize);
          WR_Insert(HTMLFile, ObjPrinterOptions.FitWidth );
          WR_Insert(HTMLFile, "<x:FitHeight>330</x:FitHeight>");
          WR_Insert(HTMLFile, "</x:Print>");
      end;
      WR_Insert(HTMLFile, "</x:WorksheetOptions>");

   end; /* HTML_SetPrinterOptions */

   // --------------------------------------------------------------------------
   /* (private) Метод установки параметров для разрывов страниц */
   private
   macro HTML_SetPageBreakOptions( HTMLFile, ObjSheet:object )
      var HTMLStrBreak    :string  = ""; /* Строка для обработки PageBreak в HTML */
      var NumStr          :integer = 0;
      var i               :integer = 0;
      var j               :integer = 0;
      var HeaderHeight    :integer = CalcHeaderHeight(ObjSheet);      // Посчитаем на всякий случай высоту заголовка таблицы
      var ArrParamPrintStr:tarray  = NULL;
      var FlagNeedHeader  :bool    = TRUE;
      var ArrPrintStr     :tarray  = ObjSheet.GetArrPrintStr();

      /* Посчитаем все PageBreak на листе отчета */
      if( _Idention )
          i = _Idention;
      end;

      while( NumStr < ArrPrintStr.Size )
          ArrParamPrintStr = ArrPrintStr[NumStr];

          /* Если очередная строка является строкой таблицы, а предыдущая нет, то добавим размер "будущего" заголовка таблицы */
          if( ValCmpArray(ArrParamPrintStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
              if( FlagNeedHeader )
                  i = i + HeaderHeight;
              end;
              FlagNeedHeader = False;
          else
              FlagNeedHeader = True ;
          end;

          if( ArrParamPrintStr[0].StrValue == KEY_STRBREAK )
              HTMLStrBreak = HTMLStrBreak + "<x:RowBreak>\n<x:Row>" + String(i) + "</x:Row>\n</x:RowBreak>\n";
          else
              /* Так как строки, являющиеся только межстрочными разделителями не заносятся в HTML-файл, то их считать не будем */
              if( Not IsArrOnlySeparator(ArrPrintStr[NumStr]) )

                  /* Обработаем раздвоенные строки */
                  j = 0;
                  while( j < ArrParamPrintStr.Size )
                      if( StrBrk(String(ArrParamPrintStr[j].StrValue), "└┴┘├┼┤┌┬┐") )
                          if( this.FlagModePrint == STD_MODEPRINT_WITH_DUALSTR )
                              i = i + 1;
                          end;
                          j = ArrParamPrintStr.Size;
                      end;
                      j = j + 1;
                  end;
                  i = i + 1;
              end;
          end;
          NumStr = NumStr + 1;
      end;

      /* Если хоть один PageBreak есть - добавим в отчет нужную секцию */
      if( HTMLStrBreak )
          WR_Insert(HTMLFile, "<x:PageBreaks>");
          WR_Insert(HTMLFile, "<x:RowBreaks>");
          WR_Insert(HTMLFile, SubStr(HTMLStrBreak, 1, StrLen(HTMLStrBreak) - 1));
          WR_Insert(HTMLFile, "</x:RowBreaks>");
          WR_Insert(HTMLFile, "</x:PageBreaks>");
      end;
   end; /* HTML_SetPageBreakOptions */

   // --------------------------------------------------------------------------
   // (Private) Пользовательский метод для начального выставления ширин колонок отчета в Excel 
   //             или подсчета ширины отчета, если не передана ссылка на файл
   private
   macro HTML_SetExcelColWidth( HTMLFile, ObjSheet:object )
    
      var i          :integer  = 0;                       /* Счетчик циклов            */
      var ColWidth   :double   = 0.0;                     /* Ширина столбца            */
      var TypeVal    :integer  = ValType(HTMLFile);       /* Тип переданного параметра */
      var Koef       :double   = ObjSheet.ExcelKoefWidth;
      var ArrColWidth:tarray   = ObjSheet.GetArrColWidth();

      /* Метод определения коэффициента пересчета ширину колонки в Excel в пункты Html */
      /* Зависимости почти экспоненциальная, но мы её апроксимирумем до двух прямых    */
      /* от 0 до 3 один участок и от 3 до 255 другой                                   */
      macro GetKoef_pt( Width : double ) : double
            var Koef:double = 8.8;

            if( Width >= 1.0 )     Koef = 8.0 + (5.0 / Width);
            else                   Koef = 14.0;
            end;
            return Koef* (1 + ( SColumnWidth - KoefScreenW)*KoefForScreen );// учёт маштабного коэф-та
      end;

      this.WidthExcelRep = 0.0;

      /* Коэффициент выбираем в зависимости от приложения вывода */
     
     //   if  ( this.WinRepOutput == WINREP_OUTPUT_EXCEL )
     // elif( this.WinRepOutput == WINREP_OUTPUT_WORD  ) Koef = ObjSheet.WordKoefWidth ;
     // elif( this.WinRepOutput == WINREP_OUTPUT_IE    ) Koef = ObjSheet.HtmlKoefWidth ;
     Koef = ObjSheet.ExcelKoefWidth; 
     //  end;
       //MsgBox(Koef);
    //   Koef = Koef *1.01;
      /* Выставление ширин колонок */ 
      if( TypeVal )
          while( i < ArrColWidth.Size )
              ColWidth = Double(ArrColWidth[i]) * Koef;
                             
              WR_Insert(HTMLFile, "<col" + " width=" + String(Int(GetKoef_pt(ColWidth) * ColWidth + 0.5))+ "></col>");

              this.WidthExcelRep = this.WidthExcelRep + ColWidth;
              i = i + 1;
          end;
      end;

   end; /* HTML_SetExcelColWidth */

   // --------------------------------------------------------------------------
   /* (Private) Внутренний метод для печати заголовка таблицы в Excel. Возвращает количество строк заголовка */
   private
   macro HTML_PrintExcelHeader(HTMLFile, Idention:integer, ArrStrOnEachPage:tarray, ObjSheet:object) :integer

      var TempStr             :string   = "";     /* Вспомогательная переменная для формирования строки для HTML */
      var Sz                  :integer  = 0;      /* Размер массива строк заголовка */
      var ArrParamPrintStr    :tarray= NULL;   /* Массив для ячеек текущей строки заголовка */
      var ArrParamPrintStrNext:tarray= NULL;   /* Массив для ячеек следующей строки заголовка */
      var SzCurRow            :integer  = 0;      /* Размер массива ячеек для текущей строки заголовка */
      var i                   :integer  = 0;      /* Счетчик циклов */
      var j                   :integer  = 0;      /* Счетчик циклов */
      var FlagNeedPrint       :bool     = False;  /* Флаг необходимости печати рассчитанной строки */
      var CountCol            :integer  = 1;      /* Количество объединяемых столбцов */
      var CountRow            :integer  = 1;      /* Количество объединяемых строк */
      var k                   :integer  = 0;      /* Счетчик циклов */
      var l                   :integer  = 0;      /* Счетчик циклов */
      var FlagBegStr          :bool     = True;   /* Флаг начала строки */
      var CountHeaderStr      :integer  = 0;      /* Число строк заголовка */
      var HeaderBC            :string   = "";     /* Ввиду того, что в Excel и в HTML формат RGB полностью антогонистичен, придется
                                                    хитрить, чтобы пользоваться едиными константами */
      var StrHexBC            :string   = "";     /* Строка для шестнадцатиричного кода цвета заливки */
      var ArrSplit            :tarray= NULL;   /* Вспомогательный массив для корректной разбивки строк */
      var Width               :integer  = 0;      /* Ширина для расчета необходимой высоты строки */
      var ArrHeader           :tarray= NULL;

      /* Сразу установим цвет заголовка из настроек по умолчанию */
      HeaderBC = ToHex(Int(Trim(ObjSheet.hd_BkGrColor)), 6);
      HeaderBC = SubStr(HeaderBC, 5, 2) + SubStr(HeaderBC, 3, 2) + SubStr(HeaderBC, 1, 2) + ";";

      // Печатаем полный заголовок
      if( ObjSheet.FlagPrintFullHeader OR                                                 // Если выставлен флажок "Всегда полный заголовок"
          ((NOT ObjSheet.FlagPrintFullHeader) AND (NOT ObjSheet.FlagPrintFirstHeader)) )  // Если выставлен флажок "Печать сокращенного заголовка", но это первый раз
          ArrHeader = ObjSheet.GetArrHeaderStr();
      else   
          ArrHeader = ObjSheet.GetArrSubHeaderStr();
      end;
      ObjSheet.FlagPrintFirstHeader = TRUE;

      /* Вывод строк заголовка */
      Sz = ArrHeader.Size;
      i = 0;
      while( i < Sz )
           ArrParamPrintStr = ArrHeader[i];
           SzCurRow         = ArrParamPrintStr.Size();
           j                = 0;
           CountCol         = 1;
           FlagBegStr       = True;

           while( j < SzCurRow )

                FlagNeedPrint = False;

                /* Работаем только с ячейками имеющими верхнее обрамление */
                if( ArrParamPrintStr[j].Border_Up )

                     FlagNeedPrint = True;

                     /* При необходимости объединяем по горизонтали */
                     if( j < (SzCurRow - 1) )
                         if((Not ArrParamPrintStr[j].Border_Right)and(Not ArrParamPrintStr[j + 1].Border_Left))
                              /* Считаем сколько подряд ячеек объединено по горизонтали */
                              CountCol      = CountCol + 1;
                              Width         = Width + ObjSheet.GetArrColWidth(j);
                              FlagNeedPrint = False;
                         else FlagNeedPrint = True;
                         end;
                     end;

                     /* Если расчет количества ячеек по горизонтали закончен, */
                     /* считаем сколько подряд ячеек объединено по вертикали  */
                     if( FlagNeedPrint )

                         CountRow = 1;
                         k        = i;
                         while( k < (Sz - 1) )

                            ArrParamPrintStrNext = ArrHeader[k + 1];

                            if( (Not ArrParamPrintStr    [j + 1 - CountCol].Border_Down) and 
                                (Not ArrParamPrintStrNext[j + 1 - CountCol].Border_Up  )    )

                                 /* Проверим, действительно ли это новая строка, а не продолжение старой */
                                 l = 0;
                                 while( l < SzCurRow )
                                    if( ArrParamPrintStrNext[l].Border_Up )
                                        CountRow = CountRow + 1;
                                        l = SzCurRow;
                                    else 
                                        l = l + 1;
                                    end;
                                 end;
                                 k = k + 1;
                            else 
                                 k = Sz - 1;
                            end;
                         end;
                     end;
                end;

                if( FlagNeedPrint )
                    /* Если печатаем первую ячейку в строке напишем открывающую скобку */
                    if( FlagBegStr )
                        if( DefaultBkGrColor != RGB(255,255,255) )
                            StrHexBC = ToHex(Int(Trim(String(DefaultBkGrColor))), 6);
                            TempStr  = "<tr style=\"background: #" + SubStr(StrHexBC,5,2) + 
                                       SubStr(StrHexBC,3,2) + SubStr(StrHexBC,1,2) + ";\">";
                        else
                            TempStr  = "<tr style=\"background: none;\">";
                        end;
                        WR_Insert(HTMLFile, TempStr);
                        FlagBegStr = False;
                    end;

                    TempStr  = "<td class='xBorder' style=\"font-family:" + ObjSheet.FontName  // Имя шрифта
                             + "; font-size:"+ String(ObjSheet.FontSize) +                     // Размер шрифта
                             "pt; background: #" + HeaderBC + ObjSheet.Get_hd_FS()             // Цвет фона
                             +"mso-number-format:\\@;"+"\""                                    // Текстовый формат
                             + " align="+ObjSheet.Get_hd_Align()                               // Выравнивание
                             +" valign=top colspan=" + String(CountCol)                        // Кол-во колонок под ячейку шапки таблицы
                             + " rowspan=" + String(CountRow);                                 // Кол-во строк под ячейку шапки таблицы

                    /* Установим необходимую высоту для раздвигающихся строк */
 /*
                    if( Width )
                        Width = Width + this.ArrColWidth[j];
                        if( FlagHighQualityRep )
                            ArrSplit = TR_StrSplitExt(String(ArrParamPrintStr[j + 1 - CountCol].StrValue), Width);
                        else
                            ArrSplit = StrSplit2(String(ArrParamPrintStr[j + 1 - CountCol].StrValue), Width);
                        end;
                        if( ArrSplit.Size > 1 )
                            TempStr = TempStr + " height=" + String(ArrSplit.Size * 18);
                        end;
                    end;
 */
                    TempStr  = TempStr + ">";
                    TempStr  = TempStr + /*ToAnsi*/(String(ArrParamPrintStr[j + 1 - CountCol].StrValue));
                    TempStr  = TempStr + "</td>";
                    CountCol = 1;
                    CountRow = 1;
                    Width    = 0;
                    WR_Insert(HTMLFile, TempStr);
                end;
                j = j + 1;
           end;

           /* Если в строке есть открывающая скобка, должна быть и закрывающая */
           if( Not FlagBegStr )
               TempStr = "</tr>";
               WR_Insert(HTMLFile, TempStr);
               CountHeaderStr = CountHeaderStr + 1;
           end;
           i = i + 1;
      end;

      /* Назначаем диапазон строк, которые будут выводится на каждой странице отчета при печати на принтере */
      if( ObjSheet.FlagShowFixedRow )
          if( CountHeaderStr )
              if( ObjSheet.FlagPrintFullHeader )
                  ArrStrOnEachPage[ObjSheet.SheetNumber-1] = 
                    "<x:ExcelName>\n"  
                  + "<x:Name>Print_Titles</x:Name>\n" 
                  + "<x:SheetIndex>" + String(ObjSheet.SheetNumber) + "</x:SheetIndex>\n" 
                  + "<x:Formula>='" + ObjSheet.SheetName + "'!$" + String(Idention + 1)
                  + ":$" + String(Idention + CountHeaderStr) + "</x:Formula>\n"
                  + "</x:ExcelName>";
              else
                  ArrStrOnEachPage[ObjSheet.SheetNumber-1] = 
                    "<x:ExcelName>\n"  
                  + "<x:Name>Print_Titles</x:Name>\n" 
                  + "<x:SheetIndex>" + String(ObjSheet.SheetNumber) + "</x:SheetIndex>\n" 
                  + "<x:Formula>='" + ObjSheet.SheetName + "'!$" + String(Idention + CountHeaderStr)
                  + ":$" + String(Idention + CountHeaderStr) + "</x:Formula>\n"
                  + "</x:ExcelName>";
              end;
          end;
      end;

      return CountHeaderStr;

   End; /* HTML_PrintExcelHeader */                    

   // --------------------------------------------------------------------------
   /* (Private) Непосредственное формирование "тела" отчета */
   private
   macro HTML_CreateBody( HTMLFile, ObjSheet:object )
   
       var SheetName            :string   = ObjSheet.SheetName;
       var ArrParamPrintStr     :tarray= NULL;        /* Массив для ячеек текущей строки                            */
       var ArrExtendedLexems    :tarray= NULL;        /* Массив расширенных параметров форматирования               */
       var ArrSplit             :tarray= NULL;        /* Вспомогательный массив для корректной разбивки строк       */
       var ArrPrintStr          :tarray= ObjSheet.GetArrPrintStr(); // Ссылка на Массив с данными закладки
       var FlagPrevStrZeroHeight:bool     = False;       /* Флаг того, что предыдущая строка была схлопнута            */
       var ValTypeValue         :integer  = 0;           /* Тип значения                                               */
       var TempCountHeaderStr   :integer  = 0;
       var FlagNeedHeader       :bool     = True;        /* Флаг необходимости вывода заголовка таблицы                */
       var i                    :integer  = 0;
       var j                    :integer  = 0;
       var k                    :integer  = 0;           /*счётчики цыкла */
       var t                    :integer  = 0;
       var e                    :integer  = 0;
       var NumStr               :integer  = 0;
       var CurRow               :integer  = 0;           /* Текущая строка в xls файле равна номеру секции <tr>        */
       var CurCol               :integer  = 0;           /* Текущая колонка в xls файле равна номеру секции <tr>       */
       var TempStr              :string   = "";          /* Вспомогательная переменная для формирования строки         */
       var NumCell              :integer  = 0;           /* Номер текущей печатаемой ячейки с строке                   */
       var CountCell            :integer  = 0;           /* Количество ячеек необходимых для печати элемента стр.      */
       var AlignCell            :string   = "";          /* Выравнивание по горизонтали в ячейке                       */
       var StrHexFC             :string   = "";          /* Строка для шестнадцатиричного кода цвета шрифта            */
       var StrHexBC             :string   = "";          /* Строка для шестнадцатиричного кода цвета заливки           */
       var StrValue             :variant  ;              /* Строка для обработки спецсимволов HTML в ячейке            */
       var StandartLexem        :string   = "";          /* Строка со стандартными параметрами форматирования          */
       var Pos                  :integer  = 0;           /* Вспомогательная переменная для проверки левой консоли     */
       var StrPrev              :string   = "";          /* Содержимое предыдущей строки при спецпроходах              */
       var StrCur               :string   = "";          /* Содержимое текущей строки при спецпроходах                 */
       var FormatStr            :string   = "";          /* Строка спецформатирования (должна стоять последней в стиле)*/
       var StrModif_Whole       :integer  = 0;           /* Требуемая ширина выводимой в ячейку информации             */
       var TempLexem            :tarray   = tarray(5,1) ;
       var PrevString           :tarray                 ;
       var BegSpStr             :integer  = 0           ;/*номер ячейки после которой строки не сливаются ( для специальной строки ) */
       var count2               :integer  = 0           ;
       var count                :integer  = 0           ;
       var countHalf            :integer  = 0           ;/*счётчик для вычисления позиции строки раздвоения */
       var TmpHalfStr           :STRING   = 0           ;
       var Sz                   :integer  = "";         //размер массива
       var FlagPrintCell        :bool     = true;       // признак вывода ячейки (некоторая псевдографика не выводится)
       // переменные для учёта раздвоения
       var PrevStr              :tarray   ;              //предыдущая строка
       var NextStr              :tarray   ;              //следующая строка 
       var Repeat0              :bool     = False;       // Признак, что после текущей идёт строка, , которую необходимо выводить в виде двух спецстрок
       var Repeat1              :bool     = False;       /* Признак, что мы делаем спецпроход, в котором формируется первая спецстрока */
       var Repeat2              :bool     = False;       /* Признак, что мы делаем спецпроход, в котором формируется вторая спецстрока */
       var Repeat3              :bool     = False;       /* Признак, что данная строка идущая после строки раздвоения*/
       var DoubleRepeat         :bool     = false;       /* Признак, что строки, требующие раздвоения идут подряд*/
       var TempPrevLexem        :tarray   = tarray;      /*Для закраски раздвоенных строк*/
       var OldPref              :integer  = 4; 
       NumStr  < 0;             
       Sz = ArrPrintStr.Size;  
     
         
       var FlagStr              :bool     = false       ;/*признак строки (не строки будем выводить через x:str , строки  <tr>str1<br>str2</tr>)*/
       ArrComment.Clear();  // Зачистим объект примечаний, т.к. он актуален для текущей закладки        
       WR_Insert(HTMLFile, "<body>" );
       WR_Insert(HTMLFile, "<table>");
       Macro GetCountSymbol(Str:string,symbol:string)  
           var i  :integer  = 0;  
           var Len:integer  = strlen(Str);
           var count = 0;  
           while(i < Len)
               if(SubStr(Str,i,1) == symbol)
                   count = count + 1; 
               end;         
               i = i + 1;
           end;
           return count;   
       end; 
       /* Установим отступ, если он задан */
       if( _Idention )
           while( i < _Idention )
              CurRow = CurRow + 1;
              WR_Insert(HTMLFile, "<tr></tr>");
              countHalf = countHalf + 1;
              i = i + 1;
           end;
       end;

       /* Установим ширины колонок на листе в Excel */
       HTML_SetExcelColWidth(HTMLFile, ObjSheet);

       /* Вывод строк */
       while( NumStr < ArrPrintStr.Size )
           ArrParamPrintStr = ArrPrintStr[NumStr];
           if(NumStr > 0 )
              PrevStr = ArrPrintStr[NumStr-1];
           end;
           if(NumStr < ArrPrintStr.Size -1)
               NextStr =  ArrPrintStr[NumStr+1];
           else
               NextStr  =  NULL; 
           end;   
           if(NumStr>0)
           end;   
           count            = 0;
           t                = 0;
           count2           = 0;
           /* Данную часть кода выполняем только если это не первый спецпроход */
           if(   NextStr   )
               /* Обрабатываем строку только если она не является признаком разрыва страницы */
               if( NextStr[0].StrValue != KEY_STRBREAK )
                   if( Not IsArrOnlySeparator(NextStr) )
                       j = 0;
                       while( j < NextStr.Size  )
                           if( ValType(NextStr[j].StrValue) == V_STRING )
                               if( StrBrk(NextStr[j].StrValue, "└┴┘├┼┤┌┬┐─") )
                                   if( this.FlagModePrint == STD_MODEPRINT_WITH_DUALSTR )
                                       if((NOT Repeat1))
                                           Repeat0 = True;
                                           DoubleRepeat = false ;
                                       else
                                          DoubleRepeat = true;
                                       end;
                                   end;
                                   BegSpStr = j;
                                   j = NextStr.Size;
                               end;
                           end;
                           j = j + 1;
                       end;
                   end;
               end;
           end;

            /* Если очередная строка является строкой таблицы, а предыдущая нет, то выведем заголовок таблицы */
            if( ValCmpArray(ArrParamPrintStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                if( FlagNeedHeader )
                    TempCountHeaderStr = HTML_PrintExcelHeader(HTMLFile, i, ArrStrOnEachPage, ObjSheet);
                    i = i + TempCountHeaderStr;
                    CurRow = CurRow + TempCountHeaderStr;
                    countHalf = countHalf + TempCountHeaderStr;
                end;
                FlagNeedHeader = False;
            else
                FlagNeedHeader = True;
            end;
            j       = 0;
            NumCell = 0;
            /* Обрабатываем строку только если она не является признаком разрыва страницы */
            if( ArrParamPrintStr[0].StrValue != KEY_STRBREAK )
                 /* Установка общих опций для строки в Excel */
                 
                 TempStr  = "<tr valign=top";
                 StrHexFC = ToHex(Int(String(DefaultFontColor)), 6);
                 TempStr  = TempStr + " style=\"font-family:" + ObjSheet.FontName + ", monospace" + "; font-size:" + String(ObjSheet.FontSize) + "pt;"
                          + " color: #"      + SubStr(StrHexFC,5,2) + SubStr(StrHexFC,3,2) + SubStr(StrHexFC,1,2) + ";";

                 if( DefaultBkGrColor != RGB(255,255,255) )
                     StrHexBC = ToHex(Int(String(DefaultBkGrColor)), 6);
                     TempStr  = TempStr + " background: #" + SubStr(StrHexBC,5,2) + SubStr(StrHexBC,3,2) + SubStr(StrHexBC,1,2) + ";";
                 else
                     TempStr  = TempStr + " background: none;";
                 end;

                 /* Если найдена строка для "раздвоения" или это первый спецпроход, то установим половинную высоту строки */
                 if( Repeat1 or Repeat2 )
                   //Exel не проводит автоподбор если установить высоту , сделаем это в постобработке!
                   TmpHalfStr = "iBook.WorkSheets("+ObjSheet.SheetNumber+").Rows("+String( countHalf + 1)+ ").RowHeight";
                   m_ExecuteStrExcel[m_ExecuteStrExcel.Size] = TmpHalfStr + "=" + TmpHalfStr +"/2" ;
                    
                 end;

                 /* Если строка является разделителем для псевдографических табличек, то просто не будем ее
                    заносить в файл, за исключением случаев, когда две такие строки идут подряд */
                 if( IsArrOnlySeparator(ArrParamPrintStr) )
                     if( Not FlagPrevStrZeroHeight )
                         FlagPrevStrZeroHeight = True;
                     else
                         countHalf = countHalf + 1;                         
                         WR_Insert(HTMLFile, TempStr + "\">");
                         FlagPrevStrZeroHeight = False;
                         i = i + 1;
                     end;
                 else 
                     TempStr               = TempStr + "\"";
                     FlagPrevStrZeroHeight = False;
                     /* Обработка отдельных ячеек */
                     CountCell = CurCol = 0;
                     while( j < ArrParamPrintStr.Size )
                          /* Получим строку стандартные и расширенные параметры форматирования для ячейки */
                          StandartLexem     = ArrParamPrintStr[j].StandartLexem;                           
                          ArrExtendedLexems = ArrParamPrintStr[j].CopyExtendedLexems();
                          if(Repeat2)
                         //     ArrExtendedLexems[ArrExtendedLexems.Size] = TempPrevLexem[j];
                          end;
 
                          FlagStr = (ValType(ArrParamPrintStr[j].StrValue) == V_STRING);

                          StrValue       = String(ArrParamPrintStr[j].StrValue);
                          StrModif_Whole = ArrParamPrintStr[j].StrModif_WholeE;
                          FormatStr = "";
                          flagPrintCell = ArrParamPrintStr[j].FlagPrint;
                          
                          /* Если собираемся печатать ячейку в первый раз в строке, занесем в файл данные по строке */
                          if( Not CountCell )
                              CurRow  = CurRow + 1;
                              TempStr = TempStr + ">";
                              if(ArrParamPrintStr.Size > 1)
                                  WR_Insert(HTMLFile, TempStr );
                                  TempStr ="";
                              end;
                              countHalf = countHalf + 1;
                               
                          end;

                          if(Repeat0 or DoubleRepeat )
                              k =0;
                              while( k < ArrExtendedLexems.Size )
                                  if( Index(ArrExtendedLexems[k], B_LEX) )
                                      ArrExtendedLexems[k] = B_LEX + TrStrSubst(StrUpr(GetArg(ArrExtendedLexems[k], B_LEX, LEX_END)), "B", "") + LEX_END;
                                  end;
                                  k = k + 1;
                              end;
                          end;
                                                                                  
                         if(Repeat1 )                                            
                              if(J)
                                  if(StrBrk(ArrParamPrintStr[j-1].StrValue,"└┴├┼│") or StrBrk(ArrParamPrintStr[j].StrValue,"└┴├┼│"))
                                      if( ArrParamPrintStr[j].StrValue != "│");  
                                      ArrExtendedLexems[ArrExtendedLexems.Size] = "ex_B(l)";
                                  end;
                              end;
                              end;
                              if(j<(ArrParamPrintStr.Size-1))
                                 if(StrBrk(ArrParamPrintStr[j+1].StrValue,"┴┘┼┤│"))
                                      ArrExtendedLexems[ArrExtendedLexems.Size] = "ex_B(r)";
                                 end;
                              end;
                               if(StrBrk(StrValue,"─") )
                                   ArrExtendedLexems[ArrExtendedLexems.Size] = "ex_B(b)";
                                end;
                          end; 

                          if(Repeat2 )
                              if(J)
                                  if(StrBrk(ArrParamPrintStr[j-1].StrValue,"┌┬┼├│") or StrBrk(ArrParamPrintStr[j].StrValue,"┌┬┼├│"))
                                      if( ArrParamPrintStr[j].StrValue != "│");  
                                      ArrExtendedLexems[ArrExtendedLexems.Size] = "ex_B(l)";
                                  end;
                              end;
                              end;
                              if(j<(ArrParamPrintStr.Size-1))
                                 if(StrBrk(ArrParamPrintStr[j+1].StrValue,"┐┬┼┤│"))                       
                                      ArrExtendedLexems[ArrExtendedLexems.Size] = "ex_B(r)";          
                                 end;                                                                  
                              end;

                          end;

                          if( Repeat3  )
                              k = 0;
                              while( k < ArrExtendedLexems.Size )
                                  if( Index(ArrExtendedLexems[k], B_LEX) )
                                      ArrExtendedLexems[k] = B_LEX + TrStrSubst(StrUpr(GetArg(ArrExtendedLexems[k], B_LEX, LEX_END)), "T", "") + LEX_END;
                                  end;
                                  k = k + 1;
                              end;
                          end;

                          ValTypeValue  = ValType(ArrParamPrintStr[j].StrValue);
                          
                          /* Деньги обработаем особым образом */
                          if  ( ValTypeValue == V_MONEY  )
                                FormatStr = " class='"+ObjSheet.lsFormat_M.GetFormatName(
                                                       ArrParamPrintStr[j].StrModif_Fract,
                                                       ArrParamPrintStr[j].CheckSymbolStandartLexem("z"), 
                                                       ArrParamPrintStr[j].CheckSymbolStandartLexem("a"));

                          /* Double обработаем особым образом */
                          elif( (ValTypeValue == V_DOUBLE) or (ValTypeValue == V_DOUBLEL)  )
                                FormatStr = " class='"+ObjSheet.lsFormat_D.GetFormatName(
                                                       ArrParamPrintStr[j].StrModif_Fract,
                                                       ArrParamPrintStr[j].CheckSymbolStandartLexem("z"), 
                                                       ArrParamPrintStr[j].CheckSymbolStandartLexem("a"));

                          elif( ValTypeValue == V_INTEGER )
                                FormatStr = " class='"+ObjSheet.lsFormat_I.GetFormatName(
                                                       ArrParamPrintStr[j].StrModif_Fract,
                                                       ArrParamPrintStr[j].CheckSymbolStandartLexem("z"), 
                                                       ArrParamPrintStr[j].CheckSymbolStandartLexem("a"));
                          elif( (ValTypeValue == V_STRING) AND (Strlen(ArrParamPrintStr[j].StrValue)< MAX_TXT_FORMAT_LEN ) )
                               FormatStr =   " class='"+ ObjSheet.lsFormat_S.GetFormatName(0,0,0);
                          elif( ValTypeValue == V_DATE )
                              AlignCell = " align=left";
                          end;
                          if(ArrParamPrintStr.Size > 1)
                          TempStr =  "<td";
                          else
                          TempStr = TempStr+ "<td";
                          end;
                          /* Установим стандартные и расширенные параметры для ячейки */
                          if  (Index(StandartLexem, "l"))  AlignCell = " align=left"  ;
                          elif(Index(StandartLexem, "c"))  AlignCell = " align=center";
                          elif(Index(StandartLexem, "r"))  AlignCell = " align=right" ;
                          end;
                          if( AlignCell )
                              TempStr = TempStr + AlignCell;
                          end;
                          AlignCell = "";
                          /* Если это второй спецпроход, то отменим вывод всех верхних разделителей */


                          if( ValCmpArray(ArrParamPrintStr[j].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                               CountCell = GetCountExcelCol(NumCell, StrModif_Whole + 1, ObjSheet);
                          else CountCell = GetCountExcelCol(NumCell, StrModif_Whole    , ObjSheet);
                          end;
                          
                       /*   if(Repeat1 AND( NumStr > 0)  )// заливка верхней спец строки цветами из выше расположенной
                              PrevString = ArrPrintStr[NumStr-1]; //нижняя строка для скорости заливается таким же цветом(в большинстве случаев отчёты монатонны)
                              
                              if(count == count2  )
                                  count2 = 0; 
                                  if(t < PrevString.Size)
                                      count  = PrevString[t].NumCell ; 
                                  end;
                                  t = t + 1;
                              end;

                              count2 = count2 + ArrParamPrintStr[j].NumCell  ;
                         
                              while((count2 > count)AND (t < PrevString.Size)  )
                                  
                                  count  = count + PrevString[t].NumCell ;
                                  t = t + 1;
                              end;

                              if((J >= BegSpStr) And ((t-1) < PrevString.Size)  )
                              TempLexem  = PrevString[t-1].CopyExtendedLexems();
                              k      = 0;
                              k=0;
                              e=0;
                              TempPrevLexem[TempPrevLexem.Size] = 0;
                                  while(k < TempLexem.Size)
                                  /*проверяем заливку ячейки*/
                                      if(Index(TempLexem[k],"ex_BC"))
                                          while(e < ArrExtendedLexems.Size)
                                              if( Index(ArrExtendedLexems[e],"ex_BC"))//  цвет ячейки задан вручную
                                                  e = ArrExtendedLexems.Size+2;
                                              end;
                                          e = e +1;
                                          end;
                                          if(Not (e == ArrExtendedLexems.Size + 3))
                                              ArrExtendedLexems[ArrExtendedLexems.Size] = TempLexem[k];
                                              TempPrevLexem[TempPrevLexem.Size-1] = TempLexem[k];
                                          end;

                                      end;
                                      k = k + 1;

                                  end;
                              end;  */
                        // end;//if(Repeat1 AND( NumStr > 0) )

                          /* Установим расширенные параметры и посчитаем необходимое для вывода количество ячеек */

                          /* Для каждой ячейки из найденной спецстроки проверяем наличие межстрочных разделителей. Если их нет сливаем
                             соответствующие ячейки из первой и второй спецстрок */

                          if( Repeat1 )

                              if( Not StrBrk(SubStr(StrValue, 1, 1), "─└┴├┼┌┬│") )
                                  TempStr = TempStr + " rowspan=2";
                              else
                                //  ArrExtendedLexems[ArrExtendedLexems.Size] = "ex_B(b)";
                                  e = 0;
                                  count = 0;
                                  while(e <= j)
                                      count = count + ArrParamPrintStr[e].StrModif_WholeE;
                                      e = e+1;
                                  end;

                                  if(NumStr > 0)
                                      e      = 0;
                                      count2 = 0;
                                      while((count > count2) AND (e < PrevStr.size))
                                          count2 =count2 + PrevStr[e].StrModif_WholeE;
                                          e = e + 1;
                                      end;
                                      TempLexem  = PrevStr[e-1].CopyExtendedLexems();
                                      k=0;
                                      e=0;
                                      while(k < TempLexem.Size)
                                      /*проверяем заливку ячейки*/
                                        if(Index(TempLexem[k],"ex_BC"))
                                            ArrExtendedLexems[ArrExtendedLexems.Size] = TempLexem[k];
                                            ArrParamPrintStr[j].ArrExtendedLexems[ArrExtendedLexems.Size]=
                                            TempLexem[k];
                                        end;
                                         k = k + 1;

                                      end;
                                  end;
                               end;
                          elif(Repeat2)
                              if( Not StrBrk(SubStr(StrValue, 1, 1), "─└┴├┼┌┬│") )
                                  FlagPrintCell = false;
                              else
                                  FlagPrintCell = ArrParamPrintStr[j].FlagPrint;
                                  CountCell     = ArrParamPrintStr[j].NumCell;
                              end;

                          end;
                          TempStr = HTML_SetExtendedParam( ArrExtendedLexems, Repeat1, Repeat2, Repeat3,
                                                           CurRow, CurCol, ArrParamPrintStr, TempStr, ObjSheet );


                          if( CountCell > 1 )
                              ArrParamPrintStr[j].NumCell = CountCell;
                              TempStr = TempStr + " colspan=" + String(CountCell);
                          end;

                          /* Откорректируем нетабличные строки для красивого вывода в Excel */
                          if( ValCmpArray(ArrParamPrintStr[0].FlagStr, ArrConstTabl) == ELEM_NO_FOUND )
                              /* Если в нетабличной строке не указан специально спецификатор переноса - запрещаем автоперенос слов */
                              if( Not Index(StandartLexem, "w") )
                                  TempStr = TempStr + " nowrap";
                              end;
                              /* Исключим псевдографику ─│└┴┘├┼┤┌┬┐, так как она при выводе бьется и заменим обрамлением */
                              if( StrBrk(StrValue, "└┴┘├┼┤┌┬┐│─") )

                                  if(Index(StrValue, "─")) StrValue = TrStrSubst(StrValue, "─", " ");end;
                                  if(Index(StrValue, "│")) StrValue = TrStrSubst(StrValue, "│", "");  end;
                                  if(Index(StrValue, "└")) StrValue = TrStrSubst(StrValue, "└", "");  end;
                                  if(Index(StrValue, "┴")) StrValue = TrStrSubst(StrValue, "┴", "");  end;
                                  if(Index(StrValue, "┘")) StrValue = TrStrSubst(StrValue, "┘", "");  end;
                                  if(Index(StrValue, "├")) StrValue = TrStrSubst(StrValue, "├", "");  end;
                                  if(Index(StrValue, "┼")) StrValue = TrStrSubst(StrValue, "┼", "");  end;
                                  if(Index(StrValue, "┤")) StrValue = TrStrSubst(StrValue, "┤", "");  end;
                                  if(Index(StrValue, "┌")) StrValue = TrStrSubst(StrValue, "┌", "");  end;
                                  if(Index(StrValue, "┬")) StrValue = TrStrSubst(StrValue, "┬", "");  end;
                                  if(Index(StrValue, "┐")) StrValue = TrStrSubst(StrValue, "┐", "");  end;

                             end;

                          else  /* Для табличных строк сразу назначим принудительное обрамление */

                               // Есле встречается ручное обрамление, то стандартное не используем
                               k = 0;
                               while( (k < ArrExtendedLexems.Size) AND (k != -1) )
                                   if( Index(ArrExtendedLexems[k], B_LEX) )  k = -1
                                   else                                      k = k + 1;
                                   end;
                               end;

                               if( k != -1 )
                                   if( Not FormatStr )  FormatStr = " class='xBorder";
                                   else                 FormatStr = FormatStr + "WithBorder";
                                   end;
                               end;
                          end;

                          if( FormatStr )
                              FormatStr = FormatStr + "'";
                          end;

                          if( String(StrValue) and (ValType(ArrParamPrintStr[j].StrValue) == V_STRING)And(ValType(StrValue)==V_String) )
                              if( StrBrk(StrValue, "&\"<>" ) )
                                   StrValue = TrStrSubst(StrValue, "&" , "&amp;" );
                                   StrValue = TrStrSubst(StrValue, "\"", "&quot;");
                                   StrValue = TrStrSubst(StrValue, "<" , "&lt;"  );
                                   StrValue = TrStrSubst(StrValue, ">" , "&gt;"  );
                               end;

//                               StrValue = ToAnsi(StrValue);
                          end;
                          //такие танцы чтобы быстро работало
                          if( FlagStr)   //  строка
                              if(StrBrk(StrValue,"\n")) // "тяжёлый кусок кода"
                                StrValue =  StrSubst(StrValue," ","&nbsp;");
                                StrValue =  StrSubst(StrValue,"\n","<br>");
                              elif(FlagStr)  TempStr = TempStr + " x:str=\"" + StrValue + "\"";
                               end;
                          end;

                        /*  if( ArrParamPrintStr[j].StrModif_Fract > 2)
                           //   if((ValType(StrValue) == V_MONEY) or (ValType(StrValue) == V_MONEYL) )
                           //      StrValue = ExecExp("String(ArrParamPrintStr[j].StrValue:" + 30 + ":" + ArrParamPrintStr[j].StrModif_Fract +")" );
                           //   end;
                          end;*/
                          if(ArrParamPrintStr[j].StrModif_Fract > 4)
                              if(( ValType(ArrParamPrintStr[j].StrValue) == V_DOUBLE)
                                   or( ValType(ArrParamPrintStr[j].StrValue) == V_DOUBLEL) )
                                  OldPref  = setdefprec(ArrParamPrintStr[j].StrModif_Fract);
                                  StrValue = String(ArrParamPrintStr[j].StrValue);
                                  setdefprec(OldPref);
                              end
                          end;

                          TempStr = TempStr + FormatStr + ">";
                          /* Если строка является индексной установим соответствую(щий при))знак */
                          if  (FlagIndexStr == STR_INDEX_TOP )   StrValue = "<sup>" + StrValue + "</sup>";
                          elif(FlagIndexStr == STR_INDEX_DOWN)   StrValue = "<sub>" + StrValue + "</sub>";
                          end;

                          if( PictStr )  TempStr = TempStr + PictStr  ;
                          else           TempStr = TempStr + StrValue;
                          end;
                          if(FlagPrintCell)
                          NumCell = NumCell + CountCell;
                          else
                          end;
                          CurCol  = CurCol  + 1;
                          TempStr = TempStr + "</td>";

                          /* Если это второй спецпроход, вставляем только ячейки, над которыми есть элементы разделителей строк */
                          if( Repeat2 )
                              StrCur = StrCur + ArrParamPrintStr[j].StrValue;
                          else
                          end;
                          if(flagPrintCell)
                              WR_Insert(HTMLFile, TempStr);
                          end;

                          j = j + 1;
                     end;
                     i = i + 1;
                 end;
                 TempStr = "</tr>";
                 WR_Insert(HTMLFile, TempStr);
                 /* Обработаем выставление и сброс флагов при спецпроходах */

                 if( Repeat3 )
                     Repeat3 = False;

                 end;

                 if( Repeat2 )
                    // NumStr  = NumStr - 1;
                     Repeat2 = False;
                     Repeat3 = True;
                 end;

                 /* Если найдена спецстрока, запомним текстовое представление предыдущей строки */
                 if( Repeat1 )
                     k       = 0;
                     StrPrev = "";
                     StrCur  = "";
                     while( k < ArrParamPrintStr.Size )
                         StrPrev = StrPrev + ArrParamPrintStr[k].StrValue;
                         k = k + 1;
                     end;
                     PrevStr = ArrParamPrintStr;
                     Repeat1 = False;
                     Repeat2 = True;
                     NumStr  = NumStr - 1;
                 end;
                 if(Repeat0)
                     Repeat0 = false;
                     repeat1 = true;
                 end;
            end;

            NumStr = NumStr + 1;

            if( this.FlagShowIndicator )
                UseProgress(NumStr);
            end;
       end;

       WR_Insert(HTMLFile, "</table>");

       ArrComment.PrintComment( HTMLFile );
   end; /* HTML_CreateBody */

   // --------------------------------------------------------------------------
   /* (Private) Установка формата представления для некоторых типов данных */  
   private
   macro HTML_CreateStyle( HTMLFile, ObjSheet:object )

       var i  :integer= 0;
       var Obj:object = NULL;

       WR_Insert(HTMLFile, "<style>");
       /* Для полного обрамления заведем специальный класс */
       WR_Insert(HTMLFile, ".xBorder");
       WR_Insert(HTMLFile, "{");
       WR_Insert(HTMLFile, "   border-left:"   + HTML_StBorderWeight + " solid windowtext;");
       WR_Insert(HTMLFile, "   border-top:"    + HTML_StBorderWeight + " solid windowtext;");
       WR_Insert(HTMLFile, "   border-right:"  + HTML_StBorderWeight + " solid windowtext;");
       WR_Insert(HTMLFile, "   border-bottom:" + HTML_StBorderWeight + " solid windowtext;");
       WR_Insert(HTMLFile, "}");

       // Стиль для примечаний
       WR_Insert(HTMLFile, ".font6");
       WR_Insert(HTMLFile, "    {color:black;"                );
       WR_Insert(HTMLFile, "    font-size:8.0pt;"             );
       WR_Insert(HTMLFile, "    font-weight:700;"             );
       WR_Insert(HTMLFile, "    font-style:normal;"           );
       WR_Insert(HTMLFile, "    text-decoration:none;"        );
       WR_Insert(HTMLFile, "    font-family:Tahoma;"          );
       WR_Insert(HTMLFile, "    mso-generic-font-family:auto;");
       WR_Insert(HTMLFile, "    mso-font-charset:204;}"       );

       /* Для денег заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_M.Size )
          Obj = ObjSheet.lsFormat_M.Get(i);
          Obj.SetFormatName("xMoney"+String(i+1));
          Obj.CreateFormatStr_M();
          WR_Insert(HTMLFile, "."+ Obj.m_FormatName);
          WR_Insert(HTMLFile, "{"            );
          WR_Insert(HTMLFile, Obj.m_FormatStr);
          WR_Insert(HTMLFile, "}"            );
          i = i + 1;
       end;

       /* Для денег в рамке заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_M.Size )
          Obj = ObjSheet.lsFormat_M.Get(i);
          WR_Insert(HTMLFile, "." + Obj.m_FormatName + "WithBorder");
          WR_Insert(HTMLFile, "{");
          WR_Insert(HTMLFile, Obj.m_FormatStr);
          WR_Insert(HTMLFile, "   border-left:"   + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "   border-top:"    + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "   border-right:"  + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "   border-bottom:" + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "}");
          i = i + 1;
       end;

       /* Для Double заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_D.Size )
          Obj = ObjSheet.lsFormat_D.Get(i);
          Obj.SetFormatName("xDecimal"+String(i+1));
          Obj.CreateFormatStr_D();
          WR_Insert(HTMLFile, "."+ Obj.m_FormatName);
          WR_Insert(HTMLFile, "{"            );
          WR_Insert(HTMLFile, Obj.m_FormatStr);
          WR_Insert(HTMLFile, "}"            );
          i = i + 1;
       end;

       /* Для Double в рамке заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_D.Size )
          Obj = ObjSheet.lsFormat_D.Get(i);
          WR_Insert(HTMLFile, "." + Obj.m_FormatName + "WithBorder");
          WR_Insert(HTMLFile, "{");
          WR_Insert(HTMLFile, Obj.m_FormatStr);
          WR_Insert(HTMLFile, "   border-left:"   + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "   border-top:"    + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "   border-right:"  + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "   border-bottom:" + HTML_StBorderWeight + " solid windowtext;");
          WR_Insert(HTMLFile, "}");
          i = i + 1;
       end;

       /* Для Integer заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_I.Size )
          Obj = ObjSheet.lsFormat_I.Get(i);
          Obj.SetFormatName("xNumber"+String(i+1));
          Obj.CreateFormatStr_I();
          Insert(HTMLFile, "."+ Obj.m_FormatName);
          Insert(HTMLFile, "{"            );
          Insert(HTMLFile, Obj.m_FormatStr);
          Insert(HTMLFile, "}"            );
          i = i + 1;
       end;

       /* Для Integer в рамке заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_I.Size )
          Obj = ObjSheet.lsFormat_I.Get(i);
          Insert(HTMLFile, "." + Obj.m_FormatName + "WithBorder");
          Insert(HTMLFile, "{");
          Insert(HTMLFile, Obj.m_FormatStr);
          Insert(HTMLFile, "   border-left:"   + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "   border-top:"    + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "   border-right:"  + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "   border-bottom:" + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "}");
          i = i + 1;
       end;

       /* Для String  заведем специальный класс */
        while( i < ObjSheet.lsFormat_S.Size )
          Obj = ObjSheet.lsFormat_S.Get(i);
          Obj.SetFormatName("xString"+String(i+1));
          Obj.CreateFormatStr_S();
          Insert(HTMLFile, "."+ Obj.m_FormatName);
          Insert(HTMLFile, "{"            );
          Insert(HTMLFile, Obj.m_FormatStr);
          Insert(HTMLFile, "}"            );
          i = i + 1;
       end;

       /* Для String в рамке заведем специальный класс */
       i = 0;
       while( i < ObjSheet.lsFormat_S.Size )
          Obj = ObjSheet.lsFormat_S.Get(i);
          Obj.SetFormatName("xString"+String(i+1));
          Obj.CreateFormatStr_S();
          Insert(HTMLFile, "." + Obj.m_FormatName + "WithBorder");
          Insert(HTMLFile, "{");
          Insert(HTMLFile, Obj.m_FormatStr);
          Insert(HTMLFile, "   border-left:"   + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "   border-top:"    + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "   border-right:"  + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "   border-bottom:" + HTML_StBorderWeight + " solid windowtext;");
          Insert(HTMLFile, "}");
          i = i + 1;
       end;

       /* Закрываем все необходимые "скобки" для стилей и раздела HEAD */
       WR_Insert(HTMLFile, "</style>");

   end; /* HTML_CreateStyle */

   // --------------------------------------------------------------------------
   /* (private) Внутренний метод для автоматической установки ширин колонок на листе Excel */ 
   private
   macro AutoCol( ObjSheet:object )

      var i               :integer    = 0;                        // Счетчик циклов
      var j               :integer    = 0;                        // Счетчик циклов
      var k               :integer    = 0;                        // Счетчик циклов
      var ArrParamPrintStr:tarray  = tarray(0,1);                 // Массив для ячеек одной строки
      var GlPos           :integer    = 0;                        // Позиция разделителя для ячеек
      var ArrGlPos        :tarray  = tarray(1000,1000);     // Массив позиций разделителей для колонок
      var ArrUnicGlPos    :tarray  = tarray;                // Массив уникальных позиций разделителей для колонок
      var ArrPrintStr     :tarray  = ObjSheet.GetArrPrintStr();// Ссылка на массив с данными
      var ArrColWidth     :tarray  = ObjSheet.GetArrColWidth();// Ссылка на массив ширин
      var ArrPrintStrCopy :tarray  = NULL;
      var FlagModifWhole  :integer = 0;
      var Size            :integer = 0;
      var Repeat          :bool    = false;
      while( i < ArrPrintStr.Size )  // Добавления для АвтоСкана !!!
          ArrParamPrintStr = tarray;
          k = 0;
          while(k < ArrPrintStr[i].Size)   // Перелопатим строчки и выкинем не печатные символы
             if(ArrPrintStr[i][k].FlagPrint or (k == ArrPrintStr[i].Size-1) )
                 if(K>0)
                     if( StrBrk(ArrPrintStr[i][k-1].StrValue ,"│├└┌")  )
                         FlagModifWhole = 1;
                     end;
                 end;
                 if( StrBrk(ArrPrintStr[i][k].StrValue ,"│├└┌"))
                     FlagModifWhole = 0;
                 end;
                 ArrParamPrintStr[ArrParamPrintStr.Size] = ArrPrintStr[i][k];
                  ArrParamPrintStr[ArrParamPrintStr.Size-1].StrModif_WholeE =
                 ArrParamPrintStr[ArrParamPrintStr.Size-1].StrModif_Whole + FlagModifWhole; // добавим слева длинны
                 FlagModifWhole  = 0;
             else
                     FlagModifWhole = 1;
             end;

               k = k+1;

          end;
          /* 
            DAI Оставлено только переопределение ширин выводимых полей с подгонкой к полной ширине отчета
                Для определения количества колонок Excel, в которых будет размещаться отчет,
                строки заголовка и данные таблицы использовать не будем.
                В отчете будем использовать столько кололонок, сколько их задано заголовком таблицы.
                Так в табличной части полностью исключается необходимость объединения ячеек для вывода данных.
                Необходимость минимизации количества объединений возникла из-за того,
                что даже в Excel 2013 имеется ограничение на количество таких объединений (32767).
                Таким образом, если в каждой строке табличной части отчета хотя бы один раз объединяется несколько ячеек,
                для отображения данных некоторого поля, то общее количество таких строк будет иметь указанное ограничение 
                (все объединения в шапке отчета и заголовке таблицы так же учитываются).
                Как только ограничение на количество объединений будет достигнуто дальнейших объеднений происходить не будет
                и данные будут выводится в ячейки ширины которых не достаточно для их корректного отображения
                что приведет к расхождению между видом заголовка таблицы и ее данными.
      
          */
          if (ObjSheet.GetArrColWidthTable().Size == 0) 
              /* DAI Только в случае, когда заголовка нет (таблица с колонками по заголовку не содержит не одного элемента),
                     в качестве основания для распределения данных по колонкам используем все возможные сведения.
                     По хорошему шапку отчета как и его подвал для определения колонок брать не нужно (нужны только данные), но пока берем все.
              */
              j = GlPos = 0;
              while( j < ArrParamPrintStr.Size )
                  if( ValCmpArray(GlPos, ArrGlPos) == ELEM_NO_FOUND )
                      ArrGlPos[ArrGlPos.Size] = GlPos;
                  end;
                  // для табличных элементов +1
                  if( ValCmpArray(ArrParamPrintStr[j].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                      GlPos = GlPos + ArrParamPrintStr[j].StrModif_WholeE + 1;
                  else
                      if(ArrParamPrintStr[j].FlagPrint)
                          GlPos = GlPos + ArrParamPrintStr[j].StrModif_WholeE;
                      end;
                  end;

                  if( ValCmpArray(GlPos, ArrGlPos) == ELEM_NO_FOUND )
                      ArrGlPos[ArrGlPos.Size] = GlPos;
                  end;

                  j = j + 1;
              end;
          end;
          i = i + 1;
      end;

      /* На случай если нет ни одного элемента, то добавим нулевой элемент, */
      /* т.к. в таблице учитываются только правые границы                   */
      if( NOT ArrGlPos.Size )
          ArrGlPos[0] = 0;
      end;

      /* Добавим к разбивке данные по переданному заголовку таблицы отчета */
      i = j = 0;
      while( i < ObjSheet.GetArrColWidthTable().Size )
          j = j + ObjSheet.GetArrColWidthTable(i) + 1;
          ArrGlPos[ArrGlPos.Size] = j;
          i = i + 1;
      end;

      /* Отсортируем полученный массив */
 //     QSortWithUserMacro(ArrGlPos, "CmpParamForQSort");

      // Убрали быстрый QSort, т.к. на больших массивах (свыше 100 элеменов) происходит переполнение стека
      ArrGlPos = SortArray(ArrGlPos, TRUE);

      /* Удалим повторяющиеся значения */
      i = 0;
      while( i < ArrGlPos.Size )
         if( Not i )
             ArrUnicGlPos[ArrUnicGlPos.Size] = ArrGlPos[i];
         else
             if( ArrUnicGlPos[ArrUnicGlPos.Size - 1] != ArrGlPos[i] )
                 ArrUnicGlPos[ArrUnicGlPos.Size] = ArrGlPos[i];
             end;
         end;
         i = i + 1;
      end;

      /* Подсчитаем настоящие ширины отчета */
      i = 0;
      ArrColWidth.Size = 0;
      while( i < ArrUnicGlPos.Size )
          if( i )
              ArrColWidth[ArrColWidth.Size] = ArrUnicGlPos[i] - ArrUnicGlPos[i - 1];
          else
              if( ArrUnicGlPos[i] > 1 )
                  ArrColWidth[ArrColWidth.Size] = ArrUnicGlPos[i] - 1;
              end;
          end;
          i = i + 1;
      end;
   end; /* AutoCol */

   // --------------------------------------------------------------------------
   macro CreateRepAllSheet( lsSheet:ClsSheet )
       var i           :integer = 0;     // Счетчик циклов
       var HTMLFileName:string  = "";    // Имя временного HTML-файла для сохранения отчета
       private FILE HTMLRp() txt write;  // Ссылка на главный HTML-файл

       /* Откроем HTML-файл */
       if( this.WorkDir ) HTMLFileName = this.WorkDir + "\\" + this.ExlusiveFileName;
       else               HTMLFileName = this.ExlusiveFileName;
       end;

       // Файл список. Должен БЫТЬ, хотя бы пустым
       WR_OPEN(HTMLRp, SubFileExt(HTMLFileName) + ".files\\filelist.xml");
       Close(HTMLRp);

       /* Открываем HTML - файл */
       WR_OPEN(HTMLRp, HTMLFileName);

       /* Получим ссылку на OLE-объект Excel */
       WR_Insert(HTMLRp, "<html xmlns:v=\"urn:schemas-microsoft-com:vml\"");
       WR_Insert(HTMLRp, "      xmlns:o=\"urn:schemas-microsoft-com:office:office\"");
       WR_Insert(HTMLRp, "      xmlns:x=\"urn:schemas-microsoft-com:office:excel\">");

       /* Формируем раздел HEAD */
       WR_Insert(HTMLRp, "<head>");
       WR_Insert(HTMLRp, "<meta http-equiv=Content-Type content=\"text/html; charset="+WR_lsEncode[WR_CURRENCODE].charset+"\">");
       WR_Insert(HTMLRp, "<meta name=\"Excel Workbook Frameset\">");
       WR_Insert(HTMLRp, "<link rel=File-List href=\"" + SubFileExt(this.ExlusiveFileName) + ".files/filelist.xml\">");
       WR_Insert(HTMLRp, "<xml>");
       WR_Insert(HTMLRp, "<x:ExcelWorkbook>");
       WR_Insert(HTMLRp, "<x:ExcelWorksheets>");

       while( i < lsSheet.Size()  )
           WR_Insert(HTMLRp, "<x:ExcelWorksheet>");
           WR_Insert(HTMLRp, "<x:Name>" + lsSheet.Get(i).SheetName + "</x:Name>");
           WR_Insert(HTMLRp, "<x:WorksheetSource HRef=\"./" + SubFileExt(this.ExlusiveFileName)
                        + ".files/"  + lsSheet.Get(i).GetFileNameHTML() + "\"/>");
           WR_Insert(HTMLRp, "</x:ExcelWorksheet>");

           i = i + 1;
       end;

       WR_Insert(HTMLRp, "</x:ExcelWorksheets>");
       WR_Insert(HTMLRp, "</x:ExcelWorkbook>"  );

       i = 0;
       while( i < ArrStrOnEachPage.Size() )
          WR_Insert(HTMLRp, ArrStrOnEachPage[i]);
          i = i + 1;
       end;

       WR_Insert(HTMLRp, "</xml>" );
       WR_Insert(HTMLRp, "</head>");
       WR_Insert(HTMLRp, "</html>");

       Close(HTMLRp);
   end;

   // --------------------------------------------------------------------------
   /**** Формирование одной закладки отчета */
   macro CreateSheet( ObjSheet:CSheetProp, _KoefScreenW:double )
       var HTMLFileName :string = "";               // Имя временного HTML-файла для сохранения отчета
       private FILE HTMLSheet() txt write;          // Ссылка на вспомогательный HTML-файл
 
       ObjSheet.FlagPrintFirstHeader = FALSE;
       KoefScreenW = _KoefScreenW;
       /* При необходимости покажем индикатор */
       if( this.FlagShowIndicator )
           InitProgress(ObjSheet.GetArrPrintStr().Size, StatusIndicatorRep, TitulIndicatorRep);       
       end;

       /* Откроем HTML-файл */
       if( this.WorkDir )  HTMLFileName = this.WorkDir + "\\" + this.ExlusiveFileName;
       else                HTMLFileName = this.ExlusiveFileName;
       end;

       /* Сконвертим заголовок таблицы из текстового представления в специальный объект */
       if( NOT ObjSheet.GetArrHeaderStr().Size ) 
           if( Not ObjSheet.GetArrColWidth().Size )
               AutoCol( ObjSheet );
           end;
           ConvertExcelHeaderStr( ObjSheet );
       end;

       HTML_SetExcelColWidth(NULL, ObjSheet);

       // Рассчитаем все необходимые параметры для размера и положения страницы с помощью объекта CPrinterOptions
       ObjPrinterOptions = CPrinterOptions;

       /* Наоткрываем в папке для закладок нужное количество файлов и запишем туда общую информацию */
       if( WR_OPEN(HTMLSheet, SubFileExt(HTMLFileName) + ".files\\" + ObjSheet.GetFileNameHTML()) )

           /* Получим ссылку на OLE-объект Excel */
           WR_Insert(HTMLSheet, "<html xmlns:v=\"urn:schemas-microsoft-com:vml\"");
           WR_Insert(HTMLSheet, "      xmlns:o=\"urn:schemas-microsoft-com:office:office\"");
           WR_Insert(HTMLSheet, "      xmlns:x=\"urn:schemas-microsoft-com:office:excel\">");

           /* Формируем раздел HEAD */
           WR_Insert(HTMLSheet, "<head>");
           WR_Insert(HTMLSheet, "<meta http-equiv=Content-Type content=\"text/html; charset="+WR_lsEncode[WR_CURRENCODE].charset+"\">");

           /* Установим ширины колонок на листе в Excel */
           HTML_SetExcelColWidth(HTMLSheet, ObjSheet); // !!! Внимаение, вызывается дважды, второй раз в HTML_CreateBody

           // Определим параметры печати
           ObjPrinterOptions.CalcPrinterOptions(ObjSheet.ZoomType, this.WidthExcelRep, ObjSheet.NumPageWidth);

           HTML_SetPageOptions(HTMLSheet, ObjSheet);

           WR_Insert(HTMLSheet, "<xml>");
              HTML_SetPrinterOptions  (HTMLSheet, ObjSheet); // Установка сетки, нулевых значений и размеров и т.п.
              HTML_SetPageBreakOptions(HTMLSheet, ObjSheet); // Разрывы листов
           WR_Insert(HTMLSheet, "</xml>");

           HTML_CreateStyle(HTMLSheet, ObjSheet);  // Вывод стилей
           WR_Insert(HTMLSheet, "</head>");

           HTML_CreateBody(HTMLSheet, ObjSheet);

           WR_Insert(HTMLSheet, "</body>");
           Close(HTMLSheet);
       else
           MsgBox( "Ошибка открытия файла закладки отчета \""+ SubFileExt(HTMLFileName) + ".files\\" + ObjSheet.GetFileNameHTML() +"\"!" );
           return false;
       end;

       if( this.FlagShowIndicator )
           RemProgress();
       end; 

       return true;
   end;

   // --------------------------------------------------------------------------
   macro CopyData()
       var i           :integer = 0;
       var HTMLFileName:string  = "";                                        // Имя временного HTML-файла для сохранения отчета
       var DirNameCopy :string  = SubFileExt(this.ExlusiveFileName)+".files";// Каталог создаваемый на терминале
       var DirList     :TDirList= NULL;                                      // Управление файлами и каталогами в сети

       /* Если работаем в трехзвенке, то пересылаем отчет на терминал */
       if( Not IsStandAlone )
           /* Проверим существование папки, в которой будем проверять наличие инструмента. */
           MakeDir(toAnsi(NameDirTerm) );

           /* Создаем папку на терминале */
           if( DirNameCopy )
               MakeDir(toAnsi(NameDirTerm) + DirNameCopy);

               /* Откроем HTML-файл */
               if( this.WorkDir )  HTMLFileName = this.WorkDir + "\\" + this.ExlusiveFileName;
               else                HTMLFileName = this.ExlusiveFileName;
               end;

               /* Пересылаем содержимое папки на терминал */
               DirList = TDirList;
               DirList.List( SubFileExt(HTMLFileName) + ".files\\*.*", "F");
               while( i < DirList.Count )

                   ArrFileHTML[ArrFileHTML.Size] = DirNameCopy + "\\" + DirList.Name(i);
                 
                   if( Not CopyFile( SubFileExt(HTMLFileName) + ".files\\"+DirList.Name(i),
                                     toAnsi(NameDirTerm) + DirNameCopy + "\\" + DirList.Name(i)) )
                       // запомним, потом удалим
                       MsgBox( "Ошибка при передаче файла\n" + DirList.Name(i) + "\nна терминал" );
                   end;
                  i = i + 1;
               end;  
           end;

           /* Пересылаем основной файл */
           if( Not CopyFile(HTMLFileName, toAnsi(NameDirTerm) + this.ExlusiveFileName) )
               MsgBox( "Ошибка при передаче файла\n" + this.ExlusiveFileName + "\nна терминал" );
           end;
       end;
   end;

End; /* Class C_HTML_Report() */
/*class CScanData(_ScanData,_ScanType)
 var  ScanData:string = _ScanData;
 var  ScanType = 0;

 if(ValType(_ScanType))
     ScanType = _ScanType 
 end; 
end;*/

/**/