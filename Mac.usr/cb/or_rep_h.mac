/*╔═══════════════════════════════════════════════════════════════════════════╗*/
/*║           Автоматизированная банковская система RS-Bank v5.1              ║*/
/*║               Copyright (c) R-Style Software Lab 2001-2004                ║*/
/*║                                                                           ║*/
/*║ Имя файла     or_rep_h.mac                                                ║*/
/*║                                                                           ║*/
/*║ Описание      Инструмент для создания универсальных отчетов               ║*/
/*║                                                                           ║*/
/*║ Программист   Зуев С.В.                                                   ║*/
/*║                                                                           ║*/
/*║ Создан        17.07.2001                                                  ║*/
/*║                                                                           ║*/
/*╚═══════════════════════════════════════════════════════════════════════════╝*/

//15.05.2014 I-00486709-2, I-00486938-2 DPN В 31-м патче лезут пустые листы из принтера
//22.09.2014 R-455621-2 DPN Добавил замену перевода каретки на пробел

Import "or_exl_h.mac";

Import BankInter;
Import rsexts;
import fileop;         // Объект для работы с файлами на сервере и терминале
Import "trlocale.d32"; // Утилитные функции написанные на СИ
Import "or_class.mac";
Import "or_set_h.mac"; // Настройки, применяемые в инструменте
Import "or_dps_h.mac"; // Класс для работы с диапазонами + сопутствующие функции
Import "or_srt_h.mac"; // Функции для сортировки
Import "or_hdr_h.mac"; // Класс для работы с заголовками любой сложности + сопутствующие функции

const TMP_FILES:string = "__tmp__.out"; /* Временный файл для перенаправления вывода,  */
                                        /* для того, чтобы узнать имя выходного потока */

private var __NumObject:integer = 0;  // Номер экземпляра данного объекта (т.е. сколько экземпляров CMakeReport создано)

/* Класс для создания отчетов */
CLASS CMakeReport(_HeaderStr:string, _SepStr:string, _CountStrOnPage:integer, _CurStr:integer)

  /* Список методов: (* - внутренние методы)
  МЕТОДЫ ЯДРА(21): (Убедительная просьба, кривыми руками не трогать!)
      AddPrintCell            - добавление информационных ячеек в конец текущей строки
     *AddNewStr               - добавление строки в основной информационный массив
      AddStr                  - добавление сформированных массивов ячеек одной строки в конец отчета
      AddStrBreak             - добавление разрыва страниц в конец отчета
      AutoScan                - автоматическое сканирование данных из квадратных скобок
      CalcColWidth            - подсчет ширины колонок таблицы отчета
     *CheckDiapason           - проверка переданного диапазона и установка корректных значений границ дипазона
      ChangeSpecialSymbol     - метод замены\восстановления спец. символов (кавычек, слешей и т.п.)
      ClearAllStr             - удаление всех сформированных массивов строк
     *ConvertHeaderStr        - преобразование переданного заголовка таблицы к заголовку с требуемыми разделителями и подсчет высоты таблицы
      Destructor              - деструктор
     *GetValueArrPrint        - внутренний метод для доступа к ячейкам информационного массива
      FillHeader              - модификация заголовка таблицы отчета, содержащего переменные 
      Init                    - инициализация класса
     *NormFlagEndTabl         - нормализация значения количества строк под разделители
     *PrintHeader             - печать заголовка таблицы отчета
      PrintRep                - формирование текстового отчета
      PrintRepCopy            - формирование копий текстового отчета
     *PrintRep_Sheet          - метод для формирования закладки Sheet отчета
     *PrintRep_Sheet_Tmp      - печать закладки текстового варианта отчета во временный файл
     *PrintSep                - печать строки разделителей
     *PrintStr                - вывод строки

  УТИЛИТНЫЕ МЕТОДЫ(19):
      AddEmptyCell            - добавление нескольких пустых информационных ячеек в конец текущей строки с автоподбором ширины
      AddEmptyStr             - добавление нескольких пустых строк в конец отчета
      AddFormatCell           - добавление информационных ячеек в конец текущей строки с автоподбором ширины
      AddStrInObject          - дополнение текущего объекта данными (строками) из другого объекта этого-же типа
      FindCellValue           - поиск значения в интервале уже существующих строк и столбцов
      CheckExtendBorder       - метод поиска в расширенном форматировании обрамления
      GetCellValue            - получение значения из уже существующей строки отчета
      GetColSum               - получение суммы по столбцу таблицы
      GetColWidthTable        - получение ширины колонки таблицы отчета
      GetCountColTable        - получение количества колонок в таблице отчета
      GetCurSheet             - получить объект "текщая закладка"
      GetHeaderWidth          - получение ширины таблицы отчета (в большинстве случаев это ширина самого отчета)
      GetNumLastStr           - получение номера последней строки отчета
      GetWidthBeforeCol       - получение ширины всех столбцов находящихся перед указанным
      IsDataExist             - определение наличия табличных строк отчета
      SetCellFormat           - изменение параметров форматирования ячейки в уже существующей строке отчета
      SetCellValue            - изменение значения в уже существующей строке отчета
      SetCellWidth            - изменение ширины ячейки в уже существующей строке отчета
      SetColFormat            - изменение параметров форматирования уже существующих ячеек в заданном диапазоне указанного столбца
      SetCurSheet             - установка текущего листа (закладки)
      SetFlagPrintFullHeader  - установка флага печати:полной шапки таблицы или сокращенной шапки
      SetFlagDebug            - включение-выключение режима отладки
      SetFlagModePrint        - установкаи формата печати строк с псевдографическими разделителями
      SetFlagShowIndicator    - установка флага показа встроенного индикатора
      SetFlagShowMidSeparator - установка флага показа межстрочных разделителей
      SetFileName             - установка имени выходного файла для сформированного документа во всех форматах
      SetFileNameWin          - установка имени выходного файла для сформированного документа в Win форматах
      SetFileNameTxt          - установка имени выходного файла для сформированного документа в txt формате

  МЕТОДЫ ДЛЯ WINDOWS-ПРЕДСТАВЛЕНИЯ(23):
      AddNewSheetBreak        - добавление признака перехода на новый лист Excel в конец отчета
      AddWinRepOutput         - пользовательский метод для добавления формата выводимого файла и приложения для вывода отчета
      CalcHeaderHeight        - расчет высоты СКОНВЕРТИРОВАННОГО заголовка таблицы отчета
      GetCountSheet           - получения числа листов Excel в отчете
      GetNumBegStrForSheet    - получения номера начальной строки из ArrPrintStr для листа Excel
      GetWorkDirName          - метод для получения рабочего каталога
      ClearTemplate           - метод очистки массива шаблонов
     *CheckOutApplication     - проверяем наличие приложения AppCheck в "списке" выбранных приложений AppSelect. Эмуляция С-го поразрядного И
      PrintWinRep             - формирование отчета в Windows представлении
     *PrintWinRep_Sheet       - печать html-го варианта отчета во временный файл
      PrintPreview_xls        - методы показа отчета в режиме "Предварительного просмотра"
      PrintOut_xls            - методы для отправки отчета на печать для Excel
      PrintOut_doc            - методы для отправки отчета на печать для Word
     *PrintMODI               - внутренний метод для печати отчета в mdi формате
      SetDefaultFontName      - установки имени шрифта
      SetDefaultFontSize      - установки размера шрифта по умолчанию и эмпирического коэффициента для Excel
      SetExecute              - установка строки для выполнения процедурой ExecStr в Excel
      SetExecuteWord          - установка строки для выполнения процедурой ExecStr в Word
      SetExecuteMacro         - установка значений членам класса, ответственным за выполнение спецформатирования и
                                пересылку макрофайла на терминал в случае работы в трехзвенке
      SetExecuteMacroWord     - установка значений членам класса, ответственным за выполнение спецформатирования в Word
                                и пересылку макрофайла на терминал в случае работы в трехзвенке
      SetExecuteRowSize       - массовая установка высоты строк в СМ для выполнения процедурой ExecStr
      SetFlagShowFixedRow     - установка флага показа фиксированных строк заголовка таблицы на каждой странице в Excel
      SetFlagShowGrid         - установка флага показа разделительной сетки в Excel
      SetFlagShowReport       - установка флага показа отчета в офисном формате
      SetFlagShowZeroValue    - установка флага показа нулевых значений
      SetFont                 - установка шрифта отчета (листа) и коэф-та ширины символа для отчета
      SetFont_Times_New_Roman - установка шрифта отчета (листа) "Times New Roman" и коэф-та ширины символа для отчета
      SetHeader               - метод инициализации закладки заголовком с расширенными параметрами
      SetHeaderStr            - метод для инициализации закладки шапкой таблицы
      SetMarginText           - установка текста колонтитулов в Excel
      SetMarginSizeVert       - пользовательский метод для установки размера отступов вертикальных
      SetMarginSizeHor        - пользовательский метод для установки размера отступов горизонтальных
      SetMarginSize           - пользовательский метод для установки размера отступов всех
      SetTemplate             - добавление строки в шаблон
      SetWinRepOutput         - установка формата выводимого файла и приложения для вывода отчета
      SetZoomType             - установка масштаба отображения в Excel для предварительного просмотра
      ShowWinRep              - показ отчета в Windows-представлении
      SetDocProperty          - Установить свойства документа (Автор, организация, и т.п) 
      SetPageScale            - Метод для установления шкалы масштаба для закладки SheetName
  ДОПОЛНИТЕЛЬНЫЕ МЕТОДЫ(10): (Различные навороты, перед использованием желательно почитать документацию)
      AddChart                - Добавить диаграмму по текущему листу
      AddSortField            - добавление объектов CSortField и CSubResField
      ClearAllSortField       - удаление всех полей сортировки
      ClearRepeats            - стирание повторяющихся значений в определенной колонке
     *CmpField                - сравнение строк отчета
      CreateSubRes            - формирование строк подитогов
      DelTmpFilesFolders      - Удаление временной папки
      HideCol                 - скрытие (пока просто удаление) колонок в уже существующих таблицах отчета
     *MakeGroupIndex          - формирование индекса автогруппировки
      MoveSheet               - Пользовательский метод предназначенный для перемещения закладок между собой
      RenumRep                - перенумерация таблицы отчета
      SetGroupColIndex        - установка (снятие) номеров колонок отчета, по которым будут групироваться данные отчета
      SetModeBigReport        - Пользовательский метод установки режима для больших отчет! В этом режиме отчет выводится позакладочно (для оптимизации работы с памятью)
      SortRep                 - сортировка строк отчета в заданном диапазоне

  МЕТОДЫ ДЛЛЯ РАБОТЫ С ШАБЛОНАМИ (ДОКУМЕНТАМИ СЛИЯНИЯ)
      AddDoc                  - Добавить документ в шаблон NameTemplate
      ClearRegisterForm       - Очистить содержимое регистрации шаблона NameTemplate
      CheckRegisterForm       - Проверить наличие регистрации шаблона с именем NameTemplate
      CreateTemplateData      - На основании данных реестра шаблонов lsTemplateDocument, добавим данные в основной объект
      RegisterForm            - Добавить шаблон с названиями полей в реестр шаблонов
      SetPathTemplate         - Пользовательский метод для задания пути до шаблонов шаблона
      ShowTemplateRep         - Пользовательский метод для создания документа слияния на основании шаблона
  */

  /* Public memebers */
  VAR CurStr          :integer = DefaultTxtBegStr;   // Номер текущей строки
  VAR CurSheet        :integer = 0;                  // Номер текущей обрабатываемой закладки
  VAR ExlusiveFileName:string  = "";                 // Уникальное имя файла, используемое для автосохранения
  VAR FormatRep       :integer = DefaultFormatRep;   // Формат файла, в котором выводится отчет
  VAR WinRepOutput    :integer = DefaultWinRepOutput;// Приложение, в которое выводится отчет
  VAR WorkDir         :string  = "";                 // Рабочий каталог

  var ReportPath         :string  = "";              // Путь до готовых отчетов
  var ReportFileName_xls :string  = "";              // Имя сформированного отчета в формате xls
  var ReportFileName_doc :string  = "";              //                                      doc 
  var ReportFileName_html:string  = "";              //                                      html


  /* Private members */  // При добавлении объектов ОБЯЗАТЕЛЬНО добавь удаление их в диструкторе!!!
  private var ArrGroupColIndex    :tarray     = tarray(10,10);     // Массив номеров колонок для группировки
  private var ArrSortField        :tarray     = tarray(10,10);     // Массив объектов содержащих поля сортировки и направление сортировки
  private var ArrTemplate         :ClsTemplate= ClsTemplate();     // Объект с данными шаблонов
  private var AutoInc             :integer    = 0;                 // Переменная для автоматической нумерации строк
  private var BegSepStr           :string     = "";                // Исходная строка, которая была передана в качестве строки элементов обрамления заголовока таблицы
  private var CountStrOnPage      :integer    = DefaultTxtPageSize;// Количество строк на печатный лист
  private var DirName_TMP         :string     = "";                // Имя папки, в которой будем сохранять временные файлы
  private var DirName_Template    :string     = "";                // Имя папки, в которой размещаются шаблоны
  private var ExecuteStrExcel     :tarray     = tarray;            // Строка для выполнения спецформатирования методом ObjExcel.ExecStr
  private var ExecuteStrWord      :tarray     = tarray;            // Строка для выполнения спецформатирования методом ObjWord .ExecStr
  private var lsSheet             :ClsSheet   = ClsSheet ;         // Список закладок отчета. Основной объект!
  private var lsTemplateDocument  :object     = NULL ;             // Реестр шаблонов для формирования документов слияния
  private var FlagAddStr          :bool       = TRUE ;             // Флаг говорящий о необходимости добавления новой строки данных
  private var FlagAutoIncUsed     :bool       = FALSE;             // Флаг необходимости проведения автоинкрементирования переменной AutoInc при добавлении строки таблицы
  private var FlagAutoScanMode    :bool       = FALSE;             // Флаг режима работы автосканирования текста (добавление в объект при False, изменение переданной строки при True)
  private var FlagShowMidSeparator:bool       = TRUE ;             // Флаг печати межстрочных разделителей таблицы
  private var FlagModeBigReport   :bool       = FALSE;             // Флаг печати в режиме больших отчет! В этом режиме отчет выводится позакладочно (для оптимизации работы с памятью)
  private var FlagModePrint       :integer    = STD_MODEPRINT_WITH_DUALSTR;// Формат печати строк с псевдографическими разделителями
  private var FlagShowIndicator   :bool       = TRUE ;             // Флаг показа встроенного индикатора
  private var m_FlagShowReport    :bool       = TRUE ;             // Флаг показа отчета в формате офисного приложения
  private var m_TIFDPI            :integer    = TIFDPI_200;        // Переменная определяющая качество печати отчета в tiff формат
  private var FileNameDocumentWin :string     = "";                // Имя выходного файла для сформированного документа
  private var FileNameDocumentTxt :string     = "";                // Имя выходного файла для сформированного документа
  private var iMacroFileName      :string     = "";                // Имя mac-файла для выполнения спецформатировоания методом ObjExcel.ExecuteMacro
  private var iMacroFileNameWord  :string     = "";                // Имя mac-файла для выполнения спецформатировоания методом ObjWord.ExecuteMacro
  private var iProc               :string     = "";                // Имя функции в mac-файле для выполнения спецформатировоания методом ObjExcel.ExecuteMacro
  private var iPrm                :string     = "";                // Строка со списком параметров для функции в mac-файле для выполнения спецформатировоания методом ObjExcel.ExecuteMacro
  private var NeedCountStrHeader  :integer    = 0;                 // Количество строк необходимых для вывода заголовка при его возникновении не в начале страницы 
  private var NeedTypeSep         :integer    = REP_NO_SEP;        // Требуемый тип разделителя
  private var ObjSeparator        :CSeparator = CSeparator();      // Объект класса CSeparator
  private var Obj_HTML_Rep        :C_HTML_Report = NULL;           // Объект HTML-ый отчет
  private var DocProperty         :CDocProperty  = NULL;           //Свойства документа(Автор, Организация и т.п)
  private var KoefScreenH         :double        = 0;              // коэффициенты для учёта маштаба шрифта (раб.стол->свойства\параметры\дополнительно->общие-> маштаб)   
  private var KoefScreenW         :double        = 0;
  private var ObjExcel            :object        = NULL; 
/*┌─────────────────────────────────────────────────────────────────────────────────┐*/
/*│Методы ядра                                                                      │*/
/*└─────────────────────────────────────────────────────────────────────────────────┘*/

  /* (Public) Пользовательский метод для получения текущей закладки    */
  macro GetCurSheet()
        return lsSheet.Get(CurSheet);
  end;

  /* (Public) Пользовательский метод установки номера текущего листа */
  macro SetCurSheet( SheetNumber:integer )
        if( SheetNumber < lsSheet.Size() )
            CurSheet = SheetNumber;
            return TRUE;
        else
            MsgBox("Ошибка CMakeReport.SetCurSheet()!|Закладки <"+string(SheetNumber)+"> нет в списке закладок отчета!");
        end;
        return FALSE;
  end;

  /* (Private) Внутренний метод добавления строки (массива для заполнения ячейками) */
  Macro AddNewStr()
        GetCurSheet.AddArrPrintStr();
  end;

  /* (Public) Пользовательский метод добавления информационных ячеек в конец текущей строки */
  Macro AddPrintCell(l_StrValue, _StrModif_Whole:integer, _StrModif_Fract:integer, _StrModif_Advan:string, _FlagStr:integer,_FlagPrint:bool)

     var ArrPrintStr  :tarray  = GetCurSheet.GetArrPrintStr();
     var PrintCell    :CParamPrintCell;               /* Объект вида CParamPrintCell                     */
     var _StrValue;                                   /* Переданное значение                             */
     var ArrScanStr   :tarray  = NULL;                /* Переменная для сканирования уже введенных строк */
     var i            :integer = 0;                   /* Счетчик циклов                                  */
     var ValTypeValue :integer = ValType(l_StrValue); // Тип значения
     var NumColumn    :integer = 0;                   // Номер последней колонки
     var ExtendType   :integer = 0;                   // Тип из строки параметров
     // Добавим новую строку
     if( FlagAddStr )
         this.AddNewStr();
         FlagAddStr = FALSE;
     end;
     /* По особому обработаем неопределенное значение */
     if( ValTypeValue == V_UNDEF )
         l_StrValue = "Undefined";
     end;

     /* Проверим, не стоит ли ключ подбора ширины выводимой информации по содержимому */
     if( _StrModif_Whole == FIT_TO_VAL )
         _StrModif_Whole = StrLen(String(l_StrValue));
     end;

     /* Проверим, автоинкрементируемое ли это поле */
     if( l_StrValue == KEY_AUTOINC )
         _StrValue       = AutoInc + 1;
         FlagAutoIncUsed = True;

     /* Проверим, итог ли это по столбцу */
     elif( l_StrValue == KEY_SUMABOVE )
         i = GetCurSheet.GetArrPrintStr.Size() - 1;
         /* Если строка не единственная */
         _StrValue = "";
         if( i >= 0 )
              ArrScanStr = GetCurSheet.GetArrPrintStr.Value(i);
              /* Если предыдущая строка является строкой таблицы */
              if( ValCmpArray(ArrScanStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )

                  /* Возьмём форматирование по последней строке, если оно не задано */
                  NumColumn = GetCurSheet.GetArrPrintStr.Value(GetCurSheet.GetArrPrintStr.Size-1).Size;
                  if( NumColumn < ArrScanStr.Size )
                     if( ValType(_StrModif_Whole) == V_UNDEF )
                         _StrModif_Whole = ArrScanStr[NumColumn].StrModif_Whole;
                     end;

                     if( ValType(_StrModif_Fract) == V_UNDEF )
                         _StrModif_Fract = ArrScanStr[NumColumn].StrModif_Fract;
                     end;

                     if( ValType(_StrModif_Advan) == V_UNDEF )
                         _StrModif_Advan = ArrScanStr[NumColumn].StandartLexem;
                     end;
                  else
                     _StrModif_Whole =  0;
                     _StrModif_Fract =  2;
                     _StrModif_Advan = "r";
                  end;
                  /* Ограничимся итогом по столбцу одной таблицы */ 
                  _StrValue = this.GetColSum(NumColumn);
              end;
          end;
     else
         _StrValue = l_StrValue;
     end;
     /* Обработаем автоподбор ширины ячеек по  ширине столбцов заголовка таблицы отчета */
     if( ValType(_StrModif_Whole) )
         if( Not _StrModif_Whole )
             NumColumn = GetCurSheet.GetArrPrintStr(GetCurSheet.GetArrPrintStr().Size-1).Size;
             if( GetCurSheet.GetArrColWidthTable().Size > NumColumn )
                 _StrModif_Whole  = GetCurSheet.GetArrColWidthTable(NumColumn);
                 if((_FlagStr == REP_ELEM_STR) )// ширины для табличных элементов увеличатся на 1, если не увеличивать строки будут лишние разбиения
                    _StrModif_Whole = _StrModif_Whole  + 1;
                 end;
                 PrintCell = CParamPrintCell(_StrValue,_StrModif_Whole, _StrModif_Fract, _StrModif_Advan, _FlagStr);
             else 
                 PrintCell = CParamPrintCell(_StrValue,NULL,_StrModif_Fract, _StrModif_Advan, _FlagStr);
             end;
         else 
             PrintCell = CParamPrintCell(_StrValue, _StrModif_Whole, _StrModif_Fract, _StrModif_Advan, _FlagStr);
         end;
     else 
         NumColumn = GetCurSheet.GetArrPrintStr(GetCurSheet.GetArrPrintStr().Size-1).Size;
         if( GetCurSheet.GetArrColWidthTable().Size > NumColumn )
             PrintCell = CParamPrintCell(_StrValue, GetCurSheet.GetArrColWidthTable(NumColumn), _StrModif_Fract, _StrModif_Advan, _FlagStr);
         else
             PrintCell = CParamPrintCell(_StrValue, NULL, _StrModif_Fract, _StrModif_Advan, _FlagStr);
         end;
     end;
     if(ValType(_FlagPrint) == V_BOOL)
         PrintCell.FlagPrint = _FlagPrint;    
     end; 
     if  ( (ValTypeValue == V_MONEY ) OR (ValTypeValue == V_MONEYL ) ) GetCurSheet.lsFormat_M.Add(PrintCell);
     elif( (ValTypeValue == V_DOUBLE) OR (ValTypeValue == V_DOUBLEL) ) GetCurSheet.lsFormat_D.Add(PrintCell);
     elif(  ValTypeValue == V_INTEGER                                ) GetCurSheet.lsFormat_I.Add(PrintCell);
     elif( ValTypeValue == V_STRING )
         if(Strlen(PrintCell.StrValue) < MAX_TXT_FORMAT_LEN)
             GetCurSheet.lsFormat_S.Add(PrintCell); // длинные строки в текстовом формате не отображаютя :(
         end;
     end; 
     ArrPrintStr.Value(ArrPrintStr.Size - 1).                                      /*Row*/
                 Value(ArrPrintStr.Value(ArrPrintStr.Size - 1).Size ) = PrintCell; /*Col*/
  End; /* AddPrintCell */

   private macro GetRegim_LoadNewApplication() : bool
     var Regim   :bool  = true; // Запускать новое приложение, true - использовать уже запущенное
     var StrErr  :string=   ""; // Строка с ошибкой определенияпеременной реестра
     if( NOT GetRegistryValue( "BANK_INI\\WINDOWS REPORT\\LOADNEWAPPLICATION",
                               V_UNDEF, Regim, StrErr ) )

         MsgBox("В реестре не найден ключ [BANK_INI\\WINDOWS REPORT\\LOADNEWAPPLICATION]!|", StrErr);
     end;

     return Regim;
  end;


  /* (Public) Пользовательский метод добавления сформированных массивов ячеек одной строки в конец отчета с возможностью автосуммирования */
  Macro AddStr(_FlagHeader:bool/*анахронизм*/, NumberTemplate )

     var i            :integer = 0;      /* Счетчик циклов */
     var j            :integer = 0;      /* Счетчик циклов */
     var ArrScanStr   :tarray  = NULL; /* Переменная для сканирования уже введенных строк */
     var TypeValue    :integer = 0;      /* Тип значения в ячейке */
     var FlagEndSelect:bool    = False;  /* Флаг окончания поиска */
     var StrGroupIndex:string  = "";     /* Строка индекса автогруппироки для новой строки */
     var ObjSheetProp :CSheetProp;       /* Объект класса CSheetProp */
     var ArrPrintStr  :tarray  = GetCurSheet.GetArrPrintStr();
     var NewSheetName :string  = "";
     var Prefix       :string  = "";

     /* Добавляем строку, только если она содержит ячейки */
     if( ArrPrintStr(ArrPrintStr.Size-1).Size )
         if( ValType(NumberTemplate) )
             this.GetValueArrPrint(ArrPrintStr.Size-1, 0).NumberTemplate = NumberTemplate;
         end;

         /* Если указан столбец для автосуммирования и текущая строка является строкой таблицы, проведем автосуммирование строк */
         if( (ArrGroupColIndex.Size) and
             (ValCmpArray(this.GetValueArrPrint(ArrPrintStr.Size-1, 0).FlagStr, ArrConstTabl) != ELEM_NO_FOUND) )

             StrGroupIndex = this.MakeGroupIndex(ArrPrintStr[ArrPrintStr.Size-1]);
             i = ArrPrintStr.Size() - 1;
             while( ( i > 0) and (Not FlagEndSelect) )
                 i = i - 1; 
                 ArrScanStr = ArrPrintStr.Value(i);
                 /* Ограничим автосуммирование одной таблицей */ 
                 if( ValCmpArray(ArrScanStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                     if( this.MakeGroupIndex(ArrScanStr) == StrGroupIndex )
                         j = 0;
                         while( j < ArrScanStr.Size() )
                             TypeValue = ValType(ArrScanStr[j].StrValue);

                             /* Суммируем только данные типа денег или количеств */
                             if( (TypeValue == V_MONEY) or (TypeValue == V_DOUBLE) )
                                  ArrScanStr[j].StrValue = ArrScanStr[j].StrValue + 
                                                           this.GetValueArrPrint(ArrPrintStr.Size-1, j).StrValue;
                             end;
                             j = j + 1;
                         end;
                         FlagEndSelect = True;
                     end;        
                 else
                     i = 0;
                 end;
             end;
         end;
         FlagAddStr = TRUE;

         // Превысили ораничение, остаток перенесем на следующий лист
         if( GetCurSheet.m_GetAddCurRow >= MAXROWSHEET )
             NewSheetName = toOEM(GetCurSheet.SheetName);
             Prefix = "_Продолжение(";
             if( (i = Index(NewSheetName,Prefix)) ) // Переносы были
                 Prefix = string(Int(SubStr(NewSheetName, i+StrLen(Prefix), 1))+1, ")");
                 NewSheetName = SubStr(NewSheetName, 1, StrLen(NewSheetName)-2);
             else                                   // Переносов не было
                 Prefix = Prefix + "1)";
             end;

             if( (StrLen(NewSheetName)+StrLen(Prefix)) > 31 )
                 NewSheetName = SubStr(NewSheetName, 1, 31-StrLen(Prefix)) + Prefix;
             else
                 NewSheetName = NewSheetName + Prefix;
             end;

             this.AddNewSheetBreak(NewSheetName, GetCurSheet.SheetStrHeader, 
                                   GetCurSheet.FlagShowGrid     ,
                                   GetCurSheet.FlagShowZeroValue);
         end;
         GetCurSheet.m_AddCurRow();

         /* Если автосуммирование не прошло, добавляем строку */
         if( Not FlagEndSelect )
             if( FlagAutoIncUsed )
                 AutoInc = AutoInc + 1;
             end;
         else
             ArrPrintStr.Size = ArrPrintStr.Size - 1;
         end;
         FlagAutoIncUsed = False;
     end;
     
  End; /* AddStr */

  /* (Public) Пользовательский метод добавления признака разрыва страниц в конец отчета */
  Macro AddStrBreak()
        this.AddPrintCell(KEY_STRBREAK, StrLen(KEY_STRBREAK), 0, "l", REP_ELEM_STR);
        this.AddStr();  
  End; /* AddStrBreak */
          
  /* (Public) Пользовательский метод для сканирования данных из квадратных скобок */
  /* Алгоритм работы
  1.Пробегаем посимвольно по строке, при этом храним предыдущий, текущий, следующий,
   cимвол. Храним символ, который находится под текущим и  над текущим.
  2. Смотрим какой символ :псевдографика, шарпы или константная часть, если до этого был не такойже тип значения выводим его сразу в AddPrintCell,
    иначе прибавляем этот символ к строке вывода ,например,"│123###2345│" разобьётся на 5 ячеек  ,
    если достигли конца строки выводим всё что осталось.
  3 Обрамление. Ячейка обрамляется сверху или снизу если над или под всеми символам присутствуют символы  ┴─┬ 
                  
    Исключение.   "сссссссссссссссссс" , где с - любая константа. Строка констант будет разбита на 3 ячейки, чтобы учесть обрамление  
                     "  ─────────────  "
    в)Также происходит проверка на обрамление слева , при смене типа содержимого. 
  4  для ячеек с псевдографикой ┤├│ устанавливается флаг вывода в Excel = false
     эти ячейки потом не выводятся,а к длинне ячейки справа прибовляется 1 (в AutoCol),
     особый случай - два таких символа подряд                 ┌──┐┌─┐
     в таком случае для второго символа FlagPrint= true       │  ││ │
                                                              └──┘└─┘ 
  5 Псевдографика удаляется в HTML_CreateBody
     */                                                 
  Macro AutoScan( StrInfo:string/*,...*/ ) : bool
  
     var ArrScanStr     :tarray  = tarray(); /* Массив строк печатаемого блока */
     var ArrScanData    :tarray  = tarray; /* Массив данных для печатаемого блока */
     var Pos1           :integer = 0;      /* Вспомогательная переменная для позиционирования */
     var Pos2           :integer = 0;      /* Вспомогательная переменная для позиционирования */
     var Pos3           :integer = 0;      /* Вспомогательная переменная для позиционирования */
     var PrintBlock     :string  = "";     /* Блок для печати */
     var DataBlock      :string  = "";     /* Блок данных */
     var TempStr        :string  = "";     /* Вспомогательная переменная для разбора строки */
     var TempLexem      :variant  ;     /* Вспомогательная переменная для формирования лексем */
     var TempLexem3      :variant  ;     /* Вспомогательная переменная для формирования лексем */
     var ObjScanData    :CScanData;        /* Переменная класса CScanData для данных */
     var TempStrModif   :string  = "";     /* Вспомогательная переменная для строки модификаторов лексемы */
     var i              :integer = 0;      /* Счетчик циклов */
     var j              :integer = 0;      /* Счетчик циклов */
     var CurElem        :integer = 0;      /* Номер текущего данного для вывода */
     var CountSimbol    :integer = 0;      /* Число символов # */
     var LenStr         :integer = 0;      /* Вспомогательная переменная для длины строки */
     var StandartLexem  :string  = "";     /* Строка со стандартными параметрами форматирования */
     var Sz             :integer = 0;      /* Размер массива */
     var FormatStr      :string  = "";     /* Строка форматирования для элементов в обрамлении */
     var LenTempLexem   :integer = 0;      /* Вспомогательная переменная для длины лексем */
     var FlagBegStr     :bool    = True;   /* Флаг начала разбираемой строки */
     var TempValue      :variant;          /* Переменная для считывания переменных параметров */
     var FloatPoint     :integer = 0;      // количество знаков после запятой
     var FlagEndStr     :bool    = false;    // признак конца строки
     var TmpSymbol      :string  = "";       // текущий символ
     Var Curstate       :integer = -1;       // тип части строки (константа,шарпы, псевдографика)
     var FlagData       :bool    = false;  // показывает добавили мы что-нибудь или нет
     Var NextStr        :string  = "";     // следующая строка
     var PrevStr        :string  = "";     // предыдущая
     var FlagTop        :bool    = false;  // обрамление сверху
     var FlagBot        :bool    = false;  // обрамление снизу
     var TopSymbol      :string  = "";     //верхний символ
     var BotSymbol      :String  = "";
     var PrevTopSymbol  :string  = "";
     var PrevBotSymbol  :string  = "";
     var FlagNewSec     :bool    = false;
     var StrModif       :string  = ""; 
     var CurDataParm    :integer = 0;
     var NextSymbol     :string  = 0;        // следующий  символ
     var PrevSymbol     :string  = 0;        // предыдущий символ
     var PrevFlagTop    :bool    = 0;
     var PrevFlagBot    :bool    = 0;
     var FlagConstB     :bool    = false;

     
     /*добавление ячейки специально для автоскана*/
     Macro AddPrintCellA(StrValue, StrModif_Whole:integer, StrModif_Fract:integer, _FormatStr:string, _StrModif, FlagStr:integer,FlagPrint,CurState:integer)

         var LenSharp:string = 0;  // количество шарпов
         if(CurState != S_GRAPH)   // псевдографику не обрамляем
         
            if(Flagtop)       _FormatStr = _FormatStr + "t";
            end;
            if(FlagBot)       _FormatStr = _FormatStr  + "b";
            end;
            FlagTop = true;
            FlagBot = true;
         end;
         if(ValType(FlagPrint) != V_BOOL) // не передан признак печати в Windows представлении
             if(StrBrk(StrValue,"│└┴┘├┼┤┌┬┐")) FlagPrint = false; // такие символы не выводим
             else                              FlagPrint = true;
             end;
             if(StrBrk(StrValue,"─"))     // в HTML_CreateBody заменим на пробелы
                 FlagPrint = true;
             end; 
         end;
         if(CurState == S_CONST)
             _StrModif = ":l"  // выравнивание
         end; 
         
         if(CurState == S_SHARP) 
             if(CurDataParm < ArrScanData.Size)
                 LenStr         = strlen(StrValue); //  количество#                
                 if(LenStr == 1)
                     LenStr = strlen(string(ArrScanData[CurDataParm].ScanData));
                     if(NOT LenStr)    LenStr = 1;
                     end;
                 end;             
                 StrValue       = ArrScanData[CurDataParm].ScanData;
                 _StrModif      = ArrScanData[CurDataParm].StrModif;
                 if(ArrScanData[CurDataParm].Flag_statData)
                     StrValue = TR_ExecExp("String(" + String(StrValue) + ":" + String(LenStr) + ":" + ArrScanData[CurDataParm].CatExtendedLexems(ArrScanData[CurDataParm].StrModif) + ")");
                 end;
                 StrModif_Fract = ArrScanData[CurDataParm].GetFloatPoint();
                 CurDataParm = CurDataParm + 1;

                 if(( LenStr < strlen(String(StrValue))) AND 
                     (Valtype(StrValue) == V_STRING)   )//значение не поместилось- обработаем как в RSL
            
                     StrValue = SubStr(StrValue, 1, LenStr );

                 end;
             else
                 MsgBox("Ошибка в строке для сканирования!\nСлишком мало данных!");
             end; 
         else 
            LenStr =  StrModif_Whole; 
         end;
         
         FlagData = false;
         if((ValType(StrValue) == V_DATE) or (ValType(StrValue) == V_TIME )) 
             AddPrintCell(StrValue, LenStr, StrModif_Fract,_StrModif + ":ex_B("+_FormatStr+")",FlagStr,FlagPrint);
             FlagData = true; 
         else
             if((StrValue)  or (CurState == S_SHARP) )  // надо проверять, что не  передали пустую строку (если тип дата - не компилит)                 
                 AddPrintCell(StrValue, LenStr, StrModif_Fract,_StrModif + ":ex_B("+_FormatStr+")",FlagStr,FlagPrint);  
                 FlagData = true; 
             end;
         end;
         StrModif  = "";                 
         FormatStr = "";         
         _StrModif = ""; 
         FlagTop = FlagBot = true;
     End;



      Macro  SetLeft(_PrevSymbol:string,_FormatStr:string)
         if(StrBrk(_PrevSymbol,"│┤"))
             _FormatStr = _FormatStr + "l"; 
         end;   
         return _FormatStr;
     end;

     Macro  SetRight(_TmpSymbol:string,_FormatStr:string)
         if(StrBrk(_TmpSymbol,"│├"))
             _FormatStr = _FormatStr + "r";        
         end;                                      
         return _FormatStr;
     end;

     Macro CheckTopBot() // проверка на обрамление сверху и снизу

      var retval:bool = false; // возращаемое значение 
      PrevFlagTop  = FlagTop;
      PrevFlagBot  = FlagBot;             
      if( Not StrBrk(TopSymbol,"─┴") )
              //  if(StrBrk(PrevTopSymbol,"─┴") AND (Not StrBrk(TopSymbol,"└┘")) )
              //  retval = true; 
              //     end;
          FlagTop = false;                                    
              // else 
              // if(Not StrBrk(PrevTopSymbol,"└─┴┘") AND (Not StrBrk(TopSymbol,"└┘")) )
              // retval = true;                                                   
             //  end;
      end;                        

      if( Not StrBrk(BotSymbol,"─┬") )

           if(StrBrk(PrevBotSymbol,"─┬") AND (Not StrBrk(BotSymbol,"┌┐")) )
               retval = true; // проверка для правильного разбиения константной части если обрамлении меняется(только снизу)
           end;    
           FlagBot = false;                                    
      else 
             if(Not StrBrk(PrevBotSymbol,"┌─┬┐") AND (Not StrBrk(BotSymbol,"┌┐")) )
                 retval = true;                                                   
             end;
      end;

      return retval;
     end;                                             
     /* Создание элемента глобального массива данных */
     Macro CreateScanData()
          /* Выделим, если есть, строку стандартных модификаторов */
          Pos2 = Index(TempLexem, ":");
          if( Pos2 )
              TempStrModif = SubStr(TempLexem, Pos2 + 1);
              ObjScanData  = CScanData(SubStr(TempLexem, 1, Pos2 - 1), TempStrModif);
          else
              TempStrModif = "l";           
              ObjScanData  = CScanData(TempLexem, TempStrModif);
          end;
          /* Занесем данные в массив */
          ArrScanData[ArrScanData.Size] = ObjScanData;
     end; /* CreateScanData */

     /* Подсчет количество групп шарпов (#) для одной строки. В случае неудачи возвращается False и выдается сообщение. 
        Внимание!!! В функции изменяются глобальный счетчик CurElem и глобальный временный массив данных TempArrScanData */
    /* Macro GetCountElemData(_Str:string)
          var TempLexem2:string = ""; /* Вспомогательная переменная для формирования лексем */
  
          TempLexem2 = _Str;
          Pos2       = Index(TempLexem2, "#");
          while( Pos2 )
              TempLexem2 = SubStr(TempLexem2, Pos2);
              Pos3 = 1;
              while( Pos3 == 1 )
                  TempLexem2 = SubStr(TempLexem2, Pos3 + 1);
                  Pos3       = Index(TempLexem2, "#");
              end;
              if( CurElem >= ArrScanData.Size )
                  MsgBox("Ошибка в строке для сканирования!\nСлишком мало данных!");
                  return False;
              end;
              TempArrScanData[TempArrScanData.Size] = ArrScanData[CurElem];             
              CurElem = CurElem + 1;
              Pos2 = Index(TempLexem2, "#");
          end;
          return True;
     end; /* GetCountElemData */*/

 
     /* Разделим печатаемый блок и данные для него */
     Pos1       = Index(StrInfo, "[");
     /* Отбросим у печатаемого блока незначащие пробелы и квадратные скобки */
     PrintBlock = " " + SubStr(Trim(StrInfo), Pos1 + 1);
     Pos1       = Index(PrintBlock, "]");     
     //PrintBlock = this.ChangeSpecialSymbol(SubStr(PrintBlock, 1, Pos1 - 1),true);
     PrintBlock = SubStr(PrintBlock, 1, Pos1 - 1); 
     /* Отбросим у данных для печати незначащие пробелы, круглые скобки и точку с запятой */
     DataBlock  = Trim(SubStr(StrInfo, Pos1 + 1));
     Pos1       = Index(DataBlock, "(");
     DataBlock  = SubStr(DataBlock, Pos1 + 1);
     DataBlock  = InvertStr(DataBlock);
     Pos1       = Index(DataBlock, ")");
     DataBlock  = SubStr(DataBlock, Pos1 + 1);
     DataBlock  = InvertStr(DataBlock);
     /* Отбросим символы перевода строки и разделим данные на лексемы */
     TempStr    = TrStrSubst(DataBlock, "\n", "");
     Pos1       = Index(TempStr, ",");

     while( Pos1 )
         TempLexem = Trim(SubStr(TempStr, 1, Pos1 - 1));
         CreateScanData();
         TempStr   = SubStr(TempStr, Pos1 + 1);
         Pos1      = Index(TempStr, ",");
     end;

     TempLexem = Trim(TempStr);
     if( TempLexem )
         CreateScanData();
     end; /*
      Считаем данные из переменных параметров, если они есть */
     i = 2;
     while( (GetParm(i, TempValue)) and (GetParm(i + 1, TempStrModif)) )
             
         ObjScanData = CScanData(TempValue, TempStrModif, FALSE);
         ArrScanData[ArrScanData.Size()] = ObjScanData;
         i = i + 2;
     end; 
     /* Разделим печатный блок на строки */
     TempStr    = PrintBlock;
     TempLexem  = "";
     Pos1       = Index(TempStr, "\n");
     while( Pos1 )
         TempLexem                     = SubStr(TempStr, 1, Pos1 - 1);
         ArrScanStr[ArrScanStr.Size()] = TempLexem;
         TempStr                       = SubStr(TempStr, Pos1 + 1);
         Pos1                          = Index(TempStr, "\n");
     end;

     if( TempStr )
         ArrScanStr[ArrScanStr.Size()] = TempStr;
     end;

 
     /*
      Если НЕ передан буфер для возвращения модифицированных данных, необходимых для построения
        заголовка рабочей таблицы отчета, содержащего переменные, то честно сканируем данные */
     if( Not FlagAutoScanMode )
         /* Найдем в строках табличные элементы и заменим их соответствующие параметры 
            расширенного форматирования */
         i  = 0;
         Sz = ArrScanStr.Size;
         while( i < Sz )
              PrevStr    = "";
              NextStr    = "";
              TempStr    = ArrScanStr[i];

              if(i)         prevStr = ArrScanStr[i-1];
              end;
              if(i != Sz-1) NextStr = ArrScanStr[i+1]  
              end; 
              Pos1       = 1;
              TempLexem  = "";
              FlagBegStr = True;//начало строки
              Curstate   = -1;
              FlagData   = false;
              LenStr     = 0;
              StrModif   = "";
              FormatStr  ="";
              FlagTop    = true;                                             
              FlagBot    = true;
              while(TmpSymbol or (FlagBegStr))

                   FlagBegStr = False;
                   PrevTopSymbol  =   SubStr(PrevStr , Pos1-1,1 );
                   PrevBotSymbol  =   SubStr(NextStr , Pos1-1,1 );
                   TopSymbol  = SubStr(PrevStr , Pos1,1 );
                   TmpSymbol  = SubStr(TempStr , Pos1,1 );
                   BotSymbol  = SubStr(NextStr , Pos1,1 );
                   NextSymbol = SubStr(TempStr , Pos1+1,1 );
                   PrevSymbol = SubStr(TempStr , Pos1-1,1 );
                   if(TmpSymbol)// если не конец
                       if(StrBrk(TmpSymbol, "│└┴┘├┼┤┌┬┐─")) // признак начала нового блока
                           if((CurState == S_CONST) OR (CurState == S_SHARP) ) // до этого была не псевдографика
                              
                              FormatStr = SetRight(TmpSymbol,FormatStr);                 // обрамим справа
                              
                              AddPrintCellA(TempLexem, strlen(TempLexem),0,FormatStr,StrModif,REP_ELEM_STR,-1,CurState,TmpSymbol);
                              CurState  = S_GRAPH;
                              TempLexem = TmpSymbol;
                           else  
                              
                              if(TmpSymbol != "─")//       вертикальное обрамление добавляем как отдельные символы
                                                  //   
                                  if(TempLexem)   //      // что - то уже было до этого
                                      AddPrintCellA(TempLexem, strlen(TempLexem),0,FormatStr,"",REP_ELEM_STR,-1,S_GRAPH);
                                      TempLexem = "";
                                  end;

                                  if(StrBrk(PrevSymbol,"│└┴┘├┼┤┌┬┐")) // обработка ││ ситуации 
                                      AddPrintCellA(TmpSymbol,1,0,FormatStr,"",REP_ELEM_STR,true,S_GRAPH);// один символ выведем на печать(потом он удалится останется ячейка ширинной 1)                                      
                                  else
                                      AddPrintCellA(TmpSymbol,1,0,FormatStr,"",REP_ELEM_STR,-1,S_GRAPH);
                                  end;
                              else
                                  TempLexem = TempLexem + TmpSymbol;
                              end;  
                              CurState  = S_GRAPH;
                           end;
                       elif(StrBrk(TmpSymbol, "#"))// шарпы

                           if((CurState == S_GRAPH) OR (CurState == S_CONST) )
                                 
                              AddPrintCellA(TempLexem, strlen(TempLexem), 0 ,FormatStr,StrModif  ,REP_ELEM_STR,-1,CurState );
                              TempLexem = "";
                              LenStr = 0;
                              FormatStr = SetLeft(PrevSymbol,FormatStr);
                           end;

                              TempLexem = TempLexem + TmpSymbol;
                              CurState  = S_SHARP;
                              CheckTopBot();

                       else  // константы
                           if((CurState   == S_GRAPH) OR (CurState == S_SHARP) )// выводим то что было раньше 
                              AddPrintCellA(TempLexem, strlen(TempLexem), 0 ,FormatStr,StrModif,REP_ELEM_STR,-1,CurState ); 
                              CurState  = S_CONST;
                              TempLexem = "";
                              StrModif  = "";
                              FormatStr = ""; 
                               
                                 if(StrBrk(Substr(TempStr,Pos1-1,1),"│┤"))
                                    FormatStr = FormatStr + "l"; 
                                 end;

                           end;

                           if(Not TempLexem) // только зашли в константную часть
                               FormatStr = SetLeft(PrevSymbol,FormatStr);
                               CurState  = S_CONST;
                           end;
                           if( CheckTopBot() ) // если мы в константной части изменили обрамление
                                FlagTop = PrevFlagTop;
                                FlagBot = PrevFlagBot;     
                                if(TempLexem)
                                   AddPrintCellA(TempLexem, strlen(TempLexem), 0 ,"",StrModif,REP_ELEM_STR,-1,CurState );
                                   TempLexem ="";
                                   FormatStr ="";
                                end;
                                FlagTop = true;
                                FlagBot = true;
                                CheckTopBot();
                           end; 
                           TempLexem = TempLexem + TmpSymbol;
                       end;
                   else // достигли, конца надо вывести то, что осталось
                      if(TempLexem)
                          AddPrintCellA(TempLexem, strlen(TempLexem), 0 , FormatStr,StrModif ,REP_ELEM_STR,-1, CurState);
                      end;
                      if(FlagData) // ели были добавлены данные надо завершить строку
                          LenStr = 0;
                          AddStr();
                      else
                         this.AddEmptyStr(); 
                      end;
                            
                   end;
                   Pos1 = Pos1+1;
             end;
           i = i + 1;
      end;  
     /* Если передан буфер для возвращения модифицированных данных, то просто сформируем в нем 
     заголовок рабочей таблицы отчета, совершив необходимые подстановки для переменных */
     else i = 0;
          while(i < ArrScanStr.Size())
               TempStr      = ArrScanStr[i];
               TempLexem    = "";
               LenTempLexem = 0;
               Pos1         = Index(TempStr, "#");
               while(Pos1)
                      if(CurElem >= ArrScanData.Size)
                           MsgBox("Ошибка в строке для сканирования!\nСлишком мало данных!");
                           return False;
                      end;
                    TempLexem    = TempLexem + SubStr(TempStr, 1, Pos1 - 1);
                    LenTempLexem = LenTempLexem + Strlen(SubStr(TempStr, 1, Pos1 - 1));
                    TempStr      = SubStr(TempStr, Pos1 + 1);
                    CountSimbol  = 1;
                    /* Подсчитываем число символов # и вставляем вместо них нужные данные */
                    Pos1 = Index(TempStr, "#");
                    while(Pos1 == 1)
                         CountSimbol = CountSimbol + 1;
                         TempStr     = SubStr(TempStr, Pos1 + 1);
                         Pos1        = Index(TempStr, "#");
                    end;
                    if(CountSimbol == 1)
                         LenStr = StrLen(ArrScanData[CurElem].ScanData);
                    else LenStr = CountSimbol;
                    end;
                    TempLexem    = TempLexem + TR_ExecExp("String(" + String(ArrScanData[CurElem].ScanData) + ":" + String(LenStr) + ":" + String(ArrScanData[CurElem].StrModif) + ")");
                    LenTempLexem = LenTempLexem + LenStr;
                    CurElem      = CurElem + 1;
               end;
               if(Trim(TempLexem + TempStr))
                    TempLexem3 = TempLexem3 + TempLexem + TempStr + "\n";
               end;
               i = i + 1;
          end;
          SetParm(1, SubStr(TempLexem3, 1, StrLen(TempLexem3) - 1));
     end;     
     return True; 
  
  End; /* AutoScan */


  /* (Public) Пользовательский метод для подсчета ширины колонок таблицы отчета */
  Macro CalcColWidth( l_HeaderStr:string, FlagPrint:bool )
     var Str:string  = ""; /* Строка-линейка для выставления ширин колонок */
     var Pos:integer = 0;  /* Переменная для определения номера позиции искомых символов */
     var i  :integer = 0;  /* Счетчик циклов */
     var ArrColWidthTable:tarray = GetCurSheet.GetArrColWidthTable();

     /* Если строка для выставления ширины колонок не задана, то используем нижнюю строку заголовка таблицы */
     if( Not l_HeaderStr )
         Str = GetCurSheet.SheetStrHeader;
         //DAI Если заголовок заканчивается переводом строки, то отрезаем его, иначе в качестве нижней 
         //окажется пустая строка и колонки определять будет не по чему
         if (SubStr(Str, StrLen(Str)) == "\n")
             Str = SubStr(Str, 1,StrLen(Str) - 1);
         end;
         while( (Pos=Index(Str, "\n")) )
             Str = SubStr(Str, Pos + 1);
         end;
     else
         Str = l_HeaderStr;
     end;

     // В шаблон занесем последнюю строку таблицы (только если заполняем данные)
     if( NOT FlagPrint )
         ArrTemplate.Set(this.CurSheet, TEMPLATE_DEFAULT, Str);
     end;

     /* Запоминаем ширины колонок в специальном массиве */ 
     ArrColWidthTable.Size = 0;
     Pos = 1;
     while( Pos )
         Pos = StrBrk(Str, ObjSeparator.MidLeft  +            
                           ObjSeparator.MidCenter+            
                           ObjSeparator.MidRight +
                           ObjSeparator.TopLeft  +
                           ObjSeparator.TopCenter+
                           ObjSeparator.TopRight  );//   "├┼┤┌┬┐");

         if( Pos > 1 )
            ArrColWidthTable[ArrColWidthTable.Size()] = Pos - 1;
            i = i + 1;
         end;
         Str = SubStr(Str, Pos + 1);
     end;
  End; /* CalcColWidth */

  /* (Private) Внутренний метод для проверки переданного диапазона и установки корректных значений границ дипазона */
  Macro CheckDiapason( _BegDiap:integer, _EndDiap:integer )
     var ArrPrintStr  :tarray  = GetCurSheet.GetArrPrintStr();
     var BegDiap      :integer = 0;                           /* Начало диапазона      */
     var EndDiap      :integer = ArrPrintStr.Size() - 1;      /* Конец диапазона       */
     var i            :integer = 0;                           /* Счетчик циклов        */
     var FlagEndSelect:bool    = False;                       /* Флаг окончания поиска */

     /* Проверим корректность переданного диапазона */
     if( ValType(_BegDiap) )
         if( (_BegDiap >= BegDiap)and(_BegDiap <= EndDiap) )
             BegDiap = _BegDiap;
         end;
         if( ValType(_EndDiap) )
             if( (_EndDiap >= BegDiap)and(_EndDiap <= EndDiap) )
                 EndDiap = _EndDiap;
             end;
         end;
     else
         /* Диапазон по умолчанию это первая таблица отчета, а в случае ее отсутствия - весь отчет */
         while( (i <= EndDiap) and (Not FlagEndSelect) )
             if( ValCmpArray(this.GetValueArrPrint(i, 0).FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                 BegDiap       = i;
                 FlagEndSelect = True;
             end;
             i = i + 1;
         end;
         if( FlagEndSelect )
             FlagEndSelect = False;
             while( (i <= EndDiap) and (Not FlagEndSelect) )
                 if( ValCmpArray(this.GetValueArrPrint(i, 0).FlagStr, ArrConstTabl) == ELEM_NO_FOUND )
                     EndDiap       = i - 1;
                     FlagEndSelect = True;
                 end;
                 i = i + 1;
             end;
         end;
     end;

     /* Установим корректные значения диапазона */
     SetParm(1, BegDiap);
     SetParm(2, EndDiap);
  End; /* CheckDiapason */

  /**** (Private) Замена/восстановление спец. смиволов в(из) промежуточные(ых) */
  /*                                    Flag=TRUE  - замена                    */
  /*                                    Flag=FALSE - восстановление            */
  macro ChangeSpecialSymbol( Value:string, Flag:bool ) : string
        var RetValue:string = Value;

        if( Flag ) // Замена
            if( Index(RetValue, "\\") )   RetValue = TrStrSubst(RetValue, "\\", "");  end;
            if( Index(RetValue, "\"") )   RetValue = TrStrSubst(RetValue, "\"", "");  end;
        else       // Восстановление
            if( Index(RetValue, "" ) )   RetValue = TrStrSubst(RetValue, "", "\\");  end;
            if( Index(RetValue, "" ) )   RetValue = TrStrSubst(RetValue, "", "\"");  end;
        end;

        return RetValue;
  end; /* ChangeSpecialSymbol */

  /* (Public) Пользовательский метод удаления всех сформированных массивов ячеек (строк) */
  Macro ClearAllStr( _FlagHeader:bool )
     if( Not _FlagHeader )
         GetCurSheet.GetArrPrintStr.Size = 0;
         GetCurSheet.ClearData();
         NeedTypeSep = REP_NO_SEP;
         AutoInc     = 0;      
     end;
  End; /* ClearAllStr */

  /* (Private) Внутренний метод преобразования переданного заголовка таблицы к заголовку с требуемыми разделителями
     и подсчет высоты таблицы */
  private macro ConvertHeaderStr( l_HeaderStr:string )

     var i      :integer = 0;  /* Счетчик циклов */
     var SepChar:string  = ""; /* Обрабатываемый символ-разделитель */
     var Pos    :integer = 0;  /* Позиция найденного символа-разделителя */
     var TempStr:string  = ""; /* Вспомогательная переменная для работы со строками */

     if( l_HeaderStr )
         /* Преобразование заголовка */ 
         GetCurSheet().SheetStrHeader = l_HeaderStr;

         // Конвертим только в случае отличия от стандарта
         if( SEP_DEFAULT != ObjSeparator.StrSeparator )
             while( i < 11 )
                 SepChar = SubStr(SEP_DEFAULT, i + 1, 1);
                 if( ObjSeparator(i) != SepChar )
                     while( (Pos = Index(GetCurSheet().SheetStrHeader, SepChar)) )
                         StrSet(GetCurSheet().SheetStrHeader, Pos, ObjSeparator(i));
                     end;
                 end;
                 i = i + 1;
             end;
         end;

         /* Подсчет высоты заголовка */
         GetCurSheet().CountStrHeader = 1;
         TempStr             = GetCurSheet().SheetStrHeader;
         while( (Pos = Index(TempStr, "\n")) )
             GetCurSheet().CountStrHeader = GetCurSheet().CountStrHeader + 1;
             TempStr = SubStr(TempStr, Pos + 1);
         end;
     end;

  end; /* ConvertHeaderStr */

  /* (Public) Пользовательский метод для модификации заголовка таблицы отчета, содержащего переменные */
  Macro FillHeader(_Str:string/*,...*/):bool
     var RetStr  :string = "";   /* Модифицированный заголовок таблицы */
     var RetValue:bool   = True; /* Возвращаемый результат сканирования заголовка таблицы */

     FlagAutoScanMode = True;
     RetValue = this.AutoScan(_Str);
     FlagAutoScanMode = False;
     /* Если сканирование прошло удачно, заменим переданный заголовок на полученный после сканирования */
     if( RetValue )
         SetParm(1, _Str);
     end;
     return RetValue;
  End; /* FillHeader */

  /* (Private) Внутренний метод для доступа к ячейкам информационного массива */
  macro GetValueArrPrint( Row:integer, Col:integer ) : variant
        return GetCurSheet.GetArrPrintStr(Row).Value(Col);
  end;


  /* (Public) Пользовательский метод инициализации класса */
  Macro Init( l_HeaderStr:string, l_SepStr:string, l_CountStrOnPage:integer, l_CurStr:integer )

     var LastNameFile:string = "";
     var HTMLFileName:string = "";
     this.WorkDir = this.GetWorkDirName();

     if( ValType(l_CurStr        ) )  this.CurStr    = l_CurStr        ;   end;
     if( ValType(l_CountStrOnPage) )  CountStrOnPage = l_CountStrOnPage;   end;
     if( CountStrOnPage < this.CurStr )
         MsgBox("Заданный при инициализации номер текущей строки \"" + String(this.CurStr) + "\" больше размера страницы \"" + String(CountStrOnPage) + "\"!");
         Exit(1);
     end;

     BegSepStr = l_SepStr;
     if( ValType(l_SepStr) )
         ObjSeparator.Init(l_SepStr);
     end;

     //!!! Добавим первую закладку, ведь не может быть отчет без закладок
     lsSheet = ClsSheet();
     lsSheet.AddNewSheet(HTML_StSheetName, l_HeaderStr);
     this.CurSheet = 0;

     if( l_HeaderStr )
         ConvertHeaderStr(l_HeaderStr); // Конвертирование строки заголовка таблицы на основе переданных разделителей ObjSeparator
         this.CalcColWidth(NULL, FALSE);// Расчет ширин колонок по таблице
     end;

     /* Сформируем имя папки, в которой будем сохранять временные файлы */
     if( NOT DirName_TMP ) // Для того, чтобы при переинициализации не создавать новых папок
         DirName_TMP = this.WorkDir;
         this.ExlusiveFileName = GetExlusiveFileName();
         this.ExlusiveFileName = this.ExlusiveFileName + string("_", __NumObject) + ".htm";
         if( DirName_TMP )  HTMLFileName = DirName_TMP +  "\\" + this.ExlusiveFileName;
         else               HTMLFileName = this.ExlusiveFileName;
         end;

         /* Создадим папку для закладок, если она еще не создана */
         DirName_TMP     = SubFileExt(HTMLFileName) + ".files";
         MakeDir( DirName_TMP );
     end;
  End; /* Init */

  /* (Private) Внутренний метод нормализации значения количества строк под разделители */
  Macro NormFlagEndTabl( FlagEndTabl:integer ) : integer
     var RetValue:integer = 0; /* Возвращаемое значение */

     if  ( FlagEndTabl == REP_NO_SEP  )
           RetValue = 0;
     elif( FlagEndTabl == REP_BEG_SEP )
           RetValue = GetCurSheet().CountStrHeader;
     else  if( (FlagEndTabl == REP_MID_SEP) and (Not FlagShowMidSeparator) ) RetValue = 0;
           else                                                              RetValue = 1;
           end;
     end;
     return RetValue;
  
  End; /* NormFlagEndTabl */

  /* (Private) Внутренний метод печати заголовка таблицы отчета */
  /*  NumStr - номер текущей строки из массива ArrPrintStr      */
  Macro PrintHeader( NumStr:integer, Sheet:object )
     /* Получаем последнюю строчку заголовка таблицы */
     var TempH       :string  = "";                       // Заголовок таблицы без нижнего разделителя
     var TempStr     :string  = Sheet.SheetStrHeader;     // Временная переменная
     var Pos         :integer = Index(TempStr, "\n");     // Позиция
     var TempStr2    :string  = Sheet.SheetStrHeader;     // Временная переменная
     var LowSeparator:string  = "";                       // Строка нижнего разделителя
     var PrevArrParamPrintStr:tarray = Sheet.GetPrevArrParamPrintStr();

     /* Печать заголовка таблицы без нижнего разделителя */
     while( Pos )
          TempH   = TempH + SubStr(TempStr, 1, Pos-1);

          TempStr = SubStr(TempStr, Pos + 1);
          Pos     = Index(TempStr, "\n");
          if( Pos )
              TempH   = TempH + "\n";
          end;
          LowSeparator = TempStr;
     end;

     // Печатаем полный заголовок
     if( Sheet.FlagPrintFullHeader OR                                              // Если выставлен флажок "Всегда полный заголовок"
         ((NOT Sheet.FlagPrintFullHeader) AND (NOT Sheet.FlagPrintFirstHeader)) )  // Если выставлен флажок "Печать сокращенного заголовка", но это первый раз

         Println(TempH);

     else // Печать сокращенного заголовка

         TempStr = InvertStr(TempH); // Инвертируем строку
         if( (Pos = Index(TempStr, "\n")) != 0)
             TempH = SubStr(TempStr, 1, Pos);
         else
            MsgBox("Ошибка <PrintHeader>!|Шапка таблицы не содержит сокращенного заголовка!");
            Exit(1);
         end;
         TempH = SubStr(InvertStr(TempH), 2); // Инвертируем строку

         // Посчитаем верхушку
         TempStr  = ObjSeparator.TopLeft; // "┌"; /* Верхний левый угол */
         TempStr2 = SubStr(TempH, 2, StrLen(TempH)-1);
         Pos = Index(TempStr2, ObjSeparator.VertLine);
         while( Pos )
            TempStr2 = SubStr(TempStr2, Pos+1);

            TempStr = TempStr + MkStr(ObjSeparator.HorizLine, Pos-1);
            if( TempStr2 )  TempStr = TempStr + ObjSeparator.TopCenter; //  "┬"; /* Разделитель столбцов на верхней линии */   
            else            TempStr = TempStr + ObjSeparator.TopRight ; //  "┐"; /* Верхний правый угол */
            end;

            Pos = Index(TempStr2, ObjSeparator.VertLine);
         end;
         Println(TempStr); // 
         Println(TempH  );

         Sheet.CountStrHeader = 3; // У сокращенного заголовка высота всегда 3
     end;

     // Если заголовок не напечатали, по причине его отсутствия, то разделитель будет REP_BEG_SEP
     if( Sheet.SheetStrHeader )  NeedTypeSep = REP_MID_SEP;
     else                        NeedTypeSep = REP_BEG_SEP;
     end;

     /* Заполняем массив как бы "предыдущей" распечатанной строки, на основании */
     /* строки нижнего разделителя заголовка таблицы                            */
     if( Sheet.GetArrColWidthTable().Size )
         TempStr = LowSeparator;
         Pos = 1;
         PrevArrParamPrintStr.Size = 0;
         while( Pos )
             Pos = StrBrk(TempStr,  ObjSeparator.MidLeft  +
                                    ObjSeparator.MidCenter+
                                    ObjSeparator.MidRight ); // "├┼┤");
             if( Pos > 1 )
                 PrevArrParamPrintStr[PrevArrParamPrintStr.Size] = CParamPrintCell(" ", Pos - 1);
             end;
             TempStr = SubStr(TempStr, Pos + 1);
         end;
     end;

     /* Печатаем строку "правильного" разделителя */
     if( Sheet.GetArrPrintStr.Size AND Sheet.SheetStrHeader )
         this.PrintSep(REP_MID_SEP, Sheet.GetArrPrintStr(NumStr));
     end;

     /* Увеличиваем счетчик распечатанных строк */
     this.CurStr = this.CurStr + Sheet.CountStrHeader;

     // Отпечатали заголовок хотя бы один раз
     Sheet.FlagPrintFirstHeader = TRUE;
  End; /* PrintHeader */

  /* (Private) Пользовательский метод для формирования закладки Sheet отчета */     
  private Macro PrintRep_Sheet( Sheet:object ) // Печатаемая закладка

     var ArrPrintStr :tarray  = Sheet.GetArrPrintStr(); // Массив с данными текущей закладки
     var CurPrintStr :tarray  = NULL;                   // Текущая печатаемая строка
     var NextPrintStr:tarray  = NULL;                   // Следующая печатаемая строка
     var i           :integer = 0;                      // Счетчик циклов
     var FlagEndTabl :integer = 0;                      // Тип разделителя строк
     var Stat        :bool    = True;                   // Статус выполнения
     var FileExt     :string  = "";                     // Расширение файла

     Sheet.FlagPrintFirstHeader = FALSE;

     // Если задано имя текстового отчета, то в него и выводим
     if( FileNameDocumentTxt )

         // Если у имени файла нет расширение, то возьмем номер коннекта
         if( NOT Index(FileNameDocumentTxt, ".") )

             SplitFile(SetOutPut(this.WorkDir + "\\" + TMP_FILES, TRUE), NULL, FileExt);

             // Если пользователь сам задал имя файла, то его и возьмем, но номер коннекта все равно допишем в хвост
             if( FileNameDocumentTxt )
                 FileNameDocumentTxt = FileNameDocumentTxt + "." + SubStr(FileExt, 2);
             end;
         end;
         SetOutput( this.WorkDir + "\\" + FileNameDocumentTxt,true );
     end;

     this.CurStr = 0; // Текущая строка

     if( FlagShowIndicator )
         InitProgress( ArrPrintStr.Size, StatusIndicatorRep, TitulIndicatorRep);
     end;

     /* Вывод строк */
     while( (Stat) and (i < ArrPrintStr.Size) )
         CurPrintStr = ArrPrintStr[i];

         /* Если текущая строка первая */ 
         if( Not i )
             /* Если текущая строка является ячейкой */
             if( CurPrintStr[0].FlagStr != REP_ELEM_STR )
                 NeedCountStrHeader = Sheet.CountStrHeader;
             end;

             if( ValCmpArray(CurPrintStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                 NeedTypeSep = REP_BEG_SEP;
             end;
         end;
         
         if( i < (ArrPrintStr.Size - 1) ) // Если текущая строка не последняя
             NextPrintStr = ArrPrintStr[i + 1];
             /* Если текущая строка является ячейкой */
             if( CurPrintStr[0].FlagStr != REP_ELEM_STR )
                 if( NextPrintStr[0].FlagStr != REP_ELEM_STR ) FlagEndTabl = REP_MID_SEP ; // Если следующая строка является ячейкой
                 else                                          FlagEndTabl = REP_LAST_SEP; // Если следующая строка является строкой
                 end;
             /* Если текущая строка является строкой */
             else            
                 if( NextPrintStr[0].FlagStr != REP_ELEM_STR ) FlagEndTabl = REP_BEG_SEP; // Если следующая строка является ячейкой
                 else                                          FlagEndTabl = REP_NO_SEP ; // Если следующая строка является строкой
                 end;
             end;   
             Stat = this.PrintStr(CurPrintStr, FlagEndTabl, i); 
         
         else               // Если текущая строка последняя
             if( CurPrintStr[0].FlagStr != REP_ELEM_STR )   // Если текущая строка является ячейкой
                 FlagEndTabl = REP_LAST_SEP;
                 Stat = this.PrintStr(CurPrintStr, FlagEndTabl, i); 
                 this.PrintSep(REP_LAST_SEP, CurPrintStr, TRUE);
             else                                           // Если текущая строка является строкой
                 FlagEndTabl = REP_NO_SEP;
                 Stat = this.PrintStr(CurPrintStr, FlagEndTabl, i); 
             end;
         end;
         i = i + 1;
         if( FlagShowIndicator )
             UseProgress(i);
         end;
     end;
     NeedTypeSep = REP_NO_SEP;
     if( FlagShowIndicator )
         RemProgress();
     end;

     // Восстановим выходной поток, если Мы его изменили
     if( FileNameDocumentTxt )
         SetOutput( Null, True );
     end;
   
  End; /* PrintRep_Sheet */


  /**** (Private) Печать текстового варианта отчета во временный файл */
  private macro PrintRep_Sheet_Tmp( Sheet:CSheetProp,
                                    FlagEndReport:bool ) // Флаг печати последнего листа в отчете

        var LastNameFile:string = SetOutPut(DirName_TMP+"\\"+Sheet.GetFileNameTXT(), TRUE); // Сменим поток вывода на временный файл

        // Выводим данные в отчет
        PrintRep_Sheet( Sheet );
        if( NOT FlagEndReport )
        //    println(""); //15.05.2014 I-00486709-2, I-00486938-2 DPN 
        end;

        SetOutput( Null, True );
  end;


  /* (Public) Пользовательский метод для формирования отчета в текстовом виде */     
  macro PrintRep()
     var i            :integer = 0;
     var PathName     :string  = "";
     var StrCommand   :string  = "";
     var COMSPEC               = GetEnv( "COMSPEC" ); // спец. переменная для испольтзования функции COPY
     var LastNameFile :string  = "";
     var SaveCurSheet :integer = CurSheet;
     var SaveFlagShowIndicator:bool = FlagShowIndicator;
     var FlagSheet    :bool    = FALSE; // Флаг многозакладочности
     var SizeIndicator:integer = 0;

     // если взведен флаг большого отчета, то выведем хвост отчета, т.к. остальное уже вывели ранее при создании новых закладок
     if( FlagModeBigReport )
         // Выведем данные по последней закладке
         PrintRep_Sheet_Tmp( lsSheet.Get(lsSheet.Size-1), TRUE/*последний лист*/ );

         i = 0;
         while( i < lsSheet.Size() )
            if( i == 0 ) StrCommand =                    DirName_TMP+"\\"+lsSheet.Get(i).GetFileNameTXT();
            else         StrCommand = StrCommand + "+" + DirName_TMP+"\\"+lsSheet.Get(i).GetFileNameTXT();
            end;
            i = i + 1;
         end;


         // Переопределим поток, т.к если мы попробуем копировать в текущий, то он будет занят
         LastNameFile = SetOutPut(this.WorkDir + "\\" + TMP_FILES, TRUE); 

         StrCommand = StrCommand+" "+LastNameFile;

         run(COMSPEC, " /c copy /b " + StrCommand);

         SetOutput( Null, True );
         DelFile( this.WorkDir + "\\" + TMP_FILES ); // Удалим временный файл
     else
         if( lsSheet.Size > 1 ) 
             FlagSheet = FALSE;
             SizeIndicator = lsSheet.Size;
         else
             FlagSheet = TRUE ;
             SizeIndicator = lsSheet.Get(0).GetArrPrintStr().Size;
         end;

         if( NOT FlagSheet )
             InitProgress( SizeIndicator, StatusIndicatorRep, TitulIndicatorRep);
         end;

         // Печатаем все листы отчета последовательно
         i = 0;
         while( i < lsSheet.Size )
            SetCurSheet( i );

            FlagShowIndicator = FlagSheet;

            PrintRep_Sheet( lsSheet.Get(i) );

            if( i < lsSheet.Size - 1)// новый лист если закладка непоследняя   
                println("");
            end;
            FlagShowIndicator = SaveFlagShowIndicator;

            i = i + 1;
            if( NOT FlagSheet )
                UseProgress(i);
            end;
         end;
         SetCurSheet( CurSheet );

         if( NOT FlagSheet )
             RemProgress();
         end;
     end;
     return TRUE;
  end;

  /* (Public) Пользовательский метод для формирования нескольких копий отчета */
  Macro PrintRepCopy( NumCopy:integer )
        var i:integer = 0;

        /* Если число копий не передали установим 1 */
        if( NOT ValType(NumCopy) ) NumCopy = 1; end;

        while( i < NumCopy )

           if( i ) println(""); end;

           this.PrintRep();
           i = i + 1;
        end;
  End;

  /* (Private) Внутренний метод печати строки разделителей */
  Macro PrintSep( _NeedTypeSep:integer, ArrParamPrintStr:tarray,
                  FlagEndReport:bool ) // Флаг печати обрамления последней строки в отчете

     var PrevArrParamPrintStr:tarray = GetCurSheet.GetPrevArrParamPrintStr();
     var Arr       :tarray   = NULL;
     var Size      :integer  = 0;
     var i         :integer  = 0;  /* Счетчик циклов для ячеек предыдущей строки */
     var j         :integer  = 0;  /* Счетчик циклов для ячеек текущей строки */
     var TempStr   :string   = ""; /* Вспомогательная переменная для формирования строки разделителей */
     var UpSepPos  :integer  = 0;  /* Текущее положение на печати засечки в верхнюю сторону */
     var DownSepPos:integer  = 0;  /* Текущее положение на печати засечки в нижнюю сторону */
     var CurSepPos :integer  = 0;  /* Текущее положение последней напечатанной засечки */
     var SzPrev    :integer  = PrevArrParamPrintStr.Size(); /* Размер массива ячеек предыдущей строки */
     var SzCur     :integer  = ArrParamPrintStr.Size();     /* Размер массива ячеек текущей строки */
     var FlagPrintBorder:bool= FALSE;  /* Флаг печати обрамления ячейки    */
     var FlagPrintSymbol:bool= FALSE;  /* Флаг обрамления с нужной стороны */

     var FlagLeft :bool = TRUE, FlagTop:bool = TRUE;
     var FlagRight:bool = TRUE, FlagBot:bool = TRUE;
     var Tmp:integer = 0;//вспомогательная переменнная 
     var Whole:integer = 0;
     macro Check(_FlagLeft:@bool, _FlagTop:@bool, _FlagRight:@bool, _FlagBot:@bool)       //┌─┬─┐
                                                                                          //│1│2│
           var _FlagPrintBorder:bool = FALSE;  /* Флаг печати обрамления ячейки    */     //├─┼─┤
           var _FlagPrintSymbol:bool = FALSE;  /* Флаг обрамления с нужной стороны */     //│3│4│
                                                                                          //└─┴─┘
           _FlagLeft = _FlagRight = _FlagBot = _FlagTop = FALSE;

           // Границы смотрим с одной стороны для скорости, если смотреть с двух сторон - долго :(((
           // Граница между Ячейками 1 и 3
           if( (j < ArrParamPrintStr.Size) AND (j >=0 ) )
               this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "T", @FlagPrintBorder, @FlagPrintSymbol);
               _FlagLeft = ((FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE));
           end;

           // Граница между Ячейками 2 и 4
           if( j < (SzCur - 1) )
               this.CheckExtendBorder(ArrParamPrintStr[j+1].GetExtendedLexems(), "T", @FlagPrintBorder, @FlagPrintSymbol);
               _FlagRight = ((FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE));
           elif( j == (SzCur - 1) )
               this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "T", @FlagPrintBorder, @FlagPrintSymbol);
               _FlagRight = ((FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE));
           end;

           // Граница между Ячейками 1 и 2
           if( i < PrevArrParamPrintStr.Size )
               this.CheckExtendBorder(PrevArrParamPrintStr[i].GetExtendedLexems(), "R", @FlagPrintBorder, @FlagPrintSymbol);
               _FlagTop = ((FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE));
           end; 

           // Граница между Ячейками 3 и 4
           if( j < (SzCur - 1) )
               this.CheckExtendBorder(ArrParamPrintStr[j+1].GetExtendedLexems(), "L", @FlagPrintBorder, @FlagPrintSymbol);
               _FlagBot = ((FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE));
           elif( j == (SzCur - 1) )
               this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "R", @FlagPrintBorder, @FlagPrintSymbol);
               _FlagBot = ((FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE));
           end;
     end;
     macro CheckElem(_PrintCell:object,Lex:string):bool
            var _FlagPrintBorder:bool,
                _FlagPrintSymbol:bool;
             
            this.CheckExtendBorder(_PrintCell.GetExtendedLexems(), Lex, @_FlagPrintBorder, @_FlagPrintSymbol);

            if((_FlagPrintBorder == FALSE) OR (_FlagPrintSymbol == TRUE))
               return True;
            else
               return False;
            end;


     end;

     if( _NeedTypeSep == REP_MID_SEP ) // разделитель для середины таблицы

         // Задан шаблон, поэтому печатаем его
         if( ArrParamPrintStr[0].NumberTemplate != -1 )
             println( ArrTemplate.Get(this.CurSheet, ArrParamPrintStr[0].NumberTemplate) );
             return;
         end;

         j = -1;
         Check(@FlagLeft, @FlagTop, @FlagRight, @FlagBot);
         if  ( FlagRight AND FlagBot ) TempStr = ObjSeparator.MidLeft  ; // MidLeft  :string = "├"; /* Разделитель строк на левой стороне таблицы */
         elif( FlagBot               ) TempStr = ObjSeparator.VertLine ; // VertLine :string = "│"; /* Вертикальная линия */
         elif( FlagTop               ) TempStr = ObjSeparator.BotLeft  ; // BotLeft  :string = "└"; /* Нижний левый угол */
         elif( FlagRight AND FlagLeft) TempStr = ObjSeparator.HorizLine; // HorizLine:string = "─"
         else                          TempStr = " ";
         end;
         j = 0;

         UpSepPos = PrevArrParamPrintStr[i].StrModif_Whole;
         DownSepPos = ArrParamPrintStr[j].StrModif_Whole;

         while( (UpSepPos < END_OF_LINE) or (DownSepPos < END_OF_LINE) )

            if( UpSepPos == DownSepPos )
                // Печатаем разделитель ячейки, только если нет расширенного форматирования с отменой
                this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "T", @FlagPrintBorder, @FlagPrintSymbol);
                if( (FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE) )
                     TempStr = TempStr + MkStr(ObjSeparator.HorizLine, UpSepPos - CurSepPos);          
                else
                     TempStr = TempStr + MkStr(" "                   , UpSepPos - CurSepPos);          
                end;

                Check(@FlagLeft, @FlagTop, @FlagRight, @FlagBot);
                if( (i == (SzPrev - 1)) and (j == (SzCur - 1)) ) // Правая граница
// println( " Правая граница i : ", i, "   j : ", j, "FlagLeft : ", FlagLeft,  "   FlagTop : ", FlagTop, "   FlagRight : ", FlagRight, "   FlagBot : ", FlagBot );
                    if  ( FlagLeft AND FlagBot AND FlagTop )  TempStr = TempStr + ObjSeparator.MidRight; // MidRight :string = "┤"; /* Разделитель строк на правой стороне таблицы */
                    elif( FlagLeft AND FlagTop             )  TempStr = TempStr + ObjSeparator.BotRight; // BotRight :string = "┘"; /* Нижний правый угол */
                    elif( FlagLeft AND FlagBot             )  TempStr = TempStr + ObjSeparator.TopRight; // TopRight :string = "┐"; /* Верхний правый угол */
                    elif( FlagLeft AND FlagRight           )  TempStr = TempStr + ObjSeparator.HorizLine; // HorizLine:string = "─"
                    elif( (NOT FlagLeft) AND (NOT FlagTop) AND (NOT FlagRight) AND (NOT FlagBot) ) 
                                                              TempStr = TempStr + " ";
                    else                                      TempStr = TempStr + ObjSeparator.VertLine;
                    end;
                else // середина

// println( " Середина       i : ", i, "   j : ", j, "FlagLeft : ", FlagLeft,  "   FlagTop : ", FlagTop, "   FlagRight : ", FlagRight, "   FlagBot : ", FlagBot );
                    if  ( FlagLeft AND FlagTop AND FlagRight AND FlagBot ) TempStr = TempStr + ObjSeparator.MidCenter; // MidCenter:string = "┼"
                    elif( FlagLeft AND FlagTop               AND FlagBot ) TempStr = TempStr + ObjSeparator.MidRight;  // MidRight :string = "┤"
                    elif(              FlagTop AND FlagRight AND FlagBot ) TempStr = TempStr + ObjSeparator.MidLeft;   // MidLeft  :string = "├"
                    elif( FlagLeft             AND FlagRight AND FlagBot ) TempStr = TempStr + ObjSeparator.TopCenter; // TopCenter:string = "┬"
                    elif( FlagLeft AND FlagTop AND FlagRight             ) TempStr = TempStr + ObjSeparator.BotCenter; // BotCenter:string = "┴"
                    elif(              FlagTop               AND FlagBot ) TempStr = TempStr + ObjSeparator.VertLine;  // VertLine :string = "│"
                    elif( FlagLeft AND             FlagRight             ) TempStr = TempStr + ObjSeparator.HorizLine; // HorizLine:string = "─"
                    else                                                   TempStr = TempStr + " ";
                    end;
                end;

                CurSepPos  = UpSepPos + 1;
                i = i + 1;
                j = j + 1;
                if( i < SzPrev ) UpSepPos = UpSepPos + PrevArrParamPrintStr[i].StrModif_Whole + 1;
                else             UpSepPos = END_OF_LINE;
                end;
                if( j < SzCur )  DownSepPos = DownSepPos + ArrParamPrintStr[j].StrModif_Whole + 1;
                else             DownSepPos = END_OF_LINE;
                end;
            else 
                if( UpSepPos < DownSepPos )
                    // Печатаем разделитель ячейки, только если нет расширенного форматирования с отменой
                    this.CheckExtendBorder(PrevArrParamPrintStr[i].GetExtendedLexems(), "B", @FlagPrintBorder, @FlagPrintSymbol);
                    if( (FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE) )
                         TempStr = TempStr + MkStr(ObjSeparator.HorizLine, UpSepPos - CurSepPos);          
                    else
                         TempStr = TempStr + MkStr(" "                   , UpSepPos - CurSepPos);          
                    end;

                    Check(@FlagLeft, @FlagTop, @FlagRight, @FlagBot);
                    if( (i == (SzPrev - 1)) and (DownSepPos == END_OF_LINE) ) // Правая граница
                       TempStr = TempStr + ObjSeparator.BotRight;                         // BotRight :string = "┘"
                    else                                                      // Середина 
                       if  ( FlagLeft AND FlagTop AND FlagRight ) TempStr = TempStr + ObjSeparator.BotCenter; // BotCenter:string = "┴"
                       elif( FlagLeft AND FlagTop               ) TempStr = TempStr + ObjSeparator.BotRight;  // BotRight :string = "┘"
                       elif(              FlagTop AND FlagRight ) TempStr = TempStr + ObjSeparator.TopLeft;   // TopLeft  :string = "┌"

                       elif( FlagLeft             AND FlagRight ) TempStr = TempStr + ObjSeparator.TopCenter; // TopCenter:string = "┬"
                       elif( FlagLeft AND FlagTop AND FlagRight ) TempStr = TempStr + ObjSeparator.HorizLine; // HorizLine:string = "─"
                       elif(              FlagTop               ) TempStr = TempStr + ObjSeparator.BotCenter; // BotCenter:string = "┴"
                       else                                       TempStr = TempStr + " ";
                       end;
                    end;

                    CurSepPos  = UpSepPos + 1;
                    i = i + 1;
                    if(i < SzPrev)
                         UpSepPos = UpSepPos + PrevArrParamPrintStr[i].StrModif_Whole + 1;
                    else UpSepPos = END_OF_LINE;
                    end;
                else 
                    this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "T", @FlagPrintBorder, @FlagPrintSymbol);
                    if( (FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE) )
                         TempStr = TempStr + MkStr(ObjSeparator.HorizLine, DownSepPos - CurSepPos);
                    else
                         TempStr = TempStr + MkStr(" "                   , DownSepPos - CurSepPos);
                    end;

                    Check(@FlagLeft, @FlagTop, @FlagRight, @FlagBot);
                    if( (j == (SzCur - 1))and(UpSepPos == END_OF_LINE) )
                       TempStr = TempStr + ObjSeparator.TopRight ;
                    else 
                    
                       if  ( FlagLeft AND FlagBot AND FlagRight ) TempStr = TempStr + ObjSeparator.TopCenter; // TopCenter:string = "┬"
                       elif( FlagLeft AND             FlagRight ) TempStr = TempStr + ObjSeparator.HorizLine; // HorizLine:string = "─"
                       elif( FlagLeft                           ) TempStr = TempStr + ObjSeparator.HorizLine; // HorizLine:string = "─"
                       elif(                          FlagRight ) TempStr = TempStr + ObjSeparator.HorizLine; // HorizLine:string = "─"
                       elif( FlagLeft AND FlagBot               ) TempStr = TempStr + ObjSeparator.TopRight ; // TopRight :string = "┐"
                       elif(              FlagBot AND FlagRight ) TempStr = TempStr + ObjSeparator.TopLeft  ; // TopLeft  :string = "┌"
                       end;
                    end;
                    CurSepPos  = DownSepPos + 1;
                    j = j + 1;
                    if(j < SzCur)
                         DownSepPos = DownSepPos + ArrParamPrintStr[j].StrModif_Whole + 1;
                    else DownSepPos = END_OF_LINE;
                    end;
                end;
            end;
         end;

     elif( _NeedTypeSep == REP_BEG_SEP ) // разделитель для верхушки таблицы
         if(CheckElem(ArrParamPrintStr[j],"T"))  
             TempStr = ObjSeparator.TopLeft; // "┌"; /* Верхний левый угол */
         else
             TempStr = " "
         end; 
         while( j < SzCur )

            if(CheckElem(ArrParamPrintStr[j],"T") ) 
                if( j != 0 )
                    Check(@FlagLeft, @FlagTop, @FlagRight, @FlagBot);
                        if(CheckElem(ArrParamPrintStr[j-1],"T")  AND FlagBot )
                                         TempStr = TempStr + ObjSeparator.TopCenter;
                        elif( FlagBot )  TempStr = TempStr + ObjSeparator.TopLeft; //  "┬"; /* Разделитель столбцов на верхней линии */   
                    else                 TempStr = TempStr + ObjSeparator.HorizLine; //  HorizLine:string = "─"
                    end;
                end;
                TempStr = TempStr + MkStr(ObjSeparator.HorizLine, ArrParamPrintStr[j].StrModif_Whole);
                // сититуация ┌──┐ ┌───┐   для элементов таблиц
                if(j < SzCur-1) 
                     if( CheckElem(ArrParamPrintStr[j],"R"))
                         if(Not CheckElem(ArrParamPrintStr[j+1], "T")) 
                             TempStr = TempStr + ObjSeparator.TopRight; 
                         end; 
                     end;
                end;                             
                if( j == (SzCur - 1) ) TempStr = TempStr + ObjSeparator.TopRight; //"┐"; /* Верхний правый угол */
                end;
            else                       TempStr = TempStr + MkStr(" ", ArrParamPrintStr[j].StrModif_Whole);
            end;
            j = j + 1;

         end;

     else // Разделитель для окончания таблицы
         if( FlagEndReport ) // Это последня строка в отчете, значит обрамление нужно отсчитывать от текущей строки
             Arr  = ArrParamPrintStr;
             Size = SzCur;
         else                // Это не последняя, значит обрамление нужно отсчитывать от предпоследней
             Arr  = PrevArrParamPrintStr;
             Size = SzPrev;
         end;
         if(CheckElem(Arr[0],"B"))
             if(CheckElem(Arr[0],"L")  )  TempStr = ObjSeparator.BotLeft;   // BotLeft  :string = "└"; /* Нижний левый угол */
             else                         TempStr = ObjSeparator.HorizLine; // HorizLine:string = "─"
             end;
         else
             if(CheckElem(Arr[0],"L")  )  TempStr = ObjSeparator.VertLine;   // │
             else                         TempStr = " "                  ;   // 
             end;    
         end;
         i = -1;
         while( i < Size-1 )
            if( i != -1 )
                 // Граница между Ячейками 1 и 2
                FlagTop = TRUE;
                FlagLeft = FlagRight = FlagBot = FlagTop = TRUE;
                Check(@FlagLeft, @FlagTop, @FlagRight, @FlagBot);
                if( i < Arr.Size )
                   if(CheckElem(Arr[i], "R"));
 
                        if(i < Arr.Size-1)
                            if(Not CheckElem(Arr[i+1], "B"))
                                   TempStr = TempStr + ObjSeparator.BotRight;
                            else  
                                   if(CheckElem(Arr[i], "B")) 
                                       TempStr = TempStr + ObjSeparator.BotCenter;
                                   else
                                       TempStr = TempStr + ObjSeparator.BotLeft; 
                                   end;       
                            end;
                        else       TempStr = TempStr + ObjSeparator.BotCenter;        
                        end;
                    else           TempStr = TempStr + ObjSeparator.HorizLine;             
                    end;
                else
                   if(this.CheckElem(Arr[i],"B"))
                       TempStr = TempStr + ObjSeparator.HorizLine; //  HorizLine:string = "─"
                   end;          
                end;
            end;

            
            if(CheckElem(Arr[i+1], "B"))
                TempStr = TempStr + MkStr(ObjSeparator.HorizLine, Arr[i+1].StrModif_Whole);
            else
                Whole = Arr[i+1].StrModif_Whole;
                if(i + 1 == 0)
                    if( (NOT CheckElem(Arr[0],"L")) AND CheckElem(ArrParamPrintStr[0],"L"))
                        Whole = Whole + 1;
                    end;
                end;
                TempStr = TempStr + MkStr(" ",Whole);
            end;

            if( i == (Size - 2) )
                if( i < 0 )  Tmp = 0;
                else         Tmp = Arr.Size-1; 
                end;
                if(CheckElem(Arr[Tmp], "B"))
                    if(CheckElem(Arr[Tmp], "R"))
                       TempStr = TempStr + ObjSeparator.BotRight        
                    end; 
                else TempStr = TempStr + " " ;
                end;
            end;
            i = i + 1;
         end;
     end;
     if((_NeedTypeSep == REP_BEG_SEP ) OR (REP_LAST_SEP == REP_LAST_SEP))
         if(Trim(TempStr) != "" )
             Println(TempStr); 
         end;
     else
     Println(TempStr);
     end; 
   
  End; /* PrintSep */

  /* (Private) Внутренний метод для вывода строки */
  Macro PrintStr( ArrParamPrintStr:tarray, FlagEndTabl:integer, NumStr:integer ) : bool

     var ArrPrintStr         :tarray  = GetCurSheet.GetArrPrintStr();          // Массив с данными текущей закладки
     var PrevArrParamPrintStr:tarray  = GetCurSheet.GetPrevArrParamPrintStr(); // Массив с данными текущей закладки
     var Sz                  :integer = ArrParamPrintStr.Size(); /* Размер массива ячеек строки */
     var i                   :integer = 0;            /* Счетчик циклов */
     var j                   :integer = 0;            /* Счетчик циклов */
     var TempArr             :tarray  = tarray;       /* Вспомогательный массив для обработки и преобразования значений строчного типа */
     var ArrSplit            :tarray  = tarray;       /* Вспомогательный массив для корректной разбивки строк */
     var CountStr            :integer = 0;            /* Количество выводимых строк */ 
     var CountStrSep         :integer = 0;            /* Количество выводимых строк для сепаратора */ 
     var TempStr             :string  = "";           /* Вспомогательная переменная для использования в функции TR_ExecExp */
     var TempValue           :variant;                /* Вспомогательная переменная для использования в функции TR_ExecExp */ 
     var TempDay             :integer = 0;            /* Вспомогательная переменная для разложения даты (времени) */  
     var TempMon             :integer = 0;            /* Вспомогательная переменная для разложения даты (времени) */ 
     var TempYear            :integer = 0;            /* Вспомогательная переменная для разложения даты (времени) */ 
     var TempCount           :integer = 0;            /* Вспомогательная переменная для подсчета количества строк */ 
     var FlagEndPage         :bool    = False;        /* Признак достижения конца страницы */
     var FlagNewPage         :bool    = False;        /* Признак принудительного разрыва страницы */
     var Pos                 :integer = 0;            /* Позиция искомого символа */
     var TmpValType          :integer = V_UNDEF;
     var LenStr              :integer = 0;            /* Длина строки */
     var FlagPrintBorder     :bool    = FALSE;        /* Флаг печати обрамления ячейки                              */
     var FlagPrintSymbol     :bool    = FALSE;        /* Флаг обрамления с нужной стороны                           */

     /* Проверим не является ли очередная строка признаком разрыва страницы */
     if( ValType(ArrParamPrintStr[0].StrValue) == V_STRING )
         if( (ArrParamPrintStr[0].StrValue == KEY_STRBREAK)   )
              FlagNewPage = True;
              FlagEndPage = True;
         end;
     end;
     
     /* Подсчитываем количество строк между разделителями */
     if( Not FlagNewPage )
          while( i < Sz )
              TempCount = 1;
              if( ArrParamPrintStr[i].StrModif_Whole > 0 )
                  if( ValType(ArrParamPrintStr[i].StrValue) == V_STRING )
                      /* Разбиваем строку в соотвествии с заданным форматом и синтаксисом предложения и
                         заменяем символы "кавычка", если таковые присутствуют в строке, на символы "",
                         а символы "обратный слеш", если таковые присутствуют в строке, на символы "" */

                     // Если в строчке ячейки есть символ '\n', то простой вариант не прокатит... Жаль
                     // #61161 Ошибка при выполнении
                     debugbreak;
                     if( (NOT Index(ArrParamPrintStr[i].StrValue, "\n" )) AND
                         (StrLen(ArrParamPrintStr[i].StrValue) <= ArrParamPrintStr[i].StrModif_Whole) )
                         TempArr[i] = ArrParamPrintStr[i].StrValue;
                         //22.09.2014 R-455621-2 DPN 
                         if (i == 1)
                             var str =  TempArr[i];
                             str = strsubst(str,strfor(13)," ");
                             str = strsubst(str,strfor(10)," ");
                             TempArr[i] = str;
                         end;
                     else
                         TempStr = this.ChangeSpecialSymbol(ArrParamPrintStr[i].StrValue, TRUE);
                         debugbreak;
                         TempStr= strsubst(TempStr,strfor(13)," ");
                         TempStr = strsubst(TempStr,strfor(10)," ");
                         TempStr= strsubst(TempStr,strfor(9)," ");
                         TempStr = strsubst(TempStr,strfor(11)," ");
                         if(FlagHighQualityRep)
                              ArrSplit = TR_StrSplitExt(TempStr, ArrParamPrintStr[i].StrModif_Whole);
                         else ArrSplit = StrSplit2(TempStr, ArrParamPrintStr[i].StrModif_Whole);
                         end;
                         TempArr[i] = "";
                         j          = 0;                    
                         while(j < ArrSplit.Size())
                              TempStr = "String(\""
                                      + ArrSplit[j] + "\":"
                                      + string(ArrParamPrintStr[i].StrModif_Whole);
                              if( ArrParamPrintStr[i].StandartLexem )
                                  TempStr = TempStr + ":" + ArrParamPrintStr[i].StandartLexem;
                              end;
                              TempStr = TempStr + ")";

                              TempStr = TR_ExecExp(TempStr);

                              /* Заменяем символы "" на символы "кавычка", а символы "" на символы "обратный амперсант" */
                              TempArr[i] = TempArr[i] + this.ChangeSpecialSymbol(TempStr, FALSE);

                              j = j + 1;
                         end;
                      end;
                      LenStr = StrLen(TempArr[i]);
                      TempCount = LenStr / ArrParamPrintStr[i].StrModif_Whole;
                      if( Mod(LenStr, ArrParamPrintStr[i].StrModif_Whole) )
                          TempCount = TempCount + 1;
                      end;
                  end;
              end;
              if( TempCount > CountStr )
                  CountStr = TempCount;
              end;
              i = i + 1;
          end;
            
           /* Проверка корректности размеров страницы и перевод страницы */
          if( (CountStr + GetCurSheet().CountStrHeader + 1) > CountStrOnPage)
               MsgBox("Заданный размер страницы \"" + String(CountStrOnPage) + "\" не достаточен для корректного вывода отчета!");
               return False;
          else 
                if( ( ArrParamPrintStr[0].FlagStr == REP_ELEM_STR )
                    AND( FlagEndTabl == REP_BEG_SEP) )    CountStrSep = 0;
                else
                    CountStrSep = this.NormFlagEndTabl(FlagEndTabl);                
                end;
               
               if((this.CurStr + CountStr + CountStrSep + NeedCountStrHeader) > CountStrOnPage) 
                    FlagEndPage = True ;
               else FlagEndPage = False;
               end;
          end;
     end;

     /* Вывод разделителей, с учетом конца страницы */
     if( FlagEndPage )
         if( (NeedTypeSep != REP_NO_SEP) AND 
             (ArrPrintStr.Value(NumStr - 1).Value(0).FlagStr != REP_ELEM_STR) )  // Проверим тип предыдущей строки
             this.PrintSep(REP_LAST_SEP, ArrParamPrintStr);
         end;
     else 
         if( NeedTypeSep == REP_MID_SEP )
             if( (FlagShowMidSeparator)or(ArrParamPrintStr[0].FlagStr == REP_ELEM_SHOWSEP) )
                  this.PrintSep(REP_MID_SEP, ArrParamPrintStr);
             end;
         elif( NeedTypeSep == REP_LAST_SEP )
             this.PrintSep(REP_LAST_SEP, ArrParamPrintStr);
         end;
     end;

     /* Вывод заголовка таблицы при достижении конца страницы или разрыве таблицы */
     if( FlagEndPage )
         this.CurStr = 0;
         Println("");
         if( (FlagEndTabl == REP_MID_SEP) or (FlagEndTabl == REP_LAST_SEP) )
             this.PrintHeader(NumStr, GetCurSheet);
         end;
     else
         if( NeedCountStrHeader )
             this.PrintHeader(NumStr, GetCurSheet);
         end;
     end;

     if( NeedTypeSep == REP_BEG_SEP  )
         this.PrintSep(REP_BEG_SEP , ArrParamPrintStr);
     end;

     /* Вывод строки */
     if( Not FlagNewPage )
         i = 0;
         while( i < CountStr )
             j = 0;
             while( j < Sz )
                TmpValType = ValType(ArrParamPrintStr[j].StrValue);

                if  ( TmpValType == V_STRING )
                     /* Формируем строку для печати */
                     TempValue = SubStr(TempArr[j], ArrParamPrintStr[j].StrModif_Whole * i + 1, ArrParamPrintStr[j].StrModif_Whole);

                     /* Заменяем символы "обратный слеш", если таковые присутствуют в строке, на символы "двойной обратный слеш",
                        а символы "кавычка", если таковые присутствуют в строке, на символы "слеш-кавычка" */
                     if( StrBrk(TempValue, "\\\"") )
                         TempStr = TrStrSubst(TempValue, "\\", "\\\\");
                         TempValue = "\"" +  TrStrSubst(TempStr, "\"", "\\" + "\"")  + "\"";
                     else
                         TempStr = TempValue;
                         TempValue = "\"" +  TempStr+ "\"";
                     end;

                elif( TmpValType == V_DATE )
                     if( Not i )
                          DateSplit(ArrParamPrintStr[j].StrValue, TempDay, TempMon, TempYear);
                          TempValue = String("Date(", TempDay, ",", TempMon, ",", TempYear, ")" );
                     else TempValue = "\"\"";
                     end;

                elif( TmpValType == V_TIME )
                     if( Not i )
                          TimeSplit(ArrParamPrintStr[j].StrValue, TempDay, TempMon, TempYear);
                          TempValue = String("Time(", TempDay, ",", TempMon, ",", TempYear, ")");
                     else TempValue = "\"\"";
                     end;

                elif( ((TmpValType == V_DOUBLE) or (TmpValType == V_DOUBLEL)   ) and
                      (ArrParamPrintStr[j].StrModif_Fract > 2)                      )
                     if( Not i )
                          TempValue = String(ArrParamPrintStr[j].StrValue:*:*, ArrParamPrintStr[j].StrModif_Whole, ArrParamPrintStr[j].StrModif_Fract);
                          if( Index(TempValue, "*") )
                            TempValue = "\"" + TempValue + "\"";
                          end;
                     else TempValue = "\"\"";
                     end;
                elif( (TmpValType == V_MONEY ) or (TmpValType == V_MONEYL ) )
                    if( Not i )
                          if( ArrParamPrintStr[j].StrValue > 0 )
                              TempValue = "$"+Trim(String(ArrParamPrintStr[j].StrValue:*:*, 
                                                          ArrParamPrintStr[j].StrModif_Whole,
                                                          ArrParamPrintStr[j].StrModif_Fract));
                          else
                              TempValue = "-$"+Trim(String(Abs(ArrParamPrintStr[j].StrValue):*:*, 
                                                          ArrParamPrintStr[j].StrModif_Whole,
                                                          ArrParamPrintStr[j].StrModif_Fract));
                          end;
                          if( Index(TempValue, "*") )
                              TempValue = "\"" + Trim(TempValue) + "\"";
                          end;
                     else TempValue = "\"\"";
                     end;
                else
                    if( Not i )
                          TempValue = String(ArrParamPrintStr[j].StrValue);
                     else TempValue = "\"\"";
                     end;
                end;
                
                if( ArrParamPrintStr[0].FlagStr != REP_ELEM_STR )
                    // Проверим обрамление
                    this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "L", @FlagPrintBorder, @FlagPrintSymbol);

                    // Печатаем разделитель ячейки, только если нет расширенного форматирования с отменой
                    if( (FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE) )
                         Print(ObjSeparator.VertLine);
                    else Print(" ");
                    end;
                else 
                    // Проверим обрамление
                   // MsgBox(ArrParamPrintStr[j].GetExtendedLexems());                                                                                                                                               
                /*    if((Index(ArrParamPrintStr[j].StrValue,"│") != 1) AND (Index(ArrParamPrintStr[j].StrValue,"├") != 1)AND (Index(ArrParamPrintStr[j].StrValue,"└") != 1) AND (Index(ArrParamPrintStr[j].StrValue,"┤") ==0 ) )

                    this.CheckExtendBorder(ArrParamPrintStr[j].GetExtendedLexems(), "L", @FlagPrintBorder, @FlagPrintSymbol);

                    // Печатаем разделитель ячейки, только если нет расширенного форматирования с отменой
                    if(  (FlagPrintSymbol==TRUE) )                                                        
                              Print(ObjSeparator.VertLine);
                            //  MsgBox(ArrParamPrintStr[j].StrValue);
                            // Print("("+ ArrParamPrintStr[j].StrValue +")");
                         
                          
                    else Print("");
                    end;
                    end; */    
                    
                    Print("");
                end;

                TempStr = "String("
                        + TempValue + ":"
                        + string(ArrParamPrintStr[j].StrModif_Whole) + ":"
                        + string(ArrParamPrintStr[j].StrModif_Fract);
                if( ArrParamPrintStr[j].StandartLexem )
                    TempStr = TempStr + ":" + ArrParamPrintStr[j].StandartLexem;
                end;
                TempStr = TempStr + ")";
                Print(TR_ExecExp(TempStr));
                j = j + 1;
            end;

            // Если элемент табличный
            if( ArrParamPrintStr[0].FlagStr != REP_ELEM_STR )

                // Проверим обрамление
                if( j-1 == Sz-1 ) 
                   this.CheckExtendBorder(ArrParamPrintStr[j-1].GetExtendedLexems(), "R", @FlagPrintBorder, @FlagPrintSymbol);
                end;

                // Печатаем разделитель ячейки, только если нет расширенного форматирования с отменой
                if( (FlagPrintBorder==FALSE) OR (FlagPrintSymbol==TRUE) )
                    Println(ObjSeparator.VertLine);
                else
                    Println(" ");
                end;
            else 
                if( j-1 == Sz-1 ) 
                   this.CheckExtendBorder(ArrParamPrintStr[j-1].GetExtendedLexems(), "R", @FlagPrintBorder, @FlagPrintSymbol);
                end; 
           
                // Печатаем разделитель ячейки, только если нет расширенного форматирования с отменой
                if(FlagPrintSymbol == TRUE)
                  Println(ObjSeparator.VertLine);    //!!! ТЕСТ
                  
                else
                    Println("");
                end;                          
            end;
            i = i + 1;
         end;
         this.CurStr = this.CurStr + CountStr;
     end;

     /* Определение типа необходимых для вывода разделителей */
     NeedTypeSep = REP_NO_SEP;
//   PrevArrParamPrintStr = ArrParamPrintStr;
//   Теперь простое копирование не проходит
     i = 0;
     PrevArrParamPrintStr.Size = 0;
     while( i < ArrParamPrintStr.Size )
        PrevArrParamPrintStr[i] = ArrParamPrintStr[i];
        i = i + 1;
     end;

     if  ( FlagEndTabl == REP_MID_SEP )
           NeedTypeSep = REP_MID_SEP;
           this.CurStr = this.CurStr + 1;
     elif( FlagEndTabl == REP_LAST_SEP )
           NeedTypeSep = REP_LAST_SEP;
           this.CurStr = this.CurStr + 1;
     end;

     /* Изменение количества строк необходимых для вывода заголовка при его возникновении не в начале страницы */
     NeedCountStrHeader = 0;
     if( FlagEndTabl == REP_BEG_SEP )
         NeedCountStrHeader = GetCurSheet().CountStrHeader;
         NeedTypeSep = REP_BEG_SEP;
     end;
     return True;
   
  End; /* PrintStr */  

/*┌─────────────────────────────────────────────────────────────────────────────────┐*/
/*│Утилитные методы                                                                 │*/
/*└─────────────────────────────────────────────────────────────────────────────────┘*/
  /* (Public) Пользовательский метод добавления нескольких пустых информационных ячеек в конец текущей строки с автоподбором ширины */
  Macro AddEmptyCell( _FlagStr:integer, _Count:integer )
     var i      :integer = 0;             /* Счетчик циклов */
     var FlagStr:integer = REP_ELEM_TABL; /* Тип ячейки */
     var Count  :integer = 1;             /* Число пустых ячеек */

     if( ValType(_FlagStr) )   FlagStr = _FlagStr;    end;
     if( ValType(_Count  ) )   Count   = _Count  ;    end;
     while( i < Count )
          this.AddPrintCell(" ", 0, 0, "c", FlagStr);
          i = i + 1;
     end;
  End; /* AddEmptyCell */
  /* (Public) Пользовательский метод получения ширины таблицы отчета с учетом межстолбцовых разделителей.
              В большинстве случаев это ширина самого отчета */
  Macro GetHeaderWidth():integer
        if(Not Strlen(Trim(GetCurSheet.SheetStrHeader)))
            return 0; 
        end;
        return SumAllElementArray(GetCurSheet.GetArrColWidthTable()) + 
               GetCurSheet.GetArrColWidthTable().Size - 1;
  End; /* GetHeaderWidth */

  /* (Public) Пользовательский метод добавления пустых строк в конец отчета */
  Macro AddEmptyStr( _Count:integer, _Len:integer )
     var i    :integer = 0; /* Счетчик циклов */
     var Count:integer = 1; /* Число пустых строк */
     var Len  :integer = GetHeaderWidth() + 1; /* Длина строки */
     if( ValType(_Count) )   Count = _Count;   end;
     if( ValType(_Len  ) )   Len   = _Len  ;   end;
     while(i  < Count )
          this.AddPrintCell(" ", Len, 0, "l", REP_ELEM_STR);
          this.AddStr();               
          i = i + 1;
     end;
  End; /* AddEmptyStr */

  /* (Public) Пользовательский метод добавления информационных ячеек таблицы в конец текущей строки с автоподбором ширины */
  Macro AddFormatCell( _StrValue, _StrModif_Advan:string, _FlagStr:integer )
        this.AddPrintCell(_StrValue, 0, 0, _StrModif_Advan, _FlagStr);
  End; /* AddFormatCell */

  /* (Public) Пользовательский метод дополнения текущего объекта данными (строками)
              из другого объекта этого-же типа. Параметры указывают из какого
              объекта и какой диапазон копировать.  */
  macro AddStrInObject( Obj:object, bIndex:integer, eIndex:integer )
        var i  :integer  = 0;
        var j  :integer  = 0;
        var Tmp:CParamPrintCell = NULL;
        var Obj_ArrPrintStr:tarray = Obj.GetCurSheet.GetArrPrintStr();
        var ArrPrintStr    :tarray = GetCurSheet.GetArrPrintStr();

        if( NOT ValType(bIndex) ) bIndex = 0;                    end;
        if( NOT ValType(eIndex) ) eIndex = Obj_ArrPrintStr.Size; end;

        j = bIndex;
        while( j < eIndex )

           i = 0;
           this.AddNewStr();

           while(i < Obj_ArrPrintStr[j].Size )
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i) = CParamPrintCell();
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).StrValue           = Obj_ArrPrintStr.Value(j).Value(i).StrValue      ;
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).StrModif_Whole     = Obj_ArrPrintStr.Value(j).Value(i).StrModif_Whole;
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).StrModif_Fract     = Obj_ArrPrintStr.Value(j).Value(i).StrModif_Fract;
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).StandartLexem      = Obj_ArrPrintStr.Value(j).Value(i).StandartLexem ;
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).AddExtendedLexemsLs( Obj_ArrPrintStr.Value(j).Value(i).CopyExtendedLexems() );
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).FlagStr            = Obj_ArrPrintStr.Value(j).Value(i).FlagStr       ;
              ArrPrintStr.Value(ArrPrintStr.Size-1).Value(i).FlagPrint          = Obj_ArrPrintStr.Value(j).Value(i).FlagPrint     ;
              // скопируем стили вывода иначе типы разедутся
              GetCurSheet.lsFormat_M =  Obj.GetCurSheet.lsFormat_M;
              GetCurSheet.lsFormat_D =  Obj.GetCurSheet.lsFormat_D;
              GetCurSheet.lsFormat_I =  Obj.GetCurSheet.lsFormat_I;
              GetCurSheet.lsFormat_S =  Obj.GetCurSheet.lsFormat_S;
              i = i + 1;
           end;
           j = j + 1;
        end;
  end;

  /* (PRIVATE) Метод проверки в строке рассширенного форматирования ArrExtendedLexems, */
  /* наличие обрамление (флаг FlagCheckBorder), а также наличие обрамление со          */
  /* стороны описанной переменной Symbol (LTRB) (флаг FlagCheckSymbol)                 */
  macro CheckExtendBorder( ArrExtendedLexems:tarray, Symbol:string, FlagCheckBorder:@bool, FlagCheckSymbol:@bool )
        var k  :integer = 0;      /* Счетчик циклов */
        var Arg:string  = "";     /* Строка аргументов расширенного параметра форматирования    */

        FlagCheckBorder = FlagCheckSymbol = FALSE;
        while( (k < ArrExtendedLexems.Size) AND (k != -1) )
             if( Index(ArrExtendedLexems[k], B_LEX) )
                 // Есть обрамление справа
                 if( (Arg = strUpr(GetArg(ArrExtendedLexems[k], B_LEX, LEX_END))) != "" )
                     if( Index(Arg, Symbol) )                  
                         FlagCheckSymbol = TRUE;
                     end;
                 end;
                 k = -1;
                 FlagCheckBorder = TRUE;
             else
                 k = k + 1;
             end;
        end;
  end;

  /* (Public) Пользовательский метод поиска значения в интервале уже существующих строк и столбцов. В случае успеха 
              возвращает True. В два последних параметра записывается строка и ячейка в строке, где было найдено значение.
              Поиск ведется с конца отчета */
  Macro FindCellValue(_FindStrValue,      _NumBegCol:integer, NumEndCol:integer, 
                      _NumBegStr:integer, _NumEndStr:integer, _NumStr  :integer, _NumCell:integer):bool

     var NumBegStr    :integer = 0;                           /* Номер начальной строки */
     var NumEndStr    :integer = GetCurSheet.GetArrPrintStr().Size() - 1; /* Номер конечной строки */
     var NumBegCol    :integer = 0;                           /* Номер начальной столбца */
     var i            :integer = 0;                           /* Счетчик циклов */
     var j            :integer = 0;                           /* Счетчик циклов */
     var ArrScanStr   :tarray  = NULL;                        /* Переменная для сканирования строк */
     var FindStrValue;                                        /* Искомое значение */
     var StandartLexem:string  = "";                          /* Строка со стандартными параметрами форматирования */

     if( (_NumBegStr > _NumEndStr) or (_NumBegCol > NumEndCol) )
         MsgBox("Некорректные параметры при вызове метода FindCellValue!");
         SetParm(6, -1);
         SetParm(7, -1);
         return False;
     end;          if(_NumBegStr > NumBegStr)  NumBegStr = _NumBegStr;  end;
     if(_NumEndStr < NumEndStr)  NumEndStr = _NumEndStr;  end;
     if(_NumBegCol > NumBegCol)  NumBegCol = _NumBegCol;  end;
     i = NumEndStr;

     FindStrValue = _FindStrValue;
     while( i >= NumBegStr )
         ArrScanStr = GetCurSheet.GetArrPrintStr(i);
         j          = ArrScanStr.Size();
         if( (j - 1) > NumEndCol ) 
             j = NumEndCol;
         end; 
         while( j >= NumBegCol )
             if( j < ArrScanStr.Size )
                 if( (ValType(ArrScanStr[j].StrValue) == ValType(FindStrValue)) )
                     if( ArrScanStr[j].StrValue == FindStrValue )
                         SetParm(6, i);
                         SetParm(7, j);
                         return True;
                     end;
                 end;
             end;
             j = j - 1;
         end;
         i = i - 1; 
     end;
     SetParm(6, -1);
     SetParm(7, -1);
     return False;
  End; /* FindCellValue */

  /* (Public) Пользовательский метод получения значения из уже существующей строки отчета */
  Macro GetCellValue(_NumStr:integer, _NumCell:integer, _StrValue, _FlagHeader:bool):integer
     var ArrPrintStr:tarray = GetCurSheet.GetArrPrintStr();
     if( Not _FlagHeader )
         if( ArrPrintStr.Size() > _NumStr )
             if( ArrPrintStr.Value(_NumStr).Size() > _NumCell )
                 SetParm(3, ArrPrintStr.Value(_NumStr).Value(_NumCell).StrValue);
             else return ERR_PRINT_CELL;
             end;
         else
             return ERR_PRINT_STR;
         end;
     else
         if( lsSheet.Get(CurSheet).GetArrHeaderStr().Size > _NumStr )
             if(lsSheet.Get(CurSheet).GetArrHeaderStr().Value(_NumStr).Size > _NumCell)
                  SetParm(3, lsSheet.Get(CurSheet).GetArrHeaderStr().Value(_NumStr).Value(_NumCell).StrValue);
             else return ERR_HEADER_CELL;
             end;
         else
             return ERR_HEADER_STR;
         end;
     end;
     return NO_ERR;
  End; /* GetCellValue */

  /* (Public) Пользовательский метод получения суммы по столбцу таблицы */
  Macro GetColSum( NumCol:integer ) : variant
     var ArrPrintStr:tarray = GetCurSheet.GetArrPrintStr();// Массив строк с данными текущей закладки
     var i         :integer = ArrPrintStr.Size() - 2;      /* Счетчик циклов */
     var ArrScanStr:tarray  = NULL;                        /* Переменная для сканирования уже введенных строк */
     var RetValue  :variant;                               /* Возвращаемое значение */

     /* Если строка не единственная */
     if( i >= 0 )
          ArrScanStr = ArrPrintStr[i];
          /* Если предыдущая строка является строкой таблицы */
          if( ValCmpArray(ArrScanStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
              /* Если передан корректный номер столбца */
              if( (NumCol >= 0) and (NumCol < ArrScanStr.Size) )
                   RetValue = ArrScanStr[NumCol].StrValue;
                   /* Ограничимся итогом по столбцу одной таблицы */ 
                   while( i > 0 )
                       i          = i - 1;
                       ArrScanStr = ArrPrintStr[i];
                       if( ValCmpArray(ArrScanStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND )
                            RetValue = RetValue + ArrScanStr[NumCol].StrValue;
                       else i = 0;
                       end;
                   end;
               else MsgBox("Задан некорректный номер столбца (" + String(NumCol) + ") для подсчета суммы!");
                    RetValue = "";
               end;
          end;
     end;
     return RetValue;
  End; /* GetColSum */

  /* (Public) Пользовательский метод получения ширины колонки таблицы отчета
              (отрицательный номер обозначает нумерацию с конца, например -1 последний) */
  Macro GetColWidthTable( _NumCol:integer ) : integer
     var NumCol:integer = 0; /* Номер колонки */

     if( ValType(_NumCol) )
          if( _NumCol < 0 )  NumCol = GetCurSheet.GetArrColWidthTable().Size + _NumCol;
          else               NumCol = _NumCol;
          end;
          if( (NumCol >= 0) and (NumCol < GetCurSheet.GetArrColWidthTable().Size) )
              return GetCurSheet.GetArrColWidthTable(NumCol);
          end;
     end;
     return 0;
  End; /* GetColWidthTable */

  /* (Public) Пользовательский метод получения количества колонок в таблице отчета */
  Macro GetCountColTable() : integer
        return GetCurSheet.GetArrColWidthTable().Size;
  End; /* GetCountColTable */


  /* (Public) Пользовательский метод получения номера последней строки отчета в момент ввода данных */
  Macro GetNumLastStr( _FlagHeader:bool ) : integer
        if( NOT _FlagHeader )   return GetCurSheet.GetArrPrintStr ().Size;
        else                    return GetCurSheet.GetArrHeaderStr().Size;
        end;
  End; /* GetNumLastStr */

  /* (Public) Пользовательский метод возвращающий ширину всех столбцов находящихся перед указанным с учетом
              межстолбцовых разделителей (отрицательный номер обозначает нумерацию с конца, например -1 перед последним) */
  Macro GetWidthBeforeCol( _NumCol:integer ) : integer
     var i    :integer = 0; /* Счетчик циклов */
     var Width:integer = 0; /* Возвращаемая ширина */

     if( _NumCol < 0 )
         _NumCol = GetCurSheet.GetArrColWidthTable().Size + _NumCol;
     end;
     while( i < _NumCol )
         Width = Width + this.GetColWidthTable(i) + 1;
         i = i + 1;
     end;
     return Width;
  End; /* GetWidthBeforeCol */

  /* (Public) Пользовательский метод определения наличия табличных строк отчета */
  Macro IsDataExist( _FlagNotShowMes:bool ) : bool
     var ArrPrintStr:tarray  = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки
     var i          :integer = ArrPrintStr.Size() - 1; /* Счетчик циклов */

     while(i >= 0)
          if(ValCmpArray(ArrPrintStr.Value(i).Value(0).FlagStr, ArrConstTabl) != ELEM_NO_FOUND)
               return True;
          end;
          i = i - 1;
     end;
     /* Если флаг запрещения показа сообщения задан и равен True, то не показываем сообщение */
     if(_FlagNotShowMes)
          return False;
     else return GetTrue(False, "Отчет не содержит данных. Вывести шапку отчета?");
     end;

  End; /* IsDataExist */

  /* (Public) Пользовательский метод изменения параметров форматирования ячейки в уже существующей строке отчета */
  Macro SetCellFormat(_NumStr:integer, _NumCell:integer, _StrModif_Advan:string):integer
     var ArrPrintStr:tarray = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки

     if( ArrPrintStr.Size() > _NumStr )
         if( ArrPrintStr.Value(_NumStr).Size() > _NumCell )
             ArrPrintStr.Value(_NumStr).Value(_NumCell).CatExtendedLexems( _StrModif_Advan );
             return NO_ERR;
         else
             return ERR_PRINT_CELL;
         end;
     else
         return ERR_PRINT_STR;
     end;

  End; /* SetCellFormat */

  /* (Public) Пользовательский метод изменения значения в уже существующей строке отчета */
  Macro SetCellValue(_NumStr:integer, _NumCell:integer, _NewStrValue, _FlagHeader:bool):integer
     var ArrPrintStr :tarray = GetCurSheet.GetArrPrintStr (); // Массив с данными текущей закладки
     var ArrHeaderStr:tarray = GetCurSheet.GetArrHeaderStr(); // Массив с данными заголовка

     if( Not _FlagHeader )
         if( ArrPrintStr.Size() > _NumStr )
             if( ArrPrintStr.Value(_NumStr).Size() > _NumCell )
                 ArrPrintStr.Value(_NumStr).Value(_NumCell).StrValue = _NewStrValue;
             else
                 return ERR_PRINT_CELL;
             end;
         else
             return ERR_PRINT_STR;
         end;
     else
         if( ArrHeaderStr().Size > _NumStr )
             if( ArrHeaderStr().Value(_NumStr).Size > _NumCell )
                 ArrHeaderStr().Value(_NumStr).Value(_NumCell).StrValue = _NewStrValue;
             else
                 return ERR_HEADER_CELL;
             end;
         else
             return ERR_HEADER_STR;
         end;
     end;
     return NO_ERR;

  End; /* SetCellValue */

  /* (Public) Пользовательский метод изменения ширины ячейки в уже существующей строке отчета */
  Macro SetCellWidth(_NumStr:integer, _NumCell:integer, _NewWidth:integer, _FlagHeader:bool):integer
     var ArrPrintStr :tarray = GetCurSheet.GetArrPrintStr (); // Массив с данными текущей закладки
     var ArrHeaderStr:tarray = GetCurSheet.GetArrHeaderStr(); // Массив с данными заголовка

     if( Not _FlagHeader )
         if( ArrPrintStr.Size() > _NumStr )
             if( ArrPrintStr.Value(_NumStr).Size() > _NumCell )
                 ArrPrintStr.Value(_NumStr).Value(_NumCell).StrModif_Whole = _NewWidth;
             else
                 return ERR_PRINT_CELL;
             end;
         else
             return ERR_PRINT_STR;
         end;
     else 
         if( ArrHeaderStr().Size > _NumStr )
             if( ArrHeaderStr().Value(_NumStr).Size > _NumCell )
                 ArrHeaderStr().Value(_NumStr).Value(_NumCell).StrModif_Whole = _NewWidth;
             else
                 return ERR_HEADER_CELL;
             end;
         else
             return ERR_HEADER_STR;
         end;
     end;
     return NO_ERR;

  End; /* SetCellWidth */

  /* (Public) Пользовательский метод изменения параметров форматирования уже существующих ячеек в заданном диапазоне указанного столбца */
  Macro SetColFormat(_NumCol:integer, _StrModif_Advan:string, _BegDiap:integer, _EndDiap:integer)
     var ArrPrintStr   :tarray  = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки
     var i             :integer = 0;   /* Счетчик циклов */
     var NumCol        :integer = 0;   /* Номер столбца, в котором будет производится изменение параметров форматирования */
     var StrModif_Advan:string  = "l"; /* Вспомогательный параметр для строки форматирования */
     var TmpObj        :CParamPrintCell = CParamPrintCell();

     if( ValType(_NumCol)         )          NumCol         = _NumCol        ;     end;
     if( ValType(_StrModif_Advan) )          StrModif_Advan = _StrModif_Advan;     end;

     /* Проверим переданный диапазон на корректность */
     this.CheckDiapason(_BegDiap, _EndDiap);

     TmpObj.CatExtendedLexems( StrModif_Advan );

     i = _BegDiap;
     while(i <= _EndDiap)
          ArrPrintStr.Value(i).Value(NumCol).StandartLexem       = TmpObj.StandartLexem;
          ArrPrintStr.Value(i).Value(NumCol).GetExtendedLexems() = TmpObj.CopyExtendedLexems();
          i = i + 1;
     end;
  End; /* SetColFormat */

  /* (Public) Пользовательский метод для установки флага печати:                    */
  /*          полной шапки таблицы Flag == TRUE или сокращенной шапки Flag == FALSE */
  Macro SetFlagPrintFullHeader( Flag:bool, NumSheet:integer )
        var i:integer = 0;
        if( ValType(NumSheet) )
            lsSheet.Get(NumSheet).FlagPrintFullHeader = Flag;
        else  // Если номер закладки не передали, то для всех
            while( i < lsSheet.Size)
                lsSheet.Get(i).FlagPrintFullHeader = Flag;
                i = i + 1;
            end;
        end;

  End; /* SetFlagDebug */

  /* (Public) Пользовательский метод для включения-выключения режима отладки */
  Macro SetFlagDebug( _FlagDebug:bool )
       if(Not ValType(_FlagDebug))
            ___FlagDebug___ = Not ___FlagDebug___;
       else ___FlagDebug___ = _FlagDebug;
       end;
  End; /* SetFlagDebug */

  /* (Public) Пользовательский метод установки флага формата печати строк с псевдографическими разделителями */
  Macro SetFlagModePrint( _FlagModePrint:integer )
        FlagModePrint = _FlagModePrint;
  End; /* SetFlagShowIndicator */

  /* (Public) Пользовательский метод установки флага показа встроенного индикатора */
  Macro SetFlagShowIndicator( _Flag:bool )
        FlagShowIndicator = _Flag;
  End; /* SetFlagShowIndicator */

  /* (Public) Пользовательский метод установки флага показа межстрочных разделителей */
  Macro SetFlagShowMidSeparator( _Flag:bool )
        FlagShowMidSeparator = _Flag;
  End; /* SetFlagShowMidSeparator */

  /* (Public) Пользовательский Метод для установки имени выходного файла для сформированного документа */
  macro SetFileNameWin( Name:string )
        FileNameDocumentWin = Name;
  end;

  /* (Public) Пользовательский Метод для установки имени выходного файла для сформированного документа */
  macro SetFileNameTxt( Name:string )
        FileNameDocumentTxt = Name;
  end;

  /* (Public) Пользовательский Метод для установки имени выходного файла для сформированного документа */
  macro SetFileName( Name:string )
        this.SetFileNameWin( Name );
        this.SetFileNameTxt( Name );
  end;

  /**** (Public) Пользовательский методы для установки качества (разрешения) формирования tiff-файла отчета (100, 200, 300) */
  macro SetTIFDPI( TIFDPI:integer )
        m_TIFDPI = TIFDPI;
  end;

  private macro CreateExcel()
         if( ObjExcel == NULL )
         /*откроем книгу и возьмём ширину колонки - эта ширина по умалчанию паказывает какой коэф-т 
         маштаба шрифта установлен */
             ObjExcel = CDAOMSExcel(NULL, GetRegim_LoadNewApplication); /* Объект класса CDAOMSExcel, для работы с Excel */  
                 ObjExcel.vrt_CreateApplicationExcel();
             if( ObjExcel.Application)
                 ObjExcel.Application.Workbooks.Add();
                 KoefScreenW = ObjExcel.Application.ActiveWorkbook.ActiveSheet.Columns(1).ColumnWidth;
                 ObjExcel.Application.ActiveWorkbook.Close();
             end;
         end;          
  end;


  /**** (Private) Печать html-го варианта отчета во временный файл */
  private macro PrintWinRep_Sheet( Sheet:CSheetProp ) : bool

        if(Not WinRepOutput)  return 0;
        end;  
        if( NOT ValType(Obj_HTML_Rep) )
            Obj_HTML_Rep = C_HTML_Report(0                    ,
                                         this.ExlusiveFileName,
                                         this.WorkDir         ,
                                         FlagModePrint        ,
                                         FlagShowIndicator,ExecuteStrExcel);
             CreateExcel();    
        end;

        return Obj_HTML_Rep.CreateSheet( Sheet,KoefScreenW,KoefScreenH );
  end;

/*┌─────────────────────────────────────────────────────────────────────────────────┐*/
/*│Методы для Windows-представления                                                 │*/
/*└─────────────────────────────────────────────────────────────────────────────────┘*/
  /* (Public) Пользовательский метод добавления признака перехода на новый лист в конец отчета */
  Macro AddNewSheetBreak(_NameNewSheet:string, _SheetStrHeader:string, 
                         _FlagShowGrid     :bool,  /* Флаг отображения сетки на листе             */
                         _FlagShowZeroValue:bool)  /* Флаг отображения нулевых значений на листе  */

     var Sheet      :object  = NULL;
     var SheetPrev  :object  = NULL;
     var ArrPrintStr:tarray  = NULL;
     var CurSheetTmp:integer = CurSheet;

     // Если выставлен флажок режима больших файлов, то перед созданием новой закладки сольем данные во временные файлы
     if( FlagModeBigReport )
         if( lsSheet.Size )
             Sheet = lsSheet.Get(lsSheet.Size-1);

             PrintRep_Sheet_Tmp( Sheet, FALSE ); // Вывод текстового отчета во временный файл
             PrintWinRep_Sheet ( Sheet        ); // Вывод html-ного  отчета во временный файл

             // Обнуляем используемые массивы
//             ArrGroupColIndex.Size = 0; // Массив номеров колонок для группировки
//             ArrSortField    .Size = 0; // Массив объектов содержащих поля сортировки и направление сортировки
             Sheet.ClearData();
         end;
     end;

     //!!! Добавим новый
     lsSheet.AddNewSheet(_NameNewSheet, _SheetStrHeader, _FlagShowGrid, _FlagShowZeroValue);

     CurSheet = lsSheet.Size()-1;

      /* Установим новые ширины столбцов для случая, когда заголовок таблицы (шкалы разбиения) отличается от предыдущего */
     if( _SheetStrHeader )
         ConvertHeaderStr( _SheetStrHeader );
         this.CalcColWidth(NULL, FALSE);
     else
         if( lsSheet.Size > 1 )
             Sheet     = lsSheet.Get(lsSheet.Size-1);
             SheetPrev = lsSheet.Get(lsSheet.Size-2);
             Sheet.CopyCalcData( SheetPrev );
         end;
     end;

  End; /* AddNewSheetBreak */

  /* (Public) Пользовательский метод добавления признака перехода на новый лист в конец отчета
              Синоним метода AddNewSheetBreak. */
  Macro AddSheet(_NameSheet:string, _SheetStrHeader:string, 
                 _FlagShowGrid     :bool,  /* Флаг отображения сетки на листе             */
                 _FlagShowZeroValue:bool)  /* Флаг отображения нулевых значений на листе  */

        AddNewSheetBreak(_NameSheet, _SheetStrHeader, _FlagShowGrid, _FlagShowZeroValue);
  end;

  /* (Public) Пользовательский метод расчета высоты СКОНВЕРТИРОВАННОГО заголовка таблицы отчета */     
  Macro CalcHeaderHeight() : integer
     var ArrParamPrintStr:tarray  = NULL;   /* Массив для ячеек текущей строки заголовка */
     var i               :integer = 0;      /* Счетчик циклов */
     var j               :integer = 0;      /* Счетчик циклов */
     var CountHeaderStr  :integer = 0;      /* Число строк заголовка */

     while( i < GetCurSheet.GetArrHeaderStr().Size )
         ArrParamPrintStr = GetCurSheet.GetArrHeaderStr(i);
         j = 0;
         while( j < ArrParamPrintStr.Size )
             /* Если хоть одна ячейка в псевдостроке имеет верхнее обрамление, значит это действительно новая строка */
             if( ArrParamPrintStr[j].Border_Up)
                 j              = ArrParamPrintStr.Size;
                 CountHeaderStr = CountHeaderStr + 1;
             else
                 j = j + 1;
             end;
         end;
         i = i + 1;
     end;
     return CountHeaderStr;
  End; /* CalcHeaderHeight */

  /* (Public) Пользовательский метод получения числа листов Excel в отчете */
  macro GetCountSheet():integer
        return lsSheet.Size();
  end; /* GetCountSheet */

  /* (Public) Пользовательский метод получения номера начальной строки из ArrPrintStr для листа Excel */
  Macro GetNumBegStrForSheet(_NumSheet:integer):integer
        return 0;
  End; /* GetNumBegStrForSheet */

  /* (Public) Метод для получения рабочего каталога */
  macro GetWorkDirName() : string
     var DirName:string = "", /* Строка с именем пути                         */
         StrErr :string = ""; /* Строка с ошибкой определения временной папки */

     GetRegistryValue( "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEXTDIR",
                       V_STRING, DirName, StrErr );

     /* Если в реестре нет ключа "TEXTDIR" или значение не задано, то поищем в bank.ini */
     if( NOT DirName )
         DirName = GetIniString( "TEXTDIR" );
     end;

     if( NOT DirName )
         DirName = GetEnv("TEMP");
         if( NOT DirName )
             DirName = GetEnv("TMP");
         end;
     else
         /* Если первый символ в DirName - это точка, то значит путь относительный, */
         /* тогда приклеем к нему CyrDir, иначе путь абсолютный                     */
         if( SubStr(DirName, 1, 1) == "." )
             DirName = GetCurDir(FALSE) + "\\" + DirName;
         end;
     end;

     return DirName;
  end;

  /* (Public) Пользовательский метод для формирования отчета в Windows представлении */     
  Macro PrintWinRep( _SheetName:string, _Idention:integer )
  
     if(Not WinRepOutput)  return 0;
     end;
     var i            :integer = 0;
     var SizeIndicator:integer = 0;
     var FlagSheet    :bool    = FALSE; // Флаг многозакладочности
     var SaveFlagShowIndicator:bool = FlagShowIndicator; // Обойдем свой собственный индикатор
    
     // Установим имя закладки (для поддержки старого "кода")
     if( _SheetName AND lsSheet.Size )
         lsSheet.SetSheetName(0, _SheetName);
     end;

     // если взведен флаг большого отчета, то выведем хвост отчета, т.к. остальное уже вывели ранее при создании новых закладок
     if( FlagModeBigReport )
         // Выведем данные по последней закладке
         PrintWinRep_Sheet( lsSheet.Get(lsSheet.Size-1) );
     else
         if( lsSheet.Size > 1 ) 
             FlagSheet = FALSE;
             SizeIndicator = lsSheet.Size;
         else
             FlagSheet = TRUE ;
             SizeIndicator = lsSheet.Get(0).GetArrPrintStr().Size;
         end;

         if( NOT FlagSheet )
             InitProgress( SizeIndicator, StatusIndicatorRep, TitulIndicatorRep);
         end;

         while( i < lsSheet.Size )
            FlagShowIndicator = FlagSheet;
               PrintWinRep_Sheet( lsSheet.Get(i) );
            FlagShowIndicator = SaveFlagShowIndicator;

            i = i + 1;
            if( NOT FlagSheet )
                UseProgress(i);
            end;
         end;

         if( NOT FlagSheet )
             RemProgress();
         end;
     end;

     Obj_HTML_Rep.CreateRepAllSheet( lsSheet ); // Создадим головной - объединяющий html-файл

     //Obj_HTML_Rep.CopyInstrument();    // Копируем инструмент на терминал
     Obj_HTML_Rep.CopyData()      ;    // Копируем данные на терминал

  End; /* PrintWinRep */

  /* (Public) Пользовательский метод для установки имени шрифта. 
              Если задан параметр NumSheet, то на закладке с номером (NumSheet),
              Если задан -1 то на текущей,
              иначе на всех                                                       */
  Macro SetDefaultFontName( FontName:string, NumSheet:integer )
       var i         :integer = 0;
       var l_NumSheet:integer = 0;
       if( ValType(NumSheet) )
           l_NumSheet = NumSheet;
           if( NumSheet == -1 )
               l_NumSheet = CurSheet;
           end;
           if( NumSheet < lsSheet.Size  )
               lsSheet.Get(l_NumSheet).FontName = FontName;
           end;
       else  // Если номер закладки не передали, то для всех
           while( i < lsSheet.Size)
               lsSheet.Get(i).FontName = FontName;
               i = i + 1;
           end;
       end;

  End; /* SetDefaultFontName */

  /* (Public) Пользовательский метод для установки размера шрифта по умолчанию и эмпирического коэффициента для Excel
              Если задан параметр NumSheet, то на закладке с номером (NumSheet),
              Если задан -1 то на текущей,
              иначе на всех                                                       */
  Macro SetDefaultFontSize( FontSize:integer, _ExcelKoefWidth:double, NumSheet:integer )
       var i             :integer = 0                ;
       var l_NumSheet    :integer = 0;
       var ExcelKoefWidth:double  = DefExcelKoefWidth;
       if( Not ValType(_ExcelKoefWidth) )
           if( (FontSize >= 8) and (FontSize <= 14) )
               if  ( this.WinRepOutput == WINREP_OUTPUT_EXCEL )
                     ExcelKoefWidth = TR_ExecExp("XLS_COURIER_SIZE_" +String(FontSize));
               elif( this.WinRepOutput == WINREP_OUTPUT_WORD  )
                     ExcelKoefWidth = TR_ExecExp("WORD_COURIER_SIZE_"+String(FontSize));
               elif( this.WinRepOutput == WINREP_OUTPUT_IE    )
                     ExcelKoefWidth = TR_ExecExp("IE_COURIER_SIZE_"  +String(FontSize));
               end;
           else
               ExcelKoefWidth = Double(FontSize) / 11.0;
           end;
       else
           ExcelKoefWidth = _ExcelKoefWidth;
       end;

       if( ValType(NumSheet) )
           l_NumSheet = NumSheet;
           if( NumSheet == -1 )
               l_NumSheet = CurSheet;
           end;
           if( l_NumSheet < lsSheet.Size  )
               lsSheet.Get(l_NumSheet).ExcelKoefWidth = ExcelKoefWidth;
               lsSheet.Get(l_NumSheet).FontSize       = FontSize      ;
           end;
       else  // Если номер закладки не передали, то для всех
           while( i < lsSheet.Size)
               lsSheet.Get(i).ExcelKoefWidth = ExcelKoefWidth;
               lsSheet.Get(i).FontSize       = FontSize      ;
               i = i + 1;
           end;
       end;

  End; /* SetDefaultFontSize */
   
  /* (Public) Пользовательский метод установки строки для выполнения процедурой ExecStr в Excel */
  Macro SetExecute( _CodeStr:string )
        ExecuteStrExcel[ExecuteStrExcel.Size] = _CodeStr;
  End;

  /* (Public) Пользовательский метод установки строки для выполнения процедурой ExecStr в Word  */
  Macro SetExecuteWord( _CodeStr:string )
        ExecuteStrWord [ExecuteStrWord.Size ] = _CodeStr;
  End;


  /* (Public) Пользовательский метод для установки значений членам класса, ответственным за выполнение спецформатирование и
              пересылка макрофайла на терминал в случае работы в трехзвенке */ 
  Macro SetExecuteMacro(MacFileName:string, Proc:string/*,...*/)

     var Segment          :string  = ""; /* Очередной необязательный параметр приведенный к строке */
     var MacFileNameOnTerm:string  = ""; /* Имя макрофайла на терминале */
     var Prm              :string  = ""; /* Строка с параметрами */
     var Val              :variant;      /* Значение очередного параметра */
     var i                :integer = 3;  /* Счетчик циклов */
     var SendMacFileName  :string  = ""; /* Имя пересылаемого макрофайла с путями */
     var FullNameFile     :string  = ""; /* Имя пересылаемого макрофайла с путями */

     /* Получим строку необязательных параметров */
     if( Proc )
         while( GetParm(i, Val) )
             Segment = String(Val);
             if( Segment )
                 Prm = String(Prm, Segment, ",");
             end;
             i = i + 1;
         end;
         Prm = SubStr(Prm, 1, StrLen(Prm) - 1);
      end;
      /* Если работаем в трехзвенке - перешлем файл с макропроцедурой спецформатирования на терминал */
// Исключено по запросу Q112552
/*
      if( Not IsStandAlone )

         /* Проверим существование папки, в которой будем проверять наличие инструмента. */
         /* Если её нет, то создадим                                                     */
         if( NOT ExistFile(NameMacDirTerm) )
             MakeDir( NameMacDirTerm );
         end;
          MacFileNameOnTerm = "m" + UserNumber + "_" + MacFileName + ".mac";
          SendMacFileName   =  NameMacDirTerm + MacFileNameOnTerm;
          if( (FullNameFile = FindPath(MacFileName)) )
              if( Not CopyFile(FullNameFile, SendMacFileName) )
                  MsgBox("Ошибка при передаче файла\n" + SendMacFileName + "\nна терминал!");
              else
                  iMacroFileName = MacFileNameOnTerm; 
              end;
          else
              MsgBox("Ошибка!|Файл ",MacFileName,"не найден!");
          end;
      else
*/
          iMacroFileName = MacFileName; 
/*
      end;
*/
      /* Зафиксируем имя макропроцедуры и строку с параметрами */
      iProc = Proc; 
      iPrm  = Prm;
       
      /* Обработаем возникновении аварийной ситуации */
      OnError(err)
          ErrorMessage(err,"Ошибка постобработки!" );   
  End; /* SetExecuteMacro */

  /* (Public) Пользовательский метод для установки значений членам класса, ответственным за выполнение спецформатирование и
              пересылка макрофайла на терминал в случае работы в трехзвенке */ 
  Macro SetExecuteMacroWord( MacFileName:string, Proc:string/*,...*/ )

     var Segment          :string  = ""; /* Очередной необязательный параметр приведенный к строке */
     var MacFileNameOnTerm:string  = ""; /* Имя макрофайла на терминале */
     var Prm              :string  = ""; /* Строка с параметрами */
     var Val              :variant;      /* Значение очередного параметра */
     var i                :integer = 3;  /* Счетчик циклов */
     var SendMacFileName  :string  = ""; /* Имя пересылаемого макрофайла с путями */
     var FullNameFile     :string  = ""; /* Имя пересылаемого макрофайла с путями */

     /* Получим строку необязательных параметров */
     if( Proc )
         while( GetParm(i, Val) )
             Segment = String(Val);
             if( Segment )
                 Prm = String(Prm, Segment, ",");
             end;
             i = i + 1;
         end;
         Prm = SubStr(Prm, 1, StrLen(Prm) - 1);
      end;
      /* Если работаем в трехзвенке - перешлем файл с макропроцедурой спецформатирования на терминал */
// Исключено по запросу Q112552
/*
      if( Not IsStandAlone )

         /* Проверим существование папки, в которой будем проверять наличие инструмента. */
         /* Если её нет, то создадим                                                     */
         if( NOT ExistFile(NameMacDirTerm) )
             MakeDir( NameMacDirTerm );
         end;

          MacFileNameOnTerm = "W" + UserNumber + "_" + MacFileName + ".mac";
          SendMacFileName   =  NameMacDirTerm + MacFileNameOnTerm;
          if( (FullNameFile = FindPath(MacFileName)) )
              if( Not CopyFile(FullNameFile, SendMacFileName) )
                  MsgBox("Ошибка при передаче файла\n" + SendMacFileName + "\nна терминал!");
              else
                  iMacroFileNameWord = MacFileNameOnTerm; 
              end;
          else
              MsgBox("Ошибка!|Файл ",MacFileName,"не найден!");
          end;
      else
*/
          iMacroFileNameWord = MacFileName; 
/*
      end;
*/
      /* Зафиксируем имя макропроцедуры и строку с параметрами */
      iProc = Proc; 
      iPrm  = Prm;
       
      /* Обработаем возникновении аварийной ситуации */
      OnError( err )
          ErrorMessage(err,"Ошибка постобработки!");
  End; /* SetExecuteMacro */

  /* (Public) Пользовательский метод установки флага показа фиксированных строк заголовка таблицы на каждой странице в Excel */
  Macro SetFlagShowFixedRow( _Flag:bool, NumSheet:integer )
        var i:integer = 0;
        if( ValType(NumSheet) )
            if( NumSheet < lsSheet.Size  )
                lsSheet.Get(NumSheet).FlagShowFixedRow = _Flag;
            end;
        else  // Если номер закладки не передали, то для всех
            while( i < lsSheet.Size)
                lsSheet.Get(i).FlagShowFixedRow = _Flag;
                i = i + 1;
            end;
        end;
  End; /* SetFlagShowFixedRow */

  /* (Public) Пользовательский метод установки флага показа разделительной сетки в Excel */
  Macro SetFlagShowGrid( _Flag:bool, NumSheet:integer )
        var i:integer = 0;
        if( ValType(NumSheet) )
            if( NumSheet < lsSheet.Size  )
                lsSheet.Get(NumSheet).FlagShowGrid = _Flag;
            end;
        else  // Если номер закладки не передали, то для всех
            while( i < lsSheet.Size)
                lsSheet.Get(i).FlagShowGrid = _Flag;
                i = i + 1;
            end;
        end;
  End; /* SetFlagShowGrid */

  /* (Public) Пользовательский метод установки флага показа отчета в офисном формате */
  Macro SetFlagShowReport( _Flag:bool )
        if( ValType(_Flag) )
            m_FlagShowReport = _Flag;
        end;
  end;

  /* (Public) Пользовательский метод установки флага показа нулевых значений в Excel */
  Macro SetFlagShowZeroValue( _Flag:bool, NumSheet:integer )
        var i:integer = 0;
        if( ValType(NumSheet) )
            if( NumSheet < lsSheet.Size  )
                lsSheet.Get(NumSheet).FlagShowZeroValue = _Flag;
            end;
        else  // Если номер закладки не передали, то для всех
            while( i < lsSheet.Size)
                lsSheet.Get(i).FlagShowZeroValue = _Flag;
                i = i + 1;
            end;
        end;
  End; /* SetFlagShowZeroValue */

  /* (Public) Пользовательский метод установки шрифта отчета (листа) и коэф-та ширины символа для отчета */
  macro SetFont( l_FontName:string, l_FontSize:integer, l_ExcelKoefWidth:double, l_NumSheet:integer )
        if( l_FontName )
            this.SetDefaultFontName( l_FontName, l_NumSheet );

            // Установить размер шрифта и коэф-та ширины символа 
            this.SetDefaultFontSize(l_FontSize, l_ExcelKoefWidth, l_NumSheet);
        end;
  end;

  /* (Public) Пользовательский метод установки шрифта отчета (листа) "Times New Roman" и коэф-та ширины символа для отчета
              Функция без параметров устанавливает для всего отчета размер 12 с коэф-ом 0.85 */
  macro SetFont_Times_New_Roman( l_FontSize:integer, l_ExcelKoefWidth:double, l_NumSheet:integer )
        if( (NOT l_ExcelKoefWidth) AND (NOT l_FontSize) )
            l_FontSize       = 12;
            l_ExcelKoefWidth = 0.80;
        end;
        this.SetFont("Times New Roman",l_FontSize, l_ExcelKoefWidth, l_NumSheet);
  end;

  /* (Public) Пользовательский метод инициализации закладки заголовком таблицы */
  macro SetHeaderStr( l_HeaderStr:string, NumSheet:integer )

       var SaveCurSheet    :integer = CurSheet; // Запомним номер текущей закладки
       var ArrColWidthTable:tarray  = NULL;
       var ArrHeaderStr    :tarray  = NULL;
       var ArrSubHeaderStr :tarray  = NULL;

       // Если передали номер закладки, то действуем для неё, т.е. делаем её текущий, а затем вернем текущую
       if( ValType(NumSheet) )
           CurSheet = NumSheet;       // Сменим текущую закладку на переданную
       end;

       if( l_HeaderStr )
           ConvertHeaderStr(l_HeaderStr); // Конвертирование строки заголовка таблицы
           this.CalcColWidth(NULL, FALSE);// Расчет ширин колонок по таблице

           GetCurSheet().SetHeaderStr( l_HeaderStr );  // Занесем заголовок в объект "Закладка"
       else
           // Если заголовок не передали, то значит его нужно зачистить, чистим.....
           ArrColWidthTable = GetCurSheet.GetArrColWidthTable();
           ArrHeaderStr     = GetCurSheet.GetArrHeaderStr    ();
           ArrSubHeaderStr  = GetCurSheet.GetArrSubHeaderStr ();

           // Почистим все массивы с информацией о заголовке
           ArrColWidthTable.Size = 0;
           ArrHeaderStr    .Size = 0;
           ArrSubHeaderStr .Size = 0;

           GetCurSheet().CountStrHeader = 0;
           GetCurSheet().SetHeaderStr( "" ); // Занесем заголовок в объект "Закладка"
       end;

       // Восстановим текущую закладку
       CurSheet = SaveCurSheet;
  end;

  /* (Public) Пользовательский метод инициализации закладки заголовком с расширенными параметрами */
  macro SetHeader( l_HeaderStr   :string , // Строка шапки
                   l_hd_BkGrColor:string , // Цвет фона
                   l_hd_FS       :string , // Стиль шрифта, По умолчанию жирный шрифт
                   l_hd_Align    :integer, // Выравнивание, По умолчанию по центру
                   NumSheet:integer )      // Номер листа

       // Установим строку заголовка (уже есть готовый метод)
       this.SetHeaderStr(l_HeaderStr, NumSheet);

       if( ValType(NumSheet) )
           if( NumSheet < lsSheet.Size  )
               lsSheet.Get(NumSheet).SetHeader( NULL,l_hd_BkGrColor, l_hd_FS, l_hd_Align );
           end;
       else
           GetCurSheet().SetHeader( NULL,l_hd_BkGrColor, l_hd_FS, l_hd_Align );
       end;
  end;


  /* (Public) Пользовательский метод установки текста колонтитулов. При вызове без параметров, сбрасываются все 
              установленные тексты колонтитулов */
  Macro SetMarginText(_MarginType:integer, _MarginText:string, NumSheet:integer)
     var i:integer = 0;
     if( ValType(NumSheet) )
         if( NumSheet < lsSheet.Size  )
             lsSheet.Get(NumSheet).FlagMarginTextUsed = True;
             lsSheet.Get(NumSheet).GetObjMargin().SetMarginText(_MarginType, _MarginText);
         end;
     else  // Если номер закладки не передали, то для всех
         while( i < lsSheet.Size)
             lsSheet.Get(i).FlagMarginTextUsed = True;
             lsSheet.Get(i).GetObjMargin().SetMarginText(_MarginType, _MarginText);
             i = i + 1;
         end;
     end;
  End; /* SetMarginText */


  /* (Public) Пользовательский метод для установки размера отступов вертикальных */
  macro SetMarginSizeVert( _TMarginSize:double, _BMarginSize:double, NumSheet:integer )
        var i:integer = 0;
        if( ValType(NumSheet) )
            lsSheet.Get(NumSheet).GetObjMargin().SetMarginSizeVert(_TMarginSize, _BMarginSize);
        else  // Если номер закладки не передали, то для всех
            while( i < lsSheet.Size)
                lsSheet.Get(i).GetObjMargin().SetMarginSizeVert(_TMarginSize, _BMarginSize);
                i = i + 1;
            end;
        end;
  end;

  /* (Public) Пользовательский метод для установки размера отступов горизонтальных */
  macro SetMarginSizeHor ( _LMarginSize:double, _RMarginSize:double, NumSheet:integer )
        var i:integer = 0;
        if( ValType(NumSheet) )
           lsSheet.Get(NumSheet).GetObjMargin().SetMarginSizeHor( _LMarginSize, _RMarginSize );
        else  // Если номер закладки не передали, то для всех
            while( i < lsSheet.Size)
                lsSheet.Get(i).GetObjMargin().SetMarginSizeHor( _LMarginSize, _RMarginSize );
                i = i + 1;
            end;
        end;
  end;

  /* (Public) Пользовательский метод для установки размера отступов всех */
  macro SetMarginSize(_TMarginSize:double, _BMarginSize:double, _LMarginSize:double, _RMarginSize:double, NumSheet:integer )
        this.SetMarginSizeVert( _TMarginSize, _BMarginSize, NumSheet );
        this.SetMarginSizeHor ( _LMarginSize, _RMarginSize, NumSheet );
  end;

  /* (Public) Пользовательский метод массовой установки высоты строк в СМ для выполнения процедурой ExecStr */
  Macro SetExecuteRowSize(_NumSheet:integer, _NumStartRow:integer/*,...*/)
     var Val:variant;      /* Значение очередного параметра */
     var i  :integer = 3;  /* Счетчик циклов */

     while( GetParm(i, Val) )
         this.SetExecute("iBook.Sheets(" + String(_NumSheet) + ").Rows(" + String(_NumStartRow + i - 3)
                       + ").RowHeight = iApplication.CentimetersToPoints(" + String(Double(Val)) + ");");
         i = i + 1;
     end;

  End; /* SetExecuteRowSize */


  /* (Private) Проверяем наличие приложения AppCheck в "списке" выбранных приложений AppSelect */
  /*           Эмуляция С-го поразрядного И                                                    */
  macro CheckOutApplication( AppSelect:integer,  AppCheck:integer ) : bool
        var StrAppSelect:string  = String(AppSelect:4:o);
        var StrAppCheck :string  = String(AppCheck     );
        var Len         :integer = StrLen(StrAppCheck  );

        if( SubStr(StrAppSelect, 4-Len+1, 1) == 1) return TRUE ;
        else                                       return FALSE;
        end;
  end;

  /* (Public) Пользовательский метод удаления всех шаблонов */
  macro ClearTemplate()
        ArrTemplate.Size = 0;
  end;

  /* (Public) Пользовательский метод для добавления строки шаблона */
  macro SetTemplate( NumberTemplate:integer, StrValue )
        ArrTemplate.Set( this.CurSheet, NumberTemplate, StrValue );
  end;

  /* (Public) Пользовательский метод для добавления формата выводимого файла и приложения для вывода отчета */
  Macro AddWinRepOutput( _WinRepOutput:integer, _FormatRep:integer )
     if( ValType(_WinRepOutput) )
         this.SetWinRepOutput(this.WinRepOutput+_WinRepOutput, this.FormatRep+_FormatRep);
     end;
  End; /* SetWinRepOutput */


  /* (Public) Пользовательский метод для установки формата выводимого файла и приложения для вывода отчета */
  Macro SetWinRepOutput(_WinRepOutput:integer, _FormatRep:integer)
        if( NOT ValType(_WinRepOutput) ) this.WinRepOutput = DefaultWinRepOutput;
        else                             this.WinRepOutput = _WinRepOutput      ;
        end;
        if( NOT ValType(_FormatRep   ) ) this.FormatRep    = DefaultFormatRep;
        else                             this.FormatRep    = _FormatRep      ;
        end;
  End; /* SetWinRepOutput */

  /* (Public) Пользовательский метод установки масштаба отображения в Excel для предварительного просмотра */
  Macro SetZoomType( _ZoomType:integer, _NPage:integer, NumSheet:integer )
        var Sheet:object = NULL;
        if( ValType(NumSheet) )
            if( NumSheet < lsSheet.Size  )
                Sheet = lsSheet.Get(NumSheet);
            end;
        else
            Sheet = lsSheet.Get(lsSheet.Size-1);
        end;

        if( ValType(_NPage)    ) Sheet.NumPageWidth = _NPage;
        else                     Sheet.NumPageWidth = 1     ;
        end;

        if( ValType(_ZoomType) ) Sheet.ZoomType = _ZoomType   ;
        else                     Sheet.ZoomType = ZOOM_TYPE_NO;
        end;
  End; /* SetZoomType */


  /* (Public) Удаление временной папки */
  Macro DelTmpFilesFolders( DirName:string, Name:string )
        var stat    :bool   = FALSE;
        var FileName:string = "";
        var Attr    :integer= 0 ; /* Атрибут найденного файла */
        var TmpName :string = SubFileExt(Name) + ".*";

        /* Удалим все файлы с именем Name.*  */
        stat = FileFindFirst( DirName+"\\"+TmpName, FileName, Attr);
        while( stat )
           if( Attr != FILEOP_A_SUBDIR )
               FileDelete( DirName+"\\"+FileName );
           end;
           stat = FileFindNext( FileName, Attr );
        end;
        FileFindClose(); // закроем поток

        /* Удалим все файлы из папки */
        TmpName = DirName+"\\"+SubFileExt(Name) + ".files";
        stat = FileFindFirst( TmpName+"\\*.*", FileName, Attr);
        while( stat )
           if( Attr != FILEOP_A_SUBDIR )
               if( NOT FileDelete( TmpName+"\\"+FileName ) )
                   stat = FALSE;
               end;
           end;

           stat = FileFindNext( FileName, Attr );
        end;

        /* Закроем поток и удалим папку */
        if( FileFindClose() )
            DirDelete( TmpName );
        end;
  End;

 
  /* (Public) Пользовательские методы для отправки отчета на печать и показа отчета в режиме "Предваритеьного просмотра" */
  macro PrintPreview_xls()
        this.SetExecute( "iApplication.visible = TRUE;"); // Иначе MSExcel зависнет в невидимом режиме ожидая ответа пользователя
        this.SetExecute( "ibook.PrintPreview();" );
  end;

  macro PrintOut_xls( _Copies:integer )
        if( Valtype(_Copies) ) this.SetExecute( "ibook.PrintOut( OptVal, OptVal," + String(_Copies) + " );" );
        else                   this.SetExecute( "ibook.PrintOut();" );
        end;
  end;

  macro PrintOut_doc( _Copies:integer )
        if( Valtype(_Copies) ) this.SetExecuteWord( "WordDocument.PrintOut( OptVal, OptVal, OptVal, OptVal, OptVal, OptVal, OptVal," + String(_Copies) + " );" );
        else                   this.SetExecuteWord( "WordDocument.PrintOut();" );
        end;
  end;

  private macro MakeFileForWE(TxtRpRead,TxtRpWrite)
     const POSTW_LINEBEG = 1;                 /* константы для обработки строк из-за которых неправильно отображается отчёт в Word */
     const POSTW_NONE    = 2;
     const POSTW_NOWRAP  = 3;
     const POSTW_NEXT    = 4;
     var CountNeedRemove    :integer = 2;     /* Количество необходимых для удаления строк с упоминанием директивы "<meta name=" */

     while( (CountNeedRemove) and (Next(TxtRpRead)) )
          if( (SubStr(TxtRpRead.Str, 1, 17) == "<meta name=ProgId"   ) or
              (SubStr(TxtRpRead.Str, 1, 20) == "<meta name=Generator")   )
               CountNeedRemove = CountNeedRemove - 1;
          else Insert(TxtRpWrite, TxtRpRead.Str);
          end;
     end;
     // при сохранении Exel добавил "лишние" строки из-за них
     //не прорисовывается последняя строка в таблице , их надо удалить
     if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_WORD))
         CountNeedRemove = POSTW_NOWRAP; // произведём особую обработку для Word'а
     else
         CountNeedRemove = POSTW_NEXT;
     end;
     // уберём  white-space:nowrap; - для правельного отображения шапки таблицы в Worde
     while( (CountNeedRemove == POSTW_NOWRAP ) AND Next(TxtRpRead)  )

         if ( SubStr(TxtRpRead.Str,2,24) != "white-space:nowrap;" )
              if( SubStr(TxtRpRead.Str,1, 9)== "</style>"          )
                  CountNeedRemove = POSTW_NEXT;
              end;
              Insert(TxtRpWrite, TxtRpRead.Str);
          end;
    
      end;

      while( Next(TxtRpRead) )
          if(countNeedRemove == POSTW_LINEBEG)
              if(SubStr(TxtRpRead.Str,2,12) == "<![endif]>")
                  countNeedRemove = POSTW_NONE;
              end;
          elif((countNeedRemove == POSTW_NEXT))
              if( SubStr(TxtRpRead.Str,2,34) == "<![if supportMisalignedColumns]>" )
                  countNeedRemove = POSTW_LINEBEG;
              else
                  Insert(TxtRpWrite, TxtRpRead.Str);
              end;
          else
              Insert(TxtRpWrite, TxtRpRead.Str);
         end;
     end;
     CountNeedRemove = POSTW_NONE;
     Close(TxtRpRead);
     Close(TxtRpWrite);
  end; 
  // пересылка файлов - временная мера(не работает open для терменала) 
  private macro CopyOnServer( CopyDir:string,CopyFileName:string,LastNameFile:@string)
      
      var HTMLFileName    :string = CopyDir +"\\"+ CopyFileName; // файл который копируем
      Var HTMLFileNameCopy:string = "";                          // файл в который копиоуем
      var LastNameFileTmp :string = "";
      var LastNameFileExt :string = "";
      var FullFileNameServ:string = ""; 
      FILE TxtRpRead () txt;                   /* Временный файл */
      FILE TxtRpWrite() txt write;             /* Окончательный файла получаемый из временного */
      var FlagDebug               = ___FlagDebug___ ;

      HTMLFileName = CopyDir + CopyFileName;
          
      if( this.WorkDir )  HTMLFileNameCopy = this.WorkDir + "\\" + CopyFileName;
      else                HTMLFileNameCopy = CopyFileName;
      end;

      if( Not CopyFile( toANSI("$"+HTMLFileName), HTMLFileNameCopy ))
          MsgBox( "Ошибка при передаче файла\n" + CopyFileName + "\nна сервер" );
          return false; 
      end;

      if( NOT WR_Open(TxtRpRead ,  HTMLFileNameCopy) )
          MsgBox("Не найден файл:\n",HTMLFileNameCopy);
          return false;
      end; 

      SplitFile(LastNameFile, LastNameFileTmp,LastNameFileExt);
      FullFileNameServ = HTMLFileNameCopy + "D";
      if( Not WR_Open(TxtRpWrite , FullFileNameServ) )
          MsgBox("Не могу создать файл:\n",FullFileNameServ);
          return false;
      end;

      MakeFileForWE(TxtRpRead,TxtRpWrite);
      Close(TxtRpRead );
      Close(TxtRpWrite);
      if( NOT CopyFile( FullFileNameServ,toANSI("$"+ LastNameFile)) )
          LastNameFile = GetUniqAdd(LastNameFile);
         
          if( Not CopyFile(FullFileNameServ,toANSI("$"+LastNameFile)) )
              MsgBox( "Ошибка при передаче файла\n"    + CopyFileName  + "\nна терминал");
          end;
      end;

      // удалим с терменала файл, который присылали
      if( (NOT FlagDebug) AND OR_ExistFile(toANSI(HTMLFileName)) )   OR_DeleteFile(HTMLFileName); 
      end; 
      // удалим файлы на сервере они не нужны
      if( (NOT FlagDebug) AND ExistFile(toANSI(HTMLFileNameCopy)))   DelFile(HTMLFileNameCopy);
      end;
      if( (NOT FlagDebug) AND ExistFile(toANSI(FullFileNameServ)))   DelFile(FullFileNameServ);
      end;
  end; //CopyOnServer


  /****** Внутренний метод для печати отчета в mdi формате */
  private macro PrintMODI( ObjExcel:object )
      var Value_OpenInMODI:integer = WR_RegRead("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\OpenInMODI");
      var l_TIFDPI        :integer = -1;
      var l_PrivateFlags  :integer = -1;
      var l_NameFileTmp   :string  = "";

      // Если ключ есть, запомним его значение, чтобы восстановить
      if( WR_CheckExistsRegKey("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\TIFDPI",
                                NULL, false) )

          l_TIFDPI = WR_RegRead("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\TIFDPI");
      end;

      // Если ключ есть, запомним его значение, чтобы восстановить
      if( WR_CheckExistsRegKey("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\PrivateFlags",
                                NULL, false) )

          l_PrivateFlags = WR_RegRead("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\PrivateFlags");
      end;


      SplitFile(ObjExcel.Book.Name, l_NameFileTmp, NULL);

      l_NameFileTmp = string(ObjExcel.Book.Path + "\\" + l_NameFileTmp + ".tif");

      // Изменим значение в ключе реестра, чтобы не показывать "Image Writer"
      WR_RegWrite("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\OpenInMODI",
                         "REG_DWORD", 0);

      // Формат вывода в tiff
      if( l_PrivateFlags == -1 ) // Если такого ключа нет - создаеим
          WR_RegCreate("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\PrivateFlags",
                       "REG_DWORD", 16);
      else                       // Иначе просто запишем значение
          WR_RegWrite("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\PrivateFlags",
                      "REG_DWORD", 16);
      end;


      // Качество (разрешение)
      if( l_TIFDPI == -1 ) // Если такого ключа нет - создаеим
          WR_RegCreate("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\TIFDPI",
                      "REG_DWORD", m_TIFDPI);
      else                       // Иначе просто запишем значение
          WR_RegWrite("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\TIFDPI",
                      "REG_DWORD", m_TIFDPI);
      end;

      ObjExcel.Book.PrintOut(1,                                               //From           Optional Variant. The number of the page at which to start printing. If this argument is omitted, printing starts at the beginning.                
                             32767,                                           //To             Optional Variant. The number of the last page to print. If this argument is omitted, printing ends with the last page.                             
                             1,                                               //Copies         Optional Variant. The number of copies to print. If this argument is omitted, one copy is printed.                                                 
                             false,                                           //Preview        Optional Variant. True to have Microsoft Excel invoke print preview before printing the object. False (or omitted) to print the object immediately.
                             "Microsoft Office Document Image Writer (Ne00:)",//ActivePrinter  Optional Variant. Sets the name of the active printer.                                                                                             
                             false,                                           //PrintToFile    Optional Variant. True to print to a file. If PrToFileName is not specified, Microsoft Excel prompts the user to enter the name of the output file.
                             true,                                            //Collate        Optional Variant. True to collate multiple copies.                                                                                                 
                             l_NameFileTmp );                                 //PrToFileName   Optional Variant. If PrintToFile is set to True, this argument specifies the name of the file you want to print to.

      //********* Восстановим значениz
      WR_RegWrite("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\OpenInMODI",
                  "REG_DWORD", Value_OpenInMODI);

      if( l_TIFDPI != -1 )
          WR_RegWrite("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\TIFDPI",
                      "REG_DWORD", l_TIFDPI);
      end;
      if( l_PrivateFlags != -1 )
          WR_RegWrite("HKEY_CURRENT_USER\\Software\\Microsoft\\Office\\11.0\\MODI\\MDI writer\\PrivateFlags",
                       "REG_DWORD", l_PrivateFlags);
      end;
  end;

 
  /* (Public) Пользовательский метод для показа сформированного отчета в Windows-представлении */
  Macro ShowWinRep()

     if(Not WinRepOutput)  return 0;
     end;
     var i                   :integer = 0 ;
     var j                   :integer = 0 ;
     var k                   :integer = 0 ;
     var LastNameFileTmp     :string  = SetOutPut(this.WorkDir + "\\" + TMP_FILES, TRUE);
     var LastNameFile        :string  = "";
     var LastNameFileExt     :string  = "";
     var TempNamePath        :string  = "";
     var FlagDebug                    = ___FlagDebug___    ;
     var DirNameWork         :string  = "";
     var SizeSheet           :integer = 0 ;
     var ZoomType            :integer   ;
     FILE TxtRpRead () txt;                   /* Временный файл */
     FILE TxtRpWrite() txt write;             /* Окончательный файла получаемый из временного */
    
     ///////////////////////////////////////////////////////
     var FileNameWithPathTmp:string  = "";    /* Имя временного файла с путем */
     var StrTmp             :string  = "TMP"; /* Строка, добавляемая к наименованию временного файла. По умолчанию "TMP" */
     var FileNameWithPathAll:string  = "";    /* Имя файла с путем */
     var ReportFileExt      :string  = "";
     
     var stat               :bool    = TRUE;
     var CheckBook          :bool    = FALSE; /* Флаг существования книги в Excel */
     var m_FlagVisible      :bool;
     var LastTmpFileName    :string="";
     /////////////////////////////////////////////////////////////////                                           
     var FileName          :string  = this.ExlusiveFileName ;  // Уникальное имя файла                    
     var Flag_Delete       :bool    = TRUE;        // Флаг удаления старых отчетов             
     
     var ObjWord  = CDAOMSWord (NULL, GetRegim_LoadNewApplication); /* Объект класса CDAOMSWord , для работы с Word  */
     var ObjIE    = CDAO_IE    (NULL, GetRegim_LoadNewApplication); /* Объект класса CDAO_IE    , для работы с IE    */
  
     /* Обрежем путь и получим только имя */
     SplitFile(LastNameFileTmp, LastNameFile, LastNameFileExt);

     // Если пользователь сам задал имя файла, то его и возьмем, но номер коннекта все равно допишем в хвост
     if( FileNameDocumentWin )
         LastNameFile = FileNameDocumentWin;
     end;

     if( LastNameFile AND LastNameFileExt  )
         LastNameFile = LastNameFile + "_" + SubStr(LastNameFileExt, 2);
     end;

     /* Восстанавливаем поток вывода и удаляем получившийся файл */
     SetOutPut(LastNameFileTmp, TRUE);
     DelFile( this.WorkDir + "\\" + TMP_FILES );
     // Построим диаграммы по листам
     var Chart    :object = NULL;
     var lsCommand:tarray = NULL;
     while( j < lsSheet.Size)
         Chart = lsSheet.Get(j).GetChart();
         if( valType(Chart) )
             lsCommand = Chart.Create();
             k = 0;
             while( k < lsCommand.Size )
                this.SetExecute( lsCommand[k] );
                k = k + 1;
             end;
         end;
         j = j + 1;
     end;
    
     /* Если работаем в трехзвенке - то запускаем отчет на терминале */
     if( Not IsStandAlone() )

         // Если в строке пути есть знак ":" или "\\", то это абсолютный путь
         if( Index(toAnsi(NameDirTerm), ":") OR Index(toAnsi(NameDirTerm), "\\\\") )
             TempNamePath = SubStr(toAnsi(NameDirTerm), 2);
         else
             TempNamePath = GetCurDir(TRUE)+"\\"+SubStr(toAnsi(NameDirTerm), 2);
             /* EVG Нужно также обрабатывать ситуацию, когда GetCurDir возвращает путь с завершающим слешем. Обычно это
                бывает, когда мапится сам каталог терминала: W:\ + \TxtFile. В этом случае 2 слеша заменяются на 1. */
             //TempNamePath = StrSubst( TempNamePath, "\\\\", "\\"); TAM 05.05.2014 R-366881-2
         end;
     else
         TempNamePath = this.WorkDir + "\\";  
     end;
///////////////////////////////////////////////////////////////////////////////////
     DirNameWork       = toOEM(TempNamePath)               ;
     SizeSheet         = lsSheet.Size()                    ;
     LastNameFile      = toANSI(DirNameWork + LastNameFile);
     ZoomType          = lsSheet.Get(0).ZoomType           ;

     if( NOT ObjExcel.Open(toAnsi(DirNameWork + FileName)) )
         return FALSE;
     end;
     CheckBook    = TRUE;

     if( SizeSheet > 1 )
      /* Только для Excel */
         ObjExcel.ExecuteMacro(iMacroFileName, iProc, iPrm);
         ObjExcel.ExecStr(ExecuteStrExcel);
         ObjExcel.SaveAs( LastNameFile + ".xls", WINREP_OUTPUT_EXCEL/*this.FormatRep*/ );

         ReportPath         = ObjExcel.Book.Path;
         ReportFileName_xls = ObjExcel.Book.Name;

         // Вывести в MODI
         if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_MODI) )
             PrintMODI(ObjExcel);
         end;

         // В зависимости от флага или открываем отчет или закрываем книгу и приложение
         if( m_FlagShowReport )               
             ObjExcel.Show();
         else
          // если в приложении одна книга (наша), то закроем приложение
             if( ObjExcel.Application.Workbooks.Count == 1)
                ObjExcel.Destructor();
             else                  // иначе только нашу книгу
                ObjExcel.Book.Close(FALSE);
             end;
         end;
         /* Удалим временный файл  c терминала*/
     else
         m_FlagVisible = ObjExcel.Application.Visible;
         ObjExcel.ExecuteMacro(iMacroFileName, iProc, iPrm);
         ObjExcel.ExecStr(ExecuteStrExcel);
         ObjExcel.Application.Visible = m_FlagVisible;
          
         var SaveOrientation:integer  = ObjExcel.Book.Sheets(1).PageSetup.Orientation; // только с первой т.к в ворд выводятся только однозакладочные

         /* Делаем такой финт ушами, только если нужен IE формат */
         if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_IE  ) OR
             CheckOutApplication(WinRepOutput, WINREP_OUTPUT_WORD) )


             LastTmpFileName = SubStr(FileName, 1, StrLen(FileName) - 4) 
                              + StrTmp + SubStr(FileName, StrLen(FileName) - 3); 
             /* Простой отчет мы сохраним в таком формате, чтобы его мог прочитать и Word и Excel */
             if( DirNameWork )
                 FileNameWithPathTmp = DirNameWork + LastTmpFileName;
             else
                 FileNameWithPathTmp = LastTmpFileName;
             end;

             if(int(ObjExcel.Application.version) < MS_2007)
             ObjExcel.SaveAs(toANSI(FileNameWithPathTmp));
             else
                 ObjExcel.Publish(toANSI(FileNameWithPathTmp));
             end;
             ReportPath = ObjExcel.Book.Path;

             ObjExcel.Book.Close(FALSE);
             CheckBook = FALSE;
             /* Удалим временный файл */
             if( (NOT FlagDebug) AND OR_ExistFile(ToAnsi(DirNameWork + FileName)) )
                 OR_DeleteFile( toAnsi(DirNameWork + FileName) );
             end;

             FileNameWithPathAll = LastNameFile
                                 + SubStr(FileNameWithPathTmp, StrLen(FileNameWithPathTmp) - 3);
             
             if( ExistFile(ToAnsi(FileNameWithPathAll)) )
                 if( FLAG_ASK_DELETEFILE )
                     Flag_Delete = GetTRUE(TRUE, "Файл <"+ FileNameWithPathAll+ ">\n уже существует в данном месте! Заменить?")
                 end;
                 if( Flag_Delete )
                     if( NOT DelFile(FileNameWithPathAll) )
                         // Не смогли удалить прибавляем к имени файла уникальный префикс
                         FileNameWithPathAll = GetUniqAdd( FileNameWithPathAll );
                     end;
                 else
                     /* Удалим временный файл */
                     if( (NOT FlagDebug) AND OR_ExistFile(ToAnsi(FileNameWithPathTmp)) )
                         OR_DeleteFile(FileNameWithPathTmp);
                     end;
                     return FALSE;
                 end;
             end;
            
             if( NOT IsStandAlone() )
                 CopyOnServer( DirNameWork, LastTmpFileName, @FileNameWithPathAll );
             else
                  if( WR_Open(TxtRpRead,  FileNameWithPathTmp) )
                      if( WR_Open(TxtRpWrite, FileNameWithPathAll) )  
                          MakeFileForWE(TxtRpRead,TxtRpWrite); 
                          Close(TxtRpRead );
                          Close(TxtRpWrite);

                          if( ExistFile(toANSI(FileNameWithPathTmp)) )
                              DelFile(toANSI(FileNameWithPathTmp)); 
                          end; 
                            
                      else
                          MsgBox("Не найден файл:\n",FileNameWithPathAll);
                      end;
                  else
                       MsgBox("Не найден файл:\n",FileNameWithPathTmp);
                  end; 
             end; 
              
                
         end;
         /* Показать в Word */
         if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_WORD) )

             ObjWord.Open(toAnsi(FileNameWithPathAll), WINREP_FORMAT_HTML);
             ObjWord.Document.PageSetup.Orientation =  SaveOrientation - 1;   // в ворде другие константы
             ObjWord.ExecuteMacro(iMacroFileNameWord, iProc, iPrm);
             ObjWord.ExecStr(ExecuteStrWord); // Постобработка
             ObjWord.SetOrientation( ZoomType );  // Установка ориентации листа отчета
             stat = ObjWord.SaveAs( LastNameFile + ".doc", WINREP_FORMAT_DOC );

             ReportFileName_doc = ObjWord.Document.Name;
             if( stat )
                 // В зависимости от флага или открываем отчет или закрываем книгу и приложение
                 if( m_FlagShowReport )
                     ObjWord.Show();
                     /*файл захватывается офисом, закроем, удалим, откроем*/
                     if((int(ObjExcel.Application.version) >= MS_2007) AND (NOT CheckOutApplication(WinRepOutput, WINREP_OUTPUT_IE)))
                         ObjWord.Document.Close();
                         OR_DeleteFile( toAnsi(FileNameWithPathAll) );
                         ObjWord.Open(toAnsi(LastNameFile + ".doc"), WINREP_FORMAT_DOC);
                     end;  
                 else
                     // если в приложении одна книга (наша), то закроем приложение
                     if( ObjWord.Application.Documents.Count == 1)
                         ObjWord.Destructor();
                     else                  // иначе только нашу книгу
                         ObjWord.Document.Close(FALSE);
                     end;
                 end;
             end;
         end;

         /* Показать в IE */
         if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_IE) )
             // В зависимости от флага или открываем отчет или нет
             SplitFile(FileNameWithPathAll, ReportFileName_html, ReportFileExt);
             if(ReportFileExt != "")
                ReportFileName_html = ReportFileName_html + ReportFileExt;
             end;
             if( m_FlagShowReport )
                 SplitFile(FileNameWithPathAll, ReportFileName_html, NULL);
                 ObjIE.Open( toAnsi(FileNameWithPathAll) );
                 ObjIE.SetOrientation( ZoomType ); // Установка ориентации листа отчета
                 ObjIE.Show();
             end;
         end;

         /* Показать в Excel */
         if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_EXCEL) ) 
             if( NOT CheckBook )
                 ObjExcel.Open(toAnsi(FileNameWithPathAll));
             end;
             ObjExcel.Sheet(1).PageSetup.Orientation = Saveorientation;
             stat = ObjExcel.SaveAs( LastNameFile + ".xls", WINREP_OUTPUT_EXCEL );

             ReportPath         = ObjExcel.Book.Path;
             ReportFileName_xls = ObjExcel.Book.Name;

             // Вывести в MODI
             if( CheckOutApplication(WinRepOutput, WINREP_OUTPUT_MODI) )
                 PrintMODI(ObjExcel);
             end;

             if( stat )
                 // В зависимости от флага или открываем отчет или закрываем книгу и приложение
                 if( m_FlagShowReport )
                     ObjExcel.Show();
                 else
                     // если в приложении одна книга (наша), то закроем приложение
                     if( ObjExcel.Application.Workbooks.Count == 1)
                         ObjExcel.Destructor();
                     else                  // иначе только нашу книгу
                         ObjExcel.Book.Close(FALSE);
                     end;
                 end;
             end;
         end;


         if( ( NOT CheckOutApplication ( WinRepOutput , WINREP_OUTPUT_IE ) )  AND
             ( NOT FlagDebug )                                                AND 
               OR_ExistFile( toAnsi(FileNameWithPathAll) )            )
             OR_DeleteFile( toAnsi(FileNameWithPathAll) );
         end;
     end;  

     if( Not IsStandAlone() )
         i = 0;
         while( i < Obj_HTML_Rep.ArrFileHTML.Size )
             RemoveFile( toANSI("$"+ DirNameWork + Obj_HTML_Rep.ArrFileHTML[i]) );
             i = i + 1;
         end;
         RemoveDir( toANSI("$"+ SubStr(DirNameWork + FileName, 1,
                                StrLen(DirNameWork + FileName)-4) + ".files") );

         if( (NOT FlagDebug) AND OR_ExistFile(toANSI(DirNameWork + FileName)) )
             OR_DeleteFile( DirNameWork + FileName );
         end;
     end; 



     OnError( Err )
         ErrorMessage(err,"Ошибка постобработки!" );
///////////////////////////////////////////////////////////////////// 
         if( NOT ___FlagDebug___ )
             this.DelTmpFilesFolders( this.WorkDir, this.ExlusiveFileName );
         end;  

  End; /* ShowWinRep */
   
/*┌─────────────────────────────────────────────────────────────────────────────────┐*/
/*│Дополнительные методы                                                            │*/
/*└─────────────────────────────────────────────────────────────────────────────────┘*/
 
  /**** (Public) Добавить диаграмму по текущему листу */
  macro AddChart( ChartType:integer, PlotBy:integer  ) : CChart
        return GetCurSheet.AddChart( ChartType, PlotBy );
  end;

  /* (Public) Пользовательский метод добавления объектов типа CSortField и CSubResField */
  Macro AddSortField(_Number:integer               ,// по какой колонке сортируем
                     _Direct:integer               ,//направление и приоритет
                     _NumColSubRes:integer         ,// в какую к-ку выводить _TextSubRes 
                     _TextSubRes:string            ,// строка напр. "Итого"
                     _CountStrForShowSubRes:integer,//минимальное число строк для вывода подитогов
                     _StrModif_ForSubRes:string    , //форматирование _TextSubRes и пустых ячеек
                     _StrModif_ForSubResSum:string)  // форматирование подитогов

     var ObjSortField:object = Null; /* Объект класса CSortField или CSubResField, в зависимости от числа параметров */

     if( ValType(_NumColSubRes) )  // Если задано меньше трех параметров, то это просто поле сортировки
         ObjSortField = CSubResField(_Number, _Direct, _NumColSubRes, _TextSubRes, _CountStrForShowSubRes,_StrModif_ForSubRes,_StrModif_ForSubResSum);
     else                          // Иначе - это сортировка с подсчетом подитогов
         ObjSortField = CSortField(_Number, _Direct); /* Объект класса CSortField */
     end;

     ArrSortField[ArrSortField.Size] = ObjSortField;

  End; /* AddSortField */

  /* (Public) Пользовательский метод удаления всех полей сортировки */
  Macro ClearAllSortField()
        ArrSortField.Size = 0;
  End; /* ClearAllSortField */

  /* (Public) Пользовательский метод стирания повторяющихся значений в определенной колонке */
  Macro ClearRepeats(_NumCol:integer, _BegDiap:integer, _EndDiap:integer, _StrItog:string)

     var ArrPrintStr:tarray = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки
     var i:integer = 0; /* Счетчик циклов */
     var j:integer = 0; /* Счетчик циклов */

     /* Проверим переданный диапазон на корректность */
     this.CheckDiapason(_BegDiap, _EndDiap);

     j = _BegDiap;
     i = j + 1;
     /* Удаляем "двойников" */
     while( i <= _EndDiap )
         if((ValCmpArray(ArrPrintStr.Value(i).Value(0).FlagStr, ArrConstTabl) != ELEM_NO_FOUND)
         and(ValCmpArray(ArrPrintStr.Value(j).Value(0).FlagStr, ArrConstTabl) != ELEM_NO_FOUND))
             if( ArrPrintStr.Value(i).Value(_NumCol).StrValue == ArrPrintStr.Value(j).Value(_NumCol).StrValue )
                 ArrPrintStr.Value(i).Value(_NumCol).StrValue = "";
             else /* Если передан признак строки с итогами, то пропускаем данную строку */
                 if( Not ValType(_StrItog) )
                     j = i;
                 else
                     if( Not Index(String(ArrPrintStr.Value(i).Value(_NumCol).StrValue), _StrItog) )
                         j = i;
                     end;
                 end;
             end;
         else j = i;
         end;
         i = i + 1;
     end;

  End; /* ClearRepeats */

  /* (Private) Внутренний метод сравнения строк отчета */
  Macro CmpField(ArrPrintCell_1:tarray, ArrPrintCell_2:tarray) : integer    

     var Stat:integer = 0; /* Результат сравнения двух строк отчета */
     var i   :integer = 0; /* Счетчик циклов */

     while( (Not Stat) and (i < ArrSortField.Size) )
          if  (ArrPrintCell_1[ArrSortField[i].Number].StrValue < ArrPrintCell_2[ArrSortField[i].Number].StrValue)
               Stat = -1 * ArrSortField[i].Direct;
          elif(ArrPrintCell_1[ArrSortField[i].Number].StrValue > ArrPrintCell_2[ArrSortField[i].Number].StrValue)
               Stat =  1 * ArrSortField[i].Direct;
          else Stat =  0;
          end;
          i = i + 1;
     end;
     return Stat;

  End; /* CmpFields */

  /* (Public) Пользовательский метод для формирования строк подитогов (вызывать только для отсортированных таблиц или отчетов!) */     
  Macro CreateSubRes(_BegDiap:integer, //Начало диапозона подсчёта
                     _EndDiap:integer  //конец диапозон подсчёта
                     /*Parms*/  )      //колонки по которым итог
  
    var ArrPrintStr              :tarray  = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки
    var i                        :integer = 0;       /* Счетчик циклов */
    var j                        :integer = 0;       /* Счетчик циклов */
    var k                        :integer = 0;       /* Счетчик циклов */
    var l                        :integer = 0;       /* Счетчик циклов */
    var m                        :integer = 0;       /* Счетчик циклов */
    var n                        :integer = 0;       /* Счетчик циклов */
    var PrevPrintStr             :tarray  = NULL;    /* Предыдущая строка при сравнении */
    var CurPrintStr              :tarray  = NULL;    /* Текущая строка при сравнении */
    var FlagEndSelect            :bool    = False;   /* Флаг окончания отбора */
    var TempSubResStr            :tarray  = tarray;  /* Вспомогательный массив для строки подитогов */
    var SzPrevStr                :integer = 0;       /* Размер массива ячеек предыдущей строки */
    var Number                   :integer = 0;       /* Номер ячейки в массиве сортировке */
    var PrintCell                :CParamPrintCell;   /* Объект класса CParamPrintCell */
    var CheckPrintStr            :tarray  = tarray;  /* Массив для проверки условий и подсчета сумм подитогов */
    var Sum                               = 0;       /* Сумма подитогов для Money и Double */
    var ArrSubResStr             :tarray  = tarray;  /* Массив строк подитогов */
    var SzArrSubRes              :integer = 0;       /* Размкр массива строк подитогов */
    var ArrPrintStrWithSubRes    :tarray  = tarray;  /* Массив печатных строк вместе с расположенными в нем строками подитогов */
    var FlagNeedAddSum           :bool    = True;    /* Флаг необходимости прибавления очередной суммы при подсчете подитогов */
    var StrModif_Advan           :string  = "";      /* Набор модификаторов строки */
    var CountStrBeforeSubRes     :integer = 0;       /* Количество строк перед подитогами */
    var NeedCountStrForShowSubRes:integer = 0;       /* Минимальное необходимое количество строк перед подитогами */
    var NumSubResStr             :integer = 0;       /* Номер строки, для которой были сформированы подитоги */
    var SzArrSort                :integer = ArrSortField.Size(); /* Размер массива полей сортировки */
    var NumItoSubRes             :tarray  = tarray(1,1) ;
    i = 3;
    NumItoSubRes[NumItoSubRes.Size] = 0;
    while(GetParm(i,NumItoSubRes[NumItoSubRes.Size]))

        i = i + 1;
    end;
    i = 0;
    macro NeedSubItog(val:integer):bool
        var h :integer = 0; 
        while(h < NumItoSubRes.Size) 
            if(val == NumItoSubRes(h))  return true; 
            end; 
        h = h + 1;
        end; 
        return false;
    End;
    /* Метод для проверки индекса и сравнения двух строк, при подходящем индексе */
    Macro CheckStr(NumStr:integer, PrevValue:tarray, CurValue:tarray)
         if( NumStr > _EndDiap )
             return True;
         else
             if( PrevPrintStr[ArrSortField[j].Number].StrValue != CurPrintStr[ArrSortField[j].Number].StrValue )
                 return True;
             else
                 return False;
             end;
         end;
    End; /* CheckStr */

    /* Проверим переданный диапазон на корректность */
    this.CheckDiapason(_BegDiap, _EndDiap);

    if( FlagShowIndicator )
        InitProgress((_EndDiap + 1) - _BegDiap, StatusIndicatorRep, "Подведение подитогов...");
    end;
    i            = _BegDiap;
    PrevPrintStr = ArrPrintStr[i];
    i            = i + 1;
    /* Цикл по строкам таблицы отчета */
    while(i <= (_EndDiap + 1))
         /* Вводим такое условие для общности алгоритма вывода общих подитогов по всей таблице (отчету) */
         if( i <= _EndDiap )  CurPrintStr = ArrPrintStr[i];
         else                 CurPrintStr = tarray;
         end;
         FlagEndSelect = False;
         j             = 0;
         /* Цикл по массиву полей сортировки */
         while((j < SzArrSort)and(Not FlagEndSelect))
              if(GenClassName(ArrSortField[j]) == "CSUBRESFIELD")
                   if(CheckStr(i, PrevPrintStr, CurPrintStr))
                        FlagEndSelect = True;
                        k = SzArrSort - 1;
                        /* Цикл по количеству добавляемых строк подитогов */
                        while(k >= j)
                             if(GenClassName(ArrSortField[k]) == "CSUBRESFIELD")
                                  TempSubResStr    = tarray;
                                  l                = 0;
                                  SzPrevStr        = PrevPrintStr.Size();
                                  /* Цикл по ячейкам предыдущей строки */ 
                                  while(l < SzPrevStr)
                                       Number = ValCmpArray(l, ArrSortField, "Number");
                                       if((Number != ELEM_NO_FOUND)and(Number <= k)and(GenClassName(ArrSortField[Number]) == "CSUBRESFIELD"))
                                            if(Not PrevPrintStr[l].StandartLexem)
                                                 StrModif_Advan = "ex_FS(b)";
                                            else StrModif_Advan = PrevPrintStr[l].StandartLexem + ":ex_FS(b)";
                                            end;
                                            PrintCell = CParamPrintCell(PrevPrintStr[l].StrValue,
                                                                        PrevPrintStr[l].StrModif_Whole,
                                                                        PrevPrintStr[l].StrModif_Fract,
                                                                        StrModif_Advan,
                                                                        PrevPrintStr[l].FlagStr);
                                       else if(((ValType(PrevPrintStr[l].StrValue) == V_MONEY) or (ValType(PrevPrintStr[l].StrValue) == V_DOUBLE))
                                                 AND ( NumItoSubRes.Size )
                                                 or  (NeedSubItog(l)      ))
                                                 /* Подсчет сумм */
                                                 m              = i - 1;
                                                 Sum            = PrevPrintStr[l].StrValue;
                                                 FlagNeedAddSum = True;
                                                 /* Цикл по проверяемым строкам таблицы отчета, находящихся выше формируемой строки подитогов */
                                                 while((m > _BegDiap)and(FlagNeedAddSum))
                                                      m              = m - 1;
                                                      n              = k;
                                                      CheckPrintStr  = ArrPrintStr[m];
                                                      /* Цикл по ячейкам очередной проверямой строки */
                                                      while((n >= 0)and(FlagNeedAddSum))
                                                           if(CheckPrintStr[ArrSortField[n].Number].StrValue != PrevPrintStr[ArrSortField[n].Number].StrValue)
                                                                FlagNeedAddSum = False;
                                                           end;
                                                           n = n - 1;
                                                      end;
                                                      if(FlagNeedAddSum)
                                                           Sum = Sum + CheckPrintStr[l].StrValue;
                                                      end;
                                                 end;
                                                 if(Not PrevPrintStr[l].StandartLexem)
                                                      StrModif_Advan = ArrSortField[k].StrModif_ForSubResSum;
                                                 else StrModif_Advan = PrevPrintStr[l].StandartLexem + ArrSortField[k].StrModif_ForSubResSum;
                                                 end;
                                                 PrintCell = CParamPrintCell(Sum, 
                                                                             PrevPrintStr[l].StrModif_Whole,
                                                                             PrevPrintStr[l].StrModif_Fract,
                                                                             StrModif_Advan,
                                                                             PrevPrintStr[l].FlagStr);
                                            else PrintCell = CParamPrintCell("",
                                                                             PrevPrintStr[l].StrModif_Whole,
                                                                             PrevPrintStr[l].StrModif_Fract,
                                                                             PrevPrintStr[l].StandartLexem + ArrSortField[k].StrModif_ForSubRes,
                                                                             PrevPrintStr[l].FlagStr);
                                            end;
                                       end;
                                       TempSubResStr[TempSubResStr.Size()] = PrintCell;
                                       l = l + 1;
                                  end;
                                  /* Запомним индекс строки, после которой надо выводить подитоги */
                                  TempSubResStr[TempSubResStr.Size()] = i;
                                  /* Запомним, при каком минимальном количестве инфорационных строк надо выводить данные подитоги */
                                  TempSubResStr[TempSubResStr.Size()] = ArrSortField[k].CountStrForShowSubRes;
                                  /* Установим текст для подитогов в нужный столбец */
                                  TempSubResStr[ArrSortField[k].NumColSubRes].StrValue = ArrSortField[k].TextSubRes;
                                  TempSubResStr[ArrSortField[k].NumColSubRes].CatExtendedLexems(ArrSortField[k].StrModif_ForSubRes);
                                  ArrSubResStr[ArrSubResStr.Size()] = TempSubResStr;
                             end;
                             k = k - 1;
                        end;
                   end;
              end;
              j = j + 1;
         end;
         PrevPrintStr = CurPrintStr;
         if( FlagShowIndicator )
             UseProgress(i - _BegDiap);
         end;
         i = i + 1;
    end;
    if( FlagShowIndicator )
        RemProgress();
    end;
    /* Вставим полученные строки с подитогами в массив строк для печати */
    i = 0;
    j = 0;
    k = -1;
    CountStrBeforeSubRes = 0;
    SzArrSubRes          = ArrSubResStr.Size(); 
    while(i < SzArrSubRes)
         /* Запомним номер строки, для которой были сформированы подитоги */
         NumSubResStr = ArrSubResStr.Value(i).Value(ArrSubResStr[i].Size - 2);
         /* Запомним минимальное количество строк, для которых надо выводить данные подитоги */
         NeedCountStrForShowSubRes = ArrSubResStr.Value(i).Value(ArrSubResStr[i].Size - 1); 
         if(j < NumSubResStr)
              CountStrBeforeSubRes = 0;
         end;
         while(j < NumSubResStr)
              ArrPrintStrWithSubRes[ArrPrintStrWithSubRes.Size()] = ArrPrintStr[j];
              if(j >= _BegDiap)
                   CountStrBeforeSubRes = CountStrBeforeSubRes + 1;
              end;
              j = j + 1;
         end;
         /* Если число строк перед подитогами больше заданного, то добавим очередную строку подитогов */
         if(CountStrBeforeSubRes >= NeedCountStrForShowSubRes) 
            /* Это условие для обязательного вывода подитогов после последней строки таблицы убрано в связи с запросом 42560 */
/*          or(NumSubResStr == ArrSubResStr.Value(SzArrSubRes - 1).Value(ArrSubResStr[i].Size - 2))) */
              /* Отбросим ячейки, в которой мы хранили индекс для вставки строки и минимальное число 
                 строк необходимых для показа подитогов */
              ArrSubResStr[i].Size = ArrSubResStr[i].Size - 2;
              ArrPrintStrWithSubRes[ArrPrintStrWithSubRes.Size()] = ArrSubResStr[i];
         /* Иначе выделим жирным шрифтом поля, по которым подводятся подитоги, а также 
            поля содержащие суммы и количества для необходимого числа предыдущих строк */
         else l = 1;
              while(l <= CountStrBeforeSubRes)
                   k            = 0;
                   PrevPrintStr = ArrPrintStrWithSubRes[ArrPrintStrWithSubRes.Size() - l];
                   SzPrevStr    = PrevPrintStr.Size();
                   while(k < SzPrevStr)
                        Number = ValCmpArray(k, ArrSortField, "Number");
                        if(((Number != ELEM_NO_FOUND)and(GenClassName(ArrSortField[Number]) == "CSUBRESFIELD"))
                         or((ValType(PrevPrintStr[k].StrValue) == V_MONEY)or(ValType(PrevPrintStr[k].StrValue) == V_DOUBLE)))
                             if(k < PrevPrintStr.Size )
                             PrevPrintStr[k].AddExtendedLexems(  "ex_FS(b)");
                        end;
                        end;
                        k = k + 1;
                   end;
                   l = l + 1;
              end;
         end;
         k = i;
         i = i + 1;
    end;
    /* Добавим осташиеся строки, которые находятся ниже диапазона подведения итогов */
    while(j < ArrPrintStr.Size())
         ArrPrintStrWithSubRes[ArrPrintStrWithSubRes.Size()] = ArrPrintStr[j];
         j = j + 1;
    end;
    ArrPrintStr.Size = 0;
    i = 0;
    while (i < ArrPrintStrWithSubRes.Size)  
        ArrPrintStr[ArrPrintStr.Size] = ArrPrintStrWithSubRes[i];
        i = i + 1;
    end; 

  
  End; /* CreateSubRes */

  /* (Private) Внутренний метод, для формирования индекса автогруппировки */
  Macro MakeGroupIndex(_ArrScanStr:tarray):string

     var Ind:string  = ""; /* Формируемый индекс автогруппировки */
     var i  :integer = 0;  /* Счетчик циклов */

     while( i < ArrGroupColIndex.Size )
         /* Проверяем на случай строк не стандартной длины, чтобы случайно не упасть по индексу... */
         if( ArrGroupColIndex[i] < _ArrScanStr.Size() )
             Ind = Ind + Trim(String(_ArrScanStr[ArrGroupColIndex[i]].StrValue));
         end;
         i = i + 1;
     end;  
     return Ind;

  End; /* MakeGroupIndex */

  /* (Public) Пользовательский метод предназначенный для перемещения закладок между собой    */
  macro MoveSheet( NumSheetSource:integer, NumSheetDesc:integer ) : bool
        return lsSheet.MoveSheet( NumSheetSource, NumSheetDesc );
  end;

  /* (Public) Пользовательский метод перенумерации таблицы отчета (самого отчета) при изменении порядка 
              следования строк(например при сортировке) или при необходимости */
  Macro RenumRep(_NumCol:integer, _BegDiap:integer, _EndDiap:integer)

     var ArrPrintStr:tarray  = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки
     var i          :integer = 0; /* Счетчик циклов */
     var NumCol     :integer = 0; /* Номер столбца, в котором будет производится перенумерация */

     if( ValType(_NumCol) )
         NumCol = _NumCol;
     end;

     /* Проверим переданный диапазон на корректность */
     this.CheckDiapason(_BegDiap, _EndDiap);

     /* Произведем перенумерацию */
     i = _BegDiap;
     while( i <= _EndDiap )
         ArrPrintStr.Value(i).Value(NumCol).StrValue = i - _BegDiap + 1;
         i = i + 1;
     end;

  End; /* RenumRep */

  /* (Public) Пользовательский метод установки (снятия) номеров колонок отчета, по которым будут групироваться данные отчета
              Внимание! Использовать аккуратно, так как для больших отчетов возможно сильное замедление создания отчета */
  Macro SetGroupColIndex( _StrDpsCol:string )

     var i          :integer = 0; /* Счетчик циклов */
     var j          :integer = 0; /* Счетчик циклов */
     var ObjDiapason:CDiapason;   /* Объект для работы с диапазонами */

     /* Если строка не передана или пустая, то очищаем массив для автогруппировки */
     if( Not _StrDpsCol )
         ArrGroupColIndex.Size = 0;
     /* Иначе прибавляем новые диапазоны автогруппировки к уже существующим */
     else
         ObjDiapason = CDiapason(_StrDpsCol);
         if( ObjDiapason.AnalysisStr() )
             /* Если строка удачно разобралась на диапазоны, формируем массив номеров колонок для автогруппировки */
             i = 0;
             while( i < ObjDiapason.ArrResult.Size() )
                 j = ObjDiapason.ArrResult[i].BegDiapason;
                 while( j <= ObjDiapason.ArrResult[i].EndDiapason )
                     ArrGroupColIndex[ArrGroupColIndex.Size()] = j;
                     j = j + 1;
                 end;
                 i = i + 1;
             end;
         end;
     end;

  End; /* SetGroupColIndex */

  /* (Public) Пользовательский метод установки режима для больших отчет!                    */
  /*          В этом режиме отчет выводится позакладочно (для оптимизации работы с памятью) */
  macro SetModeBigReport( Flag:bool )
        FlagModeBigReport = Flag;
  end;

  /* (Public) Пользовательский метод скрытия (пока просто удаления) колонок в уже существующих таблицах отчета */
  Macro HideCol(_StrDpsCol:string, _FlagNumberLine:integer)

     var ArrPrintStr     :tarray  = GetCurSheet.GetArrPrintStr(); // Массив с данными текущей закладки
     var Sz              :integer = ArrPrintStr.Size();      /* Размер массива строк */
     var SzCur           :integer = 0;                       /* Размер массива ячеек в строке */
     var SzHide          :integer = 0;                       /* Размер массива скрываемых столбцов */
     var SzGroupHide     :integer = 0;                       /* Размер массива групп скрываемых столбцов */
     var CurPrintStr     :tarray  = NULL;                    /* Текущая строка */
     var i               :integer = 0;                       /* Счетчик циклов */
     var j               :integer = 0;                       /* Счетчик циклов */
     var k               :integer = 0;                       /* Счетчик циклов */
     var ObjDiapason     :CDiapason;                         /* Объект для работы с диапазонами */
     var TempArrCol      :tarray  = tarray;                  /* Вспомогательный массив */
     var ArrHideCol      :tarray  = tarray;                  /* Массив для номеров скрываемых столбцов */
     var ArrGroupHideCol :tarray  = tarray;                  /* Массив для групп номеров скрываемых столбцов */
     var CountRealHideCol:integer = 0;                       /* Количество реально удаленных в строке столбцов (ячеек) */
     var TempStr         :string  = "";                      /* Вспомогательная переменная для преобразования заголовка */
     var ObjHeader       :CHeader = CHeader;                 /* Объект класса CHeader, служащий для корректного преобразования
                                                                заголовка после скрытия столбцов */
     var FlagNumberLine  :integer = 0;                       /* Флаг, указывающий при значении NUMBER_LINE на то, что в заголовке есть нижняя строка 
                                                              с нумерацией столбцов, которую нужно корректно расположить и перенумеровать */

     if(ValType(_FlagNumberLine))
          FlagNumberLine = _FlagNumberLine;
     end;
     /* Разберем переданную строку на диапазоны (по умолчанию границы целые числа) */
     ObjDiapason = CDiapason(_StrDpsCol);
     if(ObjDiapason.AnalysisStr())
          /* Если строка удачно разобралась на диапазоны, формируем массив номеров скрываемых столбцов.
             При этом делаем это, начиная с конца, для ускорения сортировки, так как обычно люди задают
             номера столбцов от меньшего к большему, а нам для скрытия нужно как раз наоборот */
          i = ObjDiapason.ArrResult.Size();
          while(i > 0)
               i = i - 1;
               if( ObjDiapason.ArrResult[i].EndDiapason < GetCurSheet.GetArrColWidthTable().Size )
                    j = ObjDiapason.ArrResult[i].EndDiapason;
               else j = GetCurSheet.GetArrColWidthTable().Size - 1;
               end;
               while(j >= ObjDiapason.ArrResult[i].BegDiapason)
                    TempArrCol[TempArrCol.Size()] = j;
                    j = j - 1;
               end;
          end;
     end;
     /* Отсортируем по убыванию */
     SortArray(TempArrCol, False);
     /* Отберем в массив для номеров скрываемых столбцов недублируемые номера колонок */
     SzCur = TempArrCol.Size();
     if(SzCur)
          ArrHideCol[ArrHideCol.Size()] = TempArrCol[0];
          i = 1;
          while(i < SzCur)
               if(ArrHideCol[ArrHideCol.Size() - 1] != TempArrCol[i])
                    ArrHideCol[ArrHideCol.Size()] = TempArrCol[i];
               end;
               i = i + 1;
          end;
     end;
     /* Сгруппируем их по принципу нечетная колонка - номер столбца от которого удалять по убыванию номера, 
        а четная колонка - сколько колонок удалять */
     i = 0;
     SzHide = ArrHideCol.Size();
     if(SzHide)
          ArrGroupHideCol[ArrGroupHideCol.Size()] = ArrHideCol[0];
          ArrGroupHideCol[ArrGroupHideCol.Size()] = 1;
          i = 1;
          while(i < SzHide)
               /* Если столбцы смежные - группируем их */
               if((ArrHideCol[i - 1] - ArrHideCol[i]) == 1)
                    ArrGroupHideCol[ArrGroupHideCol.Size() - 2] = ArrHideCol[i];
                    ArrGroupHideCol[ArrGroupHideCol.Size() - 1] = ArrGroupHideCol[ArrGroupHideCol.Size() - 1] + 1;
               else ArrGroupHideCol[ArrGroupHideCol.Size()] = ArrHideCol[i];
                    ArrGroupHideCol[ArrGroupHideCol.Size()] = 1;
               end;
               i = i + 1;
          end;
     end;
     /* Если хоть один элемент в массиве есть - скрываем нужные столбцы */     
     i = 0;
     SzGroupHide = ArrGroupHideCol.Size();
     if(SzGroupHide)
          if( FlagShowIndicator )
              InitProgress(Sz, StatusIndicatorRep, "Скрытие столбцов не подлежащих печати...");
          end;
          while(i < Sz)
               CurPrintStr = ArrPrintStr[i];
               SzCur       = CurPrintStr.Size();
               /* Если текущая строка является ячейкой таблицы */
               if(ValCmpArray(CurPrintStr[0].FlagStr, ArrConstTabl) != ELEM_NO_FOUND)
                    j = 0;
                    while(j < SzGroupHide)
                         /* Удаляем все намеченные группы столбцов */
                         k = ArrGroupHideCol[j];
                         while(k < (SzCur - ArrGroupHideCol[j + 1]))
                              CurPrintStr[k] = CurPrintStr[k + ArrGroupHideCol[j + 1]];
                              k              = k + 1;
                         end;
                         if(SzCur > ArrGroupHideCol[j])
                              CountRealHideCol = Min((SzCur - ArrGroupHideCol[j]), ArrGroupHideCol[j + 1]);
                         else CountRealHideCol = 0;
                         end;
                         /* Уменьшаем размер таблицы на число реально удаленных столбцов */
                         if(CountRealHideCol)
                              CurPrintStr.Size = CurPrintStr.Size - CountRealHideCol;
                         end;
                         SzCur = CurPrintStr.Size;
                         j     = j + 2;
                    end;
                    ArrPrintStr[i] = CurPrintStr;
               end;
               i = i + 1;
               if( FlagShowIndicator )
                   UseProgress(i);
               end;
          end; 
          if( FlagShowIndicator )
              RemProgress();
          end;
     end;
     /* Преобразуем заголовок таблицы в соответсвии со скрытыми столбцами */
     ObjHeader.ParcelHeader(GetCurSheet().SheetStrHeader, FlagNumberLine);
     i = 0;
     while(i < SzHide)
          ObjHeader.MarkRemoveParent(ArrHideCol[i] + 1);
          i = i + 1;
     end;
     ObjHeader.RemoveParent();
     TempStr = ObjHeader.CreateHeader(FlagNumberLine);
     /* Переинициализируем объект CMakeReport */
//     this.Init(TempStr, BegSepStr, CountStrOnPage, this.CurStr);

     ConvertHeaderStr(TempStr); // Конвертирование строки заголовка таблицы на основе переданных разделителей ObjSeparator
     this.CalcColWidth(NULL, FALSE);// Расчет ширин колонок по таблице
      
  End; /* HideCol */

  /* (Public) Пользовательский метод сортировки строк отчета в заданном диапазоне (в большинстве случаев это строки
              таблицы отчета) */
  Macro SortRep(_BegDiap:integer, _EndDiap:integer)
     /* Проверим переданный диапазон на корректность */
     this.CheckDiapason(_BegDiap, _EndDiap);

     /* Непосредственная сортировка */
     if( ArrSortField.Size() AND (_BegDiap < _EndDiap) )
         QSortWithUserMacro( GetCurSheet.GetArrPrintStr(), "CmpField", this, _BegDiap, _EndDiap );
     end;
  End; /* SortRep */

  // Метод для установления шкалы масштаба для закладки SheetName
  macro SetPageScale(SheetName:variant, Scale:integer, PaperType, Orientation:integer)

            var ObjSheet:string = "";

            if( ValType(SheetName) == V_STRING ) ObjSheet = "ibook.sheets(\""+SheetName+"\")";
            else                                 ObjSheet = "ibook.sheets("  +SheetName+  ")";
            end;

            this.SetExecute( String(ObjSheet, ".PageSetup.Zoom        = ", Scale      , ";") );
            this.SetExecute( String(ObjSheet, ".PageSetup.PaperSize   = ", PaperType  , ";") );
            this.SetExecute( String(ObjSheet, ".PageSetup.Orientation = ", Orientation, ";") );

  end;


/*┌─────────────────────────────────────────────────────────────────────────────────┐*/
/*│Методы длля работы с шаблонами (документами слияния)                             │*/
/*└─────────────────────────────────────────────────────────────────────────────────┘*/

  // Добавить шаблон с названиями полей в реестр шаблонов
  // Требования к имени шаблона такие же как к имени закладки
  macro RegisterForm( NameTemplate:string, NameTemplateDoc:string, NameOutFile:string
                      /*,... перечисление наименований полей */ ) : bool

        var i         :integer =     4;   // Номер параметра [this-0, NameTemplate-1, NameTemplateDoc-2, NameOutFile-3]
        var NameFields:string  =    "";   // Наименование поля
        var Obj       :object  =  NULL;   // Объект шаблон

        // Если объект не создан, то создадим
        if( NOT lsTemplateDocument )
            lsTemplateDocument = ClsTemplateDocument();
        end;

        if( (Obj=lsTemplateDocument.AddTemplate(NameTemplate, NameTemplateDoc, NameOutFile)) )
            while( GetParm(i, NameFields) )
               if( NameFields )
                   Obj.AddFieldsName( NameFields );
               end;
               i = i + 1;
            end;
        else
            return FALSE;
        end;

        return TRUE;
  end;

  // Добавить документ в шаблон NameTemplate
  macro AddDoc( NameTemplate:string /*,... перечисление значений полей */ ) : bool

        var Obj     :object  =  NULL;   // Объект шаблон
        var CountDoc:integer =     0;   // Кол-во документов данного типа
        var Value   :variant =  NULL;   // Значение поля
        var i       :integer =     2;   // Номер параметра [this-0, NameTemplate-1]

        // Если объект не создан, то создадим
        if( NOT lsTemplateDocument )
            MsgBox("Ошибка!|Вы не задали ни одного шаблона!|",
                   "Перед добавлением данных в документ, необходимо его зарегистрировать при помощи функции RegisterForm!");
            return FALSE;
        end;

        // Найдем нужный нам шаблон
        if( (Obj=lsTemplateDocument.AddDocument(NameTemplate)) )
            CountDoc = Obj.GetCountDoc();
            while( GetParm(i, Value) )
               Obj.AddFieldsValue( CountDoc, Value );
               i = i + 1;
            end;

        else
            return FALSE;
        end;

        return TRUE;
  end;

  // Добавить документ в шаблон NameTemplate
  macro AddDocFields( Num_NameFields:variant, ValueFields:variant ) : bool

        var Obj:object  = lsTemplateDocument.GetLastDocument(); // Возьмем последний добавленный элемент
        var Pos:integer = 0;                                    // Номер поля
        
        if( Obj )  
            if  ( ValType(Num_NameFields) == V_STRING  ) // Задали наименование поле
                if( (Pos = Obj.GetNumberFields(Num_NameFields)) != -1 )
                    Obj.SetFieldsValue(Obj.GetCountDoc-1, Pos, ValueFields );
                end;

            elif( ValType(Num_NameFields) == V_INTEGER ) // Задали номер поля
                  if( Num_NameFields < Obj.GetFieldsNameSize() )
                      Obj.SetFieldsValue(Obj.GetCountDoc-1, Num_NameFields, ValueFields );
                  else
                      MsgBox("Ошибка в методе <AddDocFields>!|Поля с номером <",Num_NameFields,"> не существует. Общее кол-во полей в шаблоне <",Obj.GetFieldsNameSize(),">!");
                  end;
            else 
                MsgBox("Ошибка в методе <AddDocFields>!|Первый параметр имеет неврный тип, допустимые значения <V_STRING, V_INTEGER>.");
            end;
        else
            MsgBox("Перед заполнением полей документа, необходимо его добавить!");
            return FALSE;
        end;
        return TRUE;
  end;

  // Очистить содержимое регистрации шаблона NameTemplate
  macro ClearRegisterForm( NameTemplate:string )
        lsTemplateDocument.ClearRegisterForm( NameTemplate );
  end;

  // На основании данных реестра шаблонов lsTemplateDocument, добавим данные в основной объект
  macro CreateTemplateData()
        var i          :integer = 0;
        var j          :integer = 0;
        var k          :integer = 0;
        var Size       :integer = lsTemplateDocument.Size();  // Кол-во шаблонов
        var CountDoc   :integer = 0;                          // Кол-во документов данного шаблона
        var CountFields:integer = 0;                          // Кол-во полей данного шаблона
        var Obj        :object  = NULL;                       // Объект шаблон
        var Header     :CHeader = NULL;                       // Объект "Конструктор заголовков"

        // Цикл по шаблонам
        while( i < Size )

           // Печать заголовка (поля шапки) документов на закладку шаблона
           Obj = lsTemplateDocument.Get(i);
           CountDoc = Obj.GetCountDoc();

           if( CountDoc > 0 )
               CountFields = Obj.GetFieldsNameSize();

               // Если есть поля
               if( CountFields )

                   // Сформиркем шапку таблицы, на основании названий полей шаблона
                   j = 0;
                   Header = CHeader();
                   while( j < CountFields )
                      Header.AddChild( Obj.GetFieldsName(j), 20 );
                      j = j + 1;
                   end;
                   if( i ) this.AddNewSheetBreak( lsTemplateDocument.GetNameTemplate(i), Header.CreateHeader() );
                   else    this.Init(Header.CreateHeader())
                   end;

                   // Печать данных документов на закладку шаблона

                   j = 0;
                   while( j < CountDoc )
                      k = 0;
                      while( k < CountFields )
                         this.AddPrintCell( Obj.GetFieldsValue(j, k), 0, 0, "", REP_ELEM_TABL );
                         k = k + 1;
                      end;
                      if( CountFields )
                          this.AddStr();
                      end;
                      j = j + 1;
                   end;
               end;
           end;
           i = i + 1;
        end;

        // Поименуем первую закладку
        if( Size )
            lsSheet.Get(0).SetSheetName( lsTemplateDocument.GetNameTemplate(0) );
        end;
  end;

  // Проверить наличие регистрации шаблона с именем NameTemplate
  macro CheckRegisterForm( NameTemplate:string ) : bool
        if( (NOT lsTemplateDocument)                             OR  // Объект не создан, значит нет зареганных шаблонов
            (lsTemplateDocument.FindTemplate(NameTemplate) == -1) )  // Такого шаблона нет
            return FALSE;
        end;
        return TRUE;
  end;

  /**** (Public) Пользовательский метод для задания пути до шаблонов шаблона */
  macro SetPathTemplate( _DirName_Template:string )
        DirName_Template = _DirName_Template;
  end;

  /**** (Public) Пользовательский метод для создания документа слияния на основании шаблона */
  macro ShowTemplateRep()

     var i              :integer = 0 ;
     var LastNameFileTmp:string  = SetOutPut(this.WorkDir + "\\" + TMP_FILES, TRUE);
     var LastNameFile   :string  = ""; // Временная переменная для получения имени файла с данными
     var LastNameFileExt:string  = ""; // Временная переменная для получения имени файла с данными
     var TempNamePath   :string  = ""; // Строка содержащая настройки банка - путь ддо шаблонов
     var TempStr        :string  = "", // Временная переменная
         StrErr         :integer =  0; // Код с ошибкой
     var RegKey         :string  = "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEMPLSDIR"; // Ключ в реестре с путем к шаблонам


     // Метод возвращает путь до файла, отрезав его от полного имени файлаFullFileName
     macro GetPathTemplate( FullFileName:string ) : string
           var DirName:string = "";
           var Size   :integer= StrLen(FullFileName);
           var i      :integer= 1;
           while( i < Size )
              if( SubStr(FullFileName, Size-i, 1) == "\\" )
                  DirName = SubStr(FullFileName, 1, Size-i-1);
                  i = Size;
              end;
              i = i + 1;
           end;
           return DirName;
     end; 
  MACRO ShowTemplateReport( IsStandAlone:bool   ,  /* Режим запуска процедуры (2-х,3-x звенка) */
                            FileName    :string ,  /* Уникальное имя файла                     */
                            DirNameWork :string ,  /* Каталог для временный файлов             */
                            DirNameMac  :string ,  /* Каталог для макросов                     */
                            LastNameFile:string ,  /* окончательное имя файла под которым будет*/
                                                   /* создан отчет, совпадает с именем макроса */
                            Regim_LoadNewApplication:bool  )  // Флаг запуска приложений MSOffice

    var ObjExcel      :CDAOMSExcel = CDAOMSExcel(NULL, Regim_LoadNewApplication);   /* Объект класса CDAOMSExcel, для работы с Excel */
    var ObjWord       :CDAOMSWord  = CDAOMSWord (NULL, Regim_LoadNewApplication);   /* Объект класса CDAOMSWord , для работы с Word  */
    var NameXLSFile   :string      = toOEM(DirNameWork) + LastNameFile+".xls";
    var NameDocument  :string      = "";
    var DisplayAlerts :integer     = -1;              // Флаг вывода сообщений
    var i             :integer     =  0;
    var Fullpath      :string      =  0;

    // Откроем XLS-файл с данными
    if( NOT ObjExcel.Open(toOEM(DirNameWork) + FileName) )
        return FALSE;
    end;

    ObjExcel.SaveAs( NameXLSFile, WINREP_OUTPUT_EXCEL );
    ObjExcel.Close();

    /* Удалим временный html-файл */
    if( ExistFile(ToAnsi(DirNameWork + FileName)) )
        DelFile( toOEM(DirNameWork) + FileName );

        /* Удаляем временную папку */
        DelTmpFilesFolders( SubStr(toOEM(DirNameWork) + FileName, 1,
                            StrLen(toOEM(DirNameWork) + FileName)-4) + ".files");
    end;

    // Создадим приложение Word для открытия шаблона
    if( NOT ObjWord.vrt_CreateApplicationWord() )
        return FALSE;
    end;

    // Отключим вывод всех сообщений и ненужных диалогов
    DisplayAlerts = ObjWord.Application.DisplayAlerts; // Запомним состояние флажка
    ObjWord.Application.DisplayAlerts = 0;             // wdAlertsNone

    // Заберем данные шаблонов из cfg файла
   // lsTemplateData.GetFile();
    

    // Создаем документы на основании списка шаблонов
    while( i < lsTemplateDocument.Size() )

        // Откроем шаблон
         
        if(NOT IsStandAlone ) // Если работаем в 3-х звенке
           Fullpath = TempNamePath+"..\\"+NameTemplateDirTerm ; // Имя пути до шаблона
        else
           Fullpath = lsTemplateDocument.Get(i).NameTemplatePath; // Имя пути до шаблона
        end;

        if( ObjWord.Open((Fullpath+"\\"+lsTemplateDocument.Get(i).NameTemplateDoc) ) )

            // Открываем источник данных, т.е. нашу таблицу
            ObjWord.Document.MailMerge.OpenDataSource(
                                       /* Name    */             NameXLSFile,
                                       /* [format]*/             6,     // wdOpenFormatAllWord
                                       /* [ConfirmConversions] */FALSE, // True to display the Convert File dialog box if the file isn't in Microsoft Word format
                                       /* [ReadOnly] */          FALSE, // True to open the data source on a read-only basis
                                       /* [LinkToSource] */      FALSE, // True to perform the query specified by Connection and SQLStatement each time the main document is opened.
                                       /* [AddToRecentFiles] */  FALSE,
                                       /* [PasswordDocument] */  "",
                                       /* [PasswordTemplate] */  "",
                                       /* [Revert]           */  FALSE,
                                       /* [WritePasswordDocument] */ "",
                                       /* [WritePasswordTemplate] */ "",
                                       /* [Connection]            */ "",
                                       /*SQLStatement*/         "SELECT * FROM `"+lsTemplateDocument.Get(i).NameTemplate+"$`" );

            // Создаем новый документ слияния
            ObjWord.Document.MailMerge.Destination        = 0; // wdSendToNewDocument
            ObjWord.Document.MailMerge.SuppressBlankLines = 0; // wdSendToNewDocument

            ObjWord.Document.MailMerge.Execute();      // Создаем документ слияния
            ObjWord.Close();                           // Закрываем шаблон

            // Получим название документа, его или задал пользователь, или воспользуемся стандатрным подходом, т.е. имя выходного потока плюс номер коннекта и плюс номер шаблона
            NameDocument = lsTemplateDocument.Get(i).NameOutFile;
            if( NOT NameDocument )
                NameDocument = LastNameFile+"_"+string(i+1)+".doc";
            end;

            // Добираемся до созданного документа (первый в коллекции открытых документов) и переименовываем его
            if( ObjWord.Application.Documents.Count )
                ObjWord.Document = ObjWord.Application.Documents.Item(1);
                ObjWord.SaveAs( toOEM(DirNameWork) + NameDocument );
            end;
        end;
        i = i + 1;
    end;

    // Покажем готовый документ слияния, если он есть конечно
    if( lsTemplateDocument.Size() )
        ObjWord.Show();
    end;

    // Вернем первоначальное состояние флажка показа сообщений
    ObjWord.Application.DisplayAlerts = DisplayAlerts; //wdAlertsAll

  END;

     
     // Получим данные в xls-файле для заполнения шаблона
     this.SetWinRepOutput(0, 0);                                      // Почистим используемые форматы
     this.AddWinRepOutput( WINREP_OUTPUT_EXCEL, WINREP_FORMAT_XLS  ); // Зададим формать XLS
     this.PrintWinRep();                                              // Заполнение данных
     
     /* Получим имя файла с данными */
     // Обрежем путь и получим только имя
     SplitFile(LastNameFileTmp, LastNameFile, LastNameFileExt);
     if( LastNameFile AND LastNameFileExt  )
         LastNameFile = LastNameFile + "_" + SubStr(LastNameFileExt, 2);
     end;
     // Восстанавливаем поток вывода и удаляем получившийся файл
     SetOutPut(LastNameFileTmp, TRUE);
     DelFile( this.WorkDir + "\\" + TMP_FILES );
     
     // Если пользователь не задал путь до шаблонов, то поищем его в реестре
     if( NOT DirName_Template )
         // Найдем месторасположение шаблонов на сервере, они лежат в одном из путей прописанных в 
         // "BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\TEMPLSDIR"
         GetRegistryValue( RegKey, V_STRING, DirName_Template, StrErr );
     end;
     
     // 1. Если в ключах реестра путь не указан не выдавать сообщение об ошибке.
     // 2. Добавить возможность указания пути к шаблонам в прикладном коде (метод объекта).
     // 3. Добавить возможность автоматического (панель для указания пути, файла) выбора необходимого шаблона
     if( NOT DirName_Template )
         GetString(DirName_Template, string("В настройках банка не указан путь до шаблонов <", RegKey, ">. Укажите путь до папки с шаблонами."));
     end;
     
     if( NOT DirName_Template )
         MsgBox( "Ошибка!|Не задан путь до папки с шаблонами." );
         return FALSE;
     end;
     
     // Определим месторасположение каждого шаблона из списка
     i = 0;
     while( i < lsTemplateDocument.Size() )
         // Нашли i-ый шаблон
         TempStr = FindPath(toANSI(lsTemplateDocument.Get(i).GetNameTemplateDoc()), DirName_Template);
         if( NOT TempStr )
             MsgBox( "В путях <",DirName_Template, ">|не найден шаблон|<",
                      lsTemplateDocument.Get(i).GetNameTemplateDoc(),">!|",
                      "Поместите шаблоны в указанный путь и повторите операцию." );
             return FALSE;
         end;
     
         // Отрежем от него путь и запишем в список
         lsTemplateDocument.Get(i).SetNameTemplatePath( GetCurDir(FALSE)+"\\"+GetPathTemplate(TempStr) );
         i = i + 1;
     end;
     
     // Для трехзвенки определим путь до временных файлов, это сложно, т.к. он может быть абсолютным, относительным и сетевым
     if( Not IsStandAlone() ) // Если работаем в трехзвенке
     
         // Если в строке пути есть знак ":" или "\\", то это абсолютный путь
         if( Index(toAnsi(NameDirTerm), ":") OR Index(toAnsi(NameDirTerm), "\\\\") )
             TempNamePath = SubStr(toAnsi(NameDirTerm), 2);
         else
             TempNamePath = GetCurDir(TRUE)+"\\"+SubStr(toAnsi(NameDirTerm), 2);
         end;
     end;
     
     
     /* Если работаем в трехзвенке - то запускаем отчет на терминале */
     if( Not IsStandAlone() )
         MakeDir( "$"+NameTemplateDirTerm ); // Создадим для этого папку
     
         // Перешлем на терминал шаблон(ы)
         i = 0;
         while( i < lsTemplateDocument.Size() )
            // Проверим дату модификации шаблона на сервере и на терминале
            if( NOT CheckFilesEqual( toANSI(lsTemplateDocument.Get(i).GetNameTemplatePath() + "\\" + lsTemplateDocument.Get(i).GetNameTemplateDoc()),
                                     toANSI(NameDirTerm + "..\\" + NameTemplateDirTerm + "\\" + lsTemplateDocument.Get(i).GetNameTemplateDoc()) ) )

               if( NOT CopyFile( toANSI(lsTemplateDocument.Get(i).GetNameTemplatePath()+"\\"+lsTemplateDocument.Get(i).GetNameTemplateDoc()),
                                 toANSI(NameDirTerm)+"..\\"+NameTemplateDirTerm+"\\"+lsTemplateDocument.Get(i).GetNameTemplateDoc() ) )
     
                   MsgBox( "Ошибка при передаче файла <" + lsTemplateDocument.Get(i).GetNameTemplateDoc() +
                            "> на терминал.|Из|<"+
                            lsTemplateDocument.Get(i).GetNameTemplatePath()+"\\"+lsTemplateDocument.Get(i).GetNameTemplateDoc()+
                            ">|в|<"+
                            toANSI(NameDirTerm+"..\\"+NameTemplateDirTerm+"\\"+lsTemplateDocument.Get(i).GetNameTemplateDoc()) + ">" );
               end;
            end;
            i = i + 1;
         end;
     
         ShowTemplateReport(  
                        IsStandAlone()                  , 
                        this.ExlusiveFileName           ,  // Уникальное имя файла                     
                        TempNamePath                    ,  // Каталог для временный файлов             
                        NameMacDirTerm                  ,  // Каталог для макросов                     
                        LastNameFile                    ,  // окончательное имя файла под которым будет
                                                           // создан отчет, совпадает с именем макроса 
                        GetRegim_LoadNewApplication()  );  // Флаг запуска приложений MSOffice

         if( NOT ___FlagDebug___ )
             this.DelTmpFilesFolders( this.WorkDir, this.ExlusiveFileName );
         end;
     else
         /* Обычный режим */
         ShowTemplateReport( 
                        IsStandAlone()                  , 
                        this.ExlusiveFileName           ,  // Уникальное имя файла                     
                        this.WorkDir + "\\"             ,  // Каталог для временный файлов             
                        ""                              ,  // Каталог для макросов                     
                        LastNameFile                    ,  // окончательное имя файла под которым будет
                                                           // создан отчет, совпадает с именем макроса 
                        GetRegim_LoadNewApplication()  );  // Флаг запуска приложений MSOffice
     end;
  end;
  /*установка свойств документа*/
  macro SetDocProperty(iDocName:string,iUserName:string,iOrgName:string )
  
      DocProperty = CDocProperty(iDocName,iUserName,iOrgName);
      SetExecute( "iBook.BuiltinDocumentProperties(\"Author\").Value  =" + "\"" + DocProperty.UserName + "\"");
      SetExecute( "iBook.BuiltinDocumentProperties(\"Company\").Value =" + "\"" + DocProperty.OrgName  + "\"");
      SetExecute( "iBook.BuiltinDocumentProperties(\"Title\").Value   =" + "\"" + DocProperty.DocName  + "\"");
 
  end;  
  /* Конструктор */
  __NumObject = __NumObject + 1; // Добавляем номер экземпляра данного объекта (т.е. сколько экземпляров CMakeReport создано)
  this.Init(_HeaderStr, _SepStr, _CountStrOnPage, _CurStr);
  /**/

 
  /**** (Public) Деструктор */
  macro Destructor()
         // Удалим временные папки, т.к. если не формировать отчет в офисных приложениях, то они не удаляются
        if( NOT ___FlagDebug___ )
            this.DelTmpFilesFolders( this.WorkDir, this.ExlusiveFileName );
        end;
        // Очистим все списки и объекты (для экономии памяти)
        ArrGroupColIndex = NULL;   // Массив номеров колонок для группировки
        ArrSortField     = NULL;   // Массив объектов содержащих поля сортировки и направление сортировки
        ArrTemplate      = NULL;   // Объект с данными шаблонов
        ExecuteStrExcel  = NULL;   // Строка для выполнения спецформатирования методом ObjExcel.ExecStr
        ExecuteStrWord   = NULL;   // Строка для выполнения спецформатирования методом ObjWord .ExecStr
        lsSheet          = NULL;   // Список закладок отчета. Основной объект!
        ObjSeparator     = NULL;   // Объект класса CSeparator
        Obj_HTML_Rep     = NULL;   // Объект HTML-ый отчет
        DocProperty      = NULL;
        lsTemplateDocument = NULL;  // Реестр шаблонов для формирования документов слияния
  end;
                                                                              


END; /* CMakeReport */
/**/