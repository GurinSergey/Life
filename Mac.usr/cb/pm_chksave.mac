//-----------------------------------------------------------------------------
// Блок      : Вне блока
// Шаг       : Вне шага
// Описание  : Общие проверки макросов скроллингов
// Gurin S. 21.12.2015 HotFix 2031.19.25 (Life_1 1.3)_11
//-----------------------------------------------------------------------------
import BankInter, OprInter, likepy, pm_tools, pm_common, pmlib, pm_const;
// Серьезность ошибки
const NOTERROR = 0, // Ошибки нет
      ERROR    = 1, // Серьезная ошибка. Сохранять нельзя.
      WARNING  = 2; // Предупредить пользователя

// Поля панели (инициализируем реальными значениями в наследнике)
// !!! Инициализировать реальными значениями полей (нумерация с нуля)!!!
// По умолчанию перемешаемся в первое поле
class TPanelFields()
  var Number:integer = 0,
      BaseAmount:integer = 0,
      FIID:integer = 0,
      BaseFIID:integer = 0,
      PayFIID:integer = 0,
      Priority:integer = 0,
      NumberPack:integer = 0,
      rmDate:integer = 0,
      PayDate:integer = 0,
      ValueDate:integer = 0,
      PayerBankEnterDate:integer = 0,
      TransferDate:integer = 0,
      PayerAccount:integer = 0,
      ReceiverAccount:integer = 0,
      PayerName:integer = 0,
      Ground:integer = 0; 
end;

private class TExecFunSaveChkParm( )
  // Парамерты платежа
  var pm_paym:TRecHandler;
  var debet:TRecHandler;
  var credit:TRecHandler;
  var rm:TRecHandler;
  
  var PaymentObj:RsbPayment; 
  // Поля панели
  var flds:TPanelFields;
  
  // Буфера счетов (чтобы не искать каждый раз)
  var PayerAccount = null;
  var ReceiverAccount = null;
  
  // Буфера счетов разноски
  var PIAccounts:TArray = TArray();

end;

// Класс ошибки
private class TError( _stat:integer, _msg:string , _fld:integer)
  var stat:integer = _stat; // Серьезность ошибки
  var msg:string = _msg;    // Сообщение
  var fld:integer;          // Поле в которое перемещаемся
  
  if(_fld != null )
    fld = _fld;
  else
    fld = 0;
  end;
end;

private class (TExecFunPIParm)TExecFunSaveChkPIParm( _prm:TExecFunSaveChkParm, _err:TArray, _func:variant, _Side:integer )
  var err/*:TArray*/ = _err;
  var prm:TExecFunSaveChkParm = _prm;
  var func:variant = _func;
  var Side:integer = _Side;
  var i:integer = 0; // Порядковый номер записи разноски
  InitTExecFunPIParm();
end;

private macro GetMsg(err:TError)
  return err.msg;
end;

private class TExecFunSaveChk( _prm:TExecFunSaveChkParm )

  var prm:TExecFunSaveChkParm = _prm;

  var ChkFun:TArray = TArray();
  var Errors:TArray = TArray();

  macro AddChk(Fun:variant)
    ChkFun[ChkFun.size] = Fun;
  end;

  macro ShowAllErrors()
    msgbox(join( map( Errors, @GetMsg ), ".|" ));
  end;
  
  macro ShowWarning(msg:string)
    Array Text, Buttons;
    Text(0) = msg;
    Buttons( 0 ) = "Cохранить";
    Buttons( 1 ) = "Продолжить редактирование";
    return IfThenElse(ConfWin( Text, Buttons ) == 0, NOTERROR, ERROR);
  end;

  macro Execute()
    if(ChkFun.size == 0)
      return NOTERROR;
    end;

    var i = 0;

    // Выполним все проверки
    while( i < ChkFun.size )
      if(not ExecMacro( ChkFun[i], prm, Errors ))
        msgbox("Не найдена процедура в макросе pm_chksave.mac: " + ChkFun[i]);
        return ERROR;
      end;
      i = i + 1;
    end;
  
    // Если есть хоть одна ERROR, то выводим список ошибок и отваливаем
    i = 0;
    while(i < Errors.size)
      if(Errors[i].stat == ERROR)
        ShowAllErrors();
        //Gurin S. 16.05.2014 R-378411-2 --2031
        if (not ((prm.pm_paym.rec.dockind == 201) and (prm.pm_paym.rec.origin != 1) and (Errors[i].msg == "Счет получателя не найден")))
            return Errors[i].fld + 1; // Увеличиваем на 1, так как реальная нумерация полей начинается с 0.
        end;
      end;
      i = i + 1;
    end;

    // Если нет ERROR, то по одному предупреждению выводим и спрашиваем
    // как дальше жить
    i = 0;
    while(i < Errors.size)
      if(Errors[i].stat == WARNING)
        if(ShowWarning(Errors[i].msg) == ERROR)
          return Errors[i].fld + 1; // Увеличиваем на 1, так как реальная нумерация полей начинается с 0.
        end;
      end;
      i = i + 1;
    end;

    return NOTERROR;
  end;

end;

// 1. Наличие номера документа
private macro CheckNumber( prm:TExecFunSaveChkParm, err:TArray )
  // Номер документа должен быть задан
  if(prm.rm.rec.Number == "")
    err[err.size] = TError(ERROR, "Номер документа должен быть задан", prm.flds.Number);
  end;
end;

// 2. Допустимость номера документа для РКЦ
private macro CheckNumberForRKC( prm:TExecFunSaveChkParm, err:TArray )
  if( (prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL) and not prm.debet.rec.IsSender
      or
      (prm.credit.rec.Group == PAYMENTS_GROUP_EXTERNAL) and not prm.credit.rec.IsSender
    )
    if( int( GetLastSymbols(prm.rm.rec.Number, PM_DOCNO_NONZERO_LEN) ) == 0 )
      err[err.size] = TError(ERROR, "Шесть последних разрядов номера должны быть отличны от '000000'", prm.flds.Number);
    end;
  end;
end;

// 5. Наличие суммы платежа
private macro CheckBaseAmount( prm:TExecFunSaveChkParm, err:TArray )
  // Сумма платежа > 0
  if(prm.pm_paym.rec.BaseAmount <= $0)
    err[err.size] = TError(ERROR, "Сумма платежа должна быть больше нуля", prm.flds.BaseAmount);
  end;
end;

// 6. Валюта платежа
// Все три валюты заданы и имеются в справочнике финансовых инструментов
private macro CheckSaveFIID( prm:TExecFunSaveChkParm, err:TArray )
  if( (prm.PaymentObj.PIList(PRT_Debet).Size == 0) and (CheckFIID( prm.pm_paym.rec.FIID ) != 0) )
    err[err.size] = TError(ERROR, "Валюта плательщика должна быть задана", prm.flds.FIID);
  end;
  
  if( CheckFIID( prm.pm_paym.rec.BaseFIID ) != 0 )
    err[err.size] = TError(ERROR, "Базовая валюта платежа должна быть задана", prm.flds.BaseFIID);
  end;
  
  if( (prm.PaymentObj.PIList(PRT_Credit).Size == 0) and (CheckFIID( prm.pm_paym.rec.PayFIID ) != 0) )
    err[err.size] = TError(ERROR, "Валюта получателя должна быть задана", prm.flds.PayFIID);
  end;
end;

// 7. Курс валюты платежа
// Курс трёх валют платежа на дату значения может быть определен
private macro CheckSaveRate( prm:TExecFunSaveChkParm, err:TArray )
  
  if((prm.pm_paym.rec.FIID != ALLFININSTR) and (CheckRateForDate( prm.pm_paym.rec.FIID, prm.pm_paym.rec.ValueDate ) != 0))
    err[err.size] = TError(ERROR, "Не найден курс валюты плательщика");
  end;
  
  if( (prm.pm_paym.rec.BaseFIID != ALLFININSTR) and (CheckRateForDate( prm.pm_paym.rec.BaseFIID, prm.pm_paym.rec.ValueDate ) != 0) )
    err[err.size] = TError(ERROR, "Не найден курс базовой валюты платежа");
  end;
  
  if( (prm.pm_paym.rec.PayFIID != ALLFININSTR) and  (CheckRateForDate( prm.pm_paym.rec.PayFIID, prm.pm_paym.rec.ValueDate ) != 0) )
    err[err.size] = TError(ERROR,  "Не найден курс валюты получателя");
  end;

end;

// 8. Очередность 
// Очередность задана и находится в интервале от 0 до 6.
private macro CheckSavePriority( prm:TExecFunSaveChkParm, err:TArray )
  if( CheckPriority( prm.rm.rec.Priority, prm.pm_paym.rec.DocKind ) != 0 )
    err[err.size] = TError(ERROR, "Очередность должна находиться в интервале от 0 до " + PM_DefaultMaxPriority(), prm.flds.Priority);
  end;
end;

// 9. Номер пачки  
// Номер пачки не отрицательный
private macro CheckSaveNumberPack( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.pm_paym.rec.NumberPack < 0 )
    err[err.size] = TError(ERROR, "Номер пачки должен быть положительный либо равен 0", prm.flds.NumberPack);
  end;
end;

// 10. Дата документа
// Дата документа задана
private macro CheckSaveDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.rm.rec.Date == date(0,0,0) )
    err[err.size] = TError(ERROR, "Дата документа должна быть задана", prm.flds.rmDate);
  end;
end;

// 11. Дата платежа (pmrmprop.PayDate)
// Дата платежа <= дате опердня, в котором проводится операция.
private macro CheckSavePayDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.pm_paym.rec.ValueDate < prm.rm.rec.PayDate )
    err[err.size] = TError(ERROR, "Дата составления документа не может быть больше даты значения", prm.flds.PayDate);
  end;
end;

// 12. Дата значения (pmpaym.ValueDate)  
// Если настройка реестра CB\PAYMENTS\CheckValueDate имеет значение "Yes", 
// то в начальном филиале платежа есть операционный день, соответствующий дате значения 
private macro CheckSaveValueDate( prm:TExecFunSaveChkParm, err:TArray )
  if( needCheckValueDate() and
      not existsOperDay(prm.pm_paym.rec.ValueDate, prm.pm_paym.rec.StartDepartment) )
    err[err.size] = TError(ERROR, "Нет операционного дня с указанной датой значения", prm.flds.ValueDate);
  end;
end;

// Дата поступления в банк плательщика

private macro CheckSavePayerBankEnterDate( prm:TExecFunSaveChkParm, err:TArray )
//LAO адаптация макроса хф 22
  //if( prm.pm_paym.rec.PayerBankEnterDate == date(0,0,0) )
  //  err[err.size] = TError(ERROR, "Не задана дата поступления в банк плательщика", prm.flds.PayerBankEnterDate);
 // end;
  if( needCheckPayerBankEnterDate() and
      not existsOperDay(prm.pm_paym.rec.PayerBankEnterDate, prm.pm_paym.rec.StartDepartment) )
    err[err.size] = TError(ERROR, "Нет операционного дня с указанной датой поступления документа в банк плательщика", prm.flds.PayerBankEnterDate);
  end;
  if( prm.pm_paym.rec.ValueDate < prm.pm_paym.rec.PayerBankEnterDate )
    err[err.size] = TError(ERROR, "Дата поступления в банк плательщика не может быть больше даты значения", prm.flds.PayerBankEnterDate);
  end;
end;

// Есть баланс в дату значения
private macro CheckSaveValueDateIsBalance( prm:TExecFunSaveChkParm, err:TArray )
  var ServiceKind, Balance;
  if( not GetDateAttr( prm.pm_paym.rec.ValueDate, ServiceKind, Balance, prm.pm_paym.rec.Department ) )
    if( Balance == CALENDAR_BALANCE_NO )
      err[err.size] = TError(ERROR, "Невозможно исполнение платежа указанной датой значения", prm.flds.ValueDate);
    end;
  else
    err[err.size] = TError(ERROR, "В календаре не найдена указанная дата значения", prm.flds.ValueDate);
  end;
end;

// ДПП
private macro CheckSaveTransferDate( prm:TExecFunSaveChkParm, err:TArray )
  var pmprop : TRecHandler = TRecHandler("pmprop.dbt");
  if( not prm.debet.rec.IsSender and (prm.debet.rec.Group == PAYMENTS_GROUP_EXTERNAL) )
    Copy(pmprop, prm.debet);
  elif( not prm.credit.rec.IsSender and (prm.credit.rec.Group == PAYMENTS_GROUP_EXTERNAL) )
    Copy(pmprop, prm.credit);
  else
    return;
  end;

  if( pmprop.rec.TransferDate == date(0,0,0) )
    err[err.size] = TError(WARNING, "Не задана исходящая ДПП", prm.flds.TransferDate);
  end;

  //Gurin S. 08.12.2014 Адаптация HF2031_19_25_110
  /*var cors : TRecHandler = TRecHandler("corschem.dbt");
  if( FindCorschem(cors, pmprop.rec.Corschem, pmprop.rec.PayFIID) == 0 )
    //Gurin S. 15.05.2014
    //if( not existsOperDay(pmprop.rec.TransferDate, cors.rec.Department) )
    //  err[err.size] = TError(WARNING, "Нет операционного дня с указанной исходящей ДПП", prm.flds.TransferDate);
    //end;
    if( IsWorkDayBranch(pmprop.rec.TransferDate, cors.rec.Department) != 1 )
      err[err.size] = TError(WARNING, "Указанная исходящая ДПП не является рабочим банковским днем в филиале схемы расчетов", prm.flds.TransferDate);
    end;
  end;*/

  if( pmprop.rec.TransferDate < prm.pm_paym.rec.ValueDate )
    err[err.size] = TError(WARNING, "Исходящая ДПП не может быть меньше даты значения", prm.flds.TransferDate);
  end;
  
end;

// Дата приема
private macro CheckSaveClientDate( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.rm.rec.ClientDate != date(0,0,0) )
    //zmp 26.11.2014 R-501756-2
    //if( not existsOperDay(prm.rm.rec.ClientDate, prm.pm_paym.rec.EndDepartment) )
    //  err[err.size] = TError(ERROR, "Нет операционного дня с указанной датой приема", 0);
    //end;
    // zmp 23.09.2014 R-456494-2 еще как может, убираю
    //if( prm.rm.rec.ClientDate > prm.pm_paym.rec.ValueDate )
    //  err[err.size] = TError(ERROR, "Дата приема не может быть больше даты значения", 0);
    //end;
  end;
end;

// Текущая дата документа
private macro CheckSaveCurrentDate( prm:TExecFunSaveChkParm, err:TArray )

 /* EVG 24/1/2014 # 206158.*/
  if( prm.pm_paym.rec.DocKind == 70 )
    prm.rm.rec.Date = prm.pm_paym.rec.ValueDate;
  end;

  if( prm.rm.rec.Date != prm.pm_paym.rec.ValueDate )
    err[err.size] = TError(ERROR, "Дата документа должна быть равна дате значения", prm.flds.rmDate);
  end;
end;

//-------------------------------------------------
// Утилитные функции для проверки счетов
//-------------------------------------------------
// Подкачка буферов счетов
private macro PumpAccount(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  
  var Account_buf:TRecHandler = TRecHandler("account.dbt");

  if((AccStr == "") or AccountIsMask( AccStr ))
    Account_buf = null;
  else
    if(pi != null)
      if(not PM_GetAccountRecord( pi.rec.Account, pi.rec.FIID, pi.rec.Chapter, Account_buf ))
        Account_buf = null;
      end;
    elif(not PM_GetAccountRecord( AccStr, IfThenElse(Side == PRT_Debet, prm.pm_paym.rec.FIID, prm.pm_paym.rec.PayFIID), prm.pm_paym.rec.Chapter, Account_buf ))
      Account_buf = null;
    end;
  end;

  if(pi != null)
    prm.PIAccounts[prm.PIAccounts.size] = Account_buf;
  elif(Side == PRT_Debet)
    prm.PayerAccount = Account_buf;
  elif(Side == PRT_Credit)
    prm.ReceiverAccount = Account_buf;
  end;
end;

macro pmchksave_CheckSavePIAccounts( piprm:TExecFunSaveChkPIParm )
  if(piprm.prm.PIAccounts.size > piprm.i)
    if(not ExecMacro(piprm.func, piprm.prm, piprm.i, piprm.Side, piprm.pi.rec.Account, piprm.prm.PIAccounts[piprm.i], piprm.pi, piprm.err))
      msgbox("Не найдена процедура в макросе pm_chksave.mac: " + piprm.func);
      return ERROR;
    end;
  else
    if(not ExecMacro(piprm.func, piprm.prm, piprm.i, piprm.Side, piprm.pi.rec.Account, null, piprm.pi, piprm.err))
      msgbox("Не найдена процедура в макросе pm_chksave.mac: " + piprm.func);
      return ERROR;
    end;
  end;
  piprm.i = piprm.i + 1;
  return NOTERROR;
end;

private macro GetNameAccFromErr(Side:integer, pi:TRecHandler)
  
  if(pi == null)
    if(Side == PRT_Debet)
      return "Счет плательщика ";
    else
      return "Счет получателя ";
    end;
  else
    if(pi.rec.Account == "")
      return "Счет разноски: ";
    else
      return "Счет разноски " + pi.rec.Account + ": ";
    end;
  end;

end;

// check_future - проверку выполнять для текущего счета дебета
private macro CheckSavePayerAccount( prm:TExecFunSaveChkParm, err:TArray, func:variant, check_future:bool )
  
  if(prm.PaymentObj.PIList(PRT_Debet).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Debet, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, err, func, PRT_Debet ));
  else
    var AccStr = "",
        AccRec : TRecHandler = TRecHandler("account.dbt");
    if(check_future)
      AccStr = prm.pm_paym.rec.FuturePayerAccount;
      if(not PM_GetAccountRecord( AccStr, prm.pm_paym.rec.FIID_FuturePayAcc, prm.pm_paym.rec.Chapter, AccRec ))
        AccRec = null;
      end;
    else
      AccStr = prm.pm_paym.rec.PayerAccount;
      AccRec = prm.PayerAccount;
    end;
    ExecMacro2(func, prm, 0, PRT_Debet, AccStr, AccRec, null, err);
  end;

end;

// check_future - проверку выполнять для текущего счета кредита
private macro CheckSaveReceiverAccount( prm:TExecFunSaveChkParm, err:TArray, func:variant, check_future:bool )
  
  if(prm.PaymentObj.PIList(PRT_Credit).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Credit, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, err, func, PRT_Credit ));
  else
    if(not prm.PaymentObj.isExternal) //zmp 06.08.2014 I-00506882
        var AccStr = "",
           AccRec : TRecHandler = TRecHandler("account.dbt");
        if(check_future)
           AccStr = prm.pm_paym.rec.FutureReceiverAccount;
           if(not PM_GetAccountRecord( AccStr, prm.pm_paym.rec.FIID_FutureRecAcc, prm.pm_paym.rec.Chapter, AccRec ))
              AccRec = null;
           end;
        else
           AccStr = prm.pm_paym.rec.ReceiverAccount;
           AccRec = prm.ReceiverAccount;
        end; 
        ExecMacro2(func, prm, 0, PRT_Credit, AccStr, AccRec, null, err);
    end;
    
  end;

end;

// Наличие счета
// Счет задан 
private macro CheckSaveAccountSetComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  
  if(AccStr == "")
    err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "должен быть задан", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  end;

end;

// 19. Наличие счета плательщика 
// Счет плательщика задан 
private macro CheckSavePayerAccountSet( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountSetComm" );
end;


// 20. Допустимость счета плательщика
private macro CheckSavePayerAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  /*if((AccStr != "") and (prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL))
    if(Account == null)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    elif((Account.rec.Open_Close == "З") and (Account.rec.Close_Date <= prm.pm_paym.rec.ValueDate))
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "закрыт с " + Account.rec.Close_Date, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;*/

  if(AccStr)
    var BIC = "";
    if(prm.debet.rec.CodeKind == PTCK_BIC)
      BIC = prm.debet.rec.BankCode;
    else
      BIC = ПолучитьКодСубъекта (prm.pm_paym.rec.PayerBankID, PTCK_BIC, NULL, 1);
    end;
  
    var AccKey = GetKey( AccStr, BIC );
  
    if( AccKey != AccStr )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "неверный ключ. Должен быть " + SubStr(AccKey, 9, 1), IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSavePayerAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSavePayerAccountOkComm" );
end;

//Счет плательщика соответствует формату 302-П ЦБ РФ    
private macro CheckSaveAccountIs302P( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )
  
  if(AccStr != "")
    if( IsNotFormat302P( AccStr ) )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не соответствует формату 385-П ЦБ РФ", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSavePayerAccountIs302P( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountIs302P" );
end;

//Счет плательщика не является маской
private macro CheckSaveAccountIsMask( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )

  if(AccStr != "")
    if( AccountIsMask( AccStr ) )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не может быть маской", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSavePayerAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountIsMask" );
end;

// 21. Разрешение операции по счету плательщика
private macro CheckSavePayerAccountOprComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if(Account == null)
    err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  elif( (prm.pm_paym.rec.DocKind != PS_INRQ) and 
        (Account.rec.Open_Close == "З")      and 
        (Account.rec.Close_Date <= IfThenElse( EditFromHistScrol , {curdate}, prm.rm.rec.Date))
      )
    err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "закрыт с " + Account.rec.Close_Date, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
  end;
  
  if(Account != null)
    if(Index(Account.rec.Type_Account, "Т"))
      err[err.size] = TError(WARNING, GetNameAccFromErr(Side, pi) + "запрещена операция дебета", IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    elif(prm.pm_paym.rec.ValueDate <= Account.rec.DateNoChange)
      err[err.size] = TError(WARNING, GetNameAccFromErr(Side, pi) + "наложен запрет проводок до " + Account.rec.DateNoChange, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSavePayerAccountOpr( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSavePayerAccountOprComm" );
end;

// 22. Наличие наименования плательщика
private macro CheckSavePayerNameSet( prm:TExecFunSaveChkParm, err:TArray )
  if((prm.PaymentObj.PIList(PRT_Debet).Size == 0) and (prm.rm.rec.PayerName == ""))
    err[err.size] = TError(ERROR, "Наименование плательщика должно быть задано", prm.flds.PayerName);
  end;
end;

// 23. Допустимость наименования плательщика
private macro CheckSavePayerNameOk( prm:TExecFunSaveChkParm, err:TArray )
  if( StrLen(prm.rm.rec.PayerName) > 160 )
    err[err.size] = TError(WARNING, "Наименование плательщика превышает 160 символов", prm.flds.PayerName);
  end;
end;

//Счет получателя соответствует формату 302-П ЦБ РФ   
private macro CheckSaveReceiverAccountIs302P( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountIs302P" );
end;

//Счет получателя не является маской
private macro CheckSaveReceiverAccountIsMask( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountIsMask" );
end;

// 29. Допустимость счета получателя
private macro CheckSaveReceiverAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if( (AccStr != "") and (not PM_AllowUnknownReceiverAccount(prm.pm_paym)) )

    var BIC = "";
    if(prm.credit.rec.CodeKind == PTCK_BIC)
      BIC = prm.credit.rec.BankCode;
    else
      BIC = ПолучитьКодСубъекта (prm.pm_paym.rec.ReceiverBankID, PTCK_BIC, NULL, 1);
    end;
    
    var AccKey = GetKey( AccStr, BIC );
      
    if( AccKey != AccStr )
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "неверный ключ. Должен быть " + SubStr(AccKey, 9, 1), IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;

  end;
end;

private macro CheckSaveReceiverAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveReceiverAccountOkComm" );
end;


// 30. Разрешение зачисления на счет получателя
private macro CheckSaveReceiverAccountOprComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if( (Account != null) and (not PM_AllowUnknownReceiverAccount(prm.pm_paym)) )
    if(Index(Account.rec.Type_Account, "У"))
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "запрещена операция кредита", IfThenElse(pi == NULL, prm.flds.ReceiverAccount, 0));
    elif(prm.pm_paym.rec.ValueDate <= Account.rec.DateNoChange)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "наложен запрет проводок до " + Account.rec.DateNoChange, IfThenElse(pi == NULL, prm.flds.PayerAccount, 0));
    end;
  end;
end;

private macro CheckSaveReceiverAccountOpr( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveReceiverAccountOprComm" );
end;

// 33. Наличие назначения платежа
private macro CheckSaveGround( prm:TExecFunSaveChkParm, err:TArray )
  if(prm.rm.rec.Ground == "")
    err[err.size] = TError(ERROR, "Назначение платежа должно быть задано", prm.flds.Ground);
  end;
end;

// 40. Счет плательщика не счет МФР
private macro CheckSaveAccountMFRComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if( (Account != null) and PM_AccountIsMFR( Account.rec.Account, Account.rec.Chapter, Account.rec.Code_Currency) )
    err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не должен быть счетом МФР", IfThenElse(pi == NULL, IfThenElse(Side == PRT_Credit, prm.flds.ReceiverAccount, prm.flds.PayerAccount), 0));
  end;
end;

private macro CheckSavePayerAccountMFR( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveAccountMFRComm" );
end;

// 41. Счет получателя не счет МФР
private macro CheckSaveReceiverAccountMFR( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountMFRComm" );
end;


// 43. Наличие счета получателя или разноски по кредиту
// (Счет получателя задан и не является маской) или существует разноска по кредиту у платежа
private macro CheckSaveReceiverAccountOrAddPiSet( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveAccountSetComm" );
end;

// 44. Проверка наличия счета получателя для платежа с разноской по дебету
private macro CheckSaveReceiverAccountWithAddPI( prm:TExecFunSaveChkParm, err:TArray )
  if((prm.PaymentObj.PIList(PRT_Debet).Size > 0) and (prm.pm_paym.rec.ReceiverAccount == ""))
    err[err.size] = TError(ERROR, "Платеж с разноской по дебету, не может быть обработан без счета получателя", prm.flds.ReceiverAccount);
  end;
end;

/**
 * 53. Допустимость списания со счета плательщика (ограничение операций по спец. банковским счетам)
 */

private macro _AllReceiverAccountsAreClient_One( overallResult:bool, acc:TRecHandler ):bool
  return overallResult and ( not PM_IsBankAccount( acc.rec.Account, acc.rec.Code_Currency, acc.rec.Chapter ) );
end;

private macro _CheckAllReceiverAccountsAreClient( prm:TExecFunSaveChkParm ):bool
  if( not prm.PaymentObj.PIList( PRT_Credit ).size )
    return ( not PM_IsBankAccount( prm.pm_paym.rec.ReceiverAccount, prm.pm_paym.rec.PayFIID, prm.pm_paym.rec.Chapter ) );
  else
    return reduce( prm.PIAccounts, @_AllReceiverAccountsAreClient_One, true );
  end;
end;

private macro CheckSaveSpecialPayerAccount_One( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )
  if( ( Account != null ) and ( Index( Account.rec.Type_Account, "Я" ) ) )
    if( InList( prm.pm_paym.rec.DocKind, CASH_PS_OUTORDER, CASH_BOF_OUTORDER, DLDOC_INOUTORDER) )
      err[err.size] = TError( WARNING, "Счет " + AccStr + " является специальным банковским.|Расходные кассовые операции по специальным банковским счетам не допускаются.", prm.flds.PayerAccount );
    elif( not _CheckAllReceiverAccountsAreClient( prm ) )
      err[err.size] = TError( WARNING, "Счет " + AccStr + " является специальным банковским.|Списание средств с таких счетов на счета, принадлежащие банку, не допускается.", prm.flds.PayerAccount );
    end;
  end;
end;

private macro CheckSaveSpecialPayerAccount( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL )
    CheckSavePayerAccount( prm, err, "CheckSaveSpecialPayerAccount_One" );
  end;
end;

/**
 * 54. Допустимость зачисления на счет получателя (ограничение операций по спец. банковским счетам)
 */

private macro _AllPayerAccountsAreSpecial_One( overallResult:bool, acc:TRecHandler ):bool
  return overallResult and ( Index( acc.rec.Type_Account, "Я" ) > 0 );
end;

private macro _CheckAllPayerAccountsAreSpecial( prm:TExecFunSaveChkParm ):bool
  if( not prm.PaymentObj.PIList( PRT_Debet ).size )
    if( prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL )
      return ( Index( prm.PayerAccount.rec.Type_Account, "Я" ) > 0 );
    else
      return PM_ExternalAccountIsSpecial( prm.pm_paym.rec.PayerAccount );
    end;
  else
    return reduce( prm.PIAccounts, @_AllPayerAccountsAreSpecial_One, true );
  end;
end;

private macro CheckSaveSpecialReceiverAccount_One( prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray )
  if( ( Account != null ) and ( Index( Account.rec.Type_Account, "Я" ) ) )
    /* Все счета по дебету тоже должны быть спецбанковскими */
    if( not _CheckAllPayerAccountsAreSpecial( prm ) )
      err[err.size] = TError( WARNING, "Счет получателя " + AccStr + " является специальным банковским.|Допускается зачисление на средств на такой счет только с другого специального банковского счета.", prm.flds.ReceiverAccount );
    end;
  end;
end;

private macro CheckSaveSpecialReceiverAccount( prm:TExecFunSaveChkParm, err:TArray )
  if( prm.credit.rec.Group == PAYMENTS_GROUP_INTERNAL )
    CheckSaveReceiverAccount( prm, err, "CheckSaveSpecialReceiverAccount_One" );
  end;
end;


// 55. Допустимость текущего счета дебета
private macro CheckSaveFuturePayerAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if(AccStr != "")
    if(Account == null)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден");
    end;
  end;
end;

private macro CheckSaveFuturePayerAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSavePayerAccount( prm, err, "CheckSaveFuturePayerAccountOkComm", true );
end;

// 56. Допустимость текущего счета кредита
private macro CheckSaveFutureReceiverAccountOkComm(prm:TExecFunSaveChkParm, i:integer, Side:integer, AccStr:string, Account:TRecHandler, pi:TRecHandler, err:TArray)
  if(AccStr != "")
    if(Account == null)
      err[err.size] = TError(ERROR, GetNameAccFromErr(Side, pi) + "не найден");
    end;
  end;
end;

private macro CheckSaveFutureReceiverAccountOk( prm:TExecFunSaveChkParm, err:TArray )
  CheckSaveReceiverAccount( prm, err, "CheckSaveFutureReceiverAccountOkComm", true );
end;

// 66. Проверка длины реквизитов
private macro initLen(Field: string, Len: integer, Name: string)
  var a= TArray(false, 3, 3);
  a[0] = Field;
  a[1] = Len;
  a[2] = Name;
  return a;
end;

private macro extractINN(InnKpp)
  var i = index(InnKpp, "/");
  if (i > 0)
    return SubStr(InnKpp, 0, i - 1);
  end;
  return InnKpp;
end;

private macro extractKPP(InnKpp)
  var i = index(InnKpp, "/");
  if (i > 0)
    return SubStr(InnKpp, i + 1);
  end;
  return "";
end;

macro CheckSave383PLength( pm_paym, debet, credit, rm )
  var checklen: bool;
  Array Text, Buttons;
  var pp;
  GetRegistryValue("CB\\PAYMENTS\\CHECKMAXLENATTR", V_BOOL, checklen, pp);
  if ((pp != 0) or checklen)
    var prm:TExecFunSaveChkParm = TExecFunSaveChkParm();
    
    if(pm_paym != null)
      prm.pm_paym = TRecHandler( "pmpaym.dbt" );
      Copy(prm.pm_paym, pm_paym);
    end;

    if(debet != null)
      prm.debet = TRecHandler( "pmprop.dbt" );
      Copy(prm.debet, debet);
    end;
    
    if(credit != null)
      prm.credit = TRecHandler( "pmprop.dbt" );
      Copy(prm.credit, credit);
    end;
    
    if(rm != null)
      prm.rm = TRecHandler( "pmrmprop.dbt" );
      Copy(prm.rm, rm);
    end;

    prm.PaymentObj = RsbPayment(pm_paym.PaymentID);

    // Заполняем буфера счетов плательщика и получателя
    if(prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL)
      PumpAccount(prm, 0, PRT_Debet, pm_paym.PayerAccount)
    end;
    
    if(prm.credit.rec.Group == PAYMENTS_GROUP_INTERNAL)
      PumpAccount(prm, 0, PRT_Credit, pm_paym.ReceiverAccount)
    end;

    var fields = TArray();

    //fields[fields.size] = initLen(prm.rm.rec.Number, 6, "Номер документа");
    fields[fields.size] = initLen(prm.rm.rec.PaymentKind, 1, "Вид платежа");
    fields[fields.size] = initLen(StrSubst(prm.pm_paym.rec.BaseAmount:0:2, ".",""), 18, "Сумма");//без разделителей
    fields[fields.size] = initLen(prm.rm.rec.PayerName, 160, "Наименование плательщика");
    fields[fields.size] = initLen(prm.pm_paym.rec.PayerAccount, 20, "Счет плательщика");
    if (prm.debet.rec.codeKind == 3)
      fields[fields.size] = initLen(prm.debet.rec.BankCode, 9, "БИК банка плательщика");
    end;
    fields[fields.size] = initLen(prm.rm.rec.PayerCorrAccNostro, 20, "Счет банка плательщика");
    if (prm.credit.rec.codeKind == 3)
      fields[fields.size] = initLen(prm.credit.rec.BankCode, 9, "БИК банка получателя");
    end;
    fields[fields.size] = initLen(prm.rm.rec.ReceiverCorrAccNostro, 20, "Счет банка получателя");
    fields[fields.size] = initLen(prm.rm.rec.ReceiverName, 160, "Наименование получателя");
    fields[fields.size] = initLen(prm.pm_paym.rec.ReceiverAccount, 20, "Счет получателя");
    fields[fields.size] = initLen(prm.rm.rec.Shifroper, 2, "Вид операции");
    fields[fields.size] = initLen(prm.rm.rec.Priority, 1, "Очередность платежа");
    fields[fields.size] = initLen(prm.rm.rec.Ground, 210, "Назначение платежа");

    if (prm.PaymentObj.DocKind == 201/*PS_PAYORDER*/)
      var PsPayOrder = RsbPsPayOrder(prm.PaymentObj.DocumentID);
      fields[fields.size] = initLen(PsPayOrder.AcceptTerm, 1, "Условие оплаты");
      fields[fields.size] = initLen(PsPayOrder.AcceptPeriod, 1, "Срок для акцепта");
    end;

    var payKind = prm.pm_paym.rec.ContentOperation;
    if ((prm.PaymentObj.PartPaymShifrMain == "16") and (
        (payKind == "ИР") or (payKind == "ИРЧО") or (payKind == "ЧИПО")))
      payKind = payKind + " " + string(prm.PaymentObj.PartPaymDateMain);
    end;
    fields[fields.size] = initLen(payKind, 16, "Содержание операции");

    fields[fields.size] = initLen(extractINN(prm.rm.rec.PayerINN), 12, "ИНН плательщика");
    fields[fields.size] = initLen(extractINN(prm.rm.rec.ReceiverINN), 12, "ИНН получателя");
    fields[fields.size] = initLen(prm.rm.rec.TaxAuthorState, 2, "Статус составителя документа");
    fields[fields.size] = initLen(extractKPP(prm.rm.rec.PayerINN), 9, "КПП плательщика");
    fields[fields.size] = initLen(extractKPP(prm.rm.rec.ReceiverINN), 9, "КПП получателя");
    fields[fields.size] = initLen(prm.rm.rec.BttTiCode, 20, "Код бюджетной классификации");
    fields[fields.size] = initLen(prm.rm.rec.OKATOCode, 11, "Код ОКАТО");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmGround, 2, "Основание налогового платежа");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmPeriod, 10, "Налоговый период");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmNumber, 15, "Номер налогового документа");
    fields[fields.size] = initLen(prm.rm.rec.TaxPmType, 2, "Тип налогового платежа");
    fields[fields.size] = initLen(prm.pm_paym.rec.PayerBankMarkDate, 10, "Отметки банка"); //без разделителей 8
    fields[fields.size] = initLen(prm.pm_paym.rec.ReceiverBankMarkDate, 10, "Отметки банка получателя");//без разделителей 8
    fields[fields.size] = initLen(prm.pm_paym.rec.PayerBankEnterDate, 10, "Поступ. в банк плат.");//без разделителей 8
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymNumber, 3, "№ ч. плат");
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymShifrMain, 2, "Шифр плат. документа");
  //  fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymNumMain, 6, "№ плат. док.");
    fields[fields.size] = initLen(prm.pm_paym.rec.PartPaymRestAmountMain, 18, "Сумма остатка платежа");

    var item: TArray, err = TArray();
    for( item, fields)
      if (strlen(item[0]) > item[1])
        err[err.size] = TError(WARNING, "Длина реквизита '"+item[2]+"' превышает "+item[1]+" символов.");
      end;
    end;
    if (err.size > 0)
      Text(0) = join( map( err, @GetMsg ), ".|" );
      Buttons( 0 ) = "Cохранить";
      Buttons( 1 ) = "Продолжить редактирование";
      return IfThenElse(ConfWin( Text, Buttons ) == 0, NOTERROR, ERROR);
    end;
  end;
  return NOTERROR;
end;

macro CheckMacroScrolCommon( flds:TPanelFields, checks:TArray, pm_paym, debet, credit, rm ):integer

  var prm:TExecFunSaveChkParm = TExecFunSaveChkParm();
  
  if(pm_paym != null)
    prm.pm_paym = TRecHandler( "pmpaym.dbt" );
    Copy(prm.pm_paym, pm_paym);
  end;

  if(debet != null)
    prm.debet = TRecHandler( "pmprop.dbt" );
    Copy(prm.debet, debet);
  end;
  
  if(credit != null)
    prm.credit = TRecHandler( "pmprop.dbt" );
    Copy(prm.credit, credit);
  end;
  
  if(rm != null)
    prm.rm = TRecHandler( "pmrmprop.dbt" );
    Copy(prm.rm, rm);
  end;

  if( flds == null )
    prm.flds = TPanelFields();
  else
    prm.flds = flds;
  end;

  prm.PaymentObj = RsbPayment(pm_paym.PaymentID);

  // Заполняем буфера счетов плательщика и получателя
  if(prm.debet.rec.Group == PAYMENTS_GROUP_INTERNAL)
    PumpAccount(prm, 0, PRT_Debet, pm_paym.PayerAccount)
  end;
  
  if(prm.credit.rec.Group == PAYMENTS_GROUP_INTERNAL)
    PumpAccount(prm, 0, PRT_Credit, pm_paym.ReceiverAccount)
  end;

  // Сохряняем в массиве счета разноски
  if(prm.PaymentObj.PIList(PRT_Debet).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Debet, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, null, "PumpAccount", PRT_Debet ) );
  elif(prm.PaymentObj.PIList(PRT_Credit).Size > 0)
    ExecFunForEachPIInList( prm.PaymentObj, PRT_Credit, null, @pmchksave_CheckSavePIAccounts, TExecFunSaveChkPIParm( prm, null, "PumpAccount", PRT_Credit ) );
  end;

  var exec:TExecFunSaveChk = TExecFunSaveChk(prm);
  var func:variant;
  for( func, checks )
    exec.AddChk( func );
  end;
  if(exec.ChkFun.size > 0)
    return exec.Execute();
  end;

  return 0;
end;

/**
 * Проверки для банковских ордеров
 */
macro BBBO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer

  var checks:TArray = TArray();
  
  checks[checks.size] = "CheckNumber";
  checks[checks.size] = "CheckBaseAmount";
  if(pm_paym.Purpose == PM_PURP_CBANKORDER)
    checks[checks.size] = "CheckSaveFIID";
    checks[checks.size] = "CheckSaveRate";
  end;
  checks[checks.size] = "CheckSavePriority";
  checks[checks.size] = "CheckSaveNumberPack";
  checks[checks.size] = "CheckSaveDate";
  checks[checks.size] = "CheckSavePayDate";
  checks[checks.size] = "CheckSaveValueDate";
  checks[checks.size] = "CheckSaveValueDateIsBalance";
  checks[checks.size] = "CheckSaveTransferDate";
  checks[checks.size] = "CheckSavePayerAccountSet";
  checks[checks.size] = "CheckSavePayerAccountOk";
  checks[checks.size] = "CheckSavePayerAccountOpr";    
  checks[checks.size] = "CheckSavePayerNameSet";
  checks[checks.size] = "CheckSaveReceiverAccountOk";
  checks[checks.size] = "CheckSaveReceiverAccountOpr";
  checks[checks.size] = "CheckSaveGround";
  checks[checks.size] = "CheckSavePayerAccountMFR";
  checks[checks.size] = "CheckSaveReceiverAccountMFR";
  checks[checks.size] = "CheckSaveReceiverAccountOrAddPiSet";
  checks[checks.size] = "CheckSaveReceiverAccountWithAddPI";
  checks[checks.size] = "CheckSaveSpecialPayerAccount";
  checks[checks.size] = "CheckSaveSpecialReceiverAccount";
  checks[checks.size] = "CheckSaveFuturePayerAccountOk";
  checks[checks.size] = "CheckSaveFutureReceiverAccountOk";

  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );

end;

/**
 * Проверки для рублёвых платежей РКО
 */
macro PSPO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm, pspayord ):integer
  var checks:TArray;
  if( pspayord.DocKind != PSPOKIND_CASH_REQUEST )
    checks = makeArray( "CheckSavePayerBankEnterDate",
                        "CheckSaveValueDateIsBalance",
                        "CheckSaveTransferDate",
                        "CheckNumberForRKC",
                        "CheckSavePayerAccountIs302P",
                        "CheckSaveReceiverAccountIs302P",
                        "CheckSaveSpecialPayerAccount",
                        "CheckSaveSpecialReceiverAccount",
                        "CheckSaveFuturePayerAccountOk",
                        "CheckSaveFutureReceiverAccountOk" );
  else
    checks = TArray();
  end;
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для валютных платежей РКО
 */
macro PSCP_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSavePayerBankEnterDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для рублёвых платежей банка
 */
macro BBBP_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSavePayerBankEnterDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckNumberForRKC",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для валютных платежей банка
 */
macro BBCP_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSavePayerBankEnterDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIsMask",
                                 "CheckSaveReceiverAccountIsMask",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для требований банка
 */
macro BBBC_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSaveValueDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSavePayerAccountOk",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для мемордеров
 */
macro BBMO_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSaveDate",
                                 "CheckSaveValueDate",
                                 "CheckSaveCurrentDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSaveReceiverAccountOk",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для инкассовых поручений к валютному счёту
 */
macro INRQ_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSavePayerBankEnterDate",
                                 "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSavePayerAccountIs302P",
                                 "CheckSaveReceiverAccountIs302P",
                                 "CheckSaveSpecialPayerAccount",
                                 "CheckSaveSpecialReceiverAccount",
                                 "CheckSaveFuturePayerAccountOk",
                                 "CheckSaveFutureReceiverAccountOk" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для кассовых документов
 */
macro CS_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray;
  if( InList( pm_paym.DocKind, CASH_PS_OUTORDER, CASH_BOF_OUTORDER, DLDOC_INOUTORDER ) )
    checks = makeArray( "CheckSavePayerAccountIs302P",
                        "CheckSaveReceiverAccountIs302P",
                        "CheckSaveSpecialPayerAccount",
                        "CheckSaveSpecialReceiverAccount" ,
                        "CheckSaveNumberPack",
                        "CheckSaveRate",               
                        "CheckSavePayerAccountOpr",
                        "CheckSavePayerNameOk",
                        "CheckSaveReceiverAccountOpr");
  else
    checks = TArray();
  end;
   // zmp  20.05.2014 I-488285 checks[ checks.size ] = "CheckSaveCurrentDate";
  checks[ checks.size ] = "CheckSaveValueDateIsBalance";
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;

/**
 * Проверки для входящих платежей
 */
macro RMIN_ScrolMacroCommonChecks( flds:TPanelFields, pm_paym, debet, credit, rm ):integer
  var checks:TArray = makeArray( "CheckSaveValueDateIsBalance",
                                 "CheckSaveTransferDate",
                                 "CheckSaveClientDate" );
  return CheckMacroScrolCommon( flds, checks, pm_paym, debet, credit, rm );
end;
