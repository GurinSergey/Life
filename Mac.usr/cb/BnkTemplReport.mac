import "or_tpl_h.mac", prpmbuff;

private var ObjTempl:CTemplateXLS = null;

class BnkTemplReport(nameTemplate:string)
  var m_nameTemplate:string = nameTemplate;
  var createObjTempl:bool = false;

  /**
   *   Метод создания отчета (для переопределения в наследнике)
   */
  macro Create()
  end;

  /**
   * Установить значение Val в поле с именем Name
   */
  macro SetVal( Name, Val )
    ObjTempl.SetValue_NameCell( Name, Val );
  end;

  /**
   * Аналог SetVal, но используется для множества значений
   */
  MACRO SetValues(/*CellName, CellValue, ...*/)
     VAR i = 1, CellName, CellValue;

     while( GetParm( i, CellName) AND GetParm( i + 1, CellValue) )
        ObjTempl.SetValue_NameCell( CellName , CellValue );
        CellValue = NULL;
        i = i + 2;
     end;
  END;


  /* EVG 4/03/2014 Метод для задания обрамления определенных имен */
  MACRO FormatSellLines( CellName )

     VAR i = 2, sz = 0, lines = TArray ;

     while( ( i < 5 ) and GetParm( i, lines( sz ) ))
        if( valType(lines( sz )) == V_UNDEF )
           lines( sz ) = 0;
        end;

        if( valType(lines( sz )) != V_INTEGER )
           msgbox( "Неправильное применение метода FormatSellLines()" );
        end;
        i = i + 1;
        sz = sz + 1;
     end;

     ObjTempl.SetDiapazon( CellName );
     ObjTempl.SetBorder( CellName, lines(0), lines(1), lines(2), lines(3) );

  END;


  /**
   *  Вывод строки в ячейки
   *  (каждую букву в отдельную ячейку)
   */
  macro SetValMultiCell(NameCell:string, Value:string, WCell:integer,LenCell:integer)
    ObjTempl.SetValueMultiCell( NameCell, Value, WCell,LenCell);
  end;

  /**
   *  Вывод строк в ячейки, аналог SetValMultiCell, но используется для множества значений
   *  (каждую букву в отдельную ячейку)
   */
  macro SetValuesMultiCell(/*NameCell:string, Value:string, WCell:integer,LenCell:integer, ...*/)
     VAR i = 1, NameCell:string, Value:string, WCell:integer,LenCell;

     while( GetParm( i, NameCell) AND GetParm( i + 1, Value) AND GetParm( i + 2, WCell) AND GetParm( i + 3, LenCell))
        ObjTempl.SetValueMultiCell( NameCell, Value, WCell,LenCell);
        i = i + 4;
     end;
  OnError( RslErrObj )
    msgbox(NameCell);
  end;


  /**
   *  Регистрация таблицы
   */
  macro RegisterTable(Name)
    return ObjTempl.RegisterTable(Name);
  end;

  /**
   * Установить название листа
   */
  macro SetSheetName(name:string)
    ObjTempl.SheetName(name);
  end;

  /**
   *  Печать
   */
  macro Print():bool

    if( ObjTempl == null )
      createObjTempl = true;
      ObjTempl = CTemplateXLS();
      ObjTempl.CreateTotalBook();
    end;

    if( not ObjTempl.OpenTemplate(m_nameTemplate) )
      return false;
    end;

    Create();
    ObjTempl.CopyAllSheetInTotalBook(null, true, null );
    ObjTempl.Close();
    
    if( (ObjTempl != null) and (createObjTempl == true))
      createObjTempl = false;
      ObjTempl.SaveTotalBook();
      ObjTempl = null;
    end;

    return true;
   
   OnError( RslErrObj )
      VAR Err = "Ошибка при выполнении отчета.\n";

      if( RslErrObj.Module != "" )
         Err = Err + "Модуль : " + RslErrObj.Module + "\n";
      end;

      if( RslErrObj.Line != 0 )
         Err = Err + "Строка : " + RslErrObj.Line + "\n";
      end;
                             
      if( RslErrObj.Message != "" )
         Err = Err + RslErrObj.Message + "\n";
      end;

      if( (ObjTempl != null) and (createObjTempl == true))
        createObjTempl = false;
        ObjTempl = null;
      end;

      MsgBox( Err );
      return false;
  end;
  /**
   *  Изменить текущий лист
   */
  macro SheetChange(_Sheet:variant, _FlagNoMessage:bool)
    ObjTempl.SheetChange(_Sheet, _FlagNoMessage);
  end;

end;

// Вызывается из сишника
macro WR_PrepPrintDocuments()
  ObjTempl = CTemplateXLS();
  ObjTempl.CreateTotalBook();
end;

// Вызывается из сишника
macro WR_PostPrintDocuments()
  ObjTempl.SaveTotalBook(NULL, not pr_PrintEA);
  ObjTempl = null;
end;
