//-----------------------------------------------------------------------------
// Блок     : 29018 - "Предобработка мемориального документа"
// Шаг      : 10    - "Проверка остатков по счетам"
// Описание : Макрос шага
//-----------------------------------------------------------------------------
// KS 02.12.2013 Перенос доработок в 31ю сборку
import pm_chkrst, cbsttls;
import pmsummo;

// Варианты ответов
private var Dlg_Ans_Carry   = " Оплатить ";
private var Dlg_Ans_InQueue = " В очередь ";
private var Dlg_Ans_Reject  = " Отвергнуть ";

private const Dlg_Var_Carry   :integer = 0;
private const Dlg_Var_InQueue :integer = 1;
private const Dlg_Var_Reject  :integer = 2;

//-----------------------------------------------------------------------------
// Выбрать направление движения
//-----------------------------------------------------------------------------
private macro PM_ChooseDirect( Account:string ):integer

  Array Text;
  Array Buttons;
  var DialogFlag = TSetDialogFlag(1);

  var select_button:integer = Dlg_Var_Carry;

  Text(0) = "К корсчету " + Account + " есть неоплаченные документы. Оплатить документ?";
  Buttons(0) = Dlg_Ans_Carry;
  Buttons(1) = Dlg_Ans_InQueue;
  Buttons(2) = Dlg_Ans_Reject;

  select_button = ConfWin( Text, Buttons );

  return select_button;
end;

/*macro CheckPIAccountRest( parm:TExecFunPIParm ):integer
  var PaymentObj:object = GenObject( "RsbPayment", parm.pi.rec.PaymentID );

  var Account:string = parm.pi.rec.Account;
  var FIID:integer = parm.pi.rec.FIID;
  var Sum:integer = parm.pi.rec.Amount;
  var MinLimit;
  debugbreak;
  // Проверить свободный остаток
  var Rest = AccGetFreeAmount( Account, CHAPT1, FIID, PaymentObj.Priority, PaymentObj.ClaimID, {curdate} );

  if( IsLoroAccount(Account, FIID) and GetLimits(Account, FIID, @MinLimit) )
    if( Rest - Sum > MinLimit )
      return 0;
    end;
  else
    if( Rest > Sum )
      return 0;
    end;
  end;

  return 1;
end;*/

private macro GetFreeAmountWithOver( Payment, chapter)

  var RestDebetFact; /* = AccGetFreeAmount( Payment.PayerAccount, chapter, Payment.PayerFIID, Payment.Priority, Payment.ClaimID, {curdate} );*/
/*SDA */
  AccGetFreeAmount( RestDebetFact, null, Payment.PayerAccount, chapter, Payment.PayerFIID, {curdate}, Payment.Priority, Payment.ClaimID); /* с учетом претензий */
  var cmd, rs, RestDebet;

/*
  if (Payment.PayerFIID != 0)
     cmd = RSDCommand("select t_planrest, t_type_account, t_limit from daccount$_dbt where t_chapter = ? and t_code_currency = ? and t_account = ?");
     cmd.addparam("chapt", RSDBP_IN, Payment.Chapter);
     cmd.addparam("fiid", RSDBP_IN, Payment.PayerFIID);
     cmd.addparam("acc" , RSDBP_IN, Payment.PayerAccount);
  else
     cmd = RSDCommand("select t_planrest, t_type_account, t_limit from daccount_dbt where t_chapter = ? and t_account = ?");
     cmd.addparam("chapt", RSDBP_IN, Payment.Chapter);
     cmd.addparam("acc", RSDBP_IN, Payment.PayerAccount);
  end;
*/
  cmd = RSDCommand("select rsi_rsb_account.planrestac(t_account,t_code_currency,?,t_chapter) t_planrest, " + "\n" +
                   "       t_type_account, " + "\n" +
                   "       rsi_rsb_account.GetAccLimit(t_account,t_chapter,t_code_currency,?) t_limit " + "\n" +
                   "  from daccount_dbt where t_chapter = ? and t_code_currency = ? and t_account = ?");
  cmd.addparam("restdate", RSDBP_IN, {curdate});
  cmd.addparam("bankdate", RSDBP_IN, {curdate});
  cmd.addparam("chapt"   , RSDBP_IN, Payment.Chapter);
  cmd.addparam("fiid"    , RSDBP_IN, Payment.PayerFIID);
  cmd.addparam("acc"     , RSDBP_IN, Payment.PayerAccount);

  rs = RSDRecordset(cmd);
  rs.MoveNext();
  RestDebet = money(rs.value(0));

  if (RestDebetFact < RestDebet)
     RestDebet = RestDebetFact; //возвращаем наименьший остаток
  end;

  if (index(rs.value("t_type_account"), "О")!=0)
     RestDebet = RestDebet + rs.value("t_limit");
  end;

  return RestDebet;

end;


private macro MO_CheckPayerAccount(Account, FIID, Amount,Payment:RsbPayment,obj:object):integer
var RestDebet;
  if( СчетПассивный(Account, obj.Chapter, FIID) and 
      ( not ЕстьПарныйСчет( Account, obj.Chapter, FIID ) ) )
    //Seleznev
    //    RestDebet = AccGetFreeAmount( Account, obj.Chapter,FIID, Payment.Priority, Payment.ClaimID, {curdate} );
    RestDebet = GetFreeAmountWithOver(Payment, obj.Chapter);
    if( RestDebet < Amount )
      if(RejectPayment(Payment, "Недостаточно средств для списания со счёта "+Account))
        return 1; //Ошибка отвержения
      end;
        msgbox( "Недостаточно средств для списания со счёта "+Account);
      return 0; //Успешно отвергли
    end;
  end;
    
  return 2;  //Если не отвергли, т.е. поверка прошла успешно
end;

private macro MO_CheckReceiverAccount(Account, FIID, Amount,Payment:RsbPayment,obj:object):integer
  var RestCredit:money,
      Rest:money;
/*  if( СчетАктивный( Account, Payment.Chapter, FIID ) and
      ( ( Payment.ToBackOffice == "" ) or ( Payment.NotForBackOffice == "X" ) ))
    if( not CheckReceiverAccount( Account, FIID, Amount, Payment.ValueDate ) )
      if(RejectPayment(Payment, "Недостаточно средств для зачисления"))
        return 1; //Ошибка отвержения
      end;
      msgbox( "Недостаточно средств для зачисления" );
      return 0; //Успешно отвергли
    end;
  end;*/
//Seleznev активный счет не проверяем

  return 2;  //Если не отвергли, т.е. поверка прошла успешно
end;

MACRO MO_CheckAccRest( Payment:RsbPayment ):integer

  var stat = 0;//:integer = PM_CheckAccRestCommon( Payment );
  var obj:object;
  var pmaddpi_rs;
  var ret;
  var RestDebet;
  var RestCredit;
  var Rest;
  var Direct, MinLimit;
  var AllowOverdraft : bool = true;

  if( (Payment.PIList(PRT_Debet).Size == 0) and IsLoroAccount(Payment.PayerAccount, Payment.PayerFIID) )
    if( (GetOprStatus(OPR_PAYM_PERMISSION) != OPR_PAYM_ST_PERMISSION_YES) and
        (GetClaimSum(Payment) != Payment.FuturePayerAmount) and
        (ДокументВочередь(Payment.FuturePayerAccount) == true) 
      )
      Direct = PM_ChooseDirect( Payment.FuturePayerAccount );
      if( Direct == Dlg_Var_InQueue )
        if( УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_PRIORITY ) )
          msgbox("Ошибка при установке сегментов статуса экземпляра операции");
          return 1;
        end;
        return 0;
      elif( Direct == Dlg_Var_Reject )
        RejectPayment(Payment, "Недостаточно средств для списания");
        return 0;
      end;
    end;

    // Если средств для оплаты недостаточно, то платеж не отвергать:
    // Установить сегмент "Документооборот" = "В очередь"
    if( CheckRestAndMakeReserve(Payment, AllowOverdraft, true, true, true, NULL, false, false, false) )
      if( УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_PRIORITY ) )
        msgbox("Ошибка при установке сегментов статуса экземпляра операции");
        return 1;
      end;
      return 0;
    end;
  else
    //Проверим остаток на счете плательщика  
    if( stat =  CheckRestAndMakeReserve(Payment, AllowOverdraft, true, true, true, NULL, false, false, false) )
      if(stat == MR_NOFREEAMOUNT)
        if(RejectPayment(Payment, "Недостаточно средств на счете плательщика"))
          return 1;
        end;
        return 0;
      else
        return 1;
      end;
    end;
  end;

  //Проверяем получателя
  if( Payment.PIList(PRT_Credit).Size > 0 ) 
    //Для сводных проверяем все счета разноски  
    var piList:TArray = Payment.PIList(PRT_Credit).asTArray();
    var pi:TRecHandler;
    for( pi, piList )
      if( ( ret = MO_CheckReceiverAccount( pi.rec.Account, pi.rec.FIID, pi.rec.Amount, Payment ) ) != 2 ) 
        return ret;
      end;
    end;
  else
    //Если не сводный или сумма получателя не распределённая (т.е. распределённая сумма у ПЛАТЕЛЬЩИКА - Payment.IsFixPayerAmount==false), 
    //то просто проверим остаток на счете получателя
    if( ( ret = MO_CheckReceiverAccount( Payment.FutureReceiverAccount, Payment.FutureReceiverFIID, Payment.FutureReceiverAmount, Payment ) ) != 2 )
      return ret;
    end;
  end;

  if( УстановитьСтатусыПлатежа( OPR_PAYM_DO, OPR_PM_ST_ENTER, OPR_PAYM_CABS, OPR_PM_ST_MFR_YES ) )
    msgbox("Ошибка при установке сегментов статуса экземпляра операции");
    return 1;
  end;

  return 0;

END;
