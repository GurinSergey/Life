/*********************************************************************************/
/*         Автоматизированная банковская система RS-Bank v5.1                    */
/*                 Copyright (c) R-Style Software Lab 2001                       */
/*                                                                               */
/*  Имя файла        : mccatacc.mac                                              */
/*                                                                               */
/*  Описание         : Фомирование номеров счетов для создания по категориям     */
/*                                                                               */
/*  Программист      : Азарцов В.В.                                              */
/*                                                                               */
/*  Создан           : //AV 20.02.01                                             */
/*                                                                               */
/*  Изменен          : 19.09.2013 Chesnokov D.S. Внесены изменения по C-22985    */
/*                     теперь счета использующие ПППППП учитывают 6-ть последних */
/*                     символов кода вида 1. Связано с переведением на 6-ти      */
/*                     нумерацию клиентов                                        */
/*********************************************************************************/
// KS 29.06.2012 C-12309 Нумерация. Изменение Категорий Учета
// KS 27.11.2013 Адаптация под 31ю сборку
IMPORT CTInter, FIInter, OprInter, PTInter, SFInter, BankInter, "globals.mac", "mccatacf.mac", rsd, "likepy.mac", oralib;

/*Номера символов из MCSTPELM_DBT*/
PRIVATE CONST MCSTPELM_SYMBOL_В = 1, /*Код валюты л/с;*/
              MCSTPELM_SYMBOL_Э = 2, /*Код эмитента (код вида "Код для л/с" эмитента)*/
              MCSTPELM_SYMBOL_Б = 3, /*Балансовый счет*/
              MCSTPELM_SYMBOL_А = 4, /*Код для л/с (вида "Код для л/с") векселедателя или акцептанта*/
              MCSTPELM_SYMBOL_Р = 5, /*код для л/с (вида "Код для л/с")" для торговой площадки (расчетного центра)*/
              MCSTPELM_SYMBOL_Г = 6, /*Код гарантийного обеспечения)*/
              MCSTPELM_SYMBOL_С = 7, /*Код сектора торговой площадки*/
              MCSTPELM_SYMBOL_Ф = 8, /*Номер филиала*/
              MCSTPELM_SYMBOL_К = 9, /*Защитный ключ*/
              MCSTPELM_SYMBOL_Л = 10, /*Код срочности*/
              MCSTPELM_SYMBOL_V = 11, /*Код финансового иструмента*/
              MCSTPELM_SYMBOL_U = 12, /*Код для л/с (вида "Код для л/с") клиента по счету*/
              MCSTPELM_SYMBOL_S = 13, /*Код клиента в БО ценных бумаг (22)*/
              MCSTPELM_SYMBOL_П = 14, /*Символы, заданные в маске шаблона номера*/
              MCSTPELM_SYMBOL_У = 15, /*Код л/с доходов/расходов*/
              MCSTPELM_SYMBOL_Н = 16, /*Номер договора/сделки (номер документа)*/
              MCSTPELM_SYMBOL_Д = 17, /*Код договора обслуживания клиента*/
              MCSTPELM_SYMBOL_D = 18, /*Код договора обслуживания банка*/
              MCSTPELM_SYMBOL_О = 19, /*Код для л/с (вида "Код для л/с") для владельца*/
              MCSTPELM_SYMBOL_М = 20, /*Код для л/с (вида "Код для л/с") для места хранения*/
              MCSTPELM_SYMBOL_W = 21, /*Номер вышестоящего документа данного первичного документа*/
              MCSTPELM_SYMBOL_F = 22, /*Код бэк-офиса*/
              MCSTPELM_SYMBOL_Е = 23, /*Код для л/с (вида "Код для л/с") (центра ответственности для субъекта*/
              MCSTPELM_SYMBOL_Х = 24, /*Код портфеля*/
              MCSTPELM_SYMBOL_Q = 25, /*День месяца даты картотеки*/
              MCSTPELM_SYMBOL_G = 26, /*Номер месяца даты картотеки*/
              MCSTPELM_SYMBOL_Т = 27, /*Год даты картотеки*/
              MCSTPELM_SYMBOL_Z = 28, /*Уникальный порядковый номер счета*/
              MCSTPELM_SYMBOL_R = 29, /*Код для л/с (вида "Код для л/с") для контрагента*/
              MCSTPELM_SYMBOL_I = 30, /*Код анкеты векселя*/
              MCSTPELM_SYMBOL_NUMBER = 31, /*Цифры*/
              /*MCSTPELM_SYMBOL_Y = 32, /*Схема переоценки*/ */
              MCSTPELM_SYMBOL_APOSTR = 33,/*Произвольные символы*/
              MCSTPELM_SYMBOL_FK= 34, /*Номер филиала-корреспондента*/
              MCSTPELM_SYMBOL_Ц= 35, /*Код вида договора ДУ*/
              MCSTPELM_SYMBOL_И= 36, /*Код договора ДУ (ИДДУ, ДП ОФБУ, ОУ ОФБУ) в номере л/счета*/
              MCSTPELM_SYMBOL_Ю= 37, /*Код ближайшего узла ТС, в котором есть хранилище ценностей */
              MCSTPELM_SYMBOL_N= 38, /*Вид финансового инструмента*/
              MCSTPELM_SYMBOL_Ъ= 39, /*Назначение счета (код из соотв. параметра)*/
              MCSTPELM_SYMBOL_L = 48, /*Уникальный порядковый номер счета*/
              MCSTPELM_SYMBOL_CODE_KA= 40, /*Код контрагента для срочных контрактов*/
              MCSTPELM_SYMBOL_CODE_REQ = 41, /*Код вида требований*/
              MCSTPELM_SYMBOL_FI_BUH = 42, /*Код вида ФИ для бухучета*/
              MCSTPELM_SYMBOL_Ч = 43, /*Код вида обязательств*/
              MCSTPELM_SYMBOL_CODE_DEB = 44, /*Код вида расходов ДУ*/
              MCSTPELM_SYMBOL_CODE_CRED = 45, /*Код вида доходов ДУ*/
              MCSTPELM_SYMBOL_ACCKIND = 46, /*Код вида счета*/
              MCSTPELM_SYMBOL_ACCFUN = 47, /*Код назначения счета*/
// 29.06.2012 KS C-12309 Ш - последние 5 символов Кода Клиента 1
/*Seleznev*/  MCSTPELM_SYMBOL_Ш = 1000, /*Код клиента (вида 101)*/
/* EVG  */    MCSTPELM_SYMBOL_J = 1002, /* Код подразделения ТС */
/* SDA  */    MCSTPELM_SYMBOL_Я = 1003, /* Объект договора - первые 5 символов */
/* SDA  */    MCSTPELM_SYMBOL_Й = 1004, /* Объект договора */
// KS 29.06.2012 C-12309 Добавил Ё - 7 символ кода 1 для клиента
/* KS   */    MCSTPELM_SYMBOL_Ё = 1005, /* 7 символ кода 1 для клиента */
//TAM 04.12.12 C-16005
              MCSTPELM_SYMBOL_Ж = 1006; //10 позиция в счете по К2


PRIVATE CONST DPRT_CODE_KIND = "COMMON\\КАТЕГОРИИ СРЕДСТВ\\ВИД_КОДА_ФИЛИАЛА";
PRIVATE CONST VSP_IN_CATACC  = "COMMON\\КАТЕГОРИИ СРЕДСТВ\\ВСП В КУ";

/*символ в который заключается часть маски, подставляемая в счет без изменений*/
PRIVATE CONST APOSTROPHE     = "\""; 

/*Нужно ключевать созданный счет */
PRIVATE VAR MC_NEED_GETKEY = false; 

PRIVATE VAR mctplelmCH = TBFile( "mctplelm.dbt", "R", 0 );
PRIVATE VAR mctplelmID = TBFile( "mctplelm.dbt", "R", 1 );

//TAM 05.12.12 C-16005
private macro GetAccOwner(account)
   var query, rs:RsdRecordset;
   query = "select t_client from daccount_dbt where T_ACCOUNT = '" + account + "'";
   rs = execSQLselect(query);
   if (rs.moveNext())
      return rs.value(0);
   else 
      return 0;
   end;
end;

private macro ChangeAcc(account)
   var key = int(Substr(account,10,1));
   if (key == 9) key = 0; end;
   return string(Substr(account,1,9) + string(key+1) + Substr(account,11));
end;
//end TAM C-16005

PRIVATE MACRO SayError( Categ:TRecHandler, Error:STRING, IsWarning:BOOL )
   if( IsWarning == null )
      Error = "Ошибка при формировании счета по категории \"" + categ.rec.Code + "\".|" + Error;
   end;

   if( isOprMultiExec == false )
      msgbox( Error );
   end;

   if( IsWarning == null )
      runerror( Error );
   end;
END;

PRIVATE MACRO GetSymbolByIDElement( CatID:INTEGER, IDElement:INTEGER )
   mctplelmID.Clear();
   mctplelmID.rec.CatID     = CatID;
   mctplelmID.rec.IDElement = IDElement;
   if( mctplelmID.GetEQ )
      return mctplelmID.rec.Symbol;
   end;
   return "";
END;

PRIVATE MACRO GetIDElementBySymbol( CatID:INTEGER, Symbol:STRING )
   mctplelmCH.Clear();
   mctplelmCH.rec.CatID  = CatID;
   mctplelmCH.rec.Symbol = Symbol;
   if( mctplelmCH.GetEQ )
      return mctplelmCH.rec.IDElement;
   end;
   return 0;
END;

/*сконвертить латинскую букву в русскую, если они одинаковы по написанию*/
PRIVATE MACRO ConvertSymb( Symb:STRING )
   var NumPos,
       LatStr = "ABCEHKMOPTX",
       RusStr = "АВСЕНКМОРТХ";

   NumPos = Index( LatStr, Symb );

   if( NumPos > 0 )
      return SubStr( RusStr, NumPos, 1 );
   end;
   return Symb;
END;

/*В верхний регистр и сконвертить в строке латинские буквы в русские (одинаковые по написанию)*/
PRIVATE MACRO ConvertString( SrcString:STRING )
   var i = 1, sym;

   SrcString = StrUpr( SrcString );
   sym = SubStr( SrcString, 1, 1 );
   while( sym )
      StrSet(SrcString, i, ConvertSymb(sym));
      i = i + 1;
      sym = SubStr(SrcString, i, 1)
   end;
   return SrcString;
END;

/*получить номер договора обслуживания*/
PRIVATE MACRO MC_GetContrNumber( id )
   var sfcontr = TRecHandler("sfcontr.dbt");
  
   if( SfGetContr( id, sfcontr ) )     
      return sfcontr.rec.AccCode;
   end;
   return "";
END;

/*  возвращает числовой код значения заданного справочника*/
PRIVATE MACRO MC_GetValueFlag( List, Element )
   var ll = TRecHandler("llvalues.dbt");      
   if( LL_FindLLVALUES( List, Element, ll ) == true )       
      return ll.rec.flag;
   end;    
   return 0; 
END;

/*найти значение классификатора*/
PRIVATE MACRO GetValueFromTempl(categ, templ, ClassNum)
   var value = -1;
   if (categ.rec.Class1 == ClassNum)
      value = templ.rec.Value1;
   elif (categ.rec.Class2 == ClassNum)
      value = templ.rec.Value2;
   elif (categ.rec.Class3 == ClassNum)
      value = templ.rec.Value3;
   elif (categ.rec.Class4 == ClassNum)
      value = templ.rec.Value4;
   elif (categ.rec.Class5 == ClassNum)
      value = templ.rec.Value5;
   elif (categ.rec.Class6 == ClassNum)
      value = templ.rec.Value6;
   elif (categ.rec.Class7 == ClassNum)
      value = templ.rec.Value7;
   elif (categ.rec.Class8 == ClassNum)
      value = templ.rec.Value8;
   end;

   return value;
END;

PRIVATE MACRO CreateStringL( PartyID, CatID )
   var query:string = "SELECT COUNT(1) + 1 "+
                      "   FROM dmcaccdoc_dbt mc"+
                      " WHERE mc.t_Contractor = :Contr"+
                      "   AND mc.t_CatID      = :CatID";

   var params:TArray = makeArray( SQLParam( "Contr", PartyID ),
                                 SQLParam( "CatID", CatID   )
                                 ); 
   
   var rs:RsdRecordset = execSQLselect( query, params, true );

   if( rs and rs.moveNext() )
      return  int( rs.value(0) );
   else
      return 0;
   end;
   
   ONERROR(x)
   MsgBox( "Ошибка получения порядкового номера счета для контрагента" + x.Message );
   return -1;
END;

PRIVATE MACRO GetIncerementChar1( PartyID, CatID )

   var query:string = "SELECT COUNT(1) + 1 "+
                      "   FROM dmcaccdoc_dbt mc"+
                      " WHERE mc.t_owner = :Owner"+
                      "   AND mc.t_CatID = :CatID";

   var params:TArray = makeArray( SQLParam( "Owner", PartyID ),
                                  SQLParam( "CatID", CatID   )
                                ); 

   var rs:RsdRecordset = execSQLselect( query, params, true );

   if( rs and rs.moveNext() )
      if (int( rs.value(0) ) > 9)
         Msgbox ("Порядковый номер счета по категории "+CatID+ " превышает 1 симол");
         return -1;
      else
         return  int( rs.value(0) );
      end;
   else
      return 0;
   end;
   
   ONERROR(x)
   MsgBox( "Ошибка получения порядкового номера счета для владельца" + x.Message );
   return -1;

END;


/* Получть уникальный порядковый номер счета*/
PRIVATE MACRO CreateStringZ( categ, SymbolZ, Account, accdoc )
  
   var i, len;
   var SqlMask, Symbol;
   var rs;
   var Z_From, Z_To;
   var QueryStr; 
   var subAcc, retVal;

   /* Установить нулевой счет - запрос вернул, что счета с походящей маской нет */
   PRIVATE MACRO SetNull( Account )
   var i, len;
   
   i = 0; len = strlen( Account );
   while( i < len )
      if( (SubStr(Account, i + 1, 1) == SymbolZ) )
         StrSet( Account, i + 1, "0" );
      end;

      i = i + 1;
   end;
    
   return Account;
end;

  /* Получить и вернуть следующий счет */
PRIVATE MACRO SetNextAccount( Account, MaxAccount );

   PRIVATE var i, curLenMaxZStr, curLenMaxAccount, N;
   PRIVATE var MaxZStr, Symbol;
   PRIVATE var NextValue : double;
   
   MaxZStr = MaxAccount;

   i = 0; curLenMaxZStr = 0; N = StrLen( MaxAccount );
   while( i < N )
      
      i = i + 1;
      /* в цифра у счета */
      if( Index("0123456789", SubStr(MaxAccount, i, 1)) )
        
         curLenMaxZStr = curLenMaxZStr + 1;

         StrSet( MaxZStr, curLenMaxZStr, SubStr(MaxAccount, i, 1) );
      end;
   end;

   MaxZStr = SubStr( MaxZStr, 1, curLenMaxZStr );

   NextValue = int(MaxZStr) + 1;

   MaxZStr = string( NextValue:0:0 );

   if( StrLen(MaxZStr) > curLenMaxZStr )
      SayError( Categ, "Невозможно сгенерировать подстановку шаблона" );
   end;

   i = 0; N = curLenMaxZStr - strlen( MaxZStr );
   while( i < N )
      MaxZStr = "0" + MaxZStr;
      i = i + 1;
   end;

   i = 0; curLenMaxZStr = 0; curLenMaxAccount = 0; N = StrLen( Account );
   while( i < N )
      i = i + 1;
      /* в этой позиции 'Z' у маски */
      if( SubStr(Account, i, 1) == SymbolZ )
         curLenMaxAccount = curLenMaxAccount + 1;
         Symbol = SubStr( MaxAccount, curLenMaxAccount, 1 );
         if( Index("0123456789", Symbol) )
            curLenMaxZStr = curLenMaxZStr + 1;
            Symbol = SubStr( MaxZStr, curLenMaxZStr, 1 );
         end;
         StrSet( Account, i, Symbol );
      end;
   end;
    
   return Account;
end;

/* *  Начало работы функции */
   if( Trim(accdoc.rec.Account) != "" )
      i = 0; len = strlen( Account );
      while( i < len )
         i = i + 1;
         if( SubStr(Account, i, 1) == SymbolZ )
            StrSet( Account, i, SubStr(accdoc.rec.Account, i, 1) );
         end;
      end;
      return Account;
   end;

   SqlMask = Account;

   Z_From = 0; Z_To = 0;

   i = 0; len = strlen( Account );
   while( i < len )
      i = i + 1;
      Symbol = SubStr( Account, i, 1 );
      if( (Symbol == SymbolZ) or (SubStr( categ.rec.Mask, i, 1 ) == GetSymbolByIDElement( accdoc.rec.CatID, MCSTPELM_SYMBOL_К)) )
         if( Symbol == SymbolZ )
            if( Z_From == 0 ) Z_From = i; end;
            Z_To = i;
         end;
         Symbol = "_";
      end;
      StrSet( SqlMask, i, Symbol );
   end;

  QueryStr = "";
  QueryStr = QueryStr + "SELECT MAX(SUBSTR(t_Account, " + Z_From + ", "+ (Z_To - Z_From + 1)+ ")) AS t_Account ";
  QueryStr = QueryStr + "  FROM ";
  QueryStr = QueryStr + " ( ";
  QueryStr = QueryStr + "SELECT t_AccDocAccount AS t_Account ";
  QueryStr = QueryStr + "  FROM dbatch_mcopenacc_tmp ";
  QueryStr = QueryStr + " WHERE t_AccDocAccount LIKE " + "'" + SqlMask + "' ";
  QueryStr = QueryStr + "UNION ALL ";
  QueryStr = QueryStr + "SELECT t_Account AS t_Account ";
  QueryStr = QueryStr + "  FROM daccount_dbt ";
  QueryStr = QueryStr + " WHERE t_Account LIKE " + "'" + SqlMask + "' ";
  QueryStr = QueryStr + " ) ";

  rs = RsdRecordset( QueryStr );
  if( rs.moveNext() )
    subAcc = rs.value(0,retVal);

    if(retVal == false)
         Account = SetNextAccount( Account, rs.value(0) );
      else
         Account = SetNull( Account );
      end;
   end;

   return Account;

END;

PRIVATE VAR TSOrder = NULL;
PRIVATE MACRO GetTSOrder( SFContrID:INTEGER ):BOOL
   if( TSOrder == NULL )
      TSOrder = TRecHandler( "tsorder.dbt" );
   end;
   return CB_GetTSContrBySfContr( SFContrID, TSOrder );
END;

/*Получить код вида договора ДУ в номере л/счета*/
PRIVATE MACRO TSOrder_GetKindCodeInAccount( accdoc:TRecHandler )
   VAR Value = -1;

   if( GetTSOrder( accdoc.rec.ClientContrID ) )
      Value = MC_TSOrder_GetKindCode( TSOrder );
      if( Value > 0 )
         Value = MC_GetValueFlag( OBJTYPE_TSKIND_ASSETMANAGE, Value );
      end;
   else
      MsgBox( "По договору ПЗО, указанному в параметрах счета, не найден договор ДУ." );
   end;
   return Value;
END;

/*Код договора ДУ (ИДДУ, ДП ОФБУ, ОУ ОФБУ) в номере л/счета*/
PRIVATE MACRO TSOrder_GetNumber_InAccount( accdoc:TRecHandler )
   VAR Value = -1;

   if( GetTSOrder( accdoc.rec.ClientContrID ) )
      Value = MC_TSOrder_GetCodeInAccount( TSOrder );
   else
      MsgBox( "По договору ПЗО, указанному в параметрах счета, не найден договор ДУ." );
   end;
   return Value;
END;


PRIVATE MACRO GetCodeTSStorage( PartyID:integer):string

   var query:string = "select pc.T_CODE"+
                     " from   dpartcode_dbt pc"+
                     " where  pc.T_PARTYID  = :Place"+
                     " and    pc.T_CODEKIND = :VS";

   var params:TArray = makeArray( SQLParam( "Place", PartyID            ),
                                  SQLParam( "VS"   , PTCK_VALUESSTORAGE )
                                 ); 

   var rs:RsdRecordset = execSQLselect( query, params, true );

   if( rs and rs.moveNext() )
      return  rs.value(0);
   else
      return "0000";
   end;

   ONERROR(x)
  
   MsgBox( "Ошибка получения Код хранилища ценностей|" + x.Message );
   return -1;
END;

PRIVATE MACRO GetCodeDVKind( FIID:integer):string

   var query:string = "select fi.t_fi_kind, fi.t_avoirkind, dv.t_optiontype, dv.t_optionstyle"+
                      "  from   dfininstr_dbt fi, dfideriv_dbt dv"+
                      " where  fi.t_fiid = dv.t_fiid"+
                      " and    fi.t_fiid = :FIID";

   var params:TArray = makeArray( SQLParam( "FIID", FIID ) ); 

   var rs:RsdRecordset = execSQLselect( query, params, true );

   if( rs and rs.moveNext() )
      if( rs.value(0) == FIKIND_DERIVATIVE )
         if( rs.value(1) == DERIVATIVE_FUTURES )
            return "2";
         elif( rs.value(1) == DERIVATIVE_OPTION )
            if( (rs.value(2) == 2) and (rs.value(3) == 1) )
               return "3";
            elif( (rs.value(2) == 1) and (rs.value(3) == 1) )
               return "4";
            elif( (rs.value(2) == 2) and (rs.value(3) == 2) )
               return "5";
            elif( (rs.value(2) == 1) and (rs.value(3) == 2) )
               return "6";
            else
               return "0";
            end;
         else
            return "0";
         end;
      else
         return "0";
      end;
   else
      return "0";
   end;

   ONERROR(x)
  
   MsgBox( "Ошибка получения вида ПИ|" + x.Message );
   return -1;

END;


/* Вернуть значение (строка или число), которое вставляется в счет вместо символа маски.
   Account        - строка в которой символы шаблона заменяются на свои значения
   Symbol         - символ для замены в шаблоне
   IDElement      - что означает Symbol в счете (конст. MCSTPELM_SYMBOL_...)
   UseLeftJustify - способ выравнивания полученного значения при подстановке его в счет
                    true  - выравнивание по левому краю, false - по правому*/
PRIVATE MACRO MC_GetValueForSymbol( Account:STRING, Symbol:STRING, IDElement:INTEGER, UseLeftJustify:@BOOL, categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT )
   
   var fininstr, mcperiod, err, FIID, DprtCodeKind = 1, DprtPartyCode = "", 
      KindPort, KeyIndex, NumBO, PartyID, KindAcc, rs, 
      CodeReq, CodeFIBu, CodeComm, CodeDeb, CodeCred, AccKind, AccFun,
      CategIsIndividual = ( FD != NULL ), bVSPinCatAcc = false,
      Value = -1;

   /* EVG */
   var Dep;

   /*по умолчанию при подстановке в счет значения, возвращаемого данным методом 
    используем выравнивание по правому краю:
     - значение короче, отведенного под него места в шаблоне, то добавляем к нему нули слева
     - значение длинее, отведенного под него места в шаблоне, то лишние символы слева отрезаем */
   UseLeftJustify = false; 

   if( IDElement   == MCSTPELM_SYMBOL_В ) /*Код валюты л/с;*/                                                        
      if( accdoc.rec.Currency >= 0 )  
         Value = ПолучитьКодФинИнДляСчета( accdoc.rec.Currency );
      end;

   elif( IDElement == MCSTPELM_SYMBOL_Э ) /*Код эмитента (код вида "Код для л/с" эмитента)*/                         

      PartyID = accdoc.rec.Issuer;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr( MC_TYPE_PARAMETR_ISSUER, NULL, NULL, accdoc.rec.FiRole );
      end;

      if( PartyID != -1 )
         if(PartyID != 0)
            Value = ПолучитьКодСубъектаДляСчета( PartyID );
//        else
//           Value = 0;
         end;
      else
         SayError( Categ, "У счета не определено значение характеристики \"Эмитент\"");
      end;

   elif( IDElement == MCSTPELM_SYMBOL_Б ) /*Балансовый счет*/                                                        
      UseLeftJustify = true; /*выравнивание по левому краю*/
      Value = MC_GetBalance( accdoc, templ, FD );      

   elif( IDElement == MCSTPELM_SYMBOL_А ) /*Код для л/с (вида "Код для л/с") векселедателя или акцептанта*/          
      Value = accdoc.rec.Issuer;      

   elif( IDElement == MCSTPELM_SYMBOL_Р ) /*Код расчетного центра ОРЦБ (код вида "Код РЦ ОРЦБ")*/                    

      PartyID  = accdoc.rec.MarketPlaceID;
     if( (PartyID == -1) AND CategIsIndividual )
        PartyID = FD.GetParametr(MC_TYPE_PARAMETR_MARKET_PLACE, NULL, NULL, accdoc.rec.FiRole );
     end;

     Value = ПолучитьКодСубъекта( PartyID, PTCK_ACC, err );
     if( err != 0 )
           SayError( Categ, "Не найден код РКЦ ОРЦБ субъекта " + ПолучитьКодСубъекта( PartyID, PTCK_CONTR, err ) ); 
     end; 

   elif( IDElement == MCSTPELM_SYMBOL_Г ) /*Код гарантийного обеспечения)*/                                          
      Value = 0;      

   elif( IDElement == MCSTPELM_SYMBOL_С ) /*Код сектора торговой площадки*/                                          
      Value = accdoc.rec.MarketPlaceOfficeID;

      if( (Value <= 0) AND CategIsIndividual) /*Пробуем вытащить из документа*/
         Value = FD.GetParametr( MC_TYPE_PARAMETR_MARKET_PLACE_OFFICE, NULL, NULL, accdoc.rec.FiRole);
         if( Value < /* поменял <= на < по запросу 153139  */ 0 ) /*не задан сектор*/
            if( FD.GetParametr( MC_TYPE_PARAMETR_MARKET_PLACE, NULL, NULL, accdoc.rec.FiRole) > 0 )
               Value = 1; /*задана ТП*/
            else
               Value = 0;
            end;
         end;
      end; 

   elif( IDElement == MCSTPELM_SYMBOL_Ф ) /*Номер филиала*/                                                          

      GetRegistryValue( DPRT_CODE_KIND, V_INTEGER, DprtCodeKind, err );
      if( err != 0 )
         SayError( Categ, "Ошибка при получении значения настройки \"" + DPRT_CODE_KIND + "\"");
      end;

      GetRegistryValue( VSP_IN_CATACC, V_BOOL, bVSPinCatAcc, err );
      if( err != 0 )
         SayError( Categ, "Ошибка при получении значения настройки \"" + VSP_IN_CATACC + "\"");
      end;

      if( bVSPinCatAcc == false )
         err = CB_GetDprtPartyCode( accdoc.rec.DepartmentID, DprtCodeKind, DprtPartyCode );
         if( err != 0 )
            CB_GetDepartmentCodeAndName( accdoc.rec.DepartmentID, DprtPartyCode );
            SayError( Categ, "Не найден код вида " + DprtCodeKind + " для субъекта, ассоциированного с филиалом " + DprtPartyCode ); 
         end;
      else
         rs = RSDRecordset("select t_name from ddp_dep_dbt where t_code = "+accdoc.rec.Branch);
         //Seleznev
         if (rs.movenext())
            Value = rs.value(0);
         else
            SayError( Categ, "Не оперделен номер ВСП по коду "+accdoc.rec.Branch);
         end;
/*       err = CB_GetDprtPartyCode( accdoc.rec.Branch, DprtCodeKind, DprtPartyCode );
       if( err != 0 )
          CB_GetDepartmentCodeAndName( accdoc.rec.Branch, DprtPartyCode );
          SayError( Categ, "Не найден код вида " + DprtCodeKind + " для субъекта, ассоциированного с ВСП " + DprtPartyCode ); 
       end;*/

      end;
   //     Value = DprtPartyCode;

   elif( IDElement == MCSTPELM_SYMBOL_FK ) /*Номер филиала-корреспондента*/                                          
     
      GetRegistryValue( DPRT_CODE_KIND, V_INTEGER, DprtCodeKind, err );
      if( err != 0 )
         SayError( Categ, "Ошибка при получении значения настройки \"" + DPRT_CODE_KIND + "\"");
      end;

      err = CB_GetDprtPartyCode( accdoc.rec.CorrDepartmentID, DprtCodeKind, DprtPartyCode );
      if( err != 0 )
         CB_GetDepartmentCodeAndName( accdoc.rec.CorrDepartmentID, DprtPartyCode );
         SayError( Categ, "Не найден код вида " + DprtCodeKind + " для субъекта, ассоциированного с филиалом " + DprtPartyCode ); 
      end;

      Value = DprtPartyCode;

   elif( IDElement == MCSTPELM_SYMBOL_К ) /*Защитный ключ*/                                                          
      MC_NEED_GETKEY = true;
      KeyIndex = Index( Account, Symbol );
      if( KeyIndex != GetKeyPosition() )
         SayError( Categ, "Позиция ключа в шаблоне не соответствует значению для банка");
      elif( Index(SubStr(Account, KeyIndex + 1), Symbol) > 0 )
         SayError( Categ, "В шаблоне несколько позиций для ключа (символ \"" + Symbol + "\")" );
      end;

   elif( IDElement == MCSTPELM_SYMBOL_Л ) /*Код срочности*/                                                         
      mcperiod = TBFile( "mcperiod.dbt", "R" );
      mcperiod.Clear();
      mcperiod.rec.ID = accdoc.rec.PeriodID;
      if( mcperiod.GetEQ() )
         Value = mcperiod.rec.PeriodCode;
      end;

   elif( IDElement == MCSTPELM_SYMBOL_V ) /*Код финансового иструмента*/                                      

      fininstr = TRecHandler("fininstr.dbt");

      FIID = accdoc.rec.FIID;
      if( (FIID == -1) AND CategIsIndividual )
         FIID = FD.GetParametr(MC_TYPE_PARAMETR_FIID, NULL, NULL, accdoc.rec.FiRole); 
      end;  

      if( (FIID >= 0) AND (ПолучитьФинИн( FIID, fininstr ) == 0) )
         /*код регистрации ценной бумаги*/ 
         if( fininstr.rec.CodeInAccount != "")
            Value = fininstr.rec.CodeInAccount;
         else
            Value = fininstr.rec.FI_Code;
         end;
      end;

   elif( IDElement == MCSTPELM_SYMBOL_U ) /*Код для л/с (вида "Код для л/с") клиента по счету*/                     
      Value = ПолучитьКодСубъектаДляСчета( MC_GetClient( accdoc, templ, categ, FD ), PTCK_ACC );

   elif( IDElement == MCSTPELM_SYMBOL_S ) /*Код клиента в БО ценных бумаг (22)*/                                    
      Value = ПолучитьКодСубъектаДляСчета( MC_GetClient( accdoc, templ, categ, FD ), PTCK_INDEPO );

   elif( IDElement == MCSTPELM_SYMBOL_У ) /*Код л/с доходов/расходов*/                                              
      Value = 0;      

   elif( IDElement == MCSTPELM_SYMBOL_Н ) /*Номер договора/сделки (номер документа)*/                               
      if( CategIsIndividual )
         Value = FD.GetParametr( MC_TYPE_PARAMETR_NUMBER, NULL, NULL, accdoc.rec.FiRole );
         if( Value == -1 )
            Value = string( FD.ID );
         end;
      end;

   elif( IDElement == MCSTPELM_SYMBOL_Д ) /*Код договора обслуживания клиента*/                                     
      PartyID = accdoc.rec.ClientContrID;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_CLIENT, NULL, NULL, accdoc.rec.FIRole);
      end;
      Value = MC_GetContrNumber( PartyID );

   elif( IDElement == MCSTPELM_SYMBOL_D ) /*Код договора обслуживания банка*/                                       
      PartyID = accdoc.rec.BankContrID;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTR_BANK, NULL, NULL, accdoc.rec.FIRole);
      end;
      Value = MC_GetContrNumber( PartyID );

   elif( IDElement == MCSTPELM_SYMBOL_О ) /*Код для л/с (вида "Код для л/с") для владельца*/                        
      PartyID = accdoc.rec.Owner;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_OWNER, NULL, NULL, accdoc.rec.FIRole);
      end;
      Value = ПолучитьКодСубъектаДляСчета( PartyID );

   elif( IDElement == MCSTPELM_SYMBOL_М ) /*Код для л/с (вида "Код для л/с") для места хранения*/                   
      PartyID = accdoc.rec.Place;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_PLACE, NULL, NULL, accdoc.rec.FIRole, accdoc.rec.Currency);
      end;
      Value = ПолучитьКодСубъектаДляСчета(PartyID);

   elif( IDElement == MCSTPELM_SYMBOL_W ) /*Номер вышестоящего документа данного первичного документа*/             
      if( CategIsIndividual )
         Value = fd.GetParametr(MC_TYPE_PARAMETR_SENIORNUMBER, NULL, NULL, accdoc.rec.FIRole);
      end;
   elif( IDElement == MCSTPELM_SYMBOL_F ) /*Код бэк-офиса*/                                                         
      NumBO = GetValueFromTempl(categ, templ, LLCLASS_BACKOFFICE);
      if( (NumBO == -1) AND CategIsIndividual )
         NumBO = FD.GetParametrTemplate( OBJTYPE_BACKOFFICE, LLCLASS_BACKOFFICE );
      end;
      Value = MC_GetValueFlag( OBJTYPE_BACKOFFICE, NumBO );

   elif( IDElement == MCSTPELM_SYMBOL_Е ) /*Код для л/с (вида "Код для л/с") (центра ответственности для субъекта*/ 
      PartyID = accdoc.rec.Centr;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CENTR, NULL, NULL, accdoc.rec.FIRole);
      end;
      Value = ПолучитьКодСубъектаДляСчета( PartyID );

   elif( IDElement == MCSTPELM_SYMBOL_Х ) /*Код портфеля*/                                                          

      Value = GetValueFromTempl( categ, templ, LLCLASS_KINDPORT );
      if( (Value == -1) AND CategIsIndividual )
         Value = FD.GetParametrTemplate( OBJTYPE_KINDPORT, LLCLASS_KINDPORT, accdoc.rec.ActionDate, accdoc.rec.FIRole );
      end;

   elif( IDElement == MCSTPELM_SYMBOL_Q ) /*День месяца даты картотеки*/                                            
      DateSplit( MC_ConvertIndexDateToDate(categ, accdoc.rec.IndexDate), Value, null, null);

   elif( IDElement == MCSTPELM_SYMBOL_G ) /*Номер месяца даты картотеки*/                                           
      DateSplit( MC_ConvertIndexDateToDate(categ, accdoc.rec.IndexDate), null, Value, null );

   elif( IDElement == MCSTPELM_SYMBOL_Т ) /*Год даты картотеки*/                                                    
      DateSplit( MC_ConvertIndexDateToDate(categ, accdoc.rec.IndexDate), null, null, Value);

   elif( IDElement == MCSTPELM_SYMBOL_Z ) /*Уникальный порядковый номер счета*/                                     
      Value = CreateStringZ( categ, Symbol, Account, accdoc );

   elif( IDElement == MCSTPELM_SYMBOL_R ) /*Код для л/с (вида "Код для л/с") для контрагента*/                      
      PartyID = accdoc.rec.Contractor;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTRACTOR, NULL, NULL, accdoc.rec.FIRole);
      end;
      Value = ПолучитьКодСубъектаДляСчета( PartyID );

   elif( IDElement == MCSTPELM_SYMBOL_I ) /*Код анкеты векселя*/                                                    
      if( CategIsIndividual )
         Value = fd.GetParametr( MC_TYPE_PARAMETR_VEKSELCODE, NULL, NULL, accdoc.rec.FIRole );
      end;
   
   elif( IDElement == MCSTPELM_SYMBOL_Ц ) /*Код вида договора ДУ*/
      Value = TSOrder_GetKindCodeInAccount( accdoc );
   
   elif( IDElement == MCSTPELM_SYMBOL_И ) /*Код договора ДУ (ИДДУ, ДП ОФБУ, ОУ ОФБУ) в номере л/счета*/
      Value = TSOrder_GetNumber_InAccount( accdoc );
 
   elif( IDElement == MCSTPELM_SYMBOL_Ю ) /*Код ближайшего узла ТС, в котором есть хранилище ценностей*/
         Value   = GetCodeTSStorage( accdoc.rec.Place );

   elif( IDElement == MCSTPELM_SYMBOL_N ) /*Код производного инструмента*/
      Value   = GetCodeDVKind( accdoc.rec.FIID );

   elif( IDElement == MCSTPELM_SYMBOL_Ъ ) /*Назначение счета (код из соотв. параметра)*/
      KindAcc = GetValueFromTempl( categ, templ, LLCLASS_KIND_ACC_PDD );
      if( (KindAcc == -1) AND CategIsIndividual )
         KindAcc = FD.GetParametrTemplate( OBJTYPE_KIND_ACCOUNT_SECUR, LLCLASS_KIND_ACC_PDD, NULL, accdoc.rec.FIRole );
      end;
      Value = MC_GetValueFlag( OBJTYPE_KIND_ACCOUNT_SECUR, KindAcc ); 

   elif( IDElement == MCSTPELM_SYMBOL_CODE_KA ) /*Код контрагента для срочных контрактов*/
      PartyID = accdoc.rec.Contractor;
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTRACTOR, NULL, NULL, accdoc.rec.FIRole);
      end;
     Value = ПолучитьКодСубъектаДляСчета( PartyID, PTCK_CONTRACT );
  elif( IDElement == MCSTPELM_SYMBOL_CODE_REQ )
     CodeReq = GetValueFromTempl( categ, templ, LLCLASS_TSREQKIND );
     if( (CodeReq == -1) AND (FD != NULL) )
        CodeReq = FD.GetParametrTemplate( OBJTYPE_TSREQKIND, LLCLASS_TSREQKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSREQKIND, CodeReq ); 
  elif( IDElement == MCSTPELM_SYMBOL_FI_BUH )
     CodeFIBu = GetValueFromTempl( categ, templ, LLCLASS_TSFIKIND );
     if( (CodeFIBu == -1) AND (FD != NULL) )
        CodeFIBu = FD.GetParametrTemplate( OBJTYPE_TSFIKIND, LLCLASS_TSFIKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSFIKIND, CodeFIBu );
  elif( IDElement == MCSTPELM_SYMBOL_Ч ) 
     CodeComm = GetValueFromTempl( categ, templ, LLCLASS_TSCOMMKIND );
     if( (CodeComm == -1) AND (FD != NULL) )
        CodeComm = FD.GetParametrTemplate( OBJTYPE_TSCOMMKIND, LLCLASS_TSCOMMKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSCOMMKIND, CodeComm );
  elif( IDElement == MCSTPELM_SYMBOL_CODE_DEB )
     CodeDeb = GetValueFromTempl( categ, templ, LLCLASS_TSDEBKIND );
     if( (CodeDeb == -1) AND (FD != NULL) )
        CodeDeb = FD.GetParametrTemplate( OBJTYPE_TSDEBKIND, LLCLASS_TSDEBKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSDEBKIND, CodeDeb );
  elif( IDElement == MCSTPELM_SYMBOL_CODE_CRED )
     CodeCred = GetValueFromTempl( categ, templ, LLCLASS_TSCREDKIND );
     if( (CodeCred == -1) AND (FD != NULL) )
        CodeCred = FD.GetParametrTemplate( OBJTYPE_TSCREDKIND, LLCLASS_TSCREDKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSCREDKIND, CodeCred );
  elif( IDElement == MCSTPELM_SYMBOL_ACCKIND )
     AccKind = GetValueFromTempl( categ, templ, LLCLASS_TSACCKIND );
     if( (AccKind == -1) AND (FD != NULL) )
        AccKind = FD.GetParametrTemplate( OBJTYPE_TSACCKIND, LLCLASS_TSACCKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSACCKIND, AccKind );
  elif( IDElement == MCSTPELM_SYMBOL_ACCFUN )
     AccFun = GetValueFromTempl( categ, templ, LLCLASS_TSACCOWNKIND );
     if( (AccFun == -1) AND (FD != NULL) )
        AccFun = FD.GetParametrTemplate( OBJTYPE_TSACCOWNKIND, LLCLASS_TSACCOWNKIND, NULL, accdoc.rec.FIRole );
     end;
     Value = MC_GetValueFlag( OBJTYPE_TSACCOWNKIND, AccFun );
  elif( IDElement == MCSTPELM_SYMBOL_L ) /*Уникальный порядковый номер счета*/                                     
      //Value = CreateStringL( accdoc.rec.Contractor, accdoc.rec.CatID );
      Value = GetIncerementChar1(accdoc.rec.Owner, accdoc.rec.CatID);
  
   elif ( IDElement == MCSTPELM_SYMBOL_Ш) /*Код клиента (вида 101)*/
      PartyID = accdoc.rec.Owner;

      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_OWNER, NULL, NULL, accdoc.rec.FIRole);
      end;

      /*SDA владелец по договору */
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTRACTOR, NULL, NULL, accdoc.rec.FIRole);
      end;

      // KS 29.06.2012 C-12309 Используем только 1й вид кода
      /* Value = ПолучитьКодСубъекта( PartyID, 101, err );

      //SDA "последний патрон" - выкусим последние пять символов из первого вида кода 
      if( err != 0 )
         Value = ПолучитьКодСубъекта( PartyID, 1, err );
         if( err == 0 )
            Value = substr(Value,strlen(Value)-4);
         end;
      else // KS 29.06.2012 C-12309 Ш - последние 5 символов Кода Клиента 101
         Value = substr(Value,strlen(Value)-4);
      end; */
      Value = ПолучитьКодСубъекта( PartyID, 1, err );
      
      //19.09.2013 Chesnokov D.S. По C-22985 используем 6-ть символов 
      if( err == 0 )
         Value = substr(Value,strlen(Value)-5);
      end;

      if( err != 0 )
         // EVG SayError( Categ, "Не определено значение кода вида 101 для владельца |"+err);
         // KS 29.06.2012 C-12309 Перепишу сообшение об ошибке
         //SayError( Categ, "Не определено значение кода вида 101 для владельца |ID: "+ PartyID);
         SayError( Categ, "Не определено значение кода вида 1 для владельца |ID: "+ PartyID);
      end;

   // KS 29.06.2012 C-12309 Добавил Ё - 7 символ кода 1 для клиента
   elif ( IDElement == MCSTPELM_SYMBOL_Ё) // KS 29.06.2012 C-12309 Ё - 7 символ кода 1 для клиента

      PartyID = accdoc.rec.Owner;

      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_OWNER, NULL, NULL, accdoc.rec.FIRole);
      end;

      /*SDA владелец по договору */
      if( (PartyID == -1) AND CategIsIndividual )
         PartyID = FD.GetParametr(MC_TYPE_PARAMETR_CONTRACTOR, NULL, NULL, accdoc.rec.FIRole);
      end;

      // KS 29.06.2012 C-12309 Используем только 1й вид кода
      Value = ПолучитьКодСубъекта( PartyID, 1, err );
      if( err == 0 )
         Value = substr(Value,7,1);
      end;

      if( err != 0 )
         // EVG SayError( Categ, "Не определено значение кода вида 101 для владельца |"+err);
         // KS 29.06.2012 C-12309 Перепишу сообшение об ошибке
         //SayError( Categ, "Не определено значение кода вида 101 для владельца |ID: "+ PartyID);
         SayError( Categ, "Не определено значение кода вида 1 для владельца |ID: "+ PartyID);
      end;
   // KS 29.06.2012 C-12309 end Добавил Ё - 7 символ кода 1 для клиента

   /* EVG Код подразделения ТС */
   elif ( IDElement == MCSTPELM_SYMBOL_J)

      if (CategIsIndividual)
         Dep = fd.office;
      else
         Dep = accdoc.rec.Branch
      end;

      rs = RSDRecordset("select t_name from ddp_dep_dbt where t_code = "+Dep);
      if (rs.movenext())
         Value = rs.value(0);
      else
         SayError( Categ, "Не оперделен номер ВСП по коду "+Dep);
      end;
   
   /* SDA Объект договора - первые 5 символов для счета - балансовый второго порядка */
   elif (IDElement == MCSTPELM_SYMBOL_Я)
      Value = substr(trim(fd.m_Payment.PayerAccount),1,5);
      /* SDA Объект договора */
      
   elif (IDElement == MCSTPELM_SYMBOL_Й)
      Value = trim(fd.m_Payment.PayerAccount);
      
   //TAM 04.12.12 C-16005
   elif (IDElement == MCSTPELM_SYMBOL_Ж)
      //значение парамтра ставим в 0 - просто резервируем позицию. После генерации счета будут проверки и заполнение
      Value = 1;
   
   else
      SayError( Categ, "Элемент шаблона счета с номером " + string(IDElement) + " не обрабатывается в макрофункции генерации номера счета.|Вместо данного символа в счет подставится '0'.", true  );
   end;
   return Value;
end;

/* Формирование номера счета по маске. Заменяет подстановочные символы на маску из шаблона 
   Symbol    - символ для замены в маске шаблона 
   IDElement - значение данного символа
   Account   - строка в которой заменяются символы
   Mask      - шаблон для подстановки*/
PRIVATE MACRO ChangeStrForSymb( categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT, Symbol:STRING, IDElement:INTEGER, Account:STRING, Mask:STRING )
   
   var Number, LeftJustify, i, j, StrNumber,
       SymbLen      = 0, 
       TemplMaskLen = strlen(Mask);

   /*определить количество символов для замены в шаблоне*/
   i = 1; 
   while( i <= TemplMaskLen )
      if( SubStr(Mask, i, 1) == Symbol )
         SymbLen = SymbLen + 1; 
      end;
      i = i + 1;
   end;

   if( SymbLen != 0 ) /*есть что менять*/
      Number = MC_GetValueForSymbol( Account, Symbol, IDElement, @LeftJustify, categ, accdoc, templ, FD );

      if( (valtype(Number) == V_INTEGER) AND (Int(Number) < 0) )
         Number = "";
      end; 

      StrNumber = LZ_acc( string(Number), SymbLen, LeftJustify );
      i = TemplMaskLen;
      j = SymbLen;
      while( (i > 0) AND (j > 0) )
         if( SubStr(Account, i, 1) == Symbol )
            /*когда i-1 == 0, SubStr вернет "", можно не проверять отдельно */
            Account = SubStr(Account, 1, i-1) + StrSubst( SubStr(Account, i), Symbol, SubStr(StrNumber, j, 1) );
            j = j - 1
         end;
         i = i - 1;
      end;
   end;
   
   return Account; 
end;

/*Заключить в кавычки каждый символ из подстроки ограниченной символом APOSTROPHE в AddMask
  Т.е. вместо 123"ABC"456 сделать 123"A""B""C"456
  Необходимо для правильной подстановки в случае, если символы доп. маски идут в шаблоне не подряд*/
PRIVATE MACRO ParseAddMask( categ:TRecHandler, AddMask:STRING )
   var i = 1, CurCh, AddMaskLen, NewAddMask = "", ApostrCount = 0;

   if( Index( AddMask, APOSTROPHE) == 0 )
      return AddMask;
   end;

   AddMaskLen = strlen( AddMask );
   while( i <= AddMaskLen )
      CurCh = SubStr( AddMask, i, 1);

      if( CurCh == APOSTROPHE )
         ApostrCount = ApostrCount + 1;
         i = i + 1;
         while( i <= AddMaskLen )
            CurCh = SubStr( AddMask, i, 1);
            if( CurCh == APOSTROPHE )
               ApostrCount = ApostrCount + 1;
               break;
            end;
            NewAddMask = NewAddMask + APOSTROPHE + CurCh + APOSTROPHE;
            i = i + 1;
         end;
      else
         NewAddMask = NewAddMask + CurCh;
      end;

      i = i + 1;
   end;

   if( mod(ApostrCount, 2 ) != 0 )
      SayError( categ, "Количество символов <"+APOSTROPHE+"> в дополнительной маске шаблона счета должно быть четным." );
   end;

   return NewAddMask;
END;

/* Подставить дополнительную маску шаблона в основную (Mask) и вернуть результат.*/
PRIVATE MACRO InsertAddMask( categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT, Mask:STRING )
   var i, j, CurCh, CurAddCh, AddCh, Symbol_AddMask, AddMask;
   
   Symbol_AddMask = GetSymbolByIDElement( categ.rec.Id, MCSTPELM_SYMBOL_П );

   if( Symbol_AddMask != "" )
      AddMask = ParseAddMask( categ, templ.rec.Mask );
      i = strlen( Mask );
      j = strlen( AddMask );
      while( i > 0 )
         CurCh = SubStr( Mask, i, 1);
         if( CurCh == APOSTROPHE ) /*пропустить обработку символа из маски*/
            i = i - 1;
            while( i > 0 )
               if( SubStr( Mask, i, 1) == APOSTROPHE )
                  break;
               end;
               i = i - 1;
            end;
         elif( CurCh == Symbol_AddMask ) /*подставить в маску вместо данного символа - символ из доп. маски*/
            if( j > 0 )
               CurAddCh = SubStr( AddMask, j, 1);
               if( CurAddCh == APOSTROPHE ) 
                  /*Символ в доп. маске заключен в APOSTROPHE, он должен остаться неизменным 
                  и при подстановке в основную маску*/
                  AddCh = SubStr( AddMask, j-2, 3);
                  j = j - 3;
               else
                  AddCh = CurAddCh;
                  j = j - 1;
               end;
            else /*В основной маске больше символов для подстановке доп. маски, чем сама доп. маска */
               AddCh = "0";
            end;
            Mask = SubStr( Mask, 1, i-1) + AddCh + SubStr( Mask, i+1);
         end;
         i = i -1;
      end;
   end;
   return Mask;
END;

/*Удалить из Mask символы, заключенные в APOSTROPHE (включая и сами символы APOSTROPHE)*/
PRIVATE MACRO DeleteConstString( categ:TRecHandler, Mask:STRING )
  var LeftA, RightA, TmpStr;

   LeftA = Index( Mask, APOSTROPHE); /*левая скобка*/
   while( LeftA != 0 )
      TmpStr = SubStr( Mask, LeftA+1 );
      RightA = Index( TmpStr, APOSTROPHE ); /*Правая скобка*/
      if( RightA == 0 )
         SayError( categ, "Количество символов <"+APOSTROPHE+"> в шаблоне счета должно быть четным." );
      end;
      Mask = SubStr(Mask,1,LeftA-1) + SubStr(TmpStr,RightA+1);
     LeftA = Index( Mask, APOSTROPHE);
   end;

   return Mask;
END;

/*Подставить в Account неизменяемые строки - заключенные в APOSTROPHE в Mask */
PRIVATE MACRO AddConstString( categ:TRecHandler, Account:STRING, Mask:STRING )
   var i = 1, j = 1, NewAccount = "", MaskLen, CurCh;

   if( Index( Mask, APOSTROPHE) == 0 )
      return Account;
   end;

   MaskLen = StrLen( Mask );
   while( i <= MaskLen )
      if( SubStr(Mask, i, 1) == APOSTROPHE )
         i = i + 1; 
         while( i <= MaskLen )
            if( SubStr(Mask, i, 1) == APOSTROPHE )
               break;
            else
               NewAccount = NewAccount + SubStr(Mask, i, 1);
            end;
            i = i + 1;
         end;
      else
         NewAccount = NewAccount + SubStr(Account, j, 1);
         j = j + 1;
      end;
      i = i + 1;
   end;

   return NewAccount;
END;

/*******************************************************************
 Сформировать номер счета по маске шаблона КУ                    
 Возможен рекурсивный вызов, если балансовый счет содержит в себе символы 
 categ       - категория (mccateg.dbt)                           
 accdoc      - счет категории учета (mcaccdoc.dbt)               
 templ       - шаблон счета (mctempl.dbt)                          
 FD          - Первичный документ                                
 Mask        - Маска шаблона, по ктоторой будет формироваться счет 
 *******************************************************************/
MACRO MC_MakeAccountNumber( categ:TRecHandler, accdoc:TRecHandler, templ:TRecHandler, FD:VARIANT, Mask:STRING )
   
   var b_Continue, MaskLen, Account, i, Symbol_IDElement, FullMask, CurSymb,
      ChangedSymbols = "0123456789";
   var DprtPartyCode : string;
                                                                             
   MC_NEED_GETKEY = false;

   /* Подставить дополнительную маску шаблона в счет.
     !!! всегда должно быть до обработки остальных символов шаблона. */
   FullMask = InsertAddMask( categ, accdoc, templ, FD, Mask );

   Account = Mask = ConvertString( DeleteConstString( categ, FullMask ) );

   MaskLen = strlen( Mask );
   i = 1; 
   while( i <= MaskLen )
      CurSymb = SubStr(Mask, i, 1);
      if( Index( ChangedSymbols, CurSymb ) == 0 ) /*символ еще не обработан*/

         Symbol_IDElement = GetIDElementBySymbol( categ.rec.Id, CurSymb );
         if( Symbol_IDElement != 0 )
            Account = ChangeStrForSymb( categ, accdoc, templ, FD, CurSymb, Symbol_IDElement, Account, Mask );
            ChangedSymbols = ChangedSymbols + CurSymb;
         else
            SayError( Categ, "В шаблоне счета не задано значение для символа \"" + CurSymb + "\"." );
         end;
      end; 
      i = i + 1;
   end;

   Account = AddConstString( categ, Account, FullMask );

   //Gurin S. 12.08.2014 R-429747-2
   if (not StrIsNumber(Account))
       SayError( Categ, "Счет " + Account + " не числовой ");
   end;

   if( MC_NEED_GETKEY == true )
      DprtPartyCode = "";

      CB_GetDprtPartyCode( accdoc.rec.DepartmentID, PTCK_BIC, DprtPartyCode );
     
      Account = GetKey( Account, DprtPartyCode );
   end;
   debugbreak;
   //TAM C-16005 05.12.12
   if(categ.rec.number == 5005) //Картотека 2
      var ClientId = FD.GetParametr(MC_TYPE_PARAMETR_OWNER, NULL, NULL, accdoc.rec.FIRole);
      if((GetAccOwner(Account) != 0) and (GetAccOwner(Account) != ClientId)) 
      //счет уже есть в БД и закреплен за другим клиентом
         //генерим новый счет
         Account = ChangeAcc(Account); 
         Account = GetKey( Account, DprtPartyCode );
         //проверяем на случай если новый счет уже закреплен за кем-то и это не наш клиент
         if( (GetAccOwner(Account) != 0) and (GetAccOwner(Account) != ClientId) )
            //пока не откроем новый счет
            while (GetAccOwner(Account) != 0) 
               Account = ChangeAcc(Account); 
               Account = GetKey( Account, DprtPartyCode );
            end;
         end;
      end;
   end;
   //end TAM C-16005 05.12.12

   return Account;

   OnError
      return "";
END;
