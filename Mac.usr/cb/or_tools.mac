/*╔═══════════════════════════════════════════════════════════════════════════╗*/
/*║           Автоматизированная банковская система RS-Bank v5.1              ║*/
/*║               Copyright (c) R-Style Software Lab 2001-2004                ║*/
/*║                                                                           ║*/
/*║ Имя файла     or_tools.mac                                                ║*/
/*║                                                                           ║*/
/*║ Описание      Утилиты для макросов                                        ║*/
/*║                                                                           ║*/
/*║ Программист   Зуев С.В.                                                   ║*/
/*║                                                                           ║*/
/*║ Создан        20.06.2001                                                  ║*/
/*║                                                                           ║*/
/*╚═══════════════════════════════════════════════════════════════════════════╝*/
// KS 26.11.2013 Адаптация под 31ю сборку
/*
Список функций:
  TrStrSubst          - Функция временно заменяющая отвалившуюся функцию StrSubst
  TrimZero            - Функция отсекает незначащие нули у дробного числа и возвращает соответствующую строку
  MonNameR            - Функция возвращает наименование месяца в родительном падеже по его номеру
  MakeDateStr         - Функция возвращает возвращает строку, сформирванную из даты с учетом переданных параметров
  InvertStr           - Функция возвращает инвертированную строку
  TR_StrSplit         - Функция разбивает строку на части указанного размера с учетом строки пользовательских разделителей 
                        и возвращает TArray частей переданной строки
  TR_StrSplitExt      - Функция разбивает строку на части указанного размера с учетом строки пользовательских разделителей, 
                        и символов перевода каретки и возвращает TArray частей переданной строки отформатированный в
                        соответствии с селектором отсечения пробелов
  ValCmpArray         - Функция проверяет, есть ли значение в массиве и возвращает номер элемента массива
                        или ELEM_NO_FOUND в противном случае
  RGB                 - Функция возвращает цвет по переданным составляющим спектра
  StrToDateOrTime     - Функция возвращает дату (время), сформированную из строки 
  SumAllElementArray  - Функция возвращает сумму всех элементов массива в заданном диапазоне (всего массива, если диапазон не задан).
                        Тип возвращаемого значения соотвествует типу массива
  MakeMoneyStr        - Функция возвращает строку, сформирванную из значения типа V_MONEY с учетом переданных параметров
  GetNumberDay        - Функция возвращает порядковый номер дня даты в году
  ToHex               - Функция возвращает шестнадцатеричное строковое представление десятичного числа
  GetExlusiveFileName - Функция формирует уникальное 12-ти символьное имя файла 
  TR_Insert           - Функция вставки строки в текстовый файл с учетом всех пробелов в строке (в том числе конечных)
                        Считывать строки с файла полученного этой функцией необходимо с помощью функции TR_Next 
  TR_Next             - Функция считывания строки из текствого файла, полученного с помощью TR_Insert 
  TR_CopyFile         - Функция для копирования файлов с сервера на терминал. Сделана в таком виде, чтобы инструмент можно
                        было бы включать в файлы на терминале. На терминале функция CopyFile отсутствует и поэтому не компилится) 
  TR_ExtString        - Функция для расширения строки до нужного размера символами с кодом 255
  TR_ExecExp          - Функция для облегчения отладки прикладного кода при падении на вызове ExecExp
*/

Import rsexts;
Import "or_set_h.mac";
Import "or_exl_h.mac";

/* Константа для функции ValCmpArray, обозначающая отсутствие искомого значения в массиве */
CONST ELEM_NO_FOUND  = -1; 
/* Константа, в виде непечатного символа с кодом 029, заменяющая пробелы.
   Необходима в связи с тем, что функция Insert отбрасывает конечные пробелы */ 
CONST SPACE_REPLACER = "";                       
/* Переменная для функции TR_ExecExp, необходимая для облегчения отладки прикладного 
   кода при падении на вызове ExecExp */
VAR ___FlagDebug___:bool = False;

/* Функция временно заменяющая отвалившуюся функцию StrSubst */
Macro TrStrSubst(Str:string, FindStr:string, ReplaceStr:string):string
  return StrSubst( Str, FindStr, ReplaceStr );
/*
  var RetStr :string  = "";  /* Возвращаемая строка */ 
  var Pos    :integer = "";  /* Позиция очередной найденной подстроки */
  var TempStr:string  = Str; /* Временная строка, которую будем крамсать */

  Pos = Index(TempStr, FindStr);
  while(Pos)
       RetStr  = RetStr + SubStr(TempStr, 1, Pos - 1) + ReplaceStr;
       TempStr = SubStr(TempStr, Pos + StrLen(FindStr) );
       Pos     = Index(TempStr, FindStr);
  end;
  return RetStr + TempStr;
*/
End; /* TrStrSubst */

/* Отсекает незначащие нули у дробного числа и возвращает соответствующую строку */
MACRO TrimZero(_Value:double);

  VAR RetValue:string = Trim(String(_Value)); /* Возвращаемое значение */

  if(Index(RetValue, GetLocaleInfo(0,LOCALE_SDECIMAL,(NOT IsStandAlone()))))
       while(SubStr(RetValue,StrLen(RetValue)) == "0")
            RetValue = SubStr(RetValue,1,StrLen(RetValue) - 1);
       end;
       if(SubStr(RetValue,StrLen(RetValue)) == GetLocaleInfo(0,LOCALE_SDECIMAL,(NOT IsStandAlone())))
            RetValue = SubStr(RetValue,1,StrLen(RetValue) - 1);
       end;     
  end;
  return RetValue;

END; /* TrimZero */

/* Возвращает наименование месяца в родительном падеже по его номеру */
MACRO MonNameR(_NumbMon:integer)

  VAR RetValue:string = ""; /* Возвращаемое значение */

  if((_NumbMon > 0) and (_NumbMon < 13))
       if((_NumbMon == 3) or (_NumbMon == 8))
            RetValue = SubStr(MonName(_NumbMon), 1, StrLen(MonName(_NumbMon))) + "а";
       else RetValue = SubStr(MonName(_NumbMon), 1, StrLen(MonName(_NumbMon)) - 1) + "я";
       end;
  end;
  return StrLwr(RetValue);   

END; /* MonNameR */

/* Возвращает возвращает строку, сформирванную из даты _Date с разделителем _StrSep и 
   параметрами _FlagTrimZero, _FlagMonName, _CountCharInYear */
MACRO MakeDateStr(_Date:date, _StrSep:string, _FlagTrimZero:bool, _FlagMonName:bool, _CountCharInYear:integer)

  VAR StrSep  :string  = "-"; /* Разделитель. По умолчанию "-" */
  VAR StrZeroD:string  = "0"; /* Строка для дней, зависящая от флага отсечения незначащих нулей. По умолчанию "0" */
  VAR StrZeroM:string  = "0"; /* Строка для месяцев, зависящая от флага отсечения незначащих нулей и 
                                 флага вывода месяца в виде слова. По умолчанию "0" */
  VAR StrMon  :string  = "";  /* Строка, зависящая от флага вывода месяца в виде слова */
  VAR StrYear :string  = "";  /* Строка с годом, содержащая заданное число символов */ 
  VAR CurDay  :integer = 0;   /* День переданной даты */
  VAR CurMon  :integer = 0;   /* Месяц переданной даты */
  VAR CurYear :integer = 0;   /* Год переданной даты */
  VAR RetValue:string  = "";  /* Возвращаемое значение */

  if(ValType(_Date) == V_DATE)
       if(_Date != Date(0, 0, 0))
            DateSplit(_Date, CurDay, CurMon, CurYear);
            if(ValType(_StrSep))
                 StrSep = _StrSep;
            end;
            if(ValType(_FlagTrimZero))
                 if(_FlagTrimZero)
                      StrZeroD = "";
                      StrZeroM = "";
                 end;
            end;
            StrMon = string(CurMon);
            if(ValType(_FlagMonName))
                 if(_FlagMonName);
                      StrMon = MonNameR(CurMon);
                      StrZeroM = "";
                 end;
            end;
            StrYear = StrSep + String(CurYear);
            if(ValType(_CountCharInYear))
                 if((_CountCharInYear > 0)and(_CountCharInYear < 4))
                      StrYear = StrSep + SubStr(StrYear, (5 - _CountCharInYear));
                 else StrYear = "";
                 end;
            end;
            if(CurMon < 10)
                 if(CurDay < 10)
                      RetValue = StrZeroD + string(CurDay) + StrSep + StrZeroM + StrMon + StrYear;
                 else RetValue = string(CurDay) + StrSep + StrZeroM + StrMon + StrYear;
                 end;
            else if(CurDay < 10)
                      RetValue = StrZeroD + string(CurDay) +  StrSep + StrMon + StrYear;
                 else RetValue = string(CurDay) + StrSep + StrMon + StrYear;
                 end;
            end;
       end;       
  end;
  return RetValue;

END; /* MakeDateStr */

/* Константы для функций разбиения строки */
CONST DEFAULT_SEPARAT = " ,.-/:"; /* Разделители слов "по умолчанию" */
CONST ERASE_ALL_SPACE = 1;        /* Все пробелы отсекаются */
CONST ADD_SPACE_END   = 2;        /* Недостающие пробелы дописываются в конец элементов массивов */
CONST ADD_SPACE_BEG   = 3;        /* Недостающие пробелы дописываются в начало элементов массивов */
CONST ADD_SPACE_SIDE  = 4;        /* Недостающие пробелы дописываются поровну в начало и конец элементов массивов */

/* Инвертирование (выворачивание) строки. Возвращает инвертированную строку */
MACRO InvertStr(Str:string)

  VAR RetStr:string  = "";          /* Возвращаемая строка */
  VAR i     :integer = StrLen(Str); /* Счетчик циклов */
  
  while(i > 0)
       RetStr = RetStr + SubStr(Str, i, 1);
       i = i - 1;
  end;
  return RetStr;

END; /* InvertStr */

/* Разбиение переданной строки на части указанного размера с учетом строки поль-
   зовательских разделителей. Возвращает TArray частей переданной строки */
MACRO TR_StrSplit(Str:string, ArrStr:TArray, Len:integer, StrSep:string)

  VAR CurStr:string  = ""; /* Текущая обрабатываемая часть строки */
  VAR Pos   :integer = 0;  /* Найденная позиция разделителя */ 

  /* Пока длина строки больше указанного размера */ 
  while(StrLen(Str) > Len)
       /* Инвертируем (выворачиваем) подстроку указанного размера */
       CurStr = InvertStr(SubStr(Str, 1, Len));
       Str    = SubStr(Str, Len + 1);
       /* Определяем первое попадание символа-разделителя в эту подстроку */
       Pos = StrBrk(CurStr, StrSep);
       /* Если разделитель есть, то все что справа инвертируем и записываем в массив, 
          а все остальное инвертируем и возвращаем в исходную строку */
       if(Pos)
            ArrStr[ArrStr.Size()] = InvertStr(SubStr(CurStr, Pos));             
            Str                   = InvertStr(SubStr(CurStr, 1, Pos - 1)) + Str;
       /* Если символа-разделителя нет, то "рвем по живому" */
       else ArrStr[ArrStr.Size()] = InvertStr(CurStr);
       end;
  end;
  /* Если после всех манипуляций остался кусочек строки меньше указанного размера, 
     записываем его в последний элемент массива */
  if(Str)
       ArrStr[ArrStr.Size()] = Str;      
  end;
  /* Возвращаем сформированный массив */
  return ArrStr;

END; /* TR_StrSplit */

/* Разбиение переданной строки на части указанного размера с учетом строки поль-
   зовательских разделителей и символов перевода каретки. Возвращает TArray 
   частей переданной строки отформатированный в соответствии с селектором
   отсечения пробелов. */
MACRO TR_StrSplitExt(Str:string, Len:integer, StrSep:string, SelSpace:integer);

  VAR ArrStr       :TArray  = TArray; /* Возвращаемый массив */
  VAR Pos          :integer = 0;      /* Найденная позиция разделителя */ 
  VAR CurStr       :string  = "";     /* Текущая обрабатываемая часть строки */
  VAR CurStrSep    :string  = "";     /* Текущая строка разделителей */
  VAR i            :integer = 0;      /* Счетчик циклов */
  VAR Sz           :integer = 0;      /* Размер возвращаемого массива */
  VAR CountAddSpase:integer = 0;      /* Число добавляемых пробелов для текущей части строки */

  /* Если строка задана и размер частей строки указан */
  if((Str) AND (Len))
       /* Если строка разделителей не передана, используем разделители "по умолчанию" */
       if(Not StrSep)     
            CurStrSep = DEFAULT_SEPARAT;
       else CurStrSep = StrSep;
       end;
       /* Разделяем полученную строку на элементарные */
       while(StrLen(Str));
            Pos = Index(Str, "\n");
            /* Если символы перевода каретки найдены */
            if(Pos)
                 /* Если это не многократный перевод каретки */
                 if(Pos != 1)
                      CurStr = SubStr(Str, 1 ,Pos - 1);
                      ArrStr = TR_StrSplit(CurStr, ArrStr, Len, CurStrSep);
                 /* Если многократный перевод каретки */ 
                 else ArrStr[ArrStr.Size()] = "";
                 end;
                 Str = SubStr(Str, Pos + 1);
            /* Если стока элементарная (без символов перевода каретки) */
            else ArrStr = TR_StrSplit(Str, ArrStr, Len, CurStrSep);
                 Str    = "";
            end;
       end;
       /* Проверим селектор отсечения пробелов */
       if(SelSpace)
            Sz = ArrStr.Size();
            i = 0;
            while(i < Sz)
                 /* Если селектор отсечения пробелов равен ERASE_ALL_SPACE, то все пробелы усекаем */
                 if(SelSpace == ERASE_ALL_SPACE)
                      ArrStr[i] = Trim(ArrStr[i]);
                 /* Если селектор отсечения пробелов равен ADD_SPACE_END, то пробелы добавляем в конец */
                 elif(SelSpace == ADD_SPACE_END)
                      CountAddSpase = Len - StrLen(ArrStr[i]);
                      ArrStr[i] = ArrStr[i] + MkStr(" ", CountAddSpase); 
                 /* Если селектор отсечения пробелов равен ADD_SPACE_BEG, то пробелы добавляем в начало */
                 elif(SelSpace == ADD_SPACE_BEG)
                      CountAddSpase = Len - StrLen(ArrStr[i]);
                      ArrStr[i] = MkStr(" ", CountAddSpase) + ArrStr[i]; 
                 /* Если селектор отсечения пробелов равен ADD_SPACE_SIDE, то пробелы добавляем в начало и конец */
                 elif(SelSpace == ADD_SPACE_SIDE)
                      CountAddSpase = Len - StrLen(Trim(ArrStr[i]));
                      ArrStr[i] = MkStr(" ", CountAddSpase/2) + Trim(ArrStr[i]) + MkStr(" ", CountAddSpase - CountAddSpase/2); 
                 end;
                 i = i + 1;
            end;
       end;
  end; 
  /* Возвращаем сформированный массив */
  return ArrStr;

END; /* TR_StrSplitExt */

/* Метод, проверяющий, есть ли значение Value в массиве Arr и возвращающий номер элемента массива или ELEM_NO_FOUND в противном случае */
MACRO ValCmpArray(Value, Arr:TArray, FieldsName:string)

  VAR i :integer = 0;          /* Счетчик циклов */

  if( ValType(FieldsName) )
      while( i < Arr.Size )
         if( Value == GenGetProp(Arr[i], FieldsName) )
             return i; 
         end;
         i = i + 1;
      end;
  else
      while( i < Arr.Size )
         if( Value == Arr[i] )
             return i; 
         end;
         i = i + 1;
      end;
  end;
  return ELEM_NO_FOUND;

END; /* ValCmpArray */

/* Возвращает цвет по переданным составляющим спектра */
MACRO RGB(R:integer,G:integer,B:integer); 

  return (R*256*256 + G*256 + B);

END; /* RGB */

/* Возвращает дату (время), сформированную из строки */
MACRO StrToDateOrTime(_StrDateTime:string, _FlagTime:bool, _StrSep:string)

  var Field_1 :integer = 0;               /* День (часы) */
  var Field_2 :integer = 0;               /* Месяц (минуты) */
  var Field_3 :integer = 0;               /* Год (секунды) */
  var StrSep  :string  = DEFAULT_SEPARAT; /* Возможные разделители полей в дате (времени) */
  var RetValue:variant;                   /* Возвращаемое значение (дата или время) */

  if(_StrDateTime)
       /* Если переданы разделители, пользуемся ими */
       if(ValType(_StrSep))
            StrSep = _StrSep;
       end;
       /* Получаем день (часы) */
       _StrDateTime = Trim(_StrDateTime);
       Field_1      = Int(_StrDateTime);
       /* Получаем месяц (минуты) */
       _StrDateTime = SubStr(_StrDateTime, StrBrk(_StrDateTime, StrSep) + 1);
       Field_2      = Int(Trim(_StrDateTime));
       /* Получаем год (секунды) */
       _StrDateTime = SubStr(_StrDateTime, StrBrk(_StrDateTime, StrSep) + 1);
       Field_3      = Int(Trim(_StrDateTime));
       /* Формируем дату (время) */
       if(Not _FlagTime)
            RetValue = Date(0, 0, 0);
            if((Field_2 < 1)or(Field_2 > 12))
                 MsgBox("Ошибка!\nНекорректная дата (месяц)");
            elif((Field_1 < 1)or(Field_1 > 31))
/* Здесь надо прикрутить проверку по календарю */
                 MsgBox("Ошибка!\nНекорректная дата (день)");
            else RetValue = Date(Field_1, Field_2, Field_3);
            end;
       else RetValue = Time(0, 0, 0);
            if(Field_1 > 24)
                 MsgBox("Ошибка!\nНекорректное время (часы)");
            elif(Field_2 > 60)
                 MsgBox("Ошибка!\nНекорректная дата (минуты)");
            elif(Field_3 > 60)
                 MsgBox("Ошибка!\nНекорректная дата (секунды)");
            else RetValue = Time(Field_1, Field_2, Field_3);
            end;            
       end;
  else if(Not _FlagTime)
            RetValue = Date(0, 0, 0);
       else RetValue = Time(0, 0, 0);
       end;
  end;

  Return RetValue;

END; /* StrToDateOrTime */

/* Возвращает сумму всех элементов массива в заданном диапазоне (всего массива, если диапазон не задан).
   Тип возвращаемого значения соотвествует типу массива */
MACRO SumAllElementArray(Arr:TArray, _BegDiap:integer, _EndDiap:integer)

  var i      :integer = 0;          /* Счетчик циклов */
  var Sz     :integer = Arr.Size(); /* Размер переданного массива */
  var Sum = 0;                          /* Сумма массива */
  var BegDiap:integer = 0;          /* Начало диапазона суммирования */
  var EndDiap:integer = Sz - 1;     /* Конец диапазона суммирования */

  /* Проверим корректность переданного диапазона суммирования */
  if(ValType(_BegDiap))
       if((_BegDiap >= BegDiap)and(_BegDiap <= EndDiap))
            BegDiap = _BegDiap;
       end;
  end;
  if(ValType(_EndDiap))
       if((_EndDiap >= BegDiap)and(_EndDiap <= EndDiap))
            EndDiap = _EndDiap;
       end;
  end;
  /* Определяем тип возвращаемого значения по умолчанию */
  if(Sz)
    if(valtype(Arr[BegDiap]) != V_UNDEF)
       Sum = Arr[BegDiap];
    end;
  end;
  i = BegDiap + 1;
  while( i <= EndDiap)
     if(valtype(Arr[i]) != V_UNDEF)
       Sum = Sum + Arr[i];
     end;
     i   = i + 1;
  end;
  Return Sum;

END; /* SumAllElementArray */

/* Возвращает возвращает строку, сформирванную из значения _Money типа V_MONEY с разделителем _StrSep и 
   параметром _FlagTrimKop, отвечающим за формат вывода значений не содержащих копейки */
MACRO MakeMoneyStr(_Money:money, _StrSep:string, _FlagTrimKop:bool)

  VAR StrRub  :string = "";  /* Строка для рублей */
  VAR StrKop  :string = "";  /* Строка для копеек */
  VAR StrSep  :string = "-"; /* Разделитель. По умолчанию "-" */
  VAR RetValue:string = "";  /* Возвращаемое значение */

  if(ValType(_Money) == V_MONEY)
       if(ValType(_StrSep))
            StrSep = _StrSep;
       end;
       StrRub = Trim(String((Floor(Double(_Money))):16:0));
       StrKop = Trim(String((100.0 * (Double(_Money) - Floor(Double(_Money)))):16:0));
       if(StrLen(StrKop) < 2)
            StrKop = "0" + StrKop;
       end;
       if(Not _FlagTrimKop)
            RetValue = StrRub + "-" + StrKop;
       else if(StrKop == "00")
                 RetValue = StrRub + "=";
            else RetValue = StrRub + "-" + StrKop;
            end
       end;
  end;
  return RetValue;

END; /* MakeMoneyStr */

/* Возвращает порядковый номер дня даты в году */
MACRO GetNumberDay(_Date:date)

   VAR Day     :integer = 1; /* День */
   VAR Mon     :integer = 1; /* Месяц */
   VAR Year    :integer = 1; /* Год */
   VAR RetValue:integer = 1; /* Возвращаемое значение */

   if(Not ValType(_Date))
        DateSplit(Date(), Day, Mon, Year);   
        RetValue = Date() - Date(1, 1, Year) + 1;
   else DateSplit(_Date, Day, Mon, Year);   
        RetValue = _Date - Date(1, 1, Year) + 1;
   end;

   return RetValue;

END; /* GetNumberDay */

/* Возвращает шестнадцатеричное строковое представление десятичного числа */
MACRO ToHex(DecimalValue, NeedSize)

  CONST Table :string  = "0123456789abcdef"; /* Таблица символов для шестнадцатиричного представления */
  VAR   Digit :integer = 0;                  /* Очередная получаемая цифра */
  VAR   RetStr:string  = "";                 /* Возвращаемое значение */ 

  while(DecimalValue)
       Digit = (DecimalValue - (Int(DecimalValue / 16)) * 16);
       RetStr = SubStr(Table, Digit + 1, 1) + RetStr;
       DecimalValue = Int(DecimalValue/16);
  end;

  if(StrLen(RetStr) < NeedSize)
       RetStr = MkStr("0", NeedSize - StrLen(RetStr)) + RetStr;
  end;

  return RetStr;

END; /* ToHex */

/**** Метод получает номер коннекта */
macro GetNumConnect() : string
     var LastNameFileTmp:string = SetOutPut("__tmp__.out", TRUE);
     var LastNameFileExt:string = "";

     /* Обрежем путь и получим только имя */
     SplitFile(LastNameFileTmp, NULL, LastNameFileExt);

     /* Восстанавливаем поток вывода и удаляем получившийся файл */
     SetOutPut(LastNameFileTmp, TRUE);
     DelFile( "__tmp__.out" );

     return SubStr(LastNameFileExt, 2);
end;

/* Формирует уникальное 12-ти символьное имя файла */
MACRO GetExlusiveFileName(Extention:string)

  var FileName:string = ""; /* Имя временного файла для сохранения отчета */
  var StrDate :string = ""; /* Часть имени временного файла, сформированная из даты */
  var StrTime :string = ""; /* Часть имени временного файла, сформированная из времени */

  StrDate = MakeDateStr(Date(), "", False, False, 2);

  StrTime = Trim(String(Time():m));
  if( StrLen(StrTime) < 11 )
      StrTime = "0" + StrTime;
  end;
  StrTime  = TrStrSubst(StrTime, ":", "");
  StrTime  = TrStrSubst(StrTime, ".", "");
  FileName = StrDate + StrTime + "_" + GetNumConnect();

  if( Extention )
      FileName = FileName + "." + Extention;
  end;

  return FileName;

END; /* GetExlusiveFileName */

/* Функция вставки строки в текстовый файл с учетом всех пробелов в строке (в том числе конечных)
   Считывать строки с файла полученного этой функцией необходимо с помощью функции TR_Next */
MACRO TR_Insert(TxtFile, Str:string)

  return Insert(TxtFile, TrStrSubst(Str, " ", SPACE_REPLACER));

END; /* TR_Insert */

/* Функция считывания строки из текствого файла, полученного с помощью TR_Insert */
MACRO TR_Next(TxtFile)

   var Stat:bool = Next(TxtFile); /* Статус выполнения функции */

   if(Stat)
        TxtFile.Str = TrStrSubst(TxtFile.Str, SPACE_REPLACER, " ");
   end;

   return Stat;

END; /* TR_Next */

/* Функция для копирования файлов с сервера на терминал. Сделана в таком виде, чтобы инструмент можно
   было бы включать в файлы на терминале. На терминале функция CopyFile отсутствует и поэтому не компилится) */
MACRO TR_CopyFile(From:string, To:string)

   return ExecExp("CopyFile(From, To)");

END; /* CopyFileMy */


/* Функция для расширения строки до нужного размера символами с кодом 255 */
MACRO TR_ExtString(Str:string, NeedLen:integer):string

   if((ValType(NeedLen) == V_INTEGER)and(NeedLen > StrLen(Str)))
        Str = Str + MkStr(StrFor(255), NeedLen - StrLen(Str));
   end;

   return Str;

END; /* TR_ExtString */

/* */

/* Функция для облегчения отладки прикладного кода при падении на вызове ExecExp */
MACRO TR_ExecExp(_Str:string):variant

   if(___FlagDebug___ == True)
        Println("Debug-->ExecExp(" + _Str + ")");
        return ExecExp(_Str);
   else return ExecExp(_Str);
   end;

   OnError( ObjError )
        MsgBox( "[Windows Reports] Ошибка!|", 
               string("|Ошибка компиляции строки отчета: [",_Str,"]"):260:l,
               "| ",
               "|Code    :",  ObjError.Code   :260:l,
               "|Message :",  ObjError.Message:260:l,
               "|Module  :",  ObjError.Module :260:l,
               "|Line    :",  ObjError.Line   :260:l,
               "|AxCode  :",  ObjError.AxCode :260:l,
               "|Err     :",  ObjError.Err    :260:l,
               "|AxMes   :",  ObjError.AxMes  :260:l,
               "| |",
               "|Для получения подробной информации взведите флаг отладочного режима ":260:l,
               "|работы, при помощи метода CMakeReport.SetFlagDebug(true)"            :260:l  );

        return "UNDEF";

END; /* TR_ExecExp */



// ############################ Утилитные методы для CMakeReport (работа со строками) ###########################

/* (Private) Внутренний метод для проверки строки в целом на содержание только межстрочных разделителей */ 
macro IsStrOnlySeparator( _TestStr:string )
   var TestStr:string  = _TestStr; // Тестируемая строка
   var Pos    :integer = 0;        // Переменная для определения номера позиции искомых символов
   var Pos2   :integer = 0;        // Переменная для определения номера позиции искомых символов

   Pos = StrBrk(TestStr, "└┴┘├┼┤┌┬┐─");
   /* Если элементов межстрочных разделителей нет, сразу же вываливаемся */
   if( Not Pos )
       return False;
   else
       while( Pos )
           if( Trim(SubStr(TrStrSubst(TestStr, "│", ""), 1, Pos - 1)) )
               return False;
           end;
           TestStr = SubStr(TestStr, Pos + 1);
           Pos2    = StrBrk(TestStr, "└┴┘├┼┤┌┬┐─");
           while( Pos2 == 1 )
               TestStr = SubStr(TestStr, Pos2 + 1);
               Pos2    = StrBrk(TestStr, "└┴┘├┼┤┌┬┐─");
           end;
           Pos = Pos2;
           /* Если элементов межстрочных разделителей уже нет, а в строке еще что-то есть кроме пробелов и
              вертикальных разделителей, значит строка не содержит не только межстрочные разделители */
           if( Not Pos )
               if( Trim(TrStrSubst(TestStr, "│", "")) )
                   return False;
               end;
           end;
       end;
   end;
   return True;
end; /* IsStrOnlySeparator */

/* (Private) Внутренний метод для проверки массива строк-ячеек на содержание только межстрочных разделителей */ 
macro IsArrOnlySeparator( ArrTestStr:tarray ) : bool
      var i      :integer = 0;      // Счетчик циклов
      var TestStr:string  = "";     // Тестируемая строка

      while( i < ArrTestStr.Size )
          TestStr = TestStr + String(ArrTestStr[i].StrValue);
          i       = i + 1;
      end;
      return IsStrOnlySeparator(TestStr);  
end; /* IsArrOnlySeparator */

/* (Private) Внутренний метод для получения строки аргументов из расширенного параметра форматирования */
macro GetArg(ArgStr:string, BegDelim:string, EndDelim:string) : string
      var Arg   :string  = "";                     // Строка аргументов расширенного параметра форматирования
      var BegPos:integer = Index(ArgStr,BegDelim); // Начальная позиция, с которой начинаются аргументы

      if( BegPos )
          Arg = SubStr(ArgStr, (BegPos + StrLen(BegDelim)));
          Arg = SubStr(Arg, 1, (Index(Arg, EndDelim) - 1) );
      end;
      return Arg;
end; /* GetArg */

/**** Метод отрезает от полного имени расширение */
macro SubFileExt( _FileName:string ) : string
      return SubStr(_FileName, 1, StrLen(_FileName) - 4);
end;


/* Функция формирует строку для вывода значения переменной с заданным количеством знаков после запятой.
   Value - значение переменной
   Point - количество знаков */
macro WR_ЧислоCЗаданнойТочностью( _Value:variant, Point:integer ) : string
   var RetValue:string = "";
   var Type    :integer = ValType( _Value );
   if( ValType(Point) AND ((Type == V_DOUBLE) OR (Type == V_DOUBLEL) OR
                           (Type == V_MONEY ) OR (Type == V_MONEYL )) )
//       RetValue = TR_ExecExp( "String("+string(_Value)+":0" + ":" + string(Point) + ")" );
       RetValue = String(_Value:*:*,0,Point);
   elif( Type == V_DATE )
       RetValue = Trim(String( _Value ));
   elif( Type == V_TIME )
       RetValue = Trim(String( _Value ));
   else
       RetValue = String( _Value );
   end;
   return RetValue;
end;


/**** Функция проверки существования ключа namekey в реестре                    */
/*    ObjReg - объект "WScript.Shell", если не передан создается внутри функции */
/*    Флаг flagMsg отвечает за сообщение о ненайденном ключе,                   */
/*         если flagMsg=true  - выдаем сообщение об ошибке (по умолчанию)       */
/*         если flagMsg=false - НЕ выдаем сообщение об ошибке                   */
macro WR_CheckExistsRegKey( namekey:string, ObjReg:object, flagMsg:bool ) : bool
      var Reg      :object = NULL;
      var l_flagMsg:bool   = true;

      if( ObjReg ) Reg = ObjReg;
      else         Reg = ActiveX("WScript.Shell", NULL, true);
      end;

      if( ValType(flagMsg) == V_BOOL )
          l_flagMsg = flagMsg;
      end;

      Reg.RegRead(namekey);

      return true;

      OnError( ObjError )
        if( flagMsg )
            MsgBox( "[Windows Reports\WR_CheckExistsRegKey] Ошибка!|Не найден ключ реестра:", 
                   "|<"        ,  namekey         :260:l,
                   "|Code    :",  ObjError.Code   :260:l,
                   "|Message :",  ObjError.Message:260:l,
                   "|Module  :",  ObjError.Module :260:l,
                   "|Line    :",  ObjError.Line   :260:l,
                   "|AxCode  :",  ObjError.AxCode :260:l,
                   "|Err     :",  ObjError.Err    :260:l,
                   "|AxMes   :",  ObjError.AxMes  :260:l,
                   "| |",
                   "|Для получения подробной информации взведите флаг отладочного режима ":260:l,
                   "|работы, при помощи метода CMakeReport.SetFlagDebug(true)"            :260:l  );
        end;
        return false;
end;

/**** Функция записывает значение l_Value в ключ реестра namekey с типом l_Type(REG_DWORD,REG_SZ и другие) */
macro WR_RegWrite( namekey:string, l_Type:string, l_Value:variant ) : bool
      var Reg =  ActiveX("WScript.Shell", NULL, true);
      if( WR_CheckExistsRegKey(namekey, Reg) )
          Reg.RegWrite( namekey, l_Value, l_Type );
          return true;
      end;

      return false;
end;

/**** Функция создает ключ namekey и записывает значение l_Value в ключ реестра namekey с типом l_Type(REG_DWORD,REG_SZ и другие) */
macro WR_RegCreate( namekey:string, l_Type:string, l_Value:variant ) : bool
      var Reg =  ActiveX("WScript.Shell", NULL, true);

      Reg.RegWrite( namekey, l_Value, l_Type );
      return true;
end;

/**** Функция возвращает значение ключа реестра namekey  */
macro WR_RegRead( namekey:string ) : variant
      var Reg =  ActiveX("WScript.Shell", NULL, true);

      if( WR_CheckExistsRegKey(namekey, Reg) )
          return Reg.RegRead(namekey);
      end;
      return "";
end;


/**** Функция открытия текстового файла по указателю pFile с именем FileName в нужной кодировке
      заданной глобальной переменной or_set_h.mac\WR_CURRENCODE
       [in ] pFile    - Указатель на файл типа FILE
       [in ] FileName - Имя файла
       [out] Возвращает true в случае успеха и false в противном случае  */
macro WR_OPEN( pFile,          // Указатель на файл
               FileName:string // Имя файла
             ) : bool          // Результат операции

    return Open(pFile, FileName, WR_lsEncode[WR_CURRENCODE].encode );
end;

/**** Функция добавления строки StrValue в текстовый файл pFile
       [in ] pFile    - Указатель на файл типа FILE
       [in ] StrValue - Строка с данными
       [out] Возвращает true в случае успеха и false в противном случае  */
macro WR_Insert( pFile,          // Указатель на файл
                 StrValue:string // Строка с данными
               ) : bool          // Результат операции
/*
    var strOut:string = StrValue;

    if( WR_CURRENCODE == 4 ) // UTF8
        ToUTF8(toAnsi(StrValue), strOut); // Теперь это не нужно, т.к. файл сразу открываем в нужной кодировке  WR_OPEN
    else
        StrValue = toAnsi(StrValue); // Теперь это не нужно, т.к. файл сразу открываем в нужной кодировке  WR_OPEN
    end;
*/
    return Insert(pFile, StrValue);
end;

/* Проверка двух файлов на идентичность по дате и времени*/
macro CheckFilesEqual( FileName1:string, FileName2:string ) : bool
      const FCOUNT:integer = 1;
   
      var Date1:date, Date2:date;
      var Time1:time, Time2:time;

      var DirList:TDirList = TDirList( FileName1, "F" );

      if( DirList.Count == FCOUNT )
          Date1 = DirList.FDate( FCOUNT - 1 );
          Time1 = DirList.FTime( FCOUNT - 1 );
      else
          return false;
      end;

      DirList = TDirList( FileName2, "F" );

      if( DirList.Count == FCOUNT )
          Date2 = DirList.FDate( FCOUNT - 1 );
          Time2 = DirList.FTime( FCOUNT - 1 );
      else
          return false;
      end;

      return ((Date1 == Date2) and (Time1 == Time2));          
end;

macro GetUniqAddWhithConnect(_FileName:string) : string
      var FileName:string = "";
      var FileNameExt:string = "";
      
      SplitFile(_FileName, FileName, FileNameExt);

      if( FileName AND FileNameExt )
         _FileName = StrSubst( GetUniqAdd( _FileName ), FileNameExt, "_" + GetNumConnect() + FileNameExt); 
      end;
      return _FileName;
end;
/**/