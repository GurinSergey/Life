/*──────────────────────────────────────────────────────────────────────────┐
  RS-Bank 6.0                                          R-Style Software Lab

  File Name   : prreplib.mac
  Created     : 10.03.2010
  Programmer  : Popova O.
  Description : Класс отчета с подведением итогов по счету, операционисту 
                и филиалу.
  Changes     : 27.08.2014 VDN C-32485 Добавил переменную для шифра, признак изменения отчета для документов К2, передача значений шифра вместо операциониста
                                       для отчета "Документы, находящиеся в К2"
└───────────────────────────────────────────────────────────────────────────*/

import PaymInter, oralib, likepy, globals;
// Виды уровней счетчиков
private const onAcnt = 0,// по счету
              onOper = 1,// по операционисту
              onDprt = 2;// по филиалу

// Класс передачи параметров для функций печати элементов отчета
class TPrnReportParm( payms:TArray, amounts:TArray, dateIn:date, dateOut:date, depnum:integer, nodenum:integer, oper:integer )

   var m_Payments  :TArray     = payms,         // Массив платежей, отобранных для отчета
       m_Amounts   :TArray     = amounts,       // Суммы, выводимые в строке документа для каждого платежа
// Данные панели параметров отчета
       m_DateIn    :date       = dateIn,
       m_DateOut   :date       = dateOut,
       m_Department:integer    = depnum,
       m_Node      :integer    = nodenum,
       m_Oper      :integer    = oper;
end;

// Отчет по платежам
class TPSReportPayments( header    :string ,        /* Заголовок отчета */
                         macroname :string ,        /* Макрос с функциями печати элементов отчета */
                         /* отобранные для отчета данные */
                         paymid    :TArray ,        /* Массив отобранных платежей  */
                         amounts   :TArray ,        /* Массив выводимых для каждого платежа сумм */
                         /* данные панели параметров отчета - для заголовков */
                         dateIn    :date   ,        /* Диапазон дат отчета */
                         dateOut   :date   ,       
                         depnum    :integer,        /* Номер филиала, по которому выпускается отчет */
                         oper      :integer         /* Номер операциониста, по которому выпускается отчет*/

       /*дальше можно передавать названия функций вывода элементов "PrintHeader",... - в порядке их объявления в классе
         если они названы как-то нестандартно */ 
                      )
 private var
      // функции вывода элементов отчета
      m_PrintHeader          :string, /* 9*/
      m_PrintDprtHeader      :string, /*10*/
      m_PrintOperHeader      :string, /*11*/
      m_PrintAccountHeader   :string, /*12*/
      m_PrintDocument        :string, /*13*/
      m_PrintItogAccount     :string, /*14*/
      m_PrintItogOper        :string, /*15*/
      m_PrintItogDprt        :string, /*16*/

      // данные для печати
      m_HeaderRepord      :string           = header        ,// заголовок отчета для индикатора выполнения
      m_MacroName         :string           = macroname     ,// макрос с функциями вывода элементов отчета
      m_curAccount        :string           = ""            ,// текущий счет
      m_curOper           :integer          = 0             ,// текущий опер
      m_curDprt           :integer          = 0             ,// текущий филиал

      m_funcParm          :TPrnReportParm   = TPrnReportParm( paymid    , 
                                                              amounts   , 
                                                              dateIn    , 
                                                              dateOut   , 
                                                              depnum    ,
                                                              oper      ) ,// параметры функции печати элемента отчета

      m_Counts      :TArray = TArray(3)     ,// массив счетчиков для каждой из сумм по счету, оперу и филиалу
      m_CurAmounts  :TArray = TArray(3)     ;// массив текущих значений сумм по счету, оперу и филиалу.

      if( ( not GetParm(  9 , m_PrintHeader              ) ) or
          ( ValType( m_PrintHeader ) != V_STRING         ) )    m_PrintHeader          = "PrintHeader"        ; end;
      if( ( not GetParm( 10 , m_PrintDprtHeader          ) ) or
          ( ValType( m_PrintDprtHeader ) != V_STRING     ) )    m_PrintDprtHeader      = "PrintDprtHeader"    ; end;
      if( ( not GetParm( 11 , m_PrintOperHeader          ) ) or
          ( ValType( m_PrintOperHeader ) != V_STRING     ) )    m_PrintOperHeader      = "PrintOperHeader"    ; end;
      if( ( not GetParm( 12 , m_PrintAccountHeader       ) ) or
          ( ValType( m_PrintAccountHeader ) != V_STRING  ) )    m_PrintAccountHeader   = "PrintAccountHeader" ; end;
      if( ( not GetParm( 13 , m_PrintDocument            ) ) or
          ( ValType( m_PrintDocument ) != V_STRING       ) )    m_PrintDocument        = "PrintDocument"      ; end;
      if( ( not GetParm( 14 , m_PrintItogAccount         ) ) or
          ( ValType( m_PrintItogAccount ) != V_STRING    ) )    m_PrintItogAccount     = "PrintItogAccount"   ; end;
      if( ( not GetParm( 15 , m_PrintItogOper            ) ) or
          ( ValType( m_PrintItogOper ) != V_STRING       ) )    m_PrintItogOper        = "PrintItogOper"      ; end;
      if( ( not GetParm( 16 , m_PrintItogDprt            ) ) or
          ( ValType( m_PrintItogDprt ) != V_STRING       ) )    m_PrintItogDprt        = "PrintItogDprt"      ; end;
      /* сброс счетчиков и сумм */
      private macro SetNULL( counts:@TArray, curamounts:@TArray )
        var i = 0;
        if( ( ValType( counts ) == V_GENOBJ ) and ( ValType( curamounts ) == V_GENOBJ ) )
          while( i < counts.size )
            counts[i]     =  0;
            curamounts[i] = $0;
            i = i + 1;
          end;
        end;
      end;
      /* подсчет количества документов и сумм */
      private macro Calculator( amounts:TArray, counts:@variant, curamounts:@variant )
        var i = 0;
        if( ValType( amounts ) == V_GENOBJ )   
          if( ValType( counts ) != V_GENOBJ ) // еще не считали ничего
             counts     = TArray( amounts.size );
             curamounts = TArray( amounts.size );
          end;                   
          while( i < amounts.size ) 
            if( ValType( counts[i] ) != V_INTEGER )
              counts[i] = 0;
            end;
            if( ValType( curamounts[i] ) != V_MONEY   )
              curamounts[i] = $0;
            end;
            if( amounts[i] > $0 )
              if( ( ValType( counts[i]     ) == V_INTEGER ) and
                  ( ValType( curamounts[i] ) == V_MONEY   ) )
                counts[i]     = counts[i]     + 1;
                curamounts[i] = curamounts[i] + amounts[i];
              else
                counts[i]     = 1;
                curamounts[i] = amounts[i];
              end;
            end;
            i = i + 1;
          end;
        end;
      end;
      /* общий заголовок */
      private macro PrintHeader() debugbreak;
        ExecMacroFile( m_MacroName, m_PrintHeader, m_funcParm );
      end;
      /* заголовок по филиалу NumDprt */
      private macro PrintDprtHeader( NumDprt:integer )
        ExecMacroFile( m_MacroName, m_PrintDprtHeader, NumDprt );
      end;
      /* заголовок по операционисту Oper (или Шифру, С-32485, VDN 27.08.2014)*/
      private macro PrintOperHeader( Oper:String ) 
        ExecMacroFile( m_MacroName, m_PrintOperHeader, Oper );
      end;
      /* заголовок по счету Account */
      private macro PrintAccountHeader( Account:string ) 
        ExecMacroFile( m_MacroName, m_PrintAccountHeader, Account );
      end;
      /* печать i-той строки отчета */
      private macro PrintDocument(i:integer)
        var j = 0;                                                             
        Calculator( m_funcParm.m_Amounts[i], @m_Counts[onAcnt], @m_CurAmounts[onAcnt] );// подсчет по счету
        Calculator( m_funcParm.m_Amounts[i], @m_Counts[onOper], @m_CurAmounts[onOper] );// подсчет по оперу
        Calculator( m_funcParm.m_Amounts[i], @m_Counts[onDprt], @m_CurAmounts[onDprt] );// подсчет по филиалу
        ExecMacroFile( m_MacroName, m_PrintDocument, m_funcParm.m_Payments[i], m_funcParm.m_Amounts[i] );
      end;
      /* итог по счету Account */
      private macro PrintItogAccount( Account:string )                            
        ExecMacroFile( m_MacroName, m_PrintItogAccount , Account, m_Counts[onAcnt], m_CurAmounts[onAcnt] );
        SetNULL( @m_Counts[onAcnt], @m_CurAmounts[onAcnt] );
      end;
      /* итог по операционисту Oper (или Шифру, С-32485, VDN 27.08.2014)*/
      private macro PrintItogOper( Oper:string )
        ExecMacroFile( m_MacroName, m_PrintItogOper, Oper, m_Counts[onOper], m_CurAmounts[onOper] );
        SetNULL( @m_Counts[onOper], @m_CurAmounts[onOper] );
      end;
      /* итог по филиалу NumDprt */
      private macro PrintItogDprt( NumDprt:integer )
        ExecMacroFile( m_MacroName, m_PrintItogDprt , NumDprt, m_Counts[onDprt], m_CurAmounts[onDprt] );
        SetNULL( @m_Counts[onDprt], @m_CurAmounts[onDprt] );
      end;

      macro PrintPSReportPayments(shifr)

        var i = 0;
        var iProgress  :integer = m_funcParm.m_Payments.size, // индикатор выполнения
            ProgressInd:integer = 1;
                  
        var curPayment:RsbPayment,  // текущие данные отчета
            prevAccount = "",       // данные предыдущей строки отчета - чтоб отслеживать изменение 
            prevOper    = 0,
            prevShifr   = "",        
            prevDepNum  = 0;

        if( m_funcParm.m_Payments.size > 0 )
          InitProgress( iProgress, null, m_HeaderRepord );
          while( i < iProgress )

            UseProgress( ProgressInd );
            
            curPayment = m_funcParm.m_Payments[i];
            if( i == 0 ) // сначала выводим все заголовки
              PrintHeader();
              PrintDprtHeader   ( curPayment.Department      );
              if ( shifr ) //VDN 27.08.2014 для измененного отчета, С-32485
                PrintOperHeader ( curPayment.ShifrOper       );
              else           
                PrintOperHeader ( curPayment.Oper            );
              end;
              PrintAccountHeader( curPayment.PayerAccount    );
              InitProgress( iProgress, null, m_HeaderRepord  );
            end;

            UseProgress( ProgressInd );
            ProgressInd = ProgressInd + 1;
            // итоги, если что-то поменялось и что-то насчитали
            if ( shifr ) //VDN 27.08.2014 для измененного отчета, С-32485
               if( ( prevAccount != "" ) and ( prevAccount  != curPayment.PayerAccount    ) or 
                   ( prevShifr   != "" ) and ( prevShifr    != curPayment.ShifrOper       ) or 
                   ( prevDepNum  != 0  ) and ( prevDepNum   != curPayment.Department      ) )
                  PrintItogAccount( prevAccount ); 
                  if( ( prevShifr   != curPayment.ShifrOper ) or ( prevDepNum != curPayment.Department  ) )
                     PrintItogOper( prevShifr );
                     if( ( prevDepNum != curPayment.Department ) )
                        PrintItogDprt  ( prevDepNum            );
                        PrintDprtHeader( curPayment.Department );// заголовок по филиалу
                     end;
                     PrintOperHeader( curPayment.ShifrOper );// заголовок по шифру
                  end;
                  if( ( prevAccount != "" ) and ( prevAccount  != curPayment.PayerAccount ) )
                     PrintAccountHeader( curPayment.PayerAccount );
                  end;
               end;
            else           
               if( ( prevAccount != "" ) and ( prevAccount  != curPayment.PayerAccount    ) or 
                   ( prevOper    != 0  ) and ( prevOper     != curPayment.Oper            ) or 
                   ( prevDepNum  != 0  ) and ( prevDepNum   != curPayment.Department      ) )
                  PrintItogAccount( prevAccount ); 
                  if( ( prevOper   != curPayment.Oper        ) or ( prevDepNum != curPayment.Department  ) )
                     PrintItogOper( prevOper );
                     if( ( prevDepNum != curPayment.Department ) )
                        PrintItogDprt  ( prevDepNum            );
                        PrintDprtHeader( curPayment.Department );// заголовок по филиалу
                     end;
                     PrintOperHeader( curPayment.Oper );// заголовок по оперу
                  end;
                  if( ( prevAccount != "" ) and ( prevAccount  != curPayment.PayerAccount ) )
                     PrintAccountHeader( curPayment.PayerAccount );
                  end;
               end;
            end;
            PrintDocument(i);

            prevAccount = curPayment.PayerAccount;
            prevOper    = curPayment.Oper;
            prevDepNum  = curPayment.Department;
            prevShifr   = curPayment.ShifrOper;
            i = i + 1;
          end;//while( i < iProgress )

          // выводим последние итоги
          if( ( m_Counts(onAcnt) != 0 ) or
              ( m_Counts(onOper) != 0 ) or
              ( m_Counts(onDprt) != 0 ) )
              PrintItogAccount( prevAccount  );
              if ( shifr ) //VDN 27.08.2014 для измененного отчета, С-32485
                 PrintItogOper   ( prevShifr    );
              else
                 PrintItogOper   ( prevOper     );
              end;
              PrintItogDprt   ( prevDepNum   );
          end;

        else//if( m_funcParm.m_Payments.size > 0 )
          msgbox("Нет документов, удовлетворяющих заданным условиям");
        end;
        RemProgress();
      end;
end;//class TPSReportPayments


MACRO ВыбратьPaymentID():string
  return "SELECT pm.t_paymentid AS paymentid ";
END;

MACRO FromPMHIST_PMPAYM():string
  return " FROM dpmhist_dbt pmh, "+
               "dpmpaym_dbt pm ";
END;

MACRO ПлатежБылПомещенВ_К2( select:@string, params:TArray, DateIn:date, DateOut:date )
  select = select + " pmh.t_statusidto = 2000 "+
                 "AND pmh.t_statusidfrom <> 2000 ";
  if( DateIn == date(0,0,0) )
    select = select + " AND pmh.t_date <= :DateOut ";
  else
    select = select + " AND pmh.t_date between :DateIn and :DateOut ";
    params[params.size] = SQLParam( "DateIn"  , DateIn  );    
  end;
  params[params.size] = SQLParam( "DateOut"  , DateOut  );    
  select = select +   " AND pmh.t_PaymentID = pm.t_PaymentID "+
                      " AND pmh.t_AutoKey = ( SELECT min( pmh1.t_AutoKey ) "+
                                              " FROM dpmhist_dbt pmh1 "+
                                             " WHERE pmh1.t_AutoKey = pmh.t_AutoKey ) ";
END;

MACRO СвязьСТаблицейСчетов( chapter:integer )
  return "    AND ac.t_Account = pm.t_PayerAccount "+
         "    AND ac.t_Code_Currency = pm.t_FIID "+
         "    AND ac.t_Chapter = " + string( chapter );
END;

MACRO ПлатежКлиентскийОрдер():string
  return " AND pm.t_DocKind = 201 "/*PS_PAYORDER*/;
END;

MACRO ПлатежКлиентскийИлиБанковскийОрдер():string
  return " AND pm.t_DocKind IN (201, 286) "/*PS_PAYORDER, DLDOC_BANKORDER*/;
END;

MACRO ДобавитьУсловиеПоСчетуПлательщика( select:@string, params:TArray, Account:string )
  if( Account != "" )
    select = select + " AND pm.t_PayerAccount = :Account ";
    params[params.size] = SQLParam( "Account", Account  );    
  end;
END;

MACRO ДобавитьУсловиеПоВалютеСчетаПлательщика( select:@string, params:TArray, FIID:integer )
  if( FIID != -1 )
    select = select + " AND pm.t_FIID = :FIID ";
    params[params.size] = SQLParam( "FIID", FIID );    
  end;
END;

MACRO ДобавитьУсловиеПоФилиалуСчета( select:@string, params:TArray, DepNum:integer )
  if( DepNum > 0 )                                 
    select = select + " AND ac.t_Department = :Department ";
    params[params.size]   = SQLParam( "Department", DepNum  );    
  end;
END;

MACRO ДобавитьУсловиеПоФилиалуПлатежа( select:@string, params:TArray, DepNum:integer )
  if( DepNum > 0 )                                 
    select = select + " AND pm.t_StartDepartment = :Department ";
    params[params.size]   = SQLParam( "Department", DepNum  );    
  end;
END;

MACRO ДобавитьУсловиеПоВСПСчета( select:@string, params:TArray, NodeNum:integer )
  if( NodeNum > 0 )                                 
    select = select + " AND ac.t_Branch = :Node ";
    params[params.size]   = SQLParam( "Node", NodeNum  );    
  end;
END;

MACRO ДобавитьУсловиеПоОперационистуПлатежа( select:@string, params:TArray, Oper:integer )
  if( Oper > 0 )
    select = select + " AND pm.t_Oper = :Oper ";
    params[params.size]   = SQLParam( "Oper", Oper );    
  end;
END;

MACRO СортировкаПоОперационистуСчетуПлательщика( select:@string )
  select = select + " ORDER BY pm.t_oper, pm.t_payeraccount, pm.t_i2placedate ";
END;

MACRO СуммаВВалютеСчета( Sum:money, DateCarry:date, Payment:object ):money

  if(( Payment.IsFixPayerAmount == true ) or ( Payment.PIList(PRT_Credit).Size != 0 ))
    return execStoredFunc( "PM_ACTUATE.ConvertSum_Ex", V_MONEY, 
                           makeArray( SQLParam( "Amount"        , Sum                            ),
                                      SQLParam( "Department"    , Payment.Department             ),
                                      SQLParam( "Rate"          , Payment.BaseRate.Rate          ),
                                      SQLParam( "Point"         , Payment.BaseRate.Point         ),
                                      SQLParam( "Scale"         , Payment.BaseRate.Scale         ),
                                      SQLParam( "IsInverse"     , Payment.BaseRate.IsInverse     ),
                                      SQLParam( "RateType"      , Payment.BaseRate.RateType      ),
                                      SQLParam( "RateDate"      , DateCarry                      ),
                                      SQLParam( "FIID1"         , Payment.BaseFIID               ),
                                      SQLParam( "FIID2"         , Payment.PayerFIID              ) ) );
  else
    Sum =  execStoredFunc( "PM_ACTUATE.ConvertSum_Ex", V_MONEY, 
                           makeArray( SQLParam( "Amount"        , Sum                            ),
                                      SQLParam( "Department"    , Payment.Department             ),
                                      SQLParam( "Rate"          , Payment.BaseRate.Rate          ),
                                      SQLParam( "Point"         , Payment.BaseRate.Point         ),
                                      SQLParam( "Scale"         , Payment.BaseRate.Scale         ),
                                      SQLParam( "IsInverse"     , Payment.BaseRate.IsInverse     ),
                                      SQLParam( "RateType"      , Payment.BaseRate.RateType      ),
                                      SQLParam( "RateDate"      , DateCarry                      ),
                                      SQLParam( "FIID1"         , Payment.BaseFIID               ),
                                      SQLParam( "FIID2"         , Payment.ReceiverFIID           ) ) );
    return execStoredFunc( "PM_ACTUATE.ConvertSum_Ex", V_MONEY, 
                           makeArray( SQLParam( "Amount"        , Sum                            ),
                                      SQLParam( "Department"    , Payment.Department             ),
                                      SQLParam( "Rate"          , Payment.FactRate.Rate          ),
                                      SQLParam( "Point"         , Payment.FactRate.Point         ),
                                      SQLParam( "Scale"         , Payment.FactRate.Scale         ),
                                      SQLParam( "IsInverse"     , Payment.FactRate.IsInverse     ),
                                      SQLParam( "RateType"      , Payment.FactRate.RateType      ),
                                      SQLParam( "RateDate"      , DateCarry                      ),
                                      SQLParam( "FIID1"         , Payment.ReceiverFIID           ),
                                      SQLParam( "FIID2"         , Payment.PayerFIID              ) ) );
  end;
  return $0;
END;

MACRO СуммаПроводкиВВалютеСчетаПлательщика( carry:object, Payment:object, chargeoff:bool ):money

  if( carry.rec.FIID_Payer == Payment.PayerFIID )
    return carry.rec.Sum_Payer;
  end;

  if( carry.rec.FIID_Receiver == Payment.PayerFIID )
    return carry.rec.Sum_Receiver;
  end;

  if( Payment.PayerFIID == 0/*NATCUR*/ )
    return carry.rec.Sum_NatCur;
  end;

  return СуммаВВалютеСчета( IfThenElse( chargeoff, carry.rec.Sum_Receiver, carry.rec.Sum_Payer ), carry.rec.Date_Carry, Payment );
END;


/* Результаты проводок */
const ПриходНаК2          = 50;//OBI2INPCARRY
const ЧастичнаяОплатаК2   = 51;//OBI2PARTCARRY
const ПолнаяОплатаК2      = 52;//OBI2CARRY
const СписаниеС_К2        = 53;//OBI2DELETE
const СписаниеВ_КОР       = 74;//OBIWPINCARRY

MACRO ВыбратьПроводкиПоВнебалансуВида( ResultCarryIN:string, DateIn:date, DateOut:date, params:TArray )
 
  var select = " SELECT trn.t_AccTrnID, pm.t_PaymentID, ac.t_Oper "+
               "   FROM dacctrn_dbt trn, dpmdocs_dbt pd, dpmpaym_dbt pm, daccount_dbt ac "+
               "  WHERE trn.t_Date_Carry BETWEEN :DateIn AND :DateOut "+
               "    AND trn.t_Result_Carry IN ( "+ ResultCarryIN + " ) "+
               "    AND trn.t_Chapter = 3 "+
               "    AND trn.t_AccTrnID = pd.t_AccTrnID "+
               "    AND pd.t_PaymentID = pm.t_PaymentID "+ СвязьСТаблицейСчетов(1);
  params[params.size]  = ( SQLParam( "DateIn" , DateIn  ) );
  params[params.size]  = ( SQLParam( "DateOut", DateOut ) );
  return select;
END;

// сумма проводки по зачислению на К2 в валюте проводки
MACRO ЗачисленнаяНаК2Сумма( PaymentObj:object ):money

  var params:TArray  = TArray();
  var select = "SELECT  trn.t_AccTrnID, nvl(trn.t_Sum_Payer, 0) "+ 
              "  FROM dacctrn_dbt trn, table( PM_CARFUN.GetPaymentCarries( :PaymentID ) ) pmcar "+
              " WHERE trn.t_AccTrnID = pmcar.t_AccTrnID "+
              "   AND trn.t_Result_Carry = 50 "+
              "   AND trn.t_date_carry BETWEEN :DateIn AND :DateOut "+
              "   AND trn.t_FIID_Payer = :FIID ";
  params[params.size] = SQLParam( "PaymentID", PaymentObj.PaymentID   );    
  params[params.size] = SQLParam( "DateIn"   , date(0,0,0)            );    
  params[params.size] = SQLParam( "DateOut"  , {curdate}              );    
  params[params.size] = SQLParam( "FIID"     , PaymentObj.BaseFIID    );

  var rs:RsdRecordset = execSQLselect( select, params, FALSE );
  if( rs )
    rs.Command.NullConversion = true;
    while( rs.MoveNext() )
      SetParm( 1, rs.value(0) );
      return money( rs.value(1) );
    end;
  end;
  return $0;
END;
