/************************************************************************/
/*         Автоматизированная банковская система RS-Bank                */
/*                 Copyright (c) R-Style Software Lab 1998              */
/*                                                                      */
/*  Имя файла        : reqinter.mac                                     */
/*                                                                      */
/*  Описание         : Общие функции заявлений на открытие счета        */
/*                                                                      */
/*  Программист      : Дудин В.А.                                       */
/*                                                                      */
/*  Создан           : 14.06.00                                         */
/*                                                                      */
// KS 22.11.2013 Перенесены доработки из 30й сборки
/************************************************************************/
IMPORT BankInter, FIInter, PTInter, CTInter, CurrInter,SfInter,globals;
IMPORT oralib, likepy, cb_sql, cat_acc, get_mfo, OprInter, wltools, pay_proc;


const RegOpenAcc = "PS\\REQOPENACC\\OPERATION\\";

CONST ДлинаОкончанияСчета = 6;

/* Следующие значения занимают 1 позицию в номере счета после "КодБанка" */
CONST КодТранзитный   = "1";
CONST КодНеТранзитный = "0";

CONST ОтказОтГенерацииСообщения = 4700;

record AccRec("account.dbt");
record LinkAccRec("account.dbt");

RECORD ReqOpenAcc(reqopena);
RECORD ReqLinkAcc(reqlinka);

RECORD OldReqOpenAcc(reqopena);

RECORD ReqChangeAcc(reqchnga);
RECORD OldReqChangeAcc(reqchnga);

/* EVG Сделал private из-за переопределения с payinter.mac при постановке документа 
   оплаты комиссиив К2 в случае недостатка средств.
RECORD pt(party);*/
private RECORD pt(party);
RECORD inst(institut);
RECORD persn(persn);
RECORD PtCode(partcode);

const SUBKIND_ORDER   = 1;
const SUBKIND_REQUEST = 2;


/*RECORD SvAcc(svacc);*/

// Получить PartyID и БИК для филиала DepCode
MACRO getDeptPartyIDandBIC(DepCode : integer, PartyID : @integer, BIC : @string)
  if( (DepCode == NULL) or (DepCode == {OperDprt}) )
    PartyID = {OurBank};
    BIC     = {MFO_Bank};
  else
    var s = "select t_PartyID from ddp_dep_dbt where t_Code = " + DepCode;
    var rs = execSQLselect(s);
    if(rs and rs.moveNext())
      PartyID = rs.value(0);
      BIC     = GetPartyCode(PartyID, PTCK_BIC);
    else
      PartyID = {OurBank};
      BIC     = {MFO_Bank};
    end;
  end;    
END;

/***********************************************************************/
/* Проверка строки на наличие только цифр                              */
/***********************************************************************/
MACRO AllDigits(Str)
  VAR i = 1, Ch;
  While (i <= StrLen(Str))
    Ch = SubStr(Str, i, 1);
    if ((Ch < "0") or (Ch > "9")) return FALSE; end;
    i = i + 1;
    end;
  return TRUE;
END;

/* Заполнить код цифрой */
MACRO SetCode(num,len)
  var i = 1;
  var cod = "";
  while(i <= len)
    cod = cod + string(num);
    i = i + 1;
  end;
  return cod;
END;

/******************************************************************************
Служебная процедура, расширяет значение num до строки длиной len,
свободные позиции слева заполняет _нулями_ (а не пробелами)
******************************************************************************/
/* EVG Сделал private из-за переопределения с pay_proc.mac при постановке документа 
   оплаты комиссиив К2 в случае недостатка средств.
MACRO LZ( num, len )*/
private MACRO LZ( num, len )
     var str1, len1;
     str1 = trim( string( num ) );
     len1 = strlen( str1 );
     if ( len1 >= len ) return str1;
     else   return  mkstr("0", len-len1 ) + str1;
     end;
END;

MACRO GetAccBlncFlag( ab, Balance0, Code_Currency )
  if((ab.Balance0==Balance0)and(ab.Chapter == 1)and(ab.Code_Currency==Code_Currency))
    return true;
  else
    return false;
  end;
END;

private macro ДиапазонИсчерпан( Balance0, Code_Currency )

  msgbox( "Диапазон порядковых номеров для счетов на балансовом " + Balance0 + " в валюте " + ПолучитьКодФинИн(Code_Currency) + " исчерпан");
  return "";

end;
/* Макрос генерации номера связанного счета */
MACRO ПолучитьОкончаниеСчета( Balance0, Code_Currency )

  FILE reqacbln   (reqacbln) write;
  FILE accblnc    (accblnc);

  VAR  ОкончаниеСчета = "";
  VAR  ercode;

  var select:string = "";
  var params:TArray = NULL;
  var rset:RsdRecordset = NULL;

  reqacbln.Code_Currency = Code_Currency;
  reqacbln.Chapter       = 1;
  reqacbln.Balance       = Balance0;
  reqacbln.Department    = {OperDprt};

  /* Если в базе уже есть заданный балансовый, то искомое окончание получаем прибавлением 1 */
  if(GetEQ(reqacbln))
    ОкончаниеСчета = String(Int(reqacbln.NumAccount) + 1);
    if( strlen( ОкончаниеСчета ) > ДлинаОкончанияСчета ) 
      return ДиапазонИсчерпан( Balance0, Code_Currency );
    end;
    reqacbln.NumAccount = LZ(ОкончаниеСчета,StrLen(reqacbln.NumAccount));
    ОкончаниеСчета = LZ(ОкончаниеСчета,ДлинаОкончанияСчета);

    if(not Update(reqacbln))
      msgbox("Ошибка при определении номера счета");
      return "";
    else return ОкончаниеСчета;
    end;
  /* Если в базе еще нет заданного балансового, то окончание ищем по файлу балансовых счетов лицевых счетов */
  else
    ercode = status();
    if( (ercode == 4) or ((ercode == 9)) )
      select = "SELECT NVL( MAX( TO_NUMBER( SUBSTR( bln.t_account, 21 - :maxLen1, :maxLen2 ) ) ), 0 ) "+
               "  FROM daccblnc_dbt  bln, daccount_dbt  acc         "+
               " WHERE bln.t_account       = acc.t_account          "+
                 " AND bln.t_chapter       = acc.t_chapter          "+
                 " AND bln.t_chapter       = 1                      "+
                 " AND bln.t_code_currency = acc.t_code_currency    "+
                 " AND bln.t_code_currency = :Code_Currency         "+
                 " AND bln.t_balance0      = :Balance               "+
                 " AND acc.t_department    = :Department            "+
                 " AND not REGEXP_LIKE((SUBSTR (bln.t_account, 21 - 6, 6)),'[^[:digit:]]')"; 


      params = makeArray( SQLParam( "maxLen1"       , ДлинаОкончанияСчета  ), 
                          SQLParam( "maxLen2"       , ДлинаОкончанияСчета  ),
                          SQLParam( "Code_Currency" , Code_Currency        ),
                          SQLParam( "Balance"       , Balance0             ),
                          SQLParam( "Department"    , {OperDprt}           )
                        );

      rset = execSQLselect( select, params, TRUE );

      if( rset and rset.moveNext() )                         
        ОкончаниеСчета = String( Int( rset.value( 0 ) ) + 1 );
        if( strlen( ОкончаниеСчета ) > ДлинаОкончанияСчета )  
          return ДиапазонИсчерпан( Balance0, Code_Currency );
        end;
        else
        ОкончаниеСчета = String( 1 );
      end;

      ОкончаниеСчета = LZ(ОкончаниеСчета,ДлинаОкончанияСчета);

      reqacbln.Code_Currency = Code_Currency;
      reqacbln.Chapter       = 1;
      reqacbln.Balance       = Balance0;
      reqacbln.NumAccount    = ОкончаниеСчета;
      reqacbln.Department    = {OperDprt};

      if(not Insert(reqacbln))
        msgbox("Ошибка при определении номера счета");
        return "";
      else return ОкончаниеСчета;
      end;

    else
      msgbox("Ошибка при определении номера счета");
      return "";
    end;
  end;
  return ОкончаниеСчета;
END;

/* Получить код спецсчета */
MACRO ПолучитьКодСпецсчета( SpecKind, Code )

  file oa( "objattr" );

  var Код = Code;

  /* Определить код спецсчета */
  oa.ObjectType = OBJTYPE_ACCOUNT;
  oa.GroupID    = 2;
  oa.AttrID     = SpecKind;
  if( GetEQ( oa ) )
    Код = SubStr( oa.NumInList, 1, 2 );
  end;

  return Код;
END;
/*Макрос получения кода банка*/
MACRO ПолучитьКодБанка(PartyID:integer)
    if(PartyID == NULL)
      PartyID = {OurBank};
    end;
    var КодБанка, ВидКода = 0, Err = 0;
    GetRegistryValue("CB\\PAYMENTS\\DEPCODEKIND", V_INTEGER, ВидКода, Err);
    if(not Err)
      КодБанка = ПолучитьКодСубъекта(PartyID, ВидКода, Err);
      if(Err)
         КодБанка = "0000";
      end;
    end;
    return КодБанка;
END;
/* Макрос генерации номера открываемого счета, для которого было введено заявление */
MACRO ПолучитьНомерСчетаЗаявления( Account, Balance0, FIID, SpecKind, DepCode )

  var ОкончаниеСчета, Balance, CodeFI, NewAccount, КодБанка, PartyID, BIC;

  if( ( Account == "" ) and ( Balance0 != "" ) )
    getDeptPartyIDandBIC(DepCode, @PartyID, @BIC);

    /* У балансового берем только первые пять символов */
    Balance = SubStr( Balance0, 1, 5 );
    Balance = LZ( Balance, 5 );
    CodeFI  = LZ( ПолучитьКодФинИнДляСчета( FIID ), 3 );

    КодБанка = ПолучитьКодБанка(PartyID);
               
    ОкончаниеСчета = ПолучитьОкончаниеСчета( Balance0, FIID );
    if( ОкончаниеСчета == "" )
      return "";
    end;

    NewAccount = Balance + CodeFI + "0" + КодБанка + КодНеТранзитный + ОкончаниеСчета;

    NewAccount = GetKey( NewAccount, BIC );
  else
    NewAccount = Account;
  end;

  return NewAccount;
END;

/* Макрос генерации номера связанного счета */
MACRO ПолучитьНомерСвязанногоСчетаЗаявления(linkacc, AccountRequest, BalanceRequest, DepCode)
/* RECORD linkacc(reqlinka) - cчета заявлений на открытие счета */
/* AccountRequest - счет из заявления */
/* BalanceRequest - балансовый из заявления */

  VAR CodeFI, Balance, КодБанка;

  if(linkacc.Account == "")
    /* У балансового берем только первые пять символов */
    if(linkacc.Balance0 != "")
      Balance = SubStr(linkacc.Balance0,1,5);
    else
      Balance = SubStr(BalanceRequest,1,5);
    end;
    
    if(strlen(Balance) > 0)      
      var PartyID = 0, BIC = "";
      getDeptPartyIDandBIC(DepCode, @PartyID, @BIC);

      Balance = LZ(Balance,5);
      CodeFI  = LZ(ПолучитьКодФинИнДляСчета(linkacc.Code_Currency),3);

      КодБанка = ПолучитьКодБанка(PartyID);

      linkacc.Account = Balance+CodeFI+"0"+КодБанка;
      if(linkacc.GroupID == OBJROLE_ACC_TRANSIT)
        linkacc.Account = linkacc.Account + КодТранзитный   + SubStr(AccountRequest,15);
      else
        linkacc.Account = linkacc.Account + КодНеТранзитный + SubStr(AccountRequest,15);
      end;

      linkacc.Account = GetKey( linkacc.Account, BIC );
    end;
  end;
  return linkacc.Account;

END;


/* Проверить, существует ли счет в базе */
macro Req_IsAccExist( FIID, Account ):integer

  var select:string = "SELECT *"+
                     " FROM daccount_dbt acc" +
                     " WHERE acc.t_Account = :Account" +
                       " AND acc.t_code_currency = :FIID";
  
  
  
  var params:TArray = makeArray( SQLParam( "Account", Account ), 
                                 SQLParam( "FIID"   , FIID    )
                               );

  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    return 0;
  else
    return 1;
  end;

end;

/* Проверить, существует ли финансовый инструмент с заданным кодом в базе */
macro Req_IsFIExist( code:string ):bool

  var select:string = "SELECT *"+
                     " FROM dfininstr_dbt fi" +
                     " WHERE fi.t_fi_code = :Code";
                      
  var params:TArray = makeArray( SQLParam( "Code", code ) );
  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    return true;
  else
    return false;
  end;

end;

macro Req_IsCliringFIID( FIID )

  var CodeFI:integer = ПолучитьКодФинИн( FIID );
  if( CodeFI > 0 )
    return false;
  else
    return true;
  end;
end;

MACRO CheckPayments( Account:string, FIID:integer ):integer
//TAM 25.11.2014 
   var select = " select 1                                     "
                "   from dpmpaym_dbt pm,                       "
                "        dpmprop_dbt db                        "
                "  where pm.t_PayerAccount = :Account          "
                "    and pm.t_FIID = :FIID                     "
                "    and pm.t_Chapter = 1                      "
                "    and pm.t_PaymStatus not in (32000, 100, 0)   "
                "    and db.t_PaymentID = pm.t_PaymentID       "
                "    and db.t_DebetCredit = 0                  "
                "    and db.t_Group = 2                        "
             ;
             /*" select 1                                     "
             "   from dpmpaym_dbt pm,                       "
             "        dpmprop_dbt db,                       "
             "        dpspayord_dbt ps,                     "
             "        dpscpord_dbt cp                       "
             "  where pm.t_PayerAccount = :Account          "
             "    and pm.t_FIID = :FIID                     "
             "    and pm.t_Chapter = 1                      "
             "    and pm.t_PaymStatus not in (32000, 100)   "
             "    and db.t_PaymentID = pm.t_PaymentID       "
             "    and db.t_DebetCredit = 0                  "
             "    and db.t_Group = 2                        "
             "    and ps.t_OrderID(+) = pm.t_PaymentID      "
             "    and cp.t_OrderID(+) = pm.t_PaymentID      "
             "    and not (  (                              "
             "                  ps.t_origin  = 7 or         "
             "                  pm.t_primdocorigin = 3 or   "
             "                  cp.t_origin = 3             "
             "                )                             "
             "              and pm.t_paymstatus = 2000      "
             "            )                                 "
             ;*/

var params:TArray = makeArray( SQLParam( "Account", Account ),
                               SQLParam( "FIID"   , FIID    ) 
                             );

  if( existsSQLselect( select, params ) )
    return 1;
  else
    return 0;
  end;

END;

MACRO CheckAllPayments( Account:string, FIID:integer, BuffAccPaym:string ):integer

var stat:integer = 0;
 
 stat = CheckPayments( Account, FIID );
 if( stat )
   SetParm( 2, Account );
 end;
 
 if( stat == 0 )

   AccRec.Account       = Account;
   AccRec.Code_Currency = FIID;
   AccRec.Chapter       = 1;
   
   if( GetLinkedObject( OBJROLE_ACC_TRANSIT, OBJTYPE_ACCOUNT, UniID( AccRec, OBJTYPE_ACCOUNT ), OBJTYPE_ACCOUNT, LinkAccRec) == 0 )
     stat = CheckPayments( LinkAccRec.Account, LinkAccRec.Code_Currency );
     if( stat )
       SetParm( 2, LinkAccRec.Account );
     end;
   end;

 end;
 
 return stat;

END;

MACRO CheckSertifForAccount( Account:string, FIID:integer, Certif:TArray ):integer

  var Cert    = TArray;
  var Certifs = TArray;
  var stat = 0;


  /* поиск по значению категории "Является бланком чековой книжки" ФИ "Бланк.чек книжки" = Да */
  var select = " SELECT certif.T_SERIES, certif.t_numberfirst, certif.t_numberlast"+
               " FROM dcertif_dbt certif, dobjatcor_dbt atcor"+
               " WHERE LPAD (certif.t_fiid, 10, '0') = atcor.t_object"+
               " AND atcor.t_objecttype         = 22        "+ /*OBJTYPE_ARTICLE*/
               " AND atcor.t_groupid            = 1         "+
               " AND atcor.t_attrid             = 1         "+
               " AND certif.t_connaccount       = :Account  "+
               " AND certif.t_connaccountFIID   = :FIID     "+
               " AND certif.t_status            = 0         ";

  var params:TArray = makeArray( SQLParam( "Account", Account ),
                                 SQLParam( "FIID"   , FIID    ) );
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  var i:integer = 0;

  while( rset and rset.moveNext() )
      Cert    = TArray;
      Cert[0] = rset.value(0);
      Cert[1] = rset.value(1);
      Cert[2] = rset.value(2);
      Certifs.value(i) = Cert;
      i = i + 1;
    end;

  SetParm( 2, Certifs );
  
  return i;

ONERROR(x)
  MsgBox( x.Message );
  return -1;

END;

// Запрос наличие неотмененных претензий к счету вида Арест или Целевое использование
MACRO RSetSelectArestSpecialClaimAccount( select_str:string, Account:string, FIID:integer ):RsdRecordset

  var select = " select " + select_str +
               "   from dacclaimstate_dbt acclaimstate, "
               "        dacclaim_dbt      acclaim "
               "  where "
               "  acclaimstate.t_StateID in (select max(state.t_StateID) " // Проверяем статус последнего документа, изменяющего претензию
               "                               from dacclaim_dbt claim, "
               "                                    dacclaimstate_dbt state "
               "                              where claim.t_Account        = :Account "
               "                                and claim.t_FIID           = :FIID "
               "                                and claim.t_Chapter        = 1 "
               "                                and claim.t_StartDate     <= :curdate1 "
               "                                and ( claim.t_FinishDate   = :zerodate or "
               "                                      claim.t_FinishDate  >= :curdate2  ) "
               "                                and claim.t_ClaimKind     in ( 1, 2 ) "/*ACCLAIM_KIND_ARREST, ACCLAIM_KIND_SPECIAL*/
               "                                and state.t_ClaimID     = claim.t_ClaimID "
               "                                and state.t_StateDate  <= :curdate3 "
               "                              group by state.t_ClaimID "
               "                            )"
               "  and acclaimstate.t_State in (1, 2, 3) "/*ACCLAIM_STATUS_ACTIVE, ACCLAIM_STATUS_MODIFIED, ACCLAIM_STATUS_STOPED */
               "  and acclaim.t_ClaimID     = acclaimstate.t_ClaimID "
               ;
  var params = makeArray( SQLParam( "Account" , Account      ),
                          SQLParam( "FIID"    , FIID         ), 
                          SQLParam( "curdate1", {curdate}    ),
                          SQLParam( "zerodate", date(0,0,0)  ),
                          SQLParam( "curdate2", {curdate}    ),
                          SQLParam( "curdate3", {curdate}    )
                        );

  return execSQLselect( select, params, TRUE );
END;

//-----------------------------------------------------------------------------
//  Есть ли у клиента или счета с претензией вида "Арест",
//  инициированной налоговыми органами, за текущую дату
//-----------------------------------------------------------------------------
MACRO CheckRestFromAccount( ClientID:integer ):integer

  var select:string =
      "select /*+LEADING(t acclaimstate)*/ count(1) "
      "from dacclaimstate_dbt acclaimstate, "
           "( select /*+LEADING(acc claim state)*/ "
                    "distinct max( state.t_stateid ) over (partition by acc.t_account, acc.t_code_currency) as t_LastStateID "
               "from daccount_dbt acc, "
                    "dacclaim_dbt claim, "
                    "dacclaimstate_dbt state "
              "where acc.t_client = :clientid "
                "and acc.t_chapter = 1 "
                "and (acc.t_type_account LIKE '%Ч%' OR acc.t_type_account LIKE '%X%') "
                "and claim.t_account = acc.t_account "
                "and claim.t_fiid = acc.t_code_currency "
                "and claim.t_chapter = 1 "
                "and claim.t_claimkind = 1 "
                "and claim.t_startdate <= :curdate1 "
                "and ( claim.t_finishdate = to_date( '01010001', 'ddmmyyyy' ) or "
                      "claim.t_finishdate >= :curdate2 ) "
                "and claim.t_initiator = 1 "
                "and state.t_claimid = claim.t_claimid "
                "and state.t_statedate <= :curdate3 ) t "
      "where acclaimstate.t_StateID = t.t_LastStateID "
        "and acclaimstate.t_State IN (1, 2, 3)";
  

  var params:TArray = makeArray( SQLParam( "clientid", ClientID  ),
                                 SQLParam( "curdate1", {curdate} ),
                                 SQLParam( "curdate2", {curdate} ),
                                 SQLParam( "curdate3", {curdate} )
                               );

  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( ( rset ) and ( rset.moveNext() ) and ( rset.value(0) > 0 ) )
    return 1;
  end;

  return 0;

ONERROR(x)
  MsgBox( x.Message );
  return 1;
END;


/* 
   Проверить клиент резидент или нет? 
   если резидент true, иначе false
*/
MACRO ClientIsResident( PartyId:integer ):integer

  var resident = true;

  var select:string =  " SELECT count(1)"+
                       " FROM dparty_dbt party"+
                       " WHERE party.t_Partyid = :Id"+
                       " AND party.t_NotResident != 'X'";

  var params:TArray = makeArray( SQLParam( "Id", PartyId ) );
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    if( rset.value(0) == 1 )
      return 1;
    else
      return 0;
    end;
  end;     

    MsgBox( "Ошибка при определении клиента как резидента " );
  
ONERROR(x)
  MsgBox( x.Message );
  return 1;

END;

/* Получить клиента счета */
macro Req_GetAccClient( FIID, Account )

  file acc    ( "account"  );
  acc.Chapter       = 1;
  acc.Code_Currency = FIID;
  acc.Account       = Account;

  if( GetEQ( acc ) )
    return acc.Client;
  end;
  return 0;
end;

/* 
   Получить расчетный счет клиента 
   заполняет Account, возвращает ошибку
   1 - нет счетов, -1 - ошибка при определении
*/

MACRO GetClientAccounts( ClientID:integer, FIID:integer, Symbol:string, Account:TArray, AccFIID:TArray ):integer

  var fromstr:string = "";
  var params         = TArray;

  var select:string  = "SELECT account.t_account, account.t_Code_Currency "+
                        " FROM daccount_dbt account, dptsvdp_dbt ptsvdp "+
                       " WHERE account.t_client = :ClientIDA"+
                         " AND ptsvdp.T_PARTYID = :ClientIDP"+
                         " AND ptsvdp.T_PARTYKIND = 1"+
                         " AND ACCOUNT.T_DEPARTMENT = ptsvdp.T_DEPARTMENT"
                         " AND account.t_open_close = chr(0)"+
                         " AND account.t_chapter = 1";
  
  params = makeArray( SQLParam( "ClientIDA", ClientID ),
                      SQLParam( "ClientIDP", ClientID )
                    );

  if( FIID != ALLFININSTR )
    select = select + " AND account.t_Code_Currency  = :FIID";
    params[params.size] = SQLParam( "FIID", FIID );
  end;

  if( StrLen( Symbol ) > 0 )
    select = select + " AND account.t_type_account LIKE '%'||:Symbol||'%'";
    params[params.size] = SQLParam( "Symbol"   , Symbol   );
  end;
                    

  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  var AccA;
  var AccF;
  var i:integer;

  if( Account )
    AccA = TArray( Account );
    i = Account.Size;
  else
    AccA = TArray;
    i = 0;
  end;

  if( AccFIID ) 
    AccF = TArray( AccFIID );
  else
    AccF = TArray;
  end;

  while( rset and rset.moveNext() )
    AccA[i] = rset.value(0);
    AccF[i] = rset.value(1);
    i = i + 1;
  end;

  if( i > 0 )
    SetParm( 3, AccA );
    SetParm( 4, AccF );
    return 0;
  else
    return 1;
  end;     

   
ONERROR(x)
  MsgBox( x.Message );
  return -1;

END;

/**
 * Макрос генерации вида счета по балансовому
 */
MACRO GenKindAccount( Balance:string, Chapter:integer ):string
  var rs:RsdRecordset = execSQLselect( "select t_Kind_Account "
                                         "from dbalance_dbt "
                                        "where t_Chapter = :Chapter "
                                          "and t_iNumPlan = 0 "
                                          "and t_Balance = :Balance", 
                                       makeArray( SQLParam( "Chapter", Chapter ), 
                                                  SQLParam( "Balance", Balance ) ) );
  if( rs.moveNext() )
    return rs.value( 0 );
  else
    return "";
  end;
END;
/**
 * Ещё один
 */
MACRO ПолучитьВидСчета( Balance:string, Chapter:integer ):string
  return GenKindAccount( Balance, Chapter );
END;

MACRO GetRegValForOPENAC( Setup:string, Type, RegVal ):integer
   
   var stat:integer = 0;

   var RegStr:string = RegOpenAcc + Setup;

   var RegValue;
  
   if( Type == GetRegistryValue( RegStr, Type, RegValue, stat ) )
     SetParm( 2, RegValue );
   end;

   return stat;

END;


MACRO RemoveStr2FormStr1( Str1:string, Str2:string ):string
  
  var result:string = "";
  
  var I:integer = 1;
  var J:integer;

  while( I <= StrLen( Str2 ) )
     
     J = 1;
     result = "";

     while( J <= StrLen( Str1 ) )

       if( SubStr( Str1, J, 1) != SubStr( Str2, I, 1) )
         result = result +  SubStr( Str1, J, 1);
       end;

       J = J + 1;
     end;
     
     Str1 = result;
     I = I + 1;

  end;

  return Str1;

END;
/*

/* 
   Удаляет из типа счета - Account валюты -  FIID, строку RemSym,
   и добавляет строку AddSym 
*/
MACRO ChangeSymbolFromType_Account( Account:string,  FIID:integer, RemSym:string, AddSym:string ):integer

   var stat:integer = 0;
   var type_account:string = "";

   var select:string = "";
   var from  :string = "";
   var params = TArray;

   if( FIID != NATCUR )
     from = "daccount$_dbt";
   else
     from = "daccount_dbt"
   end;

   select = " SELECT t_type_account  FROM "+ from + " acc  "
            " WHERE acc.t_account = :Account"+
              " AND acc.t_code_currency = :FIID"; 


  params = makeArray( SQLParam( "Account", Account ),
                      SQLParam( "FIID"   , FIID    )
                    );
  
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
     type_account = rset.value(0);
  else
    return 1;
  end;

  if( RemSym != "")
    type_account = RemoveStr2FormStr1( type_account, RemSym );
  end;

  type_account = type_account + AddSym;

  if( StrLen( type_account ) == 0 )
    type_account = "";
  end;

  select = "";
  params = TArray;

  select = " UPDATE " + from +
           " SET t_type_account = :Type_Account"
           " WHERE t_account = :Account "
             " AND t_code_currency = :FIID";

  params = makeArray( SQLParam( "Type_Account", type_account ),
                      SQLParam( "Account"     , Account      ),
                      SQLParam( "FIID"        , FIID         )
                    );

  SQL_ExecuteTrn( execSQL( select, params, TRUE ) );

  return 0;

ONERROR(x)
  MsgBox( x.Message );
  return -1;
 
END;

*/

/* получить буфер счета */
MACRO GetAccount(chapt:integer, name:string, FIID:integer):TRecHandler
  var acc:TRecHandler = TRecHandler("account.dbt", "bank.def");
  var facc:TBFile;
  
  ClearRecord(acc);
  facc = TBFile("account.dbt",  "R", 0, "account.dbt",  "bank.def");
  facc.rec.Chapter       = chapt;
  facc.rec.Code_Currency = FIID;
  facc.rec.Account       = name;
  if(facc.GetEQ())
    Copy(acc, facc);
  end;
  return acc;
END;

/* получить тип счета */
MACRO GetTypeAccount(chapt:integer, name:string, FIID:integer):string

  var acc:TRecHandler = GetAccount(chapt, name, FIID);
  return acc.rec.Type_Account;
END;

MACRO GetREQOPNAC( Account:string, stat:integer ):TRecHandler

  var rqopac:TBFile = TBFile( "reqopnac.dbt", "R", 0, "reqopnac.dbt", "bank.def" );
  var reqopnac:TRecHandler = TRecHandler( "reqopnac.dbt", "bank.def" );

  var select:string = "SELECT rq.t_RequestID FROM dreqopnac_dbt rq WHERE rq.t_Account = :Account";
  var params:TArray = makeArray( SQLParam( "Account", Account ) );

  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    
    rqopac.rec.RequestID = rset.value(0);
    
    if( rqopac.GetEQ() )
      Copy( reqopnac, rqopac );
      SetParm( 1, 0);
    else
      SetParm( 1, 1);
    end;

  else
    SetParm( 1, 1);
  end;

  return reqopnac;

ONERROR(x)
  MsgBox( x.Message );
  return -1;

END;


//-----------------------------------------------------------------------------
// Первичный документ для счета КУ "Доходы с накоп.счетов"
//-----------------------------------------------------------------------------
CLASS (TCommonFirstDoc) ProfitFromAccAccum( Code_Currency )

  VAR CodeCurr:string;

  // Вернуть параметр первого рода
  MACRO GetParametrTemplate ( ObjectID, Classificator, OperDate, FIRole )         

    // Для КУ "Доходы с накоп.счетов"
    if(  CodeCurr == NATCUR )
      return 1;
    else
      return 0;
    end;
    
  END;

  CodeCurr = Code_Currency;
  InitTCommonFirstDoc();

END;

MACRO GetObjLinkAcc( Account:string, FIID:integer, GroupID:integer ):string
record AccOut(account);
 RECORD AccIn ( account ); 

 var params:TArray = TArray();
 var select:string;
 var ObjType:integer = OBJTYPE_ACCOUNT;
 
 AccIn.Account = Account;
 AccIn.Code_Currency = FIID;
 AccIn.Chapter       = 1;
 var OBID:string = UniID( AccIn, OBJTYPE_ACCOUNT );

 if( GroupID != -1 )

    select = "select t_AttrID from dobjlink_dbt where t_ObjectType = :ObjType"+
            " and t_ObjectID = :OBID and t_GroupID = :GroupID and t_AttrType = :ObjType1"; 

    params = makeArray( SQLParam( "ObjType" , ObjType   ),
                        SQLParam( "OBID"    , OBID      ),
                        SQLParam( "GroupID" , GroupID   ),
                        SQLParam( "ObjType1", ObjType   )
                      );
 else

    select = "select t_AttrID from dobjlink_dbt where t_ObjectType = :ObjType"+
            " and t_ObjectID = :OBID"+
            " and t_AttrType = :ObjType1"; 

    params = makeArray( SQLParam( "ObjType" , ObjType ),
                        SQLParam( "OBID"    , OBID    ),
                        SQLParam( "ObjType1", ObjType )
                      );
 
 end;

 var rs:RsdRecordset = execSQLselect( select, params, FALSE );

 if( rs and rs.MoveNext() )
    RestoreFromUniID(rs.Value(0), AccOut, OBJTYPE_ACCOUNT);
    return AccOut.Account;
 else
    return "";
 end;

ONERROR(x)
  MsgBox( x.Message );
  return -1;
END;
//-----------------------------------------------------------------------------
// Поиск связанных счетов для DocKind'а (пока)
//-----------------------------------------------------------------------------
MACRO GetReqLinkAcc( RequestID:integer, DocKind:integer ):TRecHandler

  var reqlinka:TRecHandler = TRecHandler( "reqlinka.dbt", "bank.def" );

  var select:string = "SELECT *"+
                     " FROM dreqlinka_dbt rqlink" +
                     " WHERE rqlink.T_REQUESTID = :RequestID" +
                        " AND rqlink.T_DOCKIND = :DocKind"+
                        " AND rqlink.T_GROUPID = 6";
  
  
  
  var params:TArray = makeArray( SQLParam( "RequestID", RequestID ),
                                 SQLParam( "DocKind"  , DocKind   )
                               );

  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )

    reqlinka.rec.DocKind       = rset.value(0);
    reqlinka.rec.RequestID     = rset.value(1);
    reqlinka.rec.GroupID       = rset.value(2);
    reqlinka.rec.Chapter       = rset.value(3);
    reqlinka.rec.Code_Currency = rset.value(4);
    reqlinka.rec.Account       = rset.value(5);
    reqlinka.rec.Balance0      = rset.value(6);
    reqlinka.rec.Balance1      = rset.value(7);
    reqlinka.rec.Balance2      = rset.value(8);
    reqlinka.rec.Balance3      = rset.value(9);
    reqlinka.rec.Balance4      = rset.value(10);
    reqlinka.rec.Balance5      = rset.value(11);
    reqlinka.rec.Balance6      = rset.value(12);
    reqlinka.rec.Balance7      = rset.value(13);
    reqlinka.rec.Balance8      = rset.value(14);
    reqlinka.rec.Balance9      = rset.value(15);
    reqlinka.rec.Balance10     = rset.value(16);
    reqlinka.rec.Balance11     = rset.value(17);
    reqlinka.rec.Action        = rset.value(18);

  else
    reqlinka.Clear();
  end;

  return reqlinka;

ONERROR(x)
  MsgBox( x.Message );
  return -1;
END;


/* Существует ли договор обслуживания для данного счета */
macro ExistSfForAccount( FIID, Account )

  var select:string =  "SELECT count(1)"+           
                       " FROM dsfcontr_dbt"+        
                       " WHERE t_ServKind = 3"+     
                         " AND t_ObjectType = 1"+   
                         " AND t_FIID = :FIID"+     
                         " AND t_Object = :Account";


  var params:TArray = makeArray( SQLParam( "FIID"   , FIID ),
                                 SQLParam( "Account", Account )
                               );
                                 
  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    if( rset.value(0) == 1 )
      return 1;
    else
      return 0;
    end;
  end;     

    MsgBox( "Ошибка при определении договора обслуживания для данного счета " );
  
ONERROR(x)
  MsgBox( x.Message );
  return 1;
end;

// Проверить тип счета на соответствие настройке PS\\REQOPENACC\\OPERATION...
MACRO CheckTypeAccPSRegVal( TypeAcc:string, RegVal:string ): bool

   var RegTypeAcc:string = "";
   var LenRegTypeAcc;

   var stat = 0;
   var i:integer = 1;

   stat = GetRegValForOPENAC( RegVal, V_STRING, RegTypeAcc );
   
   if( stat == 0 )
     LenRegTypeAcc = strlen( RegTypeAcc );
     
     while( i <= LenRegTypeAcc )
       
       if( index( TypeAcc, substr( RegTypeAcc, i, 1 ) ) )
         return true;
       end;

       i = i+1;
     end;

   end;

   return false;

END;

MACRO CheckAgainstRegAccType( FIID, Account )

   var accbuf  :TRecHandler = TRecHandler( "account.dbt"  , "bank.def" );   

   var stat = 0;
   var i:integer = 1;

   var RegTypeAcc:string = "";
   var LenRegTypeAcc;

   accbuf = GetAccount( 1, Account, FIID );

   stat = GetRegValForOPENAC( "ТИПЫ_СЧЕТОВ", V_STRING, RegTypeAcc );
   
   if( stat == 0 )
     LenRegTypeAcc = strlen( RegTypeAcc );
     
     while( i <= LenRegTypeAcc )
       
       if( index( accbuf.rec.Type_Account, substr( RegTypeAcc, i, 1 ) ) )
         return true;
       end;

       i = i+1;
     end;

   end;

   return false;

END;

MACRO GetValueName( List, Element )
   var ll = TRecHandler("llvalues.dbt");      
   if( LL_FindLLVALUES( List, Element, ll ) == true )       
      return ll.rec.Name;
   end;    
   return ""; 
END;


PRIVATE MACRO AccountIsMask( Account:string )
  if( Index( Account, "*" ) )
    return true;
  else
    return false;
  end;
END;

 MACRO GetAccounts( Dep:integer, Branch:integer, FIID:integer, Symbol:string, Mask:string, Account:TArray, AccFIID:TArray ):integer

  var params = TArray;

  var select = "SELECT acc.t_Account, acc.t_Code_Currency "+
              " FROM daccount_dbt acc"+
              " WHERE acc.t_chapter = 1"+
                " AND acc.t_Type_Account like '%'||:Symbol||'%'"+
                " AND acc.t_Department = :Dep"+
                " AND acc.t_Branch     = :Branch"+
                " AND acc.t_Open_Close = chr(0)";


  
  params = makeArray( SQLParam( "Symbol", Symbol ),
                      SQLParam( "Dep"   , Dep    ),
                      SQLParam( "Branch", Branch )
                    );

  select = select + " AND (" + ConvertMaskToSQLFormat(Mask, "acc.t_Account") + ") ";

  if( FIID != -1 )
    select = select + " AND acc.t_Code_Currency = :FIID";
  params[params.size] = SQLParam( "FIID", FIID );
  end;

  if( Symbol == "L" )
    select = select + " AND NOT EXISTS( SELECT REQ.T_REQUESTID"+
                      " FROM DREQCLSAC_DBT REQ"+
                      " WHERE REQ.T_ACCOUNT = acc.T_ACCOUNT"+
                      " AND REQ.T_ACCOUNTFIID = acc.T_CODE_CURRENCY )";

  else
    select = select + " AND NOT EXISTS( SELECT REQ.T_REQUESTID"+
                      " FROM DREQCLOSA_DBT REQ"+
                      " WHERE REQ.T_ACCOUNT = acc.T_ACCOUNT"+
                      " AND REQ.T_CODE_CURRENCY = acc.T_CODE_CURRENCY )";
  end;


  VAR rset:RsdRecordset = execSQLselect( select, params, TRUE );

  var AccA;
  var AccF;
  var i:integer;

  if( Account )
    AccA = TArray( Account );
    i = Account.Size;
  else
    AccA = TArray;
    i = 0;
  end;

  if( AccFIID ) 
    AccF = TArray( AccFIID );
  else
    AccF = TArray;
  end;

  while( rset and rset.moveNext() )
    AccA[i] = rset.value(0);
    AccF[i] = rset.value(1);
    i = i + 1;
  end;

  if( i > 0 )
    SetParm( 5, AccA );
    SetParm( 6, AccF );
    return 0;
  else
    return 1;
  end;     

   
ONERROR(x)
  MsgBox( x.Message );
  return -1;

END;

MACRO ReadNoteForAccount( Account:string, FIID:integer, NoteKind:integer ):string

  RECORD AccIn ( account ); 

  ClearRecord( AccIn );
 
  AccIn.Account = Account;
  AccIn.Code_Currency = FIID;
  AccIn.Chapter       = 1;

  var OBID:string = UniID( AccIn, OBJTYPE_ACCOUNT );

  // Заполнить примечание
  return readNoteForObject( OBJTYPE_ACCOUNT, OBID, NoteKind );

END;

MACRO InsertNoteForAccount( Account:string, FIID:integer, NoteKind:integer, NoteStr ):integer

  RECORD AccIn ( account ); 

  ClearRecord( AccIn );
 
  AccIn.Account = Account;
  AccIn.Code_Currency = FIID;
  AccIn.Chapter       = 1;

  var OBID:string = UniID( AccIn, OBJTYPE_ACCOUNT );

  // Заполнить примечание
  if( AddNoteForObject( OBJTYPE_ACCOUNT, OBID, NoteKind, NoteStr ))
    return 1;
  end;

  return 0;
END;

//Получить тип счёта
macro GetTypeAcc(Code_Currency:integer, type_Account:string):string

  var typeac = Tbfile("typeac.dbt","r");
  
  var pos = StrBrk(type_Account,"ЧЯQX");
  if(pos)
    typeac.rec.type_Account = SubStr( type_Account,pos, 1);
  else
    typeac.rec.type_Account = SubStr( type_Account, 1, 1);
  end;

  if(Code_Currency == 0 )
    typeac.rec.InumType = 1;
  else
    typeac.rec.InumType = 4;
  end;

  if(getEQ(typeac))
    return typeac.rec.Name_Type;
  else
    return "";
  end;

end;

//Получить название валюты        
macro GetNameCurrencyAcc(Code_Currency:integer):string

  var fininstr=Tbfile("fininstr.dbt","r");

  fininstr.rec.FIID = Code_Currency;

  if(getEQ(fininstr))
    return fininstr.rec.Name;
  else
    return "";
  end;

end;

//Получить наименование филиала     
macro GetNameBranch( Code ):string
  
  var dp_dep = Tbfile("dp_dep.dbt", "r");
  var party = Tbfile("party.dbt", "r");
  dp_dep.rec.Code = Code;

  if(getEQ(dp_dep))

    party.rec.PartyID = dp_dep.rec.PartyID;

    if(getEQ(party))
      return party.rec.Name;
    else
      return "";
    end;

  else
    return "";
  end;

end;

//Получить фактический адрес филиала
macro GetRealAdressDep(Code:integer):string
  var params:TArray  = TArray(),
      select, rs, AdressDep;
  select = "select dAdress_dbt.t_CodePlace, dAdress_dbt.t_Place "+ 
             "from dDp_dep_dbt, dAdress_dbt " +
             "where "+ 
               "dDp_dep_dbt.t_Code = :Code and "+
               "dDp_dep_dbt.t_PartyID = dAdress_dbt.t_PartyID and "+
               "dAdress_dbt.t_Type = 2 ";                    //Берем фактический адрес
               //"dAdress_dbt.t_CodePlace = dAdmterr_dbt.t_NumberPlace";

      params[params.size] = ( SQLParam( "Code" , Code ));

      rs = execSQLselect( select, params, FALSE );
      if( rs and rs.MoveNext())
        AdressDep = rs.value(0) + rs.value(1);

      else
        AdressDep = "";
      end;
      return AdressDep;
end;

//Получить должность и ФИО 1-го лица клиента из справочника 
macro GetPostAndNameFirstFace( PartyID, ФИО, Post ):bool

  var params:TArray  = TArray(),
      select, rs, stat;

 select = " select off.T_POST, per.T_NAME1, per.T_NAME2, per.T_NAME3 " +
            " from dofficer_dbt off, dpersn_dbt per " +
            " where  off.T_PARTYID = :PartyID and " +
            " off.T_ISFIRSTPERSON = 'X' and " +
            " off.T_PERSONID = per.T_PERSONID ";

      params[params.size] = ( SQLParam( "PartyID" , PartyID ));

      rs = execSQLselect( select, params, FALSE );

      if( rs and rs.MoveNext() )
        SetParm(1 , rs.value(1) + " " + rs.value(2) + " " + rs.value(3));
        SetParm(2 , rs.value(0));
        stat = true;
      else
         stat = false;
      end;

      return stat;
end;

/* Получить число копий для печати */
MACRO GetNumCopy()

  var NumCopy = 0;

  if (NumCopy <= 0)
    NumCopy = 1;
    if( ( not GetInt(NumCopy,"Введите количество копий.",3)) or (NumCopy <= 0) )
      exit(1);
    end;
  end;
  return NumCopy;
END;

//Получить номер и дату догорова обслуживания
macro GetNumAndDateContr(Code_Currency:integer,Account:string, dateBegin:date, number:string, dateClose:date):bool

  var sfcontr = Tbfile("sfcontr.dbt", "r",1);
  var CloseDate:date;

  sfcontr.rec.ServKind = 3;  //PTSK_PAY РКО
  sfcontr.rec.objectType = SF_ACCOUNT;
  sfcontr.rec.FIID = Code_Currency;
  sfcontr.rec.Object = Account;
  if( getEQ(sfcontr) )
     SetParm( 2, sfcontr.rec.DateBegin);
     SetParm( 3, sfcontr.rec.number);
     SetParm( 4, sfcontr.rec.DateClose);
     return true;
  else
     SetParm( 2, date(0,0,0));
     SetParm( 3, "");
     SetParm( 4, date(0,0,0));
     return false;
  end;

end;

//Получить запись из Party.dbt
macro GetPartyRec(PartyID,TR_party):bool
  var Tb_party = Tbfile("party.dbt", "r");

    Tb_party.rec.PartyID = PartyID;

    if(getEQ(Tb_party))
      Copy(TR_party,Tb_party);
      return true;
    else
      return false;
    end;
end;      
//Сравнение двух RECORD-ов
//Если возвращает true, то равны  
MACRO CmpRECORD( rec1, rec2 ):bool

  var SizeRec1 = FldNumber( rec1 ), 
      SizeRec2 = FldNumber( rec2 ),
      i = 0,
      stat = true;

  if( SizeRec1 != SizeRec2 )
    stat = false;
  end;

  while( stat and ( i < SizeRec1 ))
    if( rec1(i) != rec2(i))
      stat = false;
    end;
  end;                        

  return stat;
END;

//------------------------------------------------------------------------------
// Выполнен ли шаг?
//------------------------------------------------------------------------------
MACRO IsStepWasExecuted( ReqID:integer, DocKind:integer, NumStep:integer ):bool
                                                                                    
  var select:string = " select st.t_IsExecute " +
                      "   from doproper_dbt op, doprstep_dbt st" +
                      "  where op.t_DocKind      = :DocKind " +
                      "    and op.t_DocumentID   = LPAD(:DocumentID, 34, '0') " +
                      "    and st.t_ID_Operation = op.t_ID_Operation " +
                      "    and st.t_Number_Step  = :NumStep " ;

  var params:TArray = makeArray( SQLParam( "DocKind"   , DocKind ),
                                 SQLParam( "DocumentID", ReqID   ),
                                 SQLParam( "NumStep",    NumStep ));
       
  var rs:RsdRecordset = execSQLselect( select, params, false );

  if( rs and rs.moveNext() )
    if(rs.value(0) == "X")
      return true;
    else
      return false;
    end;
  else
    return false;
  end;

END;

//------------------------------------------------------------------------------
// Значение настройки PS/REQOPENAC/OPERATION/НАЗНАЧАТЬ_ТП
//------------------------------------------------------------------------------
MACRO IsNeedSetSfPlan( void ):bool

  var RegVal = true;
  var error = 0;
  if( GetRegValForOPENAC( "НАЗНАЧАТЬ_ТП", V_BOOL, RegVal ) != 0 )
    RegVal = true;
  end; 
  return RegVal;
END;

//------------------------------------------------------------------------------
// Поиск тарифного плана по ID ДО 
//------------------------------------------------------------------------------
MACRO FindSfPlanIDByContract( SfContractID:integer, OnDate:date ):integer

  var SfPlanID = 0;
  var select:string = " select t_SfPlanID       " +
                      "   from dsfcontrplan_dbt " +
                      "  where t_SfContrID  = :SfContractID " +
                      "    and t_Begin     <= :OnDate       ";

  var params:TArray = makeArray( SQLParam( "SfContractID" , SfContractID ),
                                 SQLParam( "OnDate"       , OnDate       ));
       
  var rs:RsdRecordset = execSQLselect( select, params, false );

  if( rs and rs.moveNext() )
    SfPlanID = rs.value(0);
  end;

  return SfPlanID;

END;

//------------------------------------------------------------------------------
// Поиск тарифного плана по ID клиента
//------------------------------------------------------------------------------
MACRO FindSfPlanIDByClient( ClientID:integer, OnDate:date ):integer

  var SfPlanID = 0;
  var select:string = " select t_SfPlanID      " +
                      "   from dptdpsfplan_dbt " +
                      "  where t_SfPlanID    <>  0 " +
                      "    and t_PartyID      = :ClientID   " +
                      "    and t_Department   = :Department " +
                      "    and t_ServiceKind  = :ServKind   " +
                      "    and t_StartDate   <= :OnDate     " +
                      " order by t_StartDate desc ";


  var params:TArray = makeArray( SQLParam( "ClientID"   , ClientID    ),
                                 SQLParam( "Department" , {OperDprt}  ),
                                 SQLParam( "ServKind"   , PTSK_PAY    ),
                                 SQLParam( "OnDate"     , OnDate      ));
       
  var rs:RsdRecordset = execSQLselect( select, params, false );

  if( rs and rs.moveNext() )
    SfPlanID = rs.value(0);
  end;

  return SfPlanID;

END;

//-------------------------------------------------------------------------------
// Найти филиал и ВСП счета
//-------------------------------------------------------------------------------
MACRO FillDepartmentAndBranch( Account:string, FIID:integer, Department:@integer, Branch:@integer ):bool

  var select:string = "SELECT t_Department, t_Branch     "+
                      "  FROM daccount_dbt               "+
                      " WHERE t_Account       = :Account "+
                      "   AND t_code_currency = :FIID    ";
  
  var params:TArray = makeArray( SQLParam( "Account", Account ), 
                                 SQLParam( "FIID"   , FIID    )
                               );

  var rset:RsdRecordset = execSQLselect( select, params, TRUE );

  if( rset and rset.moveNext() )
    SetParm( 2, rset.value( 0 ) );
    SetParm( 3, rset.value( 1 ) );
    return true;
  end;
  return false;
END;

//-------------------------------------------------------------------------------------------------------
// Проверить тип счета на соответсвие значению настройки PS\\REQOPENACC\\OPERATION\\ТИП_ОТКР_СЧЕТА
//-------------------------------------------------------------------------------------------------------
MACRO CheckTypeAccount( TypeAccount:string, InReqTypeStr:string ):bool

  if( not InReqTypeStr )
    InReqTypeStr = "в заявлении на открытие счета";
  end;

  var TypeAccRegVal:string = "";
  var i:integer = 1;
  var ok:bool = true;

  if( not GetRegValForOPENAC( "ТИП_ОТКР_СЧЕТА", V_STRING, TypeAccRegVal ) )
    while( ok and ( i <= strlen( TypeAccount ) ) )
      if( ( SubStr( TypeAccount, i, 1 ) == "L" ) or 
          ( Index ( TypeAccRegVal, SubStr( TypeAccount, i, 1 ) ) == 0 ) )
        Msgbox("Тип счета " + SubStr( TypeAccount, i, 1 ) + " не разрешено задавать " + InReqTypeStr);
        ok = false;
      end;
      i  = i + 1;
    end;
  end;
  return ok;
END;

//-------------------------------------------------------------------------------------------------------
// Найти наименование банка для сообщений в налоговые органы и фонды
//-------------------------------------------------------------------------------------------------------
MACRO GetBankNameReqMes( PartyID, BankName ):integer

var select = " SELECT DECODE( PARTY_F.T_PARTYID, PARTY_G.T_PARTYID, PARTY_F.T_SHORTNAME,"+
                            " PARTY_G.T_SHORTNAME || ', ' || PARTY_F.T_SHORTNAME ) AS BANKNAME"+
             " FROM DDP_DEP_DBT FILIAL,"+
                  " DPARTY_DBT  PARTY_F,"+
                  " DDP_DEP_DBT GOLOVA,"+
                      " DPARTY_DBT  PARTY_G"+
             " WHERE FILIAL.T_PARTYID = :PartyID"+
               " AND PARTY_F.T_PARTYID = FILIAL.T_PARTYID "+
               " AND GOLOVA.T_PARENTCODE = 0"+
               " AND GOLOVA.T_STATUS = 2"+
               " AND PARTY_G.T_PARTYID = GOLOVA.T_PARTYID";

var params:TArray = makeArray( SQLParam( "PartyID", PartyID ) );

var rset:RsdRecordset = execSQLselect( select, params, TRUE );

if( rset and rset.moveNext() )
  SetParm( 1, rset.value(0) );
end;     

return 0;

ONERROR(x)
  MsgBox( x.Message );
  return 1;
END;

//-------------------------------------------------------------------------------------------------------
// Найти адрес банка для сообщений в налоговые органы и фонды
//-------------------------------------------------------------------------------------------------------
MACRO GetBankAdressReqMes( PartyID, Index:string, Adress:string, Phone:string )

var select = "SELECT ADRESS.T_POSTINDEX, ADRESS.T_ADRESS, ADRESS.t_PHONENUMBER"+
            " FROM DADRESS_DBT ADRESS"+
            " WHERE ADRESS.T_PARTYID = :PartyID"+
            " ORDER BY DECODE( ADRESS.T_TYPE, 3, 1, 1, 2, 3) ASC";


var params:TArray = makeArray( SQLParam( "PartyID", PartyID ) );

var rset:RsdRecordset = execSQLselect( select, params, TRUE );

var BankPhone = "";

if( rset and rset.moveNext() )
  SetParm( 1, rset.value(0));
  SetParm( 2, rset.value(1));
  if( GetParm( 3, BankPhone ) )
    SetParm( 3, rset.value(2));
  end;
end;     

  return 0;

ONERROR(x)
  MsgBox( x.Message );
  return 1;

END;

//-------------------------------------------------------------------------------------------------------
// Найти наименование клиента счета для сообщений в налоговые органы и фонды
//-------------------------------------------------------------------------------------------------------
macro GetClientNameReqMes( PartyID:integer, Name:string ):integer

var select =  " SELECT DECODE(PARTY.T_LEGALFORM,"+
              " 2, DECODE( PERSN.T_ISEMPLOYER,"+
                         " 'X', 'Индивидуальный предприниматель ' || PERSN.T_NAME1 ||' '||PERSN.T_NAME2||' '||PERSN.T_NAME3,"+
                         " PERSN.T_NAME1 ||' '||PERSN.T_NAME2||' '||PERSN.T_NAME3 ),"+
                 " PARTY.T_NAME ) AS NAME"+
" FROM DPARTY_DBT PARTY"+
" LEFT JOIN DPERSN_DBT PERSN ON PERSN.T_PERSONID = PARTY.T_PARTYID"+
" WHERE PARTY.T_PARTYID = :PartyID";

var params:TArray = makeArray( SQLParam( "PartyID", PartyID ) );

var rset:RsdRecordset = execSQLselect( select, params, TRUE );

if( rset and rset.moveNext() )
  SetParm( 1, rset.value(0));
end;     

  return 0;

ONERROR(x)
  MsgBox( x.Message );
  return 1;
 
end;

//-------------------------------------------------------------------------------------------------------
// Найти серию и номер регистрационного документа
//-------------------------------------------------------------------------------------------------------
MACRO GetRegSeriesAndNumber( RegDocKind:integer, RegPartyKind:integer, ID:integer, Series:string, Number:string ):integer

var select =  " SELECT DOC.T_SERIES, DOC.T_NUMBER"+
              " FROM DOBJRGDOC_DBT DOC"+
              " WHERE DOC.T_OBJECTID = :ID"+
                " AND DOC.T_REGDOCKIND = :DK"+
                " AND DOC.T_REGPARTYKIND = :PK"+
                " AND DOC.T_ISCLOSED = CHR(0)";

var params:TArray = makeArray( SQLParam( "ID", ID           ),
                               SQLParam( "DK", RegDocKind   ), 
                               SQLParam( "PK", RegPartyKind ) 
                             );

var rset:RsdRecordset = execSQLselect( select, params, TRUE );

if( rset and rset.moveNext() )
  SetParm( 3, rset.value(0) );
  SetParm( 4, rset.value(1) );
end;     

return 0;

ONERROR(x)
  MsgBox( x.Message );
  return 1;

END;

//-------------------------------------------------------------------------------------------------------
// Найти наименование, индекс и адрес фонда. в котором зарегистрирован банк
//-------------------------------------------------------------------------------------------------------
MACRO GetFondsData( Code:string, Name:string ):integer

                  
var select =  "SELECT PARTY.T_NAME"+
             " FROM DPARTY_DBT PARTY, DOBJCODE_DBT OBJCODE"+
             " WHERE OBJCODE.T_CODE = :Code"+
               " AND OBJCODE.T_CODEKIND = 28"+
               " AND PARTY.T_PARTYID = OBJCODE.T_OBJECTID";

var params:TArray = makeArray( SQLParam( "Code", Code ) );

var rset:RsdRecordset = execSQLselect( select, params, TRUE );

if( rset and rset.moveNext() )
  SetParm( 1, rset.value(0) );
end;     

return 0;

ONERROR(x)
  MsgBox( x.Message );
  return 1;
END;
