// KS 22.11.2013 Перенесены доработки из 30й сборки

import  InsCarryDoc, PaymInter, FIInter, PTInter, OprInter, BankInter, CTInter,"payconst.mac","pay_proc.mac",
        "globals.mac", pm_common, pm_tools, lib_str, likepy, bnk_common;




const REFER_GET_ACCOUNT_K2 = 126;
const REFER_GET_ACCOUNT_CURK2 = 172;

private const OBJGROUP_REGIONKIND_OUTSIDEREGION = 2;
private const ZeroDate = date(0,0,0);

private macro GetIndex2Refer( FIID )
  if( FIID > 0 )
    return REFER_GET_ACCOUNT_CURK2;
  end;
  return REFER_GET_ACCOUNT_K2;
end;

/******************************************************************************
Процедура генерации номера лицевого счета по входным данным
******************************************************************************/
macro MakeAccNumber(
   Chapter,     /* Глава */
   Dprt,        /* Номер отделения */
   Bal,         /* Номер балансового счета */
   FIID,        /* Идентификатор (не код !) финансового инструмента */
   Party,       /* Номер контрагента (клиента, ...) - владельца счета */
   CodeKind     /* Вид кода контрагента (клиента, ...), который должен быть в счете */
)

     var CodeFI, res_string;
     record finstr(fininstr);

     if (valtype (FIID) != V_INTEGER )
        CodeFI= LZ (FIID, 3);
     else
          CodeFI = LZ (ПолучитьКодФинИнДляСчета ( FIID ),3);
     end;

        res_string =    string (Bal) +
                        CodeFI + "0" + "0000" + LZ(Party,7);

        return GetKey(res_string, {MFO_Bank});

end;



/*-------------------------------------------------------------------------------------\
|                       Функция поиска балансового счета                               |
\-------------------------------------------------------------------------------------*/
PRIVATE MACRO   FindAccount(Chapter, FIID, Account)

        FILE    acc("account");

        acc.Chapter        = Chapter;
        acc.Account        = Account;
        acc.Code_Currency  = FIID;
        if (not GetEQ(acc))
          return Status();
        end;

        return 0;
END;

/*-------------------------------------------------------------------------------------\
|       Функция проверяет наличие лицевого счета. Если счета нет, то создает его       |
|       прототип во временном файле                                                    |
|                                                                                      |
|       Может быть вызвана только из макроса шага операции                             |
\-------------------------------------------------------------------------------------*/
MACRO   CheckAccount( Type,             /* Номер типа счета */
                      Account,          /* В случае успеха, сюда вернется номер счета*/
                      FIID,             /* Код валюты */
                      Chapter           /* Глава */
                        )

        record          RecAcc( account );
        record          ab( accblnc );
        file            Bl( balance );

        var Balance,
            stat;

        if (0)
                MsgBox( "Неопределен номер лицевого счета. Тип счета - " + Type );
                return  1;
        else

                /* Проверить, что счет есть. При необходимости - открыть */
                if ( FindAccount( Chapter, FIID, Account)  != 0 )

                        /* Поиск балансового */
                        Balance = Substr( Account, 1, 5 );
                        if (Balance == "ОВП00") Balance = "ОВП"; end;
                        Bl.Chapter  = Chapter;
                        Bl.iNumPlan = 0;
                        Bl.Balance  = Balance;
                        if (not GetEQ(Bl))
                                stat = 1;
                                if (Status() == 4)
                                        MsgBox("Не найден балансовый ", Balance);
                                        return  2;
                                else
                                        MsgBox("Ошибка Btrieve :", Status());
                                        return  3;
                                end;
                        end;

                        ClearRecord(RecAcc);
                        RecAcc.Account         = Account;
                        RecAcc.Code_Currency   = FIID;
                        RecAcc.Balance         = Balance;
                        RecAcc.Open_Date       = {curdate};
                        RecAcc.Oper            = {oper};
                        RecAcc.Client          = {OurBank};
                        RecAcc.Department      = {NumDprt};
                        RecAcc.Branch          = {NumDprt};
                        RecAcc.Kind_Account    = Bl.Kind_Account;
                        RecAcc.NameAccount     = Bl.Name_Part;
                        RecAcc.Chapter         = Chapter;
                        RecAcc.NameAccount     = Bl.Name_Part;
                        RecAcc.UserField1      = "Открыт автоматически";
                        if (RecAcc.Balance == "ОВП") RecAcc.Type_Account = RecAcc.Type_Account + "Н"; end;

                        if ( not InsertAccount(RecAcc, ab) )
                                MsgBox( "Ошибка при открытии счета " + Account );
                                return  4;
                        end;
                end;

        end;

        SetParm (1, Account );
        return  0;
end;

/******************************************************************************
Процедура генерации номера лицевого счета, привязанного к заданной валюте
******************************************************************************/
macro MakeAccNumber_FIIDLink(
   CodeFIID,    /* Код валюты, на основании которого происходит генерация */
   Bal         /* Номер балансового счета */
)

     var  res_string, acc_end;

     acc_end = "00000000001";

     res_string = string (Bal) + CodeFIID + "0" + acc_end;

     return GetKey(res_string, {MFO_Bank});
end;

/******************************************************************************
 Поиск названия клиента
******************************************************************************/
MACRO psbc_GetNameClient( Client )
  file pt( party );
  if(Client == 0)
    pt.PartyID = {OurBank};
  else
  pt.PartyID = Client;
  end;
  if( getEQ( pt ) ) 
    return  pt.Name; 
  end;
  return "";
END;

var AccountKeyChecker = VAccountKeyChecker;

private macro CreateNotBalAccountIndex2( ErrMsg:string,
                                         ObjAccount:string,
                                         ObjFIID:integer, 
                                         AttrBalI2:string,
                                         NewAccount:string, 
                                         AttrFIID:integer,
                                         AttrCodeFIID:string,
                                         AttrClient:integer,
                                         AttrNameAccount:string,
                                         AttrDepartment:integer,
                                         AttrBranch:integer,
                                         AttrKind_Account:string,
                                         AttrChapter:integer,
                                         AttrAcc_OpenDate:date
                                       )
  
  var RefI2 = "",
      err = 0;

  AttrBalI2 = SubStr(AttrBalI2, 1, 5);
  AttrCodeFIID = SubStr(strLpad(AttrCodeFIID, 3, "0"), 1, 3 );

  // Генерим референс
  if( GenerateReference( GetIndex2Refer( ObjFIID ), RefI2 ) )
    SetParm(0, "Ошибка при генерации референса " + GetIndex2Refer( ObjFIID ));
    return false;
  end;

  // Формируем результирующий номер счета
  NewAccount = AttrBalI2 + AttrCodeFIID + "0" + SubStr(ObjAccount, 10, 4) + RefI2;
  GetKey(NewAccount, {MFO_Bank});

  record RecAcc( account );
  ClearRecord(RecAcc);

  RecAcc.Account = NewAccount;

  RecAcc.Code_Currency = AttrFIID;
  RecAcc.Balance       = AttrBalI2;
  RecAcc.Open_Date     = IfThenElse(AttrAcc_OpenDate == null, {curdate}, AttrAcc_OpenDate);
  RecAcc.Oper          = {oper};
  RecAcc.Client        = AttrClient;
  RecAcc.Department    = AttrDepartment;
  RecAcc.Branch        = AttrBranch;
  RecAcc.NameAccount   = IfThenElse(strlen(AttrNameAccount) > 119, SubStr( AttrNameAccount, 1, 119 ), AttrNameAccount );
  RecAcc.Kind_Account  = AttrKind_Account;
  RecAcc.Chapter       = AttrChapter;
  RecAcc.UserField1    = "Открыт автоматически";
  
  if(not InsertAccount( RecAcc ))
    SetParm( 0, "Ошибка при открытии счета " + NewAccount);
    return false;
  end;

  SetParm( 4, NewAccount );
  return true;
end;

private macro GetLinkedAccount( GroupID:integer, objChapter:integer, objFIID:integer, objAccount:string, 
                                                 attrChapter:@integer, attrFIID:@integer, attrAccount:@string )
  var select = "select ol.t_attrid "
                 "from dobjlink_dbt ol "
                 "where OL.T_GROUPID = :GroupID "/*OBJROLE_ACC_I2OBACC*/
                   "and OL.T_OBJECTTYPE = 4 " /*OBJTYPE_ACCOUNT*/
                   "and OL.T_OBJECTID = :ObjectID "
                   "and OL.T_ATTRTYPE = 4 "; /*OBJTYPE_ACCOUNT*/

  record object(account);
  object.Chapter = objChapter;
  object.Code_Currency = objFIID;
  object.Account = objAccount;
  var ObjectID = makeObjectID(OBJTYPE_ACCOUNT, 0, object);

  VAR params:TArray = makeArray( SQLParam( "GroupID", GroupID ),     
                                 SQLParam( "ObjectID", ObjectID ) );

  var attrChapterStr = strLpad(string(attrChapter), 2, "0");
  var attrFIIDStr = strLpad(string(attrFIID), 7, "0");

  if( attrChapter > 0 )
    select = select + "and substr( OL.t_AttrID, 1, 2 ) = :attrChapter ";
    params[params.size] = SQLParam( "attrChapter", attrChapterStr );
  end;
  
  if( attrFIID >= 0 )
    select = select + "and substr( OL.t_AttrID, 3, 7 ) = :attrFIID ";
    params[params.size] = SQLParam( "attrFIID", attrFIIDStr );
  end;
  
  var rs:RsdRecordset = execSQLselect( select, params, TRUE );
  record attr(account);

  if( rs and rs.moveNext() )
    RestoreFromUniID(rs.value("t_attrid"), attr, OBJTYPE_ACCOUNT);
    attrChapter = attr.Chapter;
    attrFIID = attr.Code_Currency;
    attrAccount = attr.Account;
    return true;
  end;     

  return false;

end;

// Установка связи счетов
// !!! Вызов этой функции должен быть в транзакции !!!
macro SetLinkedAccountTrn( Account, FIID, Chapter, LinkAccount, LinkFIID, LinkChapter, GroupID)
  
  record object(account);
  record attr(account);

  attr.Code_Currency = LinkFIID;    
  attr.Chapter       = LinkChapter; 
  attr.Account       = LinkAccount;

  if( not GetLinkedAccount( GroupID, Chapter, FIID, Account, @attr.Chapter, @attr.Code_Currency, @attr.Account ) )

    object.Code_Currency = FIID;
    object.Chapter       = Chapter;
    object.Account       = Account;
    
    return SetLinkedObject( GroupID, OBJTYPE_ACCOUNT, object, OBJTYPE_ACCOUNT, attr ) == 0;
  elif( attr.Account !=  LinkAccount )
    return false;
  end;

  return true;
end;

// Установка связи счетов
// работает на шаге не в транзакции
macro SetLinkedAccount( Account, FIID, Chapter, LinkAccount, LinkFIID, LinkChapter, GroupID)

  /* EVG */
  var query;
  record acc (account);

  record object(account);
  record attr(account);

  attr.Code_Currency = LinkFIID;    
  attr.Chapter       = LinkChapter; 
  attr.Account       = LinkAccount;

  if( not GetLinkedAccount( GroupID, Chapter, FIID, Account, @attr.Chapter, @attr.Code_Currency, @attr.Account ) )

    object.Code_Currency = FIID;
    object.Chapter       = Chapter;
    object.Account       = Account;
    
    return InsertObjectLink( OBJTYPE_ACCOUNT, GroupID, makeObjectID(OBJTYPE_ACCOUNT, 0, object), NULL, OBJTYPE_ACCOUNT, makeObjectID(OBJTYPE_ACCOUNT, 0, attr  ), NULL);
  elif( attr.Account !=  LinkAccount )
    /* EVG 27.12.2010 Непонятно почему, в случае, если уже есть другой привязанный счёт, мы возвращаем ошибку.
       Удаляем старый счёт, потом привязываем новый.
    msgbox("Ошибка при привязке счета \"", LinkAccount,"\" к счету плательщика");*/
    ClearRecord( acc );
    acc.Account = Account;
    acc.Chapter = Chapter;
    acc.Code_Currency = FIID;
    query = " Delete From DOBJLINK_DBT " +
            "  Where t_GroupID    = 49 " +                    // Роль "Внебал.счет док-тов карт.ОР"
            "    and t_ObjectType = 4 " +                     // Вид объекта "Счёт"
            "    and t_AttrType   = 4 " +                     // Вид связанного объекта "Счёт"
            "    and t_ObjectID   = " + GetSQLString( UniID( acc, OBJTYPE_ACCOUNT ));
    SQL_Execute( query );
  // KS 18.12.2013 Судя по дистрибутыву false здесь не надо, это нормальная ситуация
  //else
  //   return false;
  end;

  return true;
end;

macro MassCreateNotBalAccountIndex2ForChDoc()
   debugbreak;
   var /*objlink_ins:RsbBatchEmuInsert = RsbBatchEmuInsert( "objlink.dbt", 1000, 100 ),*/
       AttrBalI2 = "",
       NewAccount = "",
       err = 0;
  
  // Получим балансовый
  GetRegistryValue( ПутьНастройкиБалансовогоСчетаКарт2, V_STRING, AttrBalI2, err );
  if( (err != REG_OK) or (AttrBalI2 == "") )
     AttrBalI2 = "90902";
  end;
  
  AttrBalI2 = SubStr(AttrBalI2, 1, 5);

  var ErrMsg = "",
      query = 
"      select distinct                                                                                                       "
"             ac.t_Account,                                                                                                  "
"             ac.t_Code_Currency as t_FIID,                                                                                  "
"             PM_SCRHLP.GetFICode( pm.t_BaseFIID ) as t_CodeFIID,                                                            "
"             ac.t_Client,                                                                                                   "
"             pt.t_Name,                                                                                                     "
"             ac.t_Department,                                                                                               "
"             ac.t_Branch,                                                                                                   "
"             b.t_Kind_Account,                                                                                              "
"             b.t_Chapter,                                                                                                   "
"             pm.t_BaseFIID as t_BaseFIID                                                                                    "
"      from V_PMMASSOPFOREXE doc,                                                                                            "
"           dpmpaym_dbt pm,                                                                                                  "
"           dpminhist_tmp h,                                                                                                 "
"           daccount_dbt ac,                                                                                                 "+
"           dparty_dbt pt,                                                                                                   "
"           dbalance_dbt b                                                                                                   "
"      where pm.t_PaymentID = doc.t_PaymentID                                                                                "
"        and pm.t_PaymStatus = 2000                                                                                          "
"        and h.t_PaymentID = doc.t_PaymentID                                                                                 "
"        and pm.t_PayerAccount != h.t_PayerAccount                                                                           "
"        and ac.t_Account = h.t_PayerAccount                                                                                 "
"        and ac.t_Code_Currency = pm.t_FIID                                                                                  "
"        and ac.t_Chapter = pm.t_Chapter                                                                                     "
"        and pt.t_PartyID(+) = ac.t_Client                                                                                   "
"        and b.t_Chapter(+) = 3                                                                                              "
"        and b.t_iNumPlan(+) = 0                                                                                             "+
"        and b.t_Balance(+) = '" + AttrBalI2 + "'                                                                            "
"        and not exists (select 1                                                                                            "
"                          from dobjlink_dbt oli2                                                                            "
"                          where oli2.t_GroupID = 2                                                                          "
"                            and oli2.t_ObjectType = 4                                                                       "
"                            and oli2.t_ObjectID = lpad(pm.t_Chapter, 2, '0') || lpad(pm.t_FIID, 7, '0') || h.t_PayerAccount "
"                            and oli2.t_ValidFromDate <= RsbSessionData.curdate                                              "
"                            and oli2.t_ValidToDate >= RsbSessionData.curdate                                                "
"                            and oli2.t_AttrType = 4                                                                         "
"                      )                                                                                                     ";

  var cmd = RsdCommand(query);

  cmd.NullConversion = true;
  
  var rs:RsdRecordset = RsdRecordset(cmd);
  
  while(rs.moveNext())

    ErrMsg = "";
    NewAccount = "";
    
    if( not CreateNotBalAccountIndex2( ErrMsg,
                                       rs.value("t_Account"),
                                       rs.value("t_FIID"), 
                                       AttrBalI2,
                                       NewAccount,
                                       rs.value("t_BaseFIID"),
                                       rs.value("t_CodeFIID"),
                                       rs.value("t_Client"),
                                       rs.value("t_Name"),
                                       rs.value("t_Department"),
                                       rs.value("t_Branch"),
                                       rs.value("t_Kind_Account"),
                                       rs.value("t_Chapter"),
                                       {curdate}
                                     ))

      msgbox( ErrMsg );
      return false;

    else
      if(not SetLinkedAccountTrn( rs.value("t_Account"), rs.value("t_FIID"), 1, NewAccount, rs.value("t_FIID"), 3, OBJROLE_ACC_I2OBACC ))
        
        msgbox( "Ошибка создания связи счета " + rs.value("t_Account") + " с внебалансовым счетом K2" );
        return false;

      end;
    end;
  end;

  return true;

end;

/*-----------------------------------------------------------------------------\
| Функция определения внебалансового лицевого счета, "привязанного"            |
| к заданному счету, который используется для K2.                                                                     |
| Если нет счета, то создается его прототип во временном файле с балансовым    |
| счетом, берущимся из настройки. Если нет настройки или в ней счет не указан, |
| то в качестве балансового используется переданный Balance                    |
| Если нет настройки по связыванию счетов, то она создается.                   |
|                                                                              |
|       Может быть вызвана только из макроса шага операции                     |
\------------------------------------------------------------------------------*/
private MACRO GetAccountLinkK2( Account,     /* Cчет, для которого ищем привязку */
                                LinkAccount, /* В случае успеха, сюда вернется номер "привязанного" счета */
                                Balance,
                                ObjFIID,     /* валюта счета */
                                AttrFIID,    /* валюта счета */
                                Acc_OpenDate /* Дата открытия внебалансового счета для К2 */
                              )

        record          RecAcc( account );
        record          ab( accblnc );
        file            Bl( balance );
        file            FileAcc( account );

        record         object(account);
        record         attr  (account);

        object.Code_Currency = ObjFIID;
        object.Chapter = 1;
        object.Account = Account;
        
        var Привязать = true;
        var ГлаваПривязанногоСчета = 3;
        var Запрос;
        var IsObject;
        var UseLinkAccount;
        var AccText;
        var QuestText;
        var NeedInsertAcc;
        var Text;
        var saveLinkAccount;
        var err;
        var autokey;

        array arr;

        attr.Code_Currency = AttrFIID;
        attr.Chapter = ГлаваПривязанногоСчета;
        attr.Account = "";

        if( GetLinkedAccount( OBJROLE_ACC_I2OBACC, object.Chapter, object.Code_Currency, object.Account, 
                                                   @attr.Chapter, @attr.Code_Currency, @attr.Account ) )
        
          LinkAccount = attr.Account;  /* Нашли настройку */
          if(LinkAccount != "" ) 
            Привязать = false;
          end;
        else /* Не найден связанный счет */
          LinkAccount = "";
        end;

        /* У балансового берем только первые пять символов */
        arr(0) = Balance;
        if(StrLen(Balance) > 5)
         StrSplit(Balance,arr,5);
        end;

        var BufAcc = "";
        if( LinkAccount == "" )
            if( GenerateReference( GetIndex2Refer( AttrFIID ), BufAcc ) )
              return 4794;
            end;
            LinkAccount = SubStr(MakeAccNumber_Link(Account, arr(0), AttrFIID ),1,13) + BufAcc;
        end;

        Запрос = true;  /* Запрос на корректировку счета вводи только первый раз */
                       /* Или при наличии "привязанного" счета */
        IsObject = true;

        /* Проверить, что счет есть. */
        if( Привязать )
            UseLinkAccount = false;  /* не использовать уже привязанный счет */
            if(FindAccount( ГлаваПривязанногоСчета, AttrFIID, LinkAccount) == 0)
                    
                    attr.Code_Currency = AttrFIID;
                    attr.Chapter = ГлаваПривязанногоСчета;
                    attr.Account = LinkAccount;

                    /* Если уже есть привязанный счет, то предупреждаем */
                    if(IsObjectLinked(OBJTYPE_ACCOUNT,attr,OBJTYPE_ACCOUNT,OBJROLE_ACC_I2OBACC,object))
                      if(Account != object.Account)

                        AccText = "в/б счет K2.";

                        QuestText = "Для счета " + Account + " не указан " + AccText +
                                    " Вы можете открыть | в/б счет вручную и привязать его к счету клиента (ГКБО\\Счета\\Alt-L).|"+ 
                                    "Программа предлагает привязать автоматически счет " + LinkAccount +
                                    ",|который уже используется для " + object.Account + "." +
                                    "|Произвести привязку счета ?";

                          if( RsbGetTrue( True, False, "NotGetTrue", QuestText ) == True )
                           /* Пользователь решил пользоваться уже используемым счетом */
                           UseLinkAccount = true;
                          elif( not GetDialogFlag() )
                            MemoryError( NULL, "Для счета " + Account + " не указан " + AccText );
                            return 4;
                          end;

                        Запрос = false;

                      end;
                    end;
            end;
        else
            UseLinkAccount = true;  /* не использовать уже привязанный счет */
        end;

        /* Поиск балансового */
        Bl.Chapter  = ГлаваПривязанногоСчета;
        Bl.iNumPlan = 0;
        Bl.Balance  = Balance;
        if (not GetEQ(Bl))
          if (Status() == 4)
            MsgBox("Значение настройки \"Балансовый счет корр-ции с карт-ками\" ", Balance, " ошибочно" );
            return  2;
          else
            MsgBox("Ошибка Btrieve :", Status());
            return  3;
          end;
        end;

        /* Проверить, что счет есть. При необходимости - открыть */
        if ( not UseLinkAccount )  

          NeedInsertAcc = true;

          attr.Code_Currency = AttrFIID;
          attr.Chapter = ГлаваПривязанногоСчета;
          attr.Account = LinkAccount;

          IsObject = IsObjectLinked( OBJTYPE_ACCOUNT, attr, OBJTYPE_ACCOUNT, OBJROLE_ACC_I2OBACC, object );
          Text     = "В/б счет К2 для " + Account;

          if( IsObject )
             if( Account != object.Account )
                Text = "В/б счет К2 для " + Account + "(исп-ся для " + object.Account + "):";
             else
                IsObject = false;
             end;
          end;

          saveLinkAccount = LinkAccount;

          if( Запрос )

             AccText = "в/б счет K2.";

             QuestText = "Для счета " + Account + " не указан " + AccText +
                         " Вы можете открыть | в/б счет вручную и привязать его к счету клиента (ГКБО\\Счета\\Alt-L).|"+ 
                         "Либо программа откроет и привяжет такой счет автоматически.|Произвести автоматическое открытие счета ?";

               if( RsbGetTrue( True, False, QuestText ) == False )
                 if( not GetDialogFlag() )
                   MemoryError( NULL, "Для счета " + Account + " не указан " + AccText );
                 end;
                 return 4;
               end;
          end;

          if( not GetString( LinkAccount, Text, 20 ) )
             return 5;
          end;

          if( saveLinkAccount != LinkAccount )
             LinkAccount = AccountKeyChecker.Do( ГлаваПривязанногоСчета, LinkAccount );
             if( IsObject ) 
               NeedInsertAcc = false; 
             end;
          end;


        else
                /* Если счет привязан, но реально в базе не существует, то его нужно открыть */
                NeedInsertAcc = (FindAccount( ГлаваПривязанногоСчета, AttrFIID, LinkAccount) != 0);
        end;

        if( NeedInsertAcc )
              ClearRecord(RecAcc);
              RecAcc.Account         = LinkAccount;

              RecAcc.Code_Currency   = AttrFIID;
              RecAcc.Balance         = Balance;
              RecAcc.Open_Date = Acc_OpenDate;
              RecAcc.Oper            = {oper};

              FileAcc.Account = Account;
              FileAcc.Chapter = 1;
              FileAcc.Code_Currency   = ObjFIID;
              if( getEQ( FileAcc) )
                RecAcc.Client        = FileAcc.Client;
                RecAcc.Department    = FileAcc.Department;
                RecAcc.Branch        = FileAcc.Branch;
              end;

              RecAcc.Kind_Account    = Bl.Kind_Account;
              RecAcc.Chapter         = ГлаваПривязанногоСчета;
              
              if( strlen(psbc_GetNameClient(RecAcc.Client)) > 119 )
                RecAcc.NameAccount   = SubStr( psbc_GetNameClient(RecAcc.Client), 1, 119 );
              else
                RecAcc.NameAccount   = psbc_GetNameClient(RecAcc.Client);
              end;

              RecAcc.UserField1      = "Открыт автоматически";
    
              if( not AccountHasBeenInserted( RecAcc ) )
                 if( not InsertAccount( RecAcc, ab, autokey, true ) )
                      MsgBox( "Ошибка при открытии счета " + LinkAccount );
                      return  6;
                 end;
              end;
        end;   

        if( Привязать )  /* Привязки нет(или "привязанный" счет = "") - создаем */
          object.Code_Currency = ObjFIID;
          object.Chapter = 1;
          object.Account = Account;                      

          attr.Code_Currency = AttrFIID;
          attr.Chapter = ГлаваПривязанногоСчета;
          attr.Account = LinkAccount;
          if(NeedInsertAcc)
            err = NOT InsertObjectLink( OBJTYPE_ACCOUNT, OBJROLE_ACC_I2OBACC, makeObjectID(OBJTYPE_ACCOUNT, 0, object), NULL, OBJTYPE_ACCOUNT, autokey , TRUE );
          else
            err = NOT InsertObjectLink( OBJTYPE_ACCOUNT, OBJROLE_ACC_I2OBACC, makeObjectID(OBJTYPE_ACCOUNT, 0, object), NULL, OBJTYPE_ACCOUNT, makeObjectID(OBJTYPE_ACCOUNT, 0, attr  ), NULL);
          end;
          if(err)
            msgbox("Ошибка при привязке счета \"", LinkAccount,"\" к счету плательщика");
            return 7;
          end;
        end;

        SetParm (1, LinkAccount );
        return  0;
end;

/*-----------------------------------------------------------------------------\
| Oпределения внебалансового лицевого счета для расчетных документов,          |
| не оплаченных в срок. Номер балансового ищется в настройках. При неудаче     |
| получает значение "90902"                                                    |
\------------------------------------------------------------------------------*/
MACRO   GetAccount90902( Account,     /* Cчет, для которого ищем привязку */
                         FIID,        /* Валюта счета, для которого ищем привязку */
                         AttrFIID,    /* Валюта счета, который должен быть привязан*/
                         Account90902,/* В случае успеха, сюда вернется номер "привязанного" счета */
                         AccountOpenDate
                       )

        var err;
        var БалансовыйКарт2;
        var Acc_OpenDate;

        GetRegistryValue( ПутьНастройкиБалансовогоСчетаКарт2, V_STRING, БалансовыйКарт2, err );
        if( (err != REG_OK) or (БалансовыйКарт2 == "") )
           БалансовыйКарт2 = "90902";
        end;

        if( AccountOpenDate == NULL )
          Acc_OpenDate = {curdate};
        else
          Acc_OpenDate = AccountOpenDate;
        end;
        err = GetAccountLinkK2( Account, Account90902, БалансовыйКарт2, FIID, AttrFIID, Acc_OpenDate );
        
        if( err!=0 ) 
          return err;
        end;

        SetParm( 3, Account90902 );
        return  0;

END;


/* Вывести на экран ошибку определения cчета корреспонденции с картотекaми */
MACRO DisplayErrMes_CorrAcc(err,СистемныйСчетДляКартотек);

      if(err != REG_OK)
        msgbox("Ошибка при определении настройки \"Cчет корреспонденции с картотекaми\"");
      elif(СистемныйСчетДляКартотек == "")
        msgbox("Не задана настройка \"Cчет корреспонденции с картотекaми\"");
      end;

      return;

END;

macro ReDefinePartPaymShifrOper(Payment : RsbPayment, err_mes : @string) : integer
  if(Payment.PartPaymDateMain == ZeroDate) // платеж не является частичной оплатой 
    return 0;
  end;
  if( not(Payment.IsExternal and not Payment.IsExternalIncoming) ) // платеж не является исходящим
    return 0;
  end;

  var err : integer = 0;
        
  var Corschem : TRecHandler = TRecHandler( "corschem.dbt" );  
  err = FindCorschem(Corschem, Payment.OutCorschem, Payment.OutCorschemFIID);
  if(err == 0)
    var AttrFound : bool = false;
    var RecParty : TRecHandler = TRecHandler("party.dbt");
    RecParty.rec.PartyID = Payment.ReceiverBankID;
    // Если корреспондент исходящей корсхемы является РКЦ и
    // значение категории ATTR_GROUP_REGIONKIND для субъекта pmpaym.ReceiverBankID равно OBJGROUP_REGIONKIND_OUTSIDEREGION
    if( БанкУБР(Corschem.rec.CorrID) and
        CheckObjAttrPresence(AttrFound, OBJTYPE_PARTY, UniID(RecParty, OBJTYPE_PARTY), PT_ATTR_GROUP_REGIONKIND, OBJGROUP_REGIONKIND_OUTSIDEREGION) and
        (AttrFound == true)
      )
      var OldShifrOper : string = Payment.ShifrOper;

      var stat : integer = 0;
      GetRegistryValue("PS\\PAYORDER\\IND2_PAYPART_CODEOP", V_STRING, Payment.ShifrOper, stat);
      if(stat)
        Payment.ShifrOper = "01";
      end;
          
      if(Payment.ShifrOper != OldShifrOper)
        Payment.OutTpSchem = Payment.OutRlsForm = 0;
        if( not DefineRlsForm(Payment, Payment.OutTransport, Payment.OutTpSchem, NULL, Payment.OutRlsForm, Payment.OutSubKindMessage) )
          err_mes = "Невозможно переопределить релиз и транспортную схему платежа после изменения шифра операции";
          err = 1;
        end;
      end;
    end;
  else
    err_mes = "Не найдена схема расчетов";
  end;

  return err;
end;