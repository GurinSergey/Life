/************************************************************************/
/*         Автоматизированная банковская система RS-Bank                */
/*                 Copyright (c) R-Style Software Lab 1998              */
/*                                                                      */
/*  Имя файла        : reqopena.mac                                      */
/*                                                                      */
/*  Описание         : Инициализация и проверки                         */
/*                     заявлений на открытие счета                      */
/*  Программист      : Дудин В.А.                                       */
/*                                                                      */
/*  Создан           : 4.06.00                                          */
/*                                                                      */
// KS 22.11.2013 Перенесены доработки из 30й сборки
/************************************************************************/
// 26-06-2012 Жаворонкова Н. (joy) R-77011-2 Предопределение значений поля: "Метод формирования оплат комиссий" = платежный документ */
// 06.02.2013 zmp R-151015-2 Сделал проверку на балансовый счет
// 11.07.2013 Жаворонкова Н. (joy) R-216779-2 Искала информацию, нашла ошибку в макросе: потерялись скобки при сравнении балансового счета и лицевого

IMPORT reqinter, reqchecks;
/*24.09.2010 Chesnokov D. */
import "CheckDelivery.mac";
import "lib_const.mac";

/* Проверяемые поля в панели заявления */
private const fld_type_account = 22,
              fld_name_account = 23,
              fld_pack_numb    = 27,
              fld_balance      = 17;
private const  ReqOpenAcc_Fld_Acc      = 18,
               ReqOpenAcc_Fld_LinkAcc  =  5,
               ReqOpenAcc_Fld_LinkABal =  4,
               ReqOpenAcc_Fld_LinkAFI  =  3;

/*Для платежей*/

/*Хинт для списков по дате заявления*/
private const Hint_ByDate     :string = "/*+FIRST_ROWS LEADING(t oproper partcode) INDEX(t dreqopena_dbt_idx6) USE_NL(t oproper partcode)*/";
/*Хинт для списков по дате закрытия*/
private const Hint_ByCloseDate:string = "/*+FIRST_ROWS LEADING(t oproper partcode) INDEX(t dreqopena_dbt_idx5) USE_NL(t oproper partcode)*/";
/*Хинт для списков по статусу первички*/
private const Hint_ByStatus   :string = "/*+FIRST_ROWS LEADING(t oproper partcode) INDEX(t dreqopena_dbt_idx3) USE_NL(t oproper partcode)*/";
/*Хинт для списков по шагу*/
private const Hint_ByStep     :string = "/*+FIRST_ROWS LEADING(t oproper reqopena partcode) INDEX(t doprstep_dbt_idx10) INDEX(reqopena dreqopena_dbt_idx0) USE_NL(t oproper reqopena partcode)*/";


/* EVG Пришлось добавить здесь. Ранее функция импортировалась из reqinter.mac,
   но там пришлось сделать её private, т.к. шло переопределение с другими макросами
   при постановке в К2 комиссии за закрытие счёта. */
/******************************************************************************
Служебная процедура, расширяет значение num до строки длиной len,
свободные позиции слева заполняет _нулями_ (а не пробелами)
******************************************************************************/
private RECORD pt(party);
private MACRO LZ( num, len )
     var str1, len1;
     str1 = trim( string( num ) );
     len1 = strlen( str1 );
     if ( len1 >= len ) return str1;
     else   return  mkstr("0", len-len1 ) + str1;
     end;
END;


/* Установка подсказки для скролингов из макроса */
MACRO УстановитьПодсказку( TableName:string, IndexNum:integer, DefaultHint:string, ScrolStates:integer ):string
  /*  Возможные значения ScrolStates:
      0  - Все                      
      1  - Отложенные               
      2  - Открытые                 
      3  - Закрытые                 
      4  - Отвергнутые              
      5  - Подготовленные к шагу */

  if( ScrolStates == 0 ) //Все

    return Hint_ByDate;

  elif( ScrolStates == 3 ) //Закрытые

    return Hint_ByCloseDate;  

  elif(    ( ScrolStates == 1 )   //Отложенные
        or ( ScrolStates == 2 )   //Открытые
        or ( ScrolStates == 4 ) ) //Отвергнутые
  
    return Hint_ByStatus;    

  elif( ScrolStates == 5 ) //Подготовленные к шагу

    return Hint_ByStep;

  end;

  return DefaultHint;
END;

/* Макрос генерации номера открываемого счета, для которого было введено заявление */
MACRO НомерСчетаЗаявления()
  ReqOpenAcc.Account=ПолучитьНомерСчетаЗаявления(ReqOpenAcc.Account, ReqOpenAcc.Balance0, ReqOpenAcc.Code_Currency, ReqOpenAcc.SpecialKind,  ReqOpenAcc.AccountDepartment);
  return 0;
END;

/* Макрос генерации номера связанного счета */
MACRO НомерСвязанногоСчетаЗаявления()
  ReqLinkAcc.Account=ПолучитьНомерСвязанногоСчетаЗаявления(ReqLinkAcc, ReqOpenAcc.Account, ReqOpenAcc.Balance0, ReqOpenAcc.AccountDepartment);
  return 0;
END;

// Функция предназначена для проверки номера основного счета в заявлении
MACRO ПроверитьНомерСчета():integer
  
  var AccKey, CodeKind, error;
  
  debugbreak;
  
  if( not IsStepWasExecuted( ReqOpenAcc.RequestID, PS_REQOPENA, 10/*открытие счета*/ ) )
    if ( (ReqOpenAcc.Account != "") and (ReqOpenAcc.Dummy != "X") )
      /* EVG
      if ( ( NOT Req_IsAccExist(ReqOpenAcc.Code_Currency, ReqOpenAcc.Account) ) and ( SubStr(ReqOpenAcc.Account, 1, 1) != "L") )
        msgbox("Счет с таким номером уже существует");
        return ReqOpenAcc_Fld_Acc;
      end;*/

      // 11.07.2013 joy Второе условие не было заключео в скобки, из-за чего проверка срабатывала неправильно
      if ( ( ReqOpenAcc.DenialOpen == "" ) and ( SubStr(ReqOpenAcc.Account, 1, 5) != LZ( ReqOpenAcc.Balance0, 5 ) ) ) 
        msgbox("Заданный счет не может быть открыт на заданном балансовом счете");
        return ReqOpenAcc_Fld_Acc;
      end;

      if ( NOT Req_IsFIExist( SubStr(ReqOpenAcc.Account, 6, 3) ) )      
        msgbox("Код валюты счета не найден в справочнике");
        return ReqOpenAcc_Fld_Acc;
      end;
      
      if ( SubStr(ReqOpenAcc.Account, 6, 3) != LZ(ПолучитьКодФинИнДляСчета( ReqOpenAcc.Code_Currency ), 3) )
        msgbox("Валюта открываемого счета не соответствует заданной");
        return ReqOpenAcc_Fld_Acc;
      end;

      var PartyID = 0, BIC = "";
      getDeptPartyIDandBIC(ReqOpenAcc.AccountDepartment, @PartyID, @BIC);
           
      /* EVG
      GetREgistryValue("CB/PAYMENTS/DEPCODEKIND", V_INTEGER, CodeKind, error);
      if ( SubStr(ReqOpenAcc.Account, 10, 4) != ПолучитьКодСубъекта(PartyID, CodeKind, error) )
        msgbox("Неверно задан код филиала в номере счета");
        return ReqOpenAcc_Fld_Acc;
      end;*/

      AccKey = GetKey( ReqOpenAcc.Account, BIC );
      if ( AccKey != ReqOpenAcc.Account )
        msgbox("Неверный ключ счета. Должен быть " + SubStr(AccKey, 9, 1));
        return ReqOpenAcc_Fld_Acc;
      end;

    end;
  end;
  
  /* EVG 28/12/2010 Проверка номера лицевого счёта. Без этого система разрешает ввести и выполнить операцию по заявлению
     на открытие вообще без номера счёта, что приводит к ошибкам СУБД. */
  if ( strLen(ReqOpenAcc.Account) < 20 )
    msgbox("Длина номера лицевого счёта \"" + ReqOpenAcc.Account + "\" меньше 20 знаков.|Пожалуйста, введите корректный номер счёта.");
    return ReqOpenAcc_Fld_Acc;
  end;

  
  return 0;
END;

// Функция предназначена для проверки номеров связанных счетов (в дистрибутиве реализуется только проверка транзитного счета)
MACRO ПроверитьНомерСвязанногоСчета():integer

  var AccKey, CodeKind, error;

  debugbreak;

  if( not IsStepWasExecuted( ReqOpenAcc.RequestID, PS_REQOPENA, 50/*открытие транзитного счета*/ ) )

    if ( (ReqLinkAcc.GroupID == OBJROLE_ACC_TRANSIT) and (ReqOpenAcc.Dummy != "X") )
      if ( NOT Req_IsAccExist(ReqLinkAcc.Code_Currency, ReqLinkAcc.Account) )
        msgbox("Счет с таким номером уже существует");
        return ReqOpenAcc_Fld_LinkAcc;
      end;

      if ( ReqOpenAcc.Balance0 != ReqLinkAcc.Balance0 ) 
        msgbox("Балансовые счета основного и транзитного счетов не совпадают");
        return ReqOpenAcc_Fld_LinkABal;
      end;

      if ( ReqOpenAcc.Code_Currency != ReqLinkAcc.Code_Currency ) 
        msgbox("Валюты основного и транзитного счетов не совпадают");
        return ReqOpenAcc_Fld_LinkAFI;
      end;

      if ( SubStr(ReqLinkAcc.Account, 1, 5) != LZ( ReqLinkAcc.Balance0, 5 ) )
        msgbox("Заданный счет не может быть открыт на заданном балансовом счете");
        return ReqOpenAcc_Fld_LinkAcc;
      end;

      if ( NOT Req_IsFIExist( SubStr(ReqLinkAcc.Account, 6, 3) ) )
        msgbox("Код валюты счета не найден в справочнике");
        return ReqOpenAcc_Fld_LinkAcc;
      end;
      
      if ( SubStr(ReqLinkAcc.Account, 6, 3) != LZ(ПолучитьКодФинИнДляСчета( ReqLinkAcc.Code_Currency ), 3) )
        msgbox("Валюта открываемого счета не соответствует заданной");
        return ReqOpenAcc_Fld_LinkAcc;
      end;
   
      var PartyID = 0, BIC = "";
      getDeptPartyIDandBIC(ReqOpenAcc.AccountDepartment, @PartyID, @BIC);
   
      /* EVG
      GetREgistryValue("CB/PAYMENTS/DEPCODEKIND", V_INTEGER, CodeKind, error);
      if ( SubStr(ReqLinkAcc.Account, 10, 4) != ПолучитьКодСубъекта(PartyID, CodeKind, error) )
        msgbox("Неверно задан код филиала в номере счета");
        return ReqOpenAcc_Fld_LinkAcc;
      end;*/
    
      if ( SubStr(ReqLinkAcc.Account, 14, 1) != "1" )
        msgbox("В номере счета отсутствует признак транзитного счета");
        return ReqOpenAcc_Fld_LinkAcc;
      end;

      AccKey = GetKey( ReqLinkAcc.Account, BIC );
      if( AccKey != ReqLinkAcc.Account )
        msgbox("Неверный ключ счета. Должен быть " + SubStr(AccKey, 9, 1));
        return ReqOpenAcc_Fld_LinkAcc;
      end;

    end;

  end;

  return 0;
 
END;

MACRO Новое_Заявление()
  debugbreak;
  /* EVG Предопределение значений полей */
  ReqOpenAcc.SfInvMethod = 2;   // Способ оплаты ТО = Плат. требование
  /* 26-06-2012 - joy R-77011-2 Предопределение значений полей - 2. Иначе ДО формируется с пустым полем "Метод формирования оплат комиссий"*/
    ReqOpenAcc.SfPayMethod = 1; // Метод формирования оплат комиссий - платежный документ 
  /* В панели заявления 1 - это "латеж банка" (ошибочный список, есть запрос) при формировании ДО - будет "платежный документ" */
  return 0;
END;

/* Номер ошибки заведомо больше числа полей, чтобы никуда не позиционироваться */
private const REQOPENA_JUSTERROR:integer = 1024;

MACRO Проверить_Заявление(Режим)

   var stat = 0;

  // zmp 30.09.2014 временный костыль по депозитным счетам
  if(not ((index(ReqOpenAcc.Type_Account, "J") != 0) and ReqOpenAcc.KIND_OPERATION == 13030))
     if( (ReqOpenAcc.Dummy != "X") and (StrLen(ReqOpenAcc.Type_Account) != 0) and
        ( not CheckTypeAccount( ReqOpenAcc.Type_Account ) ) )         
            return fld_type_account;
     end;
  end;

   if ((Режим == SCR_SAVE ) or (Режим == SCR_EDIT) or (Режим == SCR_INSERT))
    if(ReqOpenAcc.Dummy != "X")

      if( StrLen( ReqOpenAcc.NameAccount ) == 0 )
         MsgBox("Введите наименование счета");
         return fld_name_account;
      end;

      if( ReqOpenAcc.NumberPack < 0 )
         MsgBox("Номер пачки не может быть отрицательным");
         return fld_pack_numb;
      end;

      stat = PS_CheckReqopena( ReqOpenAcc ); // может вернуть CHANG_IMPORTANT=-11
      if( stat > 0 )
        return REQOPENA_JUSTERROR;
      end;

      /*zmp 06.02.2013 R-151015-2 -->*/
      if((substr(ReqOpenAcc.Account,1,5) != ReqOpenAcc.Balance0) and (ReqOpenAcc.Balance0 != ""))
         msgBox("Неверно указан балансовый счет");
         return fld_balance;
      end;
      /*<-- zmp 06.02.2013 R-151015-2*/

    end;
   end;

                                          
   /* EVG
   if((StrLen(ReqOpenAcc.Type_Account)        != 0  ) and
      (SubStr( ReqOpenAcc.Type_Account, 1, 1) != "Ч") and
      (SubStr( ReqOpenAcc.Type_Account, 1, 1) != "X") )
        MsgBox("Можно открывать только расчетные или текущие счета");
        return fld_type_account;
   end;*/
   if (Режим == SCR_ROLLBACK) // Откат операции
       if(not CheckDelivery(ReqOpenAcc.RequestID, 1))
          return 1;
       end;
   end;
                                        
   return stat;
END;

MACRO Функция_Пользователя( Режим:integer )
/*
 Возможные значения Режим:
  UFN_PANEL_INPUT(1) - функция вызвана из панели ввода объекта;
  UFN_PANEL_EDIT(2) - функция вызвана из панели корректировки объекта;
  UFN_SCROL(3) - функция вызвана из панели скролинга, единичный вызов, любая корректировка объекта запрещена;
  UFN_SCROL_FMASS(4) - функция вызвана из панели скролинга, работа по нескольким записям, вызов до начала обработки, любая корректировка объекта запрещена;
 
// Пример работы: 
 if( Режим == UFN_SCROL )
   return UPDTPAGE;    // Обновить страницу записей и область скролинга
   //return UPDTREC;     // Обновить текущую запись, загрузив из файла
 end;
 */

  const AccType_CorrAcc = "К";


   /* EVG Т.к. из интерфейса ввести тип счёта "К" нельзя, делаем его добавление
      по Ctrl-Z. */
   if ((Режим == UFN_PANEL_INPUT) or (Режим == UFN_PANEL_EDIT))
      if (GetTrue(true, "Добавить в поле \"Тип\" признак К (Корреспондентский)?"))
         if (index(ReqOpenAcc.Type_Account, AccType_CorrAcc) == 0)
            ReqOpenAcc.Type_Account = ReqOpenAcc.Type_Account + AccType_CorrAcc;
         end;
      end;
   end;
      
   return 0;
END;

/* Макрос генерации кода клиента для заявление на открытие счета */
MACRO КодКлиента()

  FILE code(partcode) key 1;
  VAR ClientCode = "";
  VAR CodeLen;

  code.CodeKind = PTCK_CONTR;
  code.Code = SetCode(9,35);
  if( (GetLE(code)) and (code.CodeKind == PTCK_CONTR) )
    ClientCode = code.Code;
  end;
  if( (ClientCode != "") and (AllDigits(ClientCode)) )
    CodeLen = strlen(ClientCode);
    ClientCode = String(Int(ClientCode) + 1);
    ClientCode = LZ(ClientCode,CodeLen);
    PtCode.Code = ClientCode;
  end;
  return 0;

END;
