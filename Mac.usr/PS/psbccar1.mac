//-----------------------------------------------------------------------------
// Блок     : "Зачисление"
// Шаг      : "Зачисление"
// Описание : Макрос шага
//-----------------------------------------------------------------------------

import PaymInter, PSInter, BankInter, FIInter, psbccomn, pm_opr, bc_categ;
import OprInter, oralib; //Jushmanov 2014-02-20 C-19151

var PaymentObj:RsbPayment;

//Возможные исходы событий
PRIVATE CONST PMBC_ACTION_OK    :integer = 0, //Ok
              PMBC_ACTION_STOP  :integer = 1, //Приостановить до исполнении дочеренго документа
              PMBC_ACTION_ERROR :integer = 2; //Возникла ошибка

//------------------------------------------------------------------------------
// Проверка дочернего документа, сформированного на предыдущем шаге
//------------------------------------------------------------------------------
PRIVATE MACRO CheckChildDoc( action:integer, oprdocs:TRecHandler ):integer

  var bcorder:object = NULL;

  if( action != PMBC_ACTION_OK )
    return action;
  end;

  var Status:integer = -1;

  if( not PM_GetOprStatus( oprdocs.rec.DocKind, oprdocs.rec.DocumentID, OPR_PAYM_STATE, @Status ) )
    return PMBC_ACTION_ERROR;
  end;
    
  //статус дочернего документа "закрыт"- Ок
  if( Status == OPR_PM_ST_CLOSE  )
    return PMBC_ACTION_OK;
  //дочерний документ еще обрабатывается - ждем
  else
    bcorder = GenObject( "RsbBuyCurrencyOrder", PaymentObj.DocumentID );
    if( bcorder.BankFunds )
      MsgBox( "Не исполнен мемориальный ордер по списанию средств" );
    else
      MsgBox( "Не исполнен мемориальный ордер по возврату излишне задепонированных средств" );
    end;
    return PMBC_ACTION_STOP;
  end;

END;

private macro GetRegExchangeIncarryDockind()
  debugbreak;
  var stat;
  var IncarryDockind;
  GetRegistryValue("PS\\EXCHANGECONTROLS\\EXCHANGE_INCARRY_DOCKIND", V_INTEGER, IncarryDockind, stat);
  return IncarryDockind;
end;

//-----------------------------------------------------------------------------
// Создать мемордер
//-----------------------------------------------------------------------------
PRIVATE MACRO CreateMemorial( BcOrder:object, Ground:string, PayerAccount:string, Amount )

  var Memorial:object         = GenObject("RsbMemorialOrder", 0 );
  var Payment:RsbMOPayment    = Memorial.Payment();
  
  Memorial.State              = 0;/*CB_DOC_STATE_DEFERRED*/;
  Memorial.Oper               = {oper};
  Memorial.Chapter            = 1;
  Memorial.Code_Currency      = PaymentObj.ReceiverFIID;

  Memorial.Kind_Oper          = " 4";
  Memorial.Origin             = CB_DOC_ORIGIN_MANUAL;

  Payment.ClientDate          =
  Payment.Date                =
  Payment.PayerBankEnterDate  =
  Payment.ValueDate           = {curdate};
                       
  Payment.DocKind             = DLDOC_MEMORIALORDER;
  Payment.Purpose             = PM_PURP_MEMORDER;

  Payment.Number              = PaymentObj.Number;
  Payment.ShifrOper           = "09";

  Payment.PayerAmount         = Amount;
  Payment.PayerFIID           = 
  Payment.ReceiverFIID        = PaymentObj.ReceiverFIID;

  Payment.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                      {OurBank}, 
                      0, 
                      "", 
                      "",
                      "",
                      PaymentObj.ReceiverFIID, 
                      1/*CHAPT1*/, 
                      PayerAccount, 
                      0, 
                      "", 
                      "" );

  Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                         PaymentObj.ReceiverBankID, 
                         PaymentObj.ReceiverBankCodeKind, 
                         PaymentObj.ReceiverBankCode, 
                         PaymentObj.ReceiverBankName,
                         PaymentObj.ReceiverBankCorrAcc,
                         PaymentObj.ReceiverFIID, 
                         1/*CHAPT1*/, 
                         PaymentObj.ReceiverAccount, 
                         PaymentObj.Receiver, 
                         PaymentObj.ReceiverName, 
                         PaymentObj.ReceiverINN );
                    
  Payment.Ground              = Ground;

  // Заполнение кода вида валютной операции
  BC_SetVOCode( BcOrder, Payment, PSBCACTION_CARRY );

  // Установить мемориальному ордеру признак автозапуска операции.
  Memorial.LaunchOper         = true;

  Payment.CryptoAction( string("Автоматическое_формирование_платежей") );
END;

//-----------------------------------------------------------------------------
// Создать банковский ордер
//-----------------------------------------------------------------------------
PRIVATE MACRO CreateBankOrder( BcOrder:object, Ground:string, PayerAccount:string, Amount )
debugbreak;
  var BankOrder:object;
  
  BankOrder = GenObject( "RsbBankOrder", 0 );
  BankOrder.Oper               = {oper};
  BankOrder.Origin             = CB_DOC_ORIGIN_MANUAL;

  BankOrder.ClientDate          =
  BankOrder.Date                =
  BankOrder.PayerBankEnterDate  =
  BankOrder.ValueDate           = {curdate};
                       
  BankOrder.DocKind             = DLDOC_BANKORDER;

  BankOrder.Number              = PaymentObj.Number;
  BankOrder.ShifrOper           = "09";

  BankOrder.PayerAmount         =
  BankOrder.ReceiverAmount      =
  BankOrder.BaseAmount          = Amount;
  BankOrder.PayerFIID           =
  BankOrder.ReceiverFIID        = PaymentObj.ReceiverFIID;

  BankOrder.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                      {OurBank}, 
                      0, 
                      "", 
                      "",
                      "",
                      PaymentObj.ReceiverFIID, 
                      1/*CHAPT1*/, 
                      PayerAccount, 
                      0, 
                      "", 
                      "" );

  BankOrder.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                         PaymentObj.ReceiverBankID, 
                         PaymentObj.ReceiverBankCodeKind, 
                         PaymentObj.ReceiverBankCode, 
                         PaymentObj.ReceiverBankName,
                         PaymentObj.ReceiverBankCorrAcc,
                         PaymentObj.ReceiverFIID, 
                         1/*CHAPT1*/, 
                         PaymentObj.ReceiverAccount, 
                         PaymentObj.Receiver, 
                         PaymentObj.ReceiverName, 
                         PaymentObj.ReceiverINN );
                    
  BankOrder.Ground              = Ground;

  // Заполнение кода вида валютной операции
  BC_SetVOCode( BcOrder, BankOrder, PSBCACTION_CARRY );

  // Установить мемориальному ордеру признак автозапуска операции.
  BankOrder.LaunchOper         = true;

  BankOrder.CryptoAction( string("Автоматическое_формирование_платежей") );
END;

//-----------------------------------------------------------------------------
// Создать платеж банка
//-----------------------------------------------------------------------------
PRIVATE MACRO CreateBankPaym( BcOrder:object, Ground:string, PayerAccount:string, Amount )
  var Payment:RsbPayment   = NULL;
  var BankPaym:object = NULL;

  if( PaymentObj.ReceiverFIID == 0 )
    BankPaym              = GenObject( "RsbBankPayment", 0 );
    Payment               = BankPaym.Payment();

    BankPaym.Origin       = MEMORDER_FDOC_AUTO;
    BankPaym.Oper         = {oper}; 
    BankPaym.Status       = 1/*MEMORDER_STATUS_POST*/;

    Payment.DocKind       = DLDOC_BANKPAYMENT;
    Payment.Purpose       = PM_PURP_BANKPAYMENT;
    Payment.PayerFIID     = 
    Payment.ReceiverFIID  = PaymentObj.ReceiverFIID;
  else
    BankPaym              = GenObject( "RsbBbCpOrder", 0 );
    Payment               = BankPaym.Payment();

    BankPaym.Origin       = CP_OR_AUTO;
    BankPaym.Oper         = {oper}; 
    BankPaym.CurrentState = 0/*CP_ST_DEFERRED*/;

    Payment.BaseFIID      =
    Payment.PayerFIID     = 
    Payment.ReceiverFIID  = PaymentObj.ReceiverFIID;
    Payment.DocKind       = BBANK_CPORDER;
    Payment.Purpose       = PM_PURP_BANKPAYMENT;
    Payment.ComissCharges = PM_CHRG_SHA;
  end;
  
  Payment.Number                   = PaymentObj.Number;
  Payment.PaymentKind              = "Э";
  Payment.ShifrOper                = "01";

  Payment.BaseAmount               =
  Payment.PayerAmount              =
  Payment.ReceiverAmount           = Amount;

  Payment.SetPayerPI( PAYMENTS_GROUP_UNDEF, 
                      {OurBank}, 
                      0, 
                      "", 
                      "",
                      "",
                      PaymentObj.ReceiverFIID, 
                      1/*CHAPT1*/, 
                      PayerAccount, 
                      PaymentObj.Payer, 
                      PaymentObj.PayerName, 
                      PaymentObj.PayerINN );

  Payment.SetReceiverPI( PAYMENTS_GROUP_UNDEF, 
                         PaymentObj.ReceiverBankID, 
                         PaymentObj.ReceiverBankCodeKind, 
                         PaymentObj.ReceiverBankCode, 
                         PaymentObj.ReceiverBankName,
                         PaymentObj.ReceiverBankCorrAcc,
                         PaymentObj.ReceiverFIID, 
                         1/*CHAPT1*/, 
                         PaymentObj.ReceiverAccount, 
                         PaymentObj.Receiver, 
                         PaymentObj.ReceiverName, 
                         PaymentObj.ReceiverINN );

  Payment.PayDate                  =
  Payment.ClientDate               = 
  Payment.Date                     =
  Payment.ValueDate                = {curdate};

  Payment.Ground                   = Ground;

  // Заполнение кода вида валютной операции
  BC_SetVOCode( BcOrder, Payment, PSBCACTION_CARRY );

  // Установить признак автозапуска операции.
  BankPaym.LaunchOper              = true;

  Payment.CryptoAction( string("Автоматическое_формирование_платежей") );
END;

//------------------------------------------------------------------------------
// Фильтрик на порожденные документы
//------------------------------------------------------------------------------
PRIVATE MACRO CheckDocKind( oprdocs:TRecHandler /*oprchilddoc.rec*/ )
  return (oprdocs.rec.DocKind == DLDOC_MEMORIALORDER);
END;

//------------------------------------------------------------------------------
// Макрос шага
//------------------------------------------------------------------------------
MACRO ExecuteStep( doc, paymDoc, DocKind:integer, ID_Operation:integer, ID_Step:integer )

  var BcOrder:object  = GenObject( "RsbBuyCurrencyOrder", PaymentObj.DocumentID );
  var FD:BuyCurOrder_FirstDoc = BuyCurOrder_FirstDoc(PaymentObj.DocumentID);
  var AmountPaid = 0, СумИсп = 0, СумСоб = 0;
  var PayerAccount:string = "", Ground:string = "";

  //находим предыдущий шаг
  var Prev_Step:integer = 0;
  var stat     :bool    = Opr_GetPrevStep( ID_Operation, ID_Step, @Prev_Step );

  //находим документы, порожденные на предыдущем шаге
  var ChildDocList:TArray;
  if( stat )
    ChildDocList = filter( OprGetChildDocs( ID_Operation, Prev_Step, true ), @CheckDocKind );
  end;

  //проверяем состояние документов, порожденных на предыдущем шаге
  var Action:integer;
  if( stat )
    Action = reduce( ChildDocList, @CheckChildDoc, PMBC_ACTION_OK );
    if( ( Action == PMBC_ACTION_STOP  ) OR
        ( Action == PMBC_ACTION_ERROR ) )
      stat = false;
    end;
  end;

  if( not stat )
    return 1;
  end;

  // биржевая заявка
  var psbcexch:TExchangeClaimRec = TExchangeClaimRec( BcOrder.RequestID );

  //Определить сумму зачисления
  if( BcOrder.BankFunds )

    BcOrder.WriteOffAmount = PaymentObj.PayerAmount;
    AmountPaid             = PaymentObj.ReceiverAmount;

  else

    if( not psbcexch.get() )
      msgbox("Отсутствует биржевая заявка");
      return 1;
    end;

    if( ((BcOrder.BCOrdKind == PSBCKIND_BUY) AND (PaymentObj.ReceiverFIID == BcOrder.ExchangeFIID)) OR
        ((BcOrder.BCOrdKind == PSBCKIND_CONV) AND (BcOrder.ConvOper == KINDOPCONV_BUY)) )
      
      AmountPaid = (BcOrder.Amount + BcOrder.BankFundsAmount);

    elif( (BcOrder.BCOrdKind == PSBCKIND_BUY) AND (PaymentObj.ReceiverFIID != BcOrder.ExchangeFIID) )

      AmountPaid = ConvertSum( (BcOrder.Amount + BcOrder.BankFundsAmount), BcOrder.Rate, BcOrder.RateScale, BcOrder.RatePoint, BcOrder.RateInv );

    elif( (BcOrder.BCOrdKind == PSBCKIND_PAY) OR ((BcOrder.BCOrdKind == PSBCKIND_CONV) AND (BcOrder.ConvOper == KINDOPCONV_PAY)) )

      СумИсп = ConvertSum( BcOrder.Amount, psbcexch.rec.Rate, psbcexch.rec.RateScale, psbcexch.rec.RatePoint, psbcexch.rec.RateInv );
      СумСоб = ConvertSum( BcOrder.BankFundsAmount, psbcexch.rec.Rate, psbcexch.rec.RateScale, psbcexch.rec.RatePoint, psbcexch.rec.RateInv );
      AmountPaid = (СумИсп + СумСоб);

    end;

  end;

  if( BcOrder.BankFunds )
    PayerAccount = FD.FindAndOpenAccount( "+СчетКонвКл", 0, {curdate}, FIROLE_FIREQ );
  else
    PayerAccount = FD.FindAndOpenAccount( "СчетДепонКл", 0, {curdate}, FIROLE_FIREQ );
  end;
  
  // Сформировать дочерний документ по зачислению средств
  // проводка со счета 47407* на 47407* ненужна

  if( SubStr( PaymentObj.ReceiverAccount, 1, 5 ) != SubStr( PayerAccount, 1, 5 ) )
    if( (BcOrder.BCOrdKind == PSBCKIND_BUY) OR (BcOrder.BCOrdKind == PSBCKIND_CONV) )
      
      Ground = BC_KindOrderName(BcOrder.BCOrdKind) + " № " + PaymentObj.Number + " от " + PaymentObj.Date + ". Зачисление купленной валюты.";
      if( PaymentObj.ReceiverBankID != PaymentObj.PayerBankID )
        CreateBankPaym( BcOrder, Ground, PayerAccount, AmountPaid );
      else
        if (GetRegExchangeIncarryDockind() == 286/*банковский ордер*/)
          CreateBankOrder( BcOrder, Ground, PayerAccount, AmountPaid );
        else
        CreateMemorial( BcOrder, Ground, PayerAccount, AmountPaid );
      end;
      end;

    elif( BcOrder.BCOrdKind == PSBCKIND_PAY )

      Ground = BC_KindOrderName(BcOrder.BCOrdKind) + " № " + PaymentObj.Number + " от " + PaymentObj.Date + ". Зачисление средств после продажи валюты.";
      if( PaymentObj.ReceiverBankID != PaymentObj.PayerBankID )
        CreateBankPaym( BcOrder, Ground, PayerAccount, AmountPaid );
      else
        if (GetRegExchangeIncarryDockind() == 286/*банковский ордер*/)
          CreateBankOrder( BcOrder, Ground, PayerAccount, AmountPaid );
        else
        CreateMemorial( BcOrder, Ground, PayerAccount, AmountPaid );
      end;
      end;

    end;
  end;
  /*VDN 25.02.2015 HF139*/
  PaymentObj.StatusInfo = "Исполнен";

  return 0;
END;

//Jushmanov 2014-02-20 C-19151
macro PostStepAction( message,      /* 1 - выполнение шага; 2 - откат шага;   */
                      errTrn,       /* статус выполнения шага. 0 - ошибки нет */
                      FirstDoc,     /* указатель на первичный документ        */
                      ID_Oper,      /* внутренний идентификатор операции      */
                      Number_Step,  /* Номер шага операции (из настроек)      */
                      KindOper,     /* номер вида операции                    */
                      KindDoc,      /* номер вида первичного документа        */
                      KindStep,     /* вид шага операции                      */
                      ID_Step )     /* внутренний идентификатор шага операции */
    debugbreak;

    private var logquery;

    if(( message == OP_EXECUTE_STEP ) and (errTrn == 0) and (IsOprMultiExec))
        if ((valtype(ID_Oper) != V_INTEGER) and (valtype(ID_Oper) != V_STRING)) ID_Oper = 0; end;
        if ((valtype(ID_Step) != V_INTEGER) and (valtype(id_Step) != V_STRING)) ID_Step = 0; end;

        logquery = "UPDATE usr_doprstep_robot_dbt SET t_is_robot_step = chr(88)" +
                   " WHERE t_id_operation = " + ID_Oper + " AND t_id_step = " + ID_Step;
        ExecSQL(logquery, null, false);
    end;

    return 0;
end;