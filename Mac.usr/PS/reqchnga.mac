/************************************************************************/
/*         Автоматизированная банковская система RS-Bank v.6.0          */
/*                 Copyright (c) R-Style Software Lab 1998              */
/*                                                                      */
/*  Имя файла        : reqchnga.mac                                     */
/*                                                                      */
/*  Описание         : Инициализация и проверки распоряжений            */
/*                     на изменение номера счета                        */
/*  Программист      : Андреева Е.П.                                    */
/*                                                                      */
/*  Создан           : 15.10.2004                                       */
/*                                                                      */
// KS 22.11.2013 Перенесены доработки из 30й сборки
/************************************************************************/
import BankInter, reqinter, reqchecks, pm_common;

/* Проверяемые поля */
private const fld_Date               = 1,
              fld_InputDate          = 2,
              fld_OldAccountFIID     = 3,
              fld_OldAccount         = 5,
              fld_ChangeGround       = 11,
              fld_NewContractNumber  = 13,
              fld_NewAccountFIID     = 13,
              fld_Balance            = 14,
              fld_NewAccount         = 15,
              fld_NewAccountOper     = 17,
              fld_NewAccountType     = 18,
              fld_NewAccountName     = 20;
private const  Fld_LinkAcc  =  5,
               Fld_LinkABal =  4,
               Fld_LinkAFI  =  3;

/* Номер ошибки заведомо больше числа полей, чтобы никуда не позиционироваться */
private const REQCHNGA_JUSTERROR:integer = 1024;

/*Для платежей*/

/*Хинт для списков по дате заявления*/
private const Hint_ByDate     :string = "/*+FIRST_ROWS LEADING(t accounts partcode person) INDEX(t dreqchnga_dbt_idx5) USE_NL(t accounts partcode person)*/";
/*Хинт для списков по дате закрытия*/
private const Hint_ByCloseDate:string = "/*+FIRST_ROWS LEADING(t accounts partcode person) INDEX(t dreqchnga_dbt_idx4) USE_NL(t accounts partcode person)*/";
/*Хинт для списков по статусу первички*/
private const Hint_ByStatus   :string = "/*+FIRST_ROWS LEADING(t accounts partcode person) INDEX(t dreqchnga_dbt_idx2) USE_NL(t accounts partcode person)*/";
/*Хинт для списков по шагу*/
private const Hint_ByStep     :string = "/*+FIRST_ROWS LEADING(t oproper reqchnga accounts partcode person) INDEX(t doprstep_dbt_idx10) INDEX(reqchnga dreqchnga_dbt_idx0) USE_NL(t oproper reqchnga accounts partcode person)*/";

/* CDS Пришлось добавить здесь. Ранее функция импортировалась из reqinter.mac,
   но там пришлось сделать её private, т.к. шло переопределение с другими макросами
   при постановке в К2 комиссии за закрытие счёта. */
/******************************************************************************
Служебная процедура, расширяет значение num до строки длиной len,
свободные позиции слева заполняет _нулями_ (а не пробелами)
******************************************************************************/
private MACRO LZ( num, len )
     var str1, len1;
     str1 = trim( string( num ) );
     len1 = strlen( str1 );
     if ( len1 >= len ) return str1;
     else   return  mkstr("0", len-len1 ) + str1;
     end;
END;

/* Установка подсказки для скролингов из макроса */
MACRO УстановитьПодсказку( TableName:string, IndexNum:integer, DefaultHint:string, ScrolStates:integer ):string
  /*  Возможные значения ScrolStates:
      0  - Все                      
      1  - Отложенные               
      2  - Открытые                 
      3  - Закрытые                 
      4  - Отвергнутые              
      5  - Подготовленные к шагу */

  if( ScrolStates == 0 ) //Все

    return Hint_ByDate;

  elif( ScrolStates == 3 ) //Закрытые

    return Hint_ByCloseDate;  

  elif(    ( ScrolStates == 1 )   //Отложенные
        or ( ScrolStates == 2 )   //Открытые
        or ( ScrolStates == 4 ) ) //Отвергнутые
  
    return Hint_ByStatus;    

  elif( ScrolStates == 5 ) //Подготовленные к шагу

    return Hint_ByStep;

  end;

  return DefaultHint;
END;

/* Макрос генерации номера открываемого счета */
MACRO НомерСчетаЗаявления()
  ReqChangeAcc.NewAccount = ПолучитьНомерСчетаЗаявления( ReqChangeAcc.NewAccount, ReqChangeAcc.Balance0, ReqChangeAcc.NewAccountFIID, ReqChangeAcc.NewAccountSpecKind, ReqChangeAcc.NewAccountDep );
  return 0;
END;

// Функция предназначена для проверки номера основного счета в заявлении
MACRO ПроверитьНомерСчета():integer
  
  var AccKey, CodeKind, error;
  
  if( (ReqChangeAcc.Dummy != "X") and (ReqChangeAcc.NewAccount != "") and (not IsStepWasExecuted(ReqChangeAcc.RequestID, PS_REQCHANGE, 10/*открытие счета*/)) )
    if ( ( NOT Req_IsAccExist(ReqChangeAcc.NewAccountFIID, ReqChangeAcc.NewAccount) ) and ( SubStr(ReqChangeAcc.NewAccount, 1, 1) != "L") )
      msgbox("Счет с таким номером уже существует");
      return fld_NewAccount;
    end;                                                    

    if ( SubStr(ReqChangeAcc.NewAccount, 1, 5) != LZ( ReqChangeAcc.Balance0, 5 ) )
      msgbox("Заданный счет не может быть открыт на заданном балансовом счете");
      return fld_NewAccount;
    end;

    if ( NOT Req_IsFIExist( SubStr(ReqChangeAcc.NewAccount, 6, 3) ) )      
      msgbox("Код валюты счета не найден в справочнике");
      return fld_NewAccount;
    end;
    
    if ( SubStr(ReqChangeAcc.NewAccount, 6, 3) != LZ(ПолучитьКодФинИнДляСчета( ReqChangeAcc.NewAccountFIID ), 3) )
      msgbox("Валюта открываемого счета не соответствует заданной");
      return fld_NewAccount;
    end;

    var PartyID = 0, BIC = "";
    getDeptPartyIDandBIC(ReqChangeAcc.NewAccountDep, @PartyID, @BIC);

    AccKey = GetKey( ReqChangeAcc.NewAccount, BIC );
    if ( AccKey != ReqChangeAcc.NewAccount )
      msgbox("Неверный ключ счета. Должен быть " + SubStr(AccKey, 9, 1));
      return fld_NewAccount;
    end;
/* SDA - коды СМФР не используются в обычных банках                  
    GetREgistryValue("CB/PAYMENTS/DEPCODEKIND", V_INTEGER, CodeKind, error);
    if ( SubStr(ReqChangeAcc.NewAccount, 10, 4) != ПолучитьКодСубъекта(PartyID, CodeKind, error) )
      msgbox("Неверно задан код филиала в номере счета");
      return fld_NewAccount;
    end;
*/  
  end;

  return 0;
END;

// Функция предназначена для проверки номеров связанных счетов (в дистрибутиве реализуется только проверка транзитного счета)
MACRO ПроверитьНомерСвязанногоСчета():integer

  var AccKey, CodeKind, error;

  if( not IsStepWasExecuted( ReqChangeAcc.RequestID, PS_REQCHANGE, 40/*открытие транзитного счета*/ ) )
    if ( (ReqChangeAcc.Dummy != "X") and (ReqLinkAcc.GroupID == OBJROLE_ACC_TRANSIT) )
      if ( NOT Req_IsAccExist(ReqLinkAcc.Code_Currency, ReqLinkAcc.Account) )
        msgbox("Счет с таким номером уже существует");
        return Fld_LinkAcc;
      end;

      if ( ReqChangeAcc.Balance0 != ReqLinkAcc.Balance0 ) 
        msgbox("Балансовые счета основного и транзитного счетов не совпадают");
        return Fld_LinkABal;
      end;

      if ( ReqChangeAcc.NewAccountFIID != ReqLinkAcc.Code_Currency ) 
        msgbox("Валюты основного и транзитного счетов не совпадают");
        return Fld_LinkAFI;
      end;

      if ( SubStr(ReqLinkAcc.Account, 1, 5) != LZ( ReqLinkAcc.Balance0, 5 ) )
        msgbox("Заданный счет не может быть открыт на заданном балансовом счете");
        return Fld_LinkAcc;
      end;

      if ( NOT Req_IsFIExist( SubStr(ReqLinkAcc.Account, 6, 3) ) )
        msgbox("Код валюты счета не найден в справочнике");
        return Fld_LinkAcc;
      end;
      
      if ( SubStr(ReqLinkAcc.Account, 6, 3) != LZ(ПолучитьКодФинИнДляСчета( ReqLinkAcc.Code_Currency ), 3) )
        msgbox("Валюта открываемого счета не соответствует заданной");
        return Fld_LinkAcc;
      end;

      var PartyID = 0, BIC = "";
      getDeptPartyIDandBIC(ReqChangeAcc.NewAccountDep, @PartyID, @BIC);

      AccKey = GetKey( ReqLinkAcc.Account, BIC );
      if( AccKey != ReqLinkAcc.Account )
        msgbox("Неверный ключ счета. Должен быть " + SubStr(AccKey, 9, 1));
        return Fld_LinkAcc;
      end;
     
      GetREgistryValue("CB/PAYMENTS/DEPCODEKIND", V_INTEGER, CodeKind, error);
      if ( SubStr(ReqLinkAcc.Account, 10, 4) != ПолучитьКодСубъекта(PartyID, CodeKind, error) )
        msgbox("Неверно задан код филиала в номере счета");
        return Fld_LinkAcc;
      end;
    
      if ( SubStr(ReqLinkAcc.Account, 14, 1) != "1" )
        msgbox("В номере счета отсутствует признак транзитного счета");
        return Fld_LinkAcc;
      end;
    end;
  end;

  return 0;
 
END;

/* Выдать сообщение о незаполненности поля FieldName */
macro PrintErrMsg( FieldName )
  msgbox( "Не заполнено поле \'" + FieldName + "\'");
end;

/*  Определение, что две записи(имеющие одинаковое описание в bank.def)
    совпадают, или отличаются только одним полем с заданным именем.
    Если записи совпадают, возвращается true */
private macro ПроверкаИдентичности( Запись1, Запись2, НаименованиеНепроверяемогоПоля )
  var НомерНепроверяемогоПоля = -1;
  var i = 0;

  if( (ValType(НаименованиеНепроверяемогоПоля) == V_STRING) and (НаименованиеНепроверяемогоПоля != "") )
    НомерНепроверяемогоПоля = FldIndex(Запись1,НаименованиеНепроверяемогоПоля);
  end;

  while(i < FldNumber(Запись1))
    if( (i != НомерНепроверяемогоПоля) and (Запись1(i) != Запись2(i)) ) return false; end;
    i = i + 1;
  end;

  return true;
end;


MACRO Новое_Заявление()
  return 0;
END;

/* При редактировании производим проверку важности внесенных изменений        */
/* Константы важности внесенных изменений:                                    */
/* CHANG_NOTIMPORTANT - изменения неважные (сохранение без отката операции)   */
/* CHANG_IMPORTANT    - изменения важны (сохранение изменений возможно только */
/*                      при откате)                                           */
/* CHANG_NOTKEEP      - не сохранять изменения                                */
/* Если возвращаемое значение  > 0, то это оно интерпретируется как номер     */
/*                                  поля с ошибочным параметром               */
/* Если возвращаемое значение  = 0, то cчитается, что проверка прошла успешно */
/*                                  и сохранение изменений можно производить  */
/*                                  без отката операции                       */

MACRO Проверить_Заявление( Режим )
  var stat:integer = 0;
 
  /* Проверки при вводе и редактировании распоряжения */
  if( ( Режим == 2 ) or ( Режим == 3 ) or ( Режим == 8 ) )

     if( ReqChangeAcc.NewAccount == "")
       НомерСчетаЗаявления();
    end;
    
     stat = CheckKey( 1, ReqChangeAcc.NewAccount );

    if( ReqChangeAcc.Date == date(0, 0, 0) )
      PrintErrMsg( "Дата" );
      return fld_Date;
    end;

    if( ReqChangeAcc.InputDate == date(0, 0, 0) )
      PrintErrMsg( "Дата ввода" );
      return fld_InputDate;
    end;

    if( ReqChangeAcc.OldAccountFIID < 0 )
      PrintErrMsg( "Валюта" );
      return fld_OldAccountFIID;
    end;

    if( StrLen( ReqChangeAcc.OldAccount ) == 0 )
      PrintErrMsg( "Закрываемый счет" );
      return fld_OldAccount;
    end;

    if( ReqChangeAcc.NewAccountFIID < 0 )
      PrintErrMsg( "Валюта нового счета" );
      return fld_NewAccountFIID;
    end;

    if( StrLen( ReqChangeAcc.NewAccount ) == 0 )
      PrintErrMsg( "Новый счет" );
      return fld_NewAccount;
    end;

    if( ReqChangeAcc.Dummy != "X" )
      if( StrLen( ReqChangeAcc.ChangeGround ) == 0 )
        PrintErrMsg( "Основание изменения номера счета" );
        return fld_ChangeGround;
      end;

      if( StrLen( ReqChangeAcc.Balance0 ) == 0 )
        PrintErrMsg( "Балансовый счет" );
        return fld_Balance;
      end;

      if( ReqChangeAcc.NewAccountOper == 0 )
        PrintErrMsg( "Операционист" );
        return fld_NewAccountOper;
      end;
    
      if( StrLen( ReqChangeAcc.NewAccountType ) == 0 )
        PrintErrMsg( "Тип нового счета" );
        return fld_NewAccountType;
      elif( (ReqChangeAcc.Dummy != "X") and 
            not CheckTypeAccount( ReqChangeAcc.NewAccountType, "в распоряжении на изменение номера счета" )
          )
        return fld_NewAccountType;
      end;
  
      if( StrLen( ReqChangeAcc.NewAccountName ) == 0 )
        PrintErrMsg( "Наименование нового счета" );
        return fld_NewAccountName;
      end;
    end;
  
    if( ReqChangeAcc.Dummy != "X" )
      
      // Валюта старого счета совпадает с валютой нового счета
      if( ReqChangeAcc.NewAccountFIID != ReqChangeAcc.OldAccountFIID )
        MsgBox("Валюта нового счета не совпадает с валютой старого счета. " +
               "Проведение операции возможно только при нулевых остатках на основном " +
               "и связанных счетах.");        
        if( not ПолучитьОстаток(ReqChangeAcc.OldAccount, CHAPT1, ReqChangeAcc.OldAccountFIID) )
          // если остаток на старом счете = 0.00, то серьезность ошибки = 1
          return CHANG_IMPORTANT;
        else
          return fld_NewAccountFIID;
        end;
      end;

      var select = "select t_Department, t_Branch, t_Type_Account " +
                   "  from daccount_dbt " +
                   " where t_Account = '" + ReqChangeAcc.OldAccount + "'" +
                   "   and t_chapter = 1 " +
                   "   and t_Code_Currency = " + ReqChangeAcc.OldAccountFIID;
      var rs = execSQLselect( select );
      if (rs and rs.MoveNext() )
  
        // Филиалы старого и нового счетов совпадают
        if( (ReqChangeAcc.NewAccountDep != rs.value("t_Department")) or
            (ReqChangeAcc.NewAccountBranch != rs.value("t_Branch"))
          )
          MsgBox("Филиалы счетов до и после изменения не совпадают");
          return fld_NewAccountOper; // сам филиал не редактируется, а определяется по операционисту
        end;

        // Тип нового счета совпадает с одним из типов старого счета
        if( StrBrk(rs.value("t_Type_Account"), ReqChangeAcc.NewAccountType) == 0 )
          MsgBox("Тип нового счета не соответствует типу старого счета");
          return CHANG_IMPORTANT; // серьезность ошибки = 1
        end;

      end;

      if( PS_CheckReqchnga( ReqChangeAcc ) )
        return REQCHNGA_JUSTERROR;
      end;

    end;

  end;

  /* В режиме редактирования проверяем изменения на важность */
  /* Проверяем только для распоряжений, по которым начали операцию */
  if( Режим == 3 )
    if( ReqChangeAcc.CurrentState != 0 )
      /* Изменение любого поля считаем важным */
      if( not ПроверкаИдентичности( ReqChangeAcc, OldReqChangeAcc ) )
        stat = CHANG_IMPORTANT;
      else
        stat = CHANG_NOTIMPORTANT;
      end;
    end;
  end;

  return stat;
END;

MACRO Функция_Пользователя( Режим:integer )
 /*
 Возможные значения Режим:
  UFN_PANEL_INPUT(1) - функция вызвана из панели ввода объекта;
  UFN_PANEL_EDIT(2) - функция вызвана из панели корректировки объекта;
  UFN_SCROL(3) - функция вызвана из панели скролинга, единичный вызов, любая корректировка объекта запрещена;
  UFN_SCROL_FMASS(4) - функция вызвана из панели скролинга, работа по нескольким записям, вызов до начала обработки, любая корректировка объекта запрещена;
 
// Пример работы: 
 if( Режим == UFN_SCROL )
   return UPDTPAGE;    // Обновить страницу записей и область скролинга
   //return UPDTREC;     // Обновить текущую запись, загрузив из файла
 end;
 */
  return 0;
END;


/* Макрос генерации номера связанного счета */
MACRO НомерСвязанногоСчетаЗаявления()
  ReqLinkAcc.Account = ПолучитьНомерСвязанногоСчетаЗаявления( ReqLinkAcc, ReqChangeAcc.NewAccount, ReqChangeAcc.Balance0, ReqChangeAcc.NewAccountDep );
  return 0;
END;
