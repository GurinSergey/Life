/************************************************************************/
/*         Автоматизированная банковская система RS-Bank                */
/*                 Copyright (c) R-Style Software Lab 1998              */
/*                                                                      */
/*  Имя файла        : reqopnac.mac                                     */
/*                                                                      */
/*  Описание         : Инициализация и проверки                         */
/*                     заявлений на открытие накопительного счета       */
/*  Программист      : Локтюшин В.Ю.                                    */
/*                                                                      */
/*  Создан           : 12.12.2006                                       */
/*                                                                      */
/************************************************************************/
IMPORT reqinter;

RECORD ReqOpenAccum(reqopnac);
RECORD OldReqOpenAccum(reqopnac);

/* EVG Пришлось добавить здесь. Ранее функция импортировалась из reqinter.mac,
   но там пришлось сделать её private, т.к. шло переопределение с другими макросами
   при постановке в К2 комиссии за закрытие счёта. */
/******************************************************************************
Служебная процедура, расширяет значение num до строки длиной len,
свободные позиции слева заполняет _нулями_ (а не пробелами)
******************************************************************************/
private MACRO LZ( num, len )
     var str1, len1;
     str1 = trim( string( num ) );
     len1 = strlen( str1 );
     if ( len1 >= len ) return str1;
     else   return  mkstr("0", len-len1 ) + str1;
     end;
END;

/* Макрос генерации номера открываемого счета, для которого было введено заявление */
MACRO НомерСчетаЗаявления()
  ReqOpenAccum.Account=ПолучитьНомерСчетаЗаявления(ReqOpenAccum.Account, ReqOpenAccum.Balance0, ReqOpenAccum.AccountFIID, "L" );
  return 0;
END;

const fld_DATE       = 1, 
      fld_INPUTDATE  = 2,
      fld_CLIENTCODE = 3,
      fld_CLIENTNAME = 4,
      fld_PERSONNAME = 5,
      fld_FIICODE    = 6,
      fld_BALANCE    = 8,
      fld_NEWACC     = 9,
      fld_NAMEACC    = 10,
      fld_OPER       = 13,
      fld_PACKNUMB   = 14;

/*Для платежей*/

/*Хинт для списков по дате заявления*/
private const Hint_ByDate     :string = "/*+FIRST_ROWS LEADING(t oproper partcode) INDEX(t dreqopnac_dbt_idx6) USE_NL(t oproper partcode)*/";
/*Хинт для списков по дате закрытия*/
private const Hint_ByCloseDate:string = "/*+FIRST_ROWS LEADING(t oproper partcode) INDEX(t dreqopnac_dbt_idx4) USE_NL(t oproper partcode)*/";
/*Хинт для списков по статусу первички*/
private const Hint_ByStatus   :string = "/*+FIRST_ROWS LEADING(t oproper partcode) INDEX(t dreqopnac_dbt_idx2) USE_NL(t oproper partcode)*/";
/*Хинт для списков по шагу*/
private const Hint_ByStep     :string = "/*+FIRST_ROWS LEADING(t oproper reqopnac partcode) INDEX(t doprstep_dbt_idx10) INDEX(reqopnac dreqopnac_dbt_idx0) USE_NL(t oproper reqopnac partcode)*/";

/* Установка подсказки для скролингов из макроса */
MACRO УстановитьПодсказку( TableName:string, IndexNum:integer, DefaultHint:string, ScrolStates:integer ):string
  /*  Возможные значения ScrolStates:
      0  - Все                      
      1  - Отложенные               
      2  - Открытые                 
      3  - Закрытые                 
      4  - Отвергнутые              
      5  - Подготовленные к шагу */

  if( ScrolStates == 0 ) //Все

    return Hint_ByDate;

  elif( ScrolStates == 3 ) //Закрытые

    return Hint_ByCloseDate;  

  elif(    ( ScrolStates == 1 )   //Отложенные
        or ( ScrolStates == 2 )   //Открытые
        or ( ScrolStates == 4 ) ) //Отвергнутые
  
    return Hint_ByStatus;    

  elif( ScrolStates == 5 ) //Подготовленные к шагу

    return Hint_ByStep;

  end;

  return DefaultHint;
END;

MACRO FindBal( Account:string ):bool
  return existsSQLselect( "select 1 "
                            "from dbalance_dbt "
                           "where t_Chapter = 1 "
                             "and t_iNumPlan = 0 "
                             "and t_Balance = :Balance", 
                           makeArray( SQLParam( "Balance", Substr( Account, 1, 5 ) ) ) );
END;

MACRO Новое_Заявление()
  return 0;
END;

MACRO Проверить_Заявление(Режим)
  debugbreak;

  var AccKey, CodeKind, error;
  var stat = 0;
  var Err:string = "Не заполнено поле: ";
  var ZeroDate   = Date( 0, 0, 0 );

  if ( (Режим == 2 ) or (Режим == 3) or (Режим == 8) )

     if( ReqOpenAccum.AccountOper == 0)
       ReqOpenAccum.AccountOper = {oper};
       ReqOpenAccum.AccountDepartment = {OperDprt};
       ReqOpenAccum.AccountBranch = {OperDprtNode};
     end;

     if( ReqOpenAccum.Date <= ZeroDate )
       msgbox( Err, "Дата" );
      return fld_DATE;
     end;

     if( ReqOpenAccum.InputDate <= ZeroDate )
       msgbox( Err, "Дата ввода" );
      return fld_INPUTDATE;
     end;
                      
     if( not ReqOpenAccum.ClientID )
       msgbox( Err, "Клиент" );
       return fld_CLIENTCODE;
     end;
  
     if( ReqOpenAccum.ClientName == "" )
       msgbox( Err, "Клиент: наименование" );
       return fld_CLIENTNAME;
     end;

     if( ReqOpenAccum.PersonName == "" )
       msgbox( Err, "Заявитель" );
       return fld_PERSONNAME;
     end;

     if( ReqOpenAccum.AccountFIID == ALLFININSTR )
       msgbox( Err, "Код валюты"  );
       return fld_FIICODE;
     end;

     if( ReqOpenAccum.Balance0 == "" )
       msgbox( Err, "Балансовый" );
       return fld_BALANCE;
     end;

     if( (ReqOpenAccum.Account != "") and not FindBal( ReqOpenAccum.Account ) )
       msgbox ("Не найден балансовый счет: ", Substr( ReqOpenAccum.Account, 1, 5 ) );
       return fld_BALANCE;
     end;

     if( ReqOpenAccum.AccountName == "" )
       msgbox( Err, "Наименование счета" );
       return fld_NAMEACC;
     end;

     if( not ReqOpenAccum.AccountOper )
       msgbox( Err, "Операционист" );
       return fld_OPER;
     end;

     if( ReqOpenAccum.NumberPack < 0 )
       msgbox( "Номер пачки не может быть отрицательным" );
       return fld_PACKNUMB;
     end;

     if( (ReqOpenAccum.Account != "") and (not IsStepWasExecuted(ReqOpenAccum.RequestID, PS_REQOPNAC, 10/*открытие счета*/)) )
       if ( NOT Req_IsAccExist(ReqOpenAccum.AccountFIID, ReqOpenAccum.Account) )
         msgbox("Счет с таким номером уже существует");
         return fld_NEWACC;
       end;

       if ( SubStr(ReqOpenAccum.Account, 1, 5) != LZ( ReqOpenAccum.Balance0, 5 ) )
         msgbox("Заданный счет не может быть открыт на заданном балансовом счете");
         return fld_NEWACC;
       end;

       if ( NOT Req_IsFIExist( SubStr(ReqOpenAccum.Account, 6, 3) ) )      
         msgbox("Код валюты счета не найден в справочнике");
         return fld_NEWACC;
       end;
       
       if ( SubStr(ReqOpenAccum.Account, 6, 3) != LZ(ПолучитьКодФинИнДляСчета( ReqOpenAccum.AccountFIID ), 3) )
         msgbox("Неверный код валюты в номере счета");
         return fld_NEWACC;
       end;

       AccKey = GetKey( ReqOpenAccum.Account, {MFO_Bank} );
       if ( AccKey != ReqOpenAccum.Account )
         msgbox("Неверный ключ счета. Должен быть " + SubStr(AccKey, 9, 1));
         return fld_NEWACC;
       end;
            
       GetREgistryValue("CB/PAYMENTS/DEPCODEKIND", V_INTEGER, CodeKind, error);
       if ( SubStr(ReqOpenAccum.Account, 10, 4) != ПолучитьКодСубъекта({OurBank}, CodeKind, error) )
         msgbox("Неверно задан код филиала в номере счета");
         return fld_NEWACC;
       end;
     end;

  end;

  if( ( not stat ) and ( Режим == 3 ) 
      and ( not CmpRECORD( OldReqOpenAccum, ReqOpenAccum ) )
      and ( ReqOpenAccum.CurrentState != 0 ) //REQOPENA_ST_DEFERRED  = 0  Отложена
      and ( ReqOpenAccum.CurrentState != 20 ) //REQOPENA_ST_REJECTED  = 20 Отвергнута
    )
    stat = CHANG_IMPORTANT;
  end;

  return stat;
END;

MACRO Функция_Пользователя( Режим:integer )
   return 0;
END;
