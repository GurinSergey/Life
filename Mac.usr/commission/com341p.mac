/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   EVG Макрос пользовательского алгоритма расчёта базовых сумм комиссии 3.4.1
       "Перевод средств в пользу клиентов других банков - на корсчета в Банке".

       Тип комиссии - периодическая.
   ChangeLog:
   //RR 19.02.2014 Адаптирую под 2031(darhdoc_dbt -> dacctrn_dbt)
   //joy 14.11.2014 I-00532241 в 2031 обязательно надо проверять, что t_state в проводках = 1
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

import sfinter, cb_sql;
import CommissLib;
import lib_comiss_common;

/*
    Если при расчете произошла ошибка, поместить в эту переменную ненулевое значение
*/
var MacroError :integer = 0;
private var FICode_calc:string = "";

  /* Тип величины
enum SfBaseTypes{*/
private const   SF_BASETYPE_SUM     = 1;      /* Сумма*/
private const   SF_BASETYPE_QUONT   = 2;      /* Количество*/

private const NATCUR = 0;
record sfbassum( "sfbassum.str" );

/* EVG Добавил приём структуры sfcontr для вызова из макроса sfacrpay.mac */
macro CalcServiceSum( sfcontr_addr/*Договор обслуживания*/, BeginDate/*Начало периода*/, EndDate/*Конец периода*/,
      sAddr /* EVG Какой-то ещё адрес */, sfcontrStruc /*Cтруктура sfcontr*/ )

    record sfcontr( sfcontr );
    var query, rs, stat, cmd;
    var wasOperated = false,
        CommQuont   = 0;

    var МаскаКорСчетов   = "'30109','30110'";
    //private var БИКиБанковГруппы = "044525986, 046311808, 046577781, 042908701, 044583859, 040702756, 042007755, 047308902, 041806835, 046577859";
    private var БИКиБанковГруппы = getBICsBanks();

debugbreak;
    /* EVG При вызове из sfacrpay.mac используем полученную структуру sfcontrStruc вместо адреса sfcontr_addr */
    if ( ValType (sfcontr_addr) != V_UNDEF )
       SetBuff( sfcontr, sfcontr_addr );
    else
       Copy ( sfcontr, sfcontrStruc );
    end;

    query = " Select count(rownum) From DPmPaym_dbt paym " +
            "  Where ( paym.t_PayerAccount       = ? " + 
            "          or paym.t_ReceiverAccount = ? ) " +
            "    and ( subStr(paym.t_FuturePayerAccount, 1, 5) in ( ? ) " +
            "          or subStr(paym.t_FutureReceiverAccount, 1, 5) in ( ? ) ) " +
            "    and paym.t_PaymStatus           = 32000 " +
            "    AND EXISTS (SELECT ARH.T_ACCTRNID " +
            "                  FROM dacctrn_dbt arh, dpmdocs_dbt pmd " +
            "                 WHERE AND ARH.T_ACCTRNID = PMD.T_ACCTRNID" +
            "                   AND pmd.t_paymentid = paym.t_paymentid " +
            "                   AND arh.t_chapter = 1                  " +
            "                   AND arh.t_state = 1                  "+
            "                  AND arh.t_date_carry BETWEEN ? AND ? ) " +
            "    AND paym.t_receiverbankid NOT IN ( SELECT code.t_objectid " +
            "                                         FROM dobjcode_dbt code " +
            "                                        WHERE code.t_code IN (?) " +
            "                                          AND code.t_codekind = 3 " +
            "                                          AND code.t_objecttype = 3) ";

          cmd = rsdcommand(query);
          cmd.AddParam("", RSDBP_IN,sfcontr.Object);
          cmd.AddParam("", RSDBP_IN,sfcontr.Object);
          cmd.AddParam("", RSDBP_IN,МаскаКорСчетов);
          cmd.AddParam("", RSDBP_IN,МаскаКорСчетов);
          cmd.AddParam("", RSDBP_IN,BeginDate);
          cmd.AddParam("", RSDBP_IN,EndDate);
          cmd.AddParam("", RSDBP_IN,БИКиБанковГруппы);

    rs = rsdRecordSet(cmd);
    if (rs and rs.moveNext())
     MsgBox(rs.value(0));
       CommQuont = rs.value(0, null, V_INTEGER);

    end;


    /* EVG При вызове из sfacrpay.mac возвращаем true в случае положительного результата расчёта */
    if ( ValType (sfcontrStruc) != V_UNDEF )
       if (CommQuont > 0)
          return true;
       end;
       return false;
    end;

    
    ClearRecord(sfbassum);

    sfbassum.baseType = SF_BASETYPE_QUONT;
    sfbassum.baseQuont  = CommQuont;

    sfbassum.baseType2 = SF_BASETYPE_QUONT;
    sfbassum.baseQuont2  = CommQuont;

    stat = InsertSumList(sfbassum);

    if( stat )
      MsgBox("Ошибка при вставке базовой суммы");
    end;

    
end;/*CalcServiceSum*/
