/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   ████████   ████████
   ███   ███  ███   ███
   ███  ████  ███  ████
   ███████    ███████
   ███  ███   ███  ███
   ███   ███  ███   ███

   RR Рахмедов Р.С.

   Имя файла: sld_com202021.mac

   Создан:    30.06.2014(R-374616)

   Описание:  Макрос пользовательского алгоритма расчёта базовых сумм комиссии 20.20.21
              В качестве суммы комиссии берется наибольшее из значений:
               1. Количество точек указанных в 151 примечании на клиенте * на тариф
               2. Процент от суммы инкассации.
               
              Значение тарифа по комиссии 20.20.21 задаётся в поле "Максимальная сумма" та-
              рифа с базовой суммой > 0.00. Кроме этого, обязательным является наличие 
              второго тарифа с базовой суммой > 0.01 и значением 100%, который будет 
              использоваться для получения суммы комиссии.
       
              Таким образом для расчёта комиссии, необходимо 2 тарифа:
                 - первый тариф (база > 0.00) используется для указания значения тарифа 
                   в графе "Макс. сумма";
                 - второй тариф (база > 0.01) - реально использующийся при расчёте 
                   комиссии, в котором указано значение 100% и не указано максимальной 
                   суммы.
              
   ChangeLog:
-----------------------------------------------------------------------------------------------------------------------------------------------------

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

import sfinter, ctinter, cb_sql, RSD;

/*
    Если при расчете произошла ошибка, поместить в эту переменную ненулевое значение
*/
var MacroError :integer = 0;
private var FICode_calc:string = "";

  /* Тип величины
enum SfBaseTypes{*/
private const   SF_BASETYPE_SUM     = 1;      /* Сумма*/
private const   SF_BASETYPE_QUONT   = 2;      /* Количество*/

private const NATCUR = 0;
record sfbassum( "sfbassum.str" );
record calcal (sfcalcal);

// Вид примечаний "Количество точек инкассации"
CONST NOTEKIND_POINTCOUNT = 151;

 MACRO CalcServiceSum( sfcontr_addr/*Договор обслуживания*/, BeginDate/*Начало периода*/, EndDate/*Конец периода*/,
       sAddr /* EVG Какой-то ещё адрес */, sfcontrStruc /*Cтруктура sfcontr*/ )

     record sfcontr( sfcontr );
     record pty( party );
     debugbreak;
     var query, rs, stat, sql, cmd;
     var CommSum = $0, cSum1 = $0, cSum2 = $0;
     var SingComSum, PointsCount;
     var TarifValue = 0, MinValue = 0, MaxValue = 0, TarifType = 0;


     /* EVG При вызове из sfacrpay.mac используем полученную структуру sfcontrStruc вместо адреса sfcontr_addr */
     if ( ValType (sfcontr_addr) != V_UNDEF )
        SetBuff( sfcontr, sfcontr_addr );
        SetBuff( calcal, sAddr );
     else
        Copy ( sfcontr, sfcontrStruc );
     end;
    
     if ((ValType (sAddr) == V_UNDEF) or (calcal.CommNumber == 0))
         calcal.FeeType    = 1;
         calcal.CommNumber = 1161; 
     end;
     
     rs = RSDRecordSet( " SELECT   NVL ( " +
                        "             (SELECT   SUM (TRN.T_SUM_NATCUR) " +
                        "                FROM   dacctrn_dbt trn " +
                        "               WHERE   trn.t_date_carry between (SELECT TRUNC (TO_DATE ('"+EndDate+"'), 'month') FROM DUAL) and '"+EndDate+"' " +
                        "                       AND REGEXP_LIKE ('\\s' || LOWER (trn.t_ground), '[П\\п]репроводительная ведомость') " +
                        "                       AND SUBSTR (TRN.T_ACCOUNT_PAYER, 1, 5) = '20202' " +
                        "                       AND (SUBSTR (TRN.T_ACCOUNT_RECEIVER, 1, 3) IN ('405', '406', '407') " +
                        "                            OR SUBSTR (TRN.T_ACCOUNT_RECEIVER, 1, 5) IN ('40802', '40807', '40821')) " +
                        "                       AND trn.t_state = 1 " +
                        "                       AND TRN.T_ACCOUNTID_RECEIVER IN " +
                        "                                (SELECT   ACC.T_ACCOUNTID " +
                        "                                   FROM   daccount_dbt acc " +
                        "                                  WHERE   ACC.T_CLIENT = "+sfcontr.partyid+")), " +
                        "             0 " +
                        "          ) " +
                        "             ssum " +
                        "   FROM   DUAL " );
     rs.movenext();
     
     if (rs.value("ssum") > 0)
     
       ClearRecord(pty);
       pty.partyid = sfcontr.partyid;
       debugbreak;
       PointsCount = 0;
       PointsCount = readNoteForObject(OBJTYPE_PARTY, UniID(pty, OBJTYPE_PARTY), NOTEKIND_POINTCOUNT);
    
       if ( ExecMacroFile("CommissLib", "GetTarifInfo", sfcontr, EndDate, EndDate, 1, 1161, @TarifValue, @MinValue, @MaxValue, @TarifType) )
         cSum1 = PointsCount * MaxValue;
         cSum2 = rs.value("ssum") * (TarifValue/100);
         if ((cSum1 == 0) and (cSum2 == 0))
           CommSum = 0;
         elif (cSum1 > cSum2)
           CommSum = cSum1;
         elif (cSum2 > cSum1)
           CommSum = cSum2;
         end;
       end;
     
     end;
     /* EVG При вызове из sfacrpay.mac возвращаем true в случае положительного результата расчёта */
     if ( ValType (sfcontrStruc) != V_UNDEF )
         if (CommSum > 0)
             return true;
         end;
         return false;
     end;

    
     ClearRecord(sfbassum);

     sfbassum.baseType = SF_BASETYPE_SUM;
     sfbassum.baseSum  = CommSum;

     sfbassum.baseType2 = SF_BASETYPE_SUM;
     sfbassum.baseSum2  = CommSum;

     stat = InsertSumList(sfbassum);

     if( stat )
       MsgBox("Ошибка при вставке базовой суммы");
     end;

    
 END;/*CalcServiceSum*/