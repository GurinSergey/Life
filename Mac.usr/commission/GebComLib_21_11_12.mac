//RR 24.05.2012 исправил таблицудля поиска
//Гуцу Е. 13.08.2012 Добавил доработку GEB_GetCom34RecordSet() и GEB_GetCom34RecordSetTPTorg(), исключающую из расчёта комиссий 3.4.* платежи на клиентов, которым подключены пакеты платежей (заявка C-11436-7).
//Жаворонкова Н. (joy) 21.11.2012 I-00287979-3 Исправлен запрос поиска тарифа в GEB_GetComCurrencyControlSum
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   EVG Специфические функции, используемых при расчёте комиссий в банке ГЭБ.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
import CommissLib;
import fg_Life_Parm;    // EVG 8/08/2012


PRIVATE CONST {Tarif 5.2.3 MIN} =       $0.00,
              {Tarif 5.2.3 MAX} =  $300000.00,
              {Tarif 5.2.4 MIN} =  $300000.01,
              {Tarif 5.2.4 MAX} =  $600000.00,
              {Tarif 5.2.5 MIN} =  $600000.01,
              {Tarif 5.2.5 MAX} = $1000000.00,
              {Tarif 5.2.6 MIN} = $1000000.01,
              {Tarif 5.2.6 MAX} = $5000000.00,
              {Tarif 5.2.7 MIN} = $5000000.01;

CONST TotalCashLimit = $5000000;

//RR Из название переменной все ясно
private var БИКиБанковГруппы = "044525986, 046311808, 046577781, 042908701, 046577859, 040702756, 042007755, 047308902, 041806835";

/* Условия счетов для отбора при расчёте комиссии за ведение счёта 2.2.0 */
PRIVATE MACRO GEB_220_AccountMasc()
   var sql;

   sql = " and t_Open_Close                             = Chr(0) " +            // Открытые
         " and instr(t_type_account, 'П')               = 0 " +                 // Не покрытие
         " and instr(t_type_account, 'L')               = 0 " +                 // Не накопительный
         " and instr(t_type_account, 'Y')               = 0 " +                 // Не транзитный
         " and instr(t_type_account, 'Я')               = 0 " +                 // Не специальный
         " and instr(t_usertypeaccount, 'D')            = 0 " +                 // Не СКС
         " and SubStr(t_Account, 1, 3) between          '405' and '408' ";      // Маска обрабатываемых бал. счетов

   return sql;
END;



MACRO GEB_IsProperCashCommission (Contr, Calcal, Sum)
   var sql, rs;
   var TarifNumber, TarifPlan;

   SQL = "SELECT subStr(com.t_code, 1, 5) cod, pln.t_num num ";
   SQL = SQL + "  FROM dsfcomiss_dbt com, dsfplan_dbt pln, dsfcontrplan_dbt cplan ";
   SQL = SQL + " WHERE com.t_feetype     = " + Calcal.FeeType;
   SQL = SQL + "   AND com.t_number      = " + Calcal.CommNumber;
   SQL = SQL + "   AND cplan.t_sfcontrid = " + Contr.Id;
   SQL = SQL + "   AND cplan.t_begin     = (SELECT MAX (t_begin) ";
   SQL = SQL + "                              FROM dsfcontrplan_dbt ";
   SQL = SQL + "                             WHERE t_sfcontrid = cplan.t_sfcontrid) ";
   SQL = SQL + "   AND pln.t_sfplanid    = cplan.t_sfplanid ";

   rs = rsdRecordSet(SQL);
   if (rs and rs.MoveNext())
      TarifNumber = rs.Value("cod", null, V_STRING);
      TarifPlan   = rs.Value("num", null, V_INTEGER);
   end;


   if   ( (TarifNumber == "5.2.3") )

      return CheckMinMax( Sum, {Tarif 5.2.3 MIN}, {Tarif 5.2.3 MAX});
      
   elif ( (TarifNumber == "5.2.4") )

      return CheckMinMax( Sum, {Tarif 5.2.4 MIN}, {Tarif 5.2.4 MAX});

   elif ( (TarifNumber == "5.2.5") )

      return CheckMinMax( Sum, {Tarif 5.2.5 MIN}, {Tarif 5.2.5 MAX});

   elif ( (TarifNumber == "5.2.6") )

      return CheckMinMax( Sum, {Tarif 5.2.6 MIN}, {Tarif 5.2.6 MAX});

   elif ( (TarifNumber == "5.2.7") )

      return ( Sum >= {Tarif 5.2.7 MIN} );           // Для тарифа 5.2.7 только минимум.

   end;


   return false;
END;



MACRO GEB_Cash_CalcSymbSum_Period( dKind, CashDoc, CashSymbols)
  var query, rs, rs1, mm, yy;
  var PaymValueDate = date(0,0,0),
      MonthBegDate  = date(0,0,0),
      CashSymbSum   = $0,
      cdocAutokey = 0,
      cdocAppKind = 0,
      cdocAppKey  = "";

      macro AddLeftZero( val, len )

         while ( strLen(val) < len )
            val = "0" + val;
         end;
         return val;

      end;

    
    /* Найдём из платежа дату документа */
    query = " Select paym.t_ValueDate " +
            "   From DPmPaym_dbt paym " +
            "  Where paym.t_DocKind    = " + dKind +
            "    and paym.t_DocumentID = " + CashDoc.AutoKey;
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       PaymValueDate = rs.value(0, null, V_DATE);
    end;

    /* Определим дату начала текущего месяца */
    dateSplit(PaymValueDate, null, mm, yy);
    MonthBegDate = date(1, mm, yy);
    
    
    
    /* Посчитаем общую сумму снятия наличных по указанному символу за текущий месяц 
       (с начала месяца по дату выполнения данной операции). */
    CashSymbSum = $0;

    /* Цикл по кассовым документам со счёта клиента за указанный период */
    query = " Select doc.t_AutoKey AutoKey, doc.t_ConnectAppKind AppKind, doc.t_ConnectAppKey AppKey" +
            "   From DPsCshDoc_dbt doc, DpmPaym_dbt pm " +
            "  Where doc.t_ClientAccount   = " + GetSQLString(CashDoc.ClientAccount) +
            "    and pm.t_PaymentID = doc.t_Autokey " +
            "    and pm.t_DocKind   = doc.t_DocKind " +
            "    and pm.t_ValueDate >= " + GetSQLDate(MonthBegDate) +
            "    and pm.t_ValueDate <= " + GetSQLDate(PaymValueDate);
    rs = rsdRecordSet(query);
    //msgbox ("1   ", query);
    while (rs and rs.moveNext())

       cdocAutokey = SQL_ConvTypeInteger(rs.value("AutoKey", null, V_INTEGER));
       cdocAppKind = SQL_ConvTypeInteger(rs.value("AppKind", null, V_INTEGER));
       cdocAppKey  = SQL_ConvTypeStr(rs.value("AppKey",  null, V_STRING));

       if ( (cdocAppKind == 0) and (cdocAppKey == "") )
          query = " Select nvl(sum(symb.t_Sum), 0) " +
                  "   From DSymbCash_dbt symb " +
                  "  Where trim(symb.t_Symbol)  in " + CashSymbols +
                  "    and symb.t_ApplicationKey = " + GetSQLString( AddLeftZero(cdocAutokey, 34) );
          rs1 = rsdRecordSet(query);
          while (rs1 and rs1.moveNext())
             CashSymbSum = CashSymbSum + rs1.value(0, null, V_MONEY);
          end;
       //msgbox ("2   ", query);
       else
          query = " Select nvl(sum(symb.t_Sum), 0) " +
                  "   From DSymbCash_dbt symb " +
                  "  Where trim(symb.t_Symbol)  in " + CashSymbols +
                  "    and symb.t_ApplicationKey = " + GetSQLString( AddLeftZero(cdocAppKind, 5) +
                                                                                 cdocAppKey );
          rs1 = rsdRecordSet(query);
          while (rs1 and rs1.moveNext())
             CashSymbSum = CashSymbSum + rs1.value(0, null, V_MONEY);
          end;
       //msgbox ("3   ", query);
       end;

    end;

    return CashSymbSum;
END;




MACRO GEB_GetCom34RecordSet( Account, Origin, BegDate, EndDate, Tarif )
  var query, rs, cmd,SQL, StrNOT, StrAttrId;
  var OriginClause = "";

  if (ValType(Tarif) == V_UNDEF)
     StrAttrId = "";
     StrNot = "NOT";
  else    
     StrAttrId = " AND oc.t_attrid = "+string(Tarif);
     StrNot = "";
  end;
  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin =  "+CLB_DocOrigin;
  else
     OriginClause = " and ord.t_Origin <> "+CLB_DocOrigin;
  end;


  SQL = " SELECT   COUNT(paym.t_paymentid), NVL(SUM(paym.t_amount), 0) ";
  SQL = SQL + "  FROM   dpmpaym_dbt paym, ";
  SQL = SQL + "         dpmrmprop_dbt prop, ";
  SQL = SQL + "         dpspayord_dbt ord, ";
  SQL = SQL + "         daccount_dbt acc ";
  SQL = SQL + " WHERE       paym.t_payeraccount = ?";
  SQL = SQL + "         AND acc.t_account = paym.t_payeraccount ";
  SQL = SQL + "         AND acc.t_chapter = paym.t_chapter ";
                        /* Кроме платежей на счета бюдж. организаций */
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
                        /* Кроме платежей на счета физ. лиц */
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT IN ('423', '426') ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 5) NOT IN ('40817', '40820', '30232') ";
                        /* Кроме платежей с перечисленными текстовками в основании */
  SQL = SQL + "         AND NOT ( REGEXP_LIKE( '\\s'||lower(prop.t_ground), '(\\sПК\\s|\\sп\\.карта|п/карта|карточный\\sсчет|\\sп/к\\s)' ) ";
  SQL = SQL + "                   OR REGEXP_LIKE ( prop.t_ground, '(40817|40820)\\d{15}' ) ";
  SQL = SQL + "                   OR REGEXP_LIKE ( prop.t_ground, '(423|426)\\d{17}' ) ";
  SQL = SQL + "                 ) ";
                               /* По regexp: \s - пробел, \. - точка */
  SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
  SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
  SQL = SQL + "         AND paym.t_receiverbankid NOT IN ( SELECT code.t_objectid "; //RR 10.07.2012 Теперь платежи между банками группы комиссией не облагаются
  SQL = SQL + "                                              FROM dobjcode_dbt code ";
  SQL = SQL + "                                             WHERE code.t_code IN ("+БИКиБанковГруппы+") ";
  SQL = SQL + "                                               AND code.t_codekind = 3 ";
  SQL = SQL + "                                               AND code.t_objecttype = 3) ";
  SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
  SQL = SQL + "         AND prop.t_shifroper <> '16' ";
  SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid ";
  SQL = SQL + "         AND EXISTS ";
  SQL = SQL + "               (SELECT /*+INDEX(arh darhdoc_dbt_idx5)*/ 1 ";
  SQL = SQL + "                  FROM   dpmdocs_dbt pmd, darhdoc_dbt arh ";
  SQL = SQL + "                 WHERE       pmd.t_paymentid = paym.t_paymentid ";
  SQL = SQL + "                         AND arh.t_applicationkey = pmd.t_applicationkey ";
  SQL = SQL + "                         AND arh.t_chapter = 1 ";
  SQL = SQL + "                         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate)+") ";
  SQL = SQL + "         AND "+StrNOT+" EXISTS ";
  SQL = SQL + "               (SELECT   1 ";
  SQL = SQL + "                  FROM   dobjatcor_dbt oc ";
  SQL = SQL + "                 WHERE       oc.t_objecttype = 501 ";
  SQL = SQL + "                         AND oc.t_groupid = 10 "+StrAttrId;
  SQL = SQL + "                         AND oc.t_object = LPAD(paym.t_paymentid, 10, 0)) " + OriginClause;

  /* EVG 23/08/2012 Доработка для исключения признака категории 200 "Категория для пакетов комиссий" */
  SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
  SQL = SQL + "                           FROM dobjatcor_dbt oc ";
  SQL = SQL + "                          WHERE     oc.t_objecttype = 3 ";
  SQL = SQL + "                                AND oc.t_groupid    = 200 ";
  SQL = SQL + "                                AND oc.t_object     = LPAD(acc.t_client, 10, 0)) ";

  cmd = rsdcommand(SQL);
  cmd.AddParam("", RSDBP_IN, Account);
       // msgbox (sql);
       
       /*
       setoutput ("d:\\12345.txt", false);
       println(sql);
       setoutput (null, true);
       */

  rs = rsdRecordSet(cmd);
  return rs;
END;


MACRO GEB_CheckRestricted( sfcontr )
    var query, rs;
    var CountGeneral    = 0,
        CountRestricted = 0;
debugbreak;
    /* Посчитаем общее количество счетов клиента */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Code_currency = 0 " +
            "    and t_Client        = " + sfcontr.PartyID
            + GEB_220_AccountMasc() +
            " Union All " +
            " Select count(*) from DAccount$_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Client        = " + sfcontr.PartyID
            + GEB_220_AccountMasc();
    //msgbox (query);
    rs = rsdRecordSet(query);
    while (rs and rs.moveNext())
       CountGeneral = CountGeneral + rs.value(0, null, V_INTEGER);
    end;


    /* Посчитаем количество счетов с типом "Т" */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Code_currency = 0 " +
            "    and t_Client        = " + sfcontr.PartyID +
            "    and instr(t_Type_Account, " + GetSQLString(TypeRestricted) + ") > 0 "
            + GEB_220_AccountMasc() +
            " Union All " +
            " Select count(*) from DAccount$_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Client        = " + sfcontr.PartyID +
            "    and instr(t_Type_Account, " + GetSQLString(TypeRestricted) + ") > 0 "
            + GEB_220_AccountMasc();
    rs = rsdRecordSet(query);
    while (rs and rs.moveNext())
       CountRestricted = CountRestricted + rs.value(0, null, V_INTEGER);
    end;

    /* Если все счета имеют тип Т... */
    if (CountRestricted == CountGeneral)
       return true;
    end;

    return false;
end;

 //RR 16.04.2012 В 30-ке изменился набор параметров для AccGetFreeAmount
 MACRO GEB_CheckArrested( EndDate, sfcontr )
    var query, rs;
    var Account,
        CodeCur,
        RestSimpleAboveZero = false,
        RestFreeAboveZero = false,
        RestSimple = $0,
        RestFree = $0,
        Limit = 0,
        FreeLimitAmount;


    query = " Select t_Account, t_Code_Currency, t_limit from DAccount_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Code_currency = 0 " +
            "    and t_Client        = " + sfcontr.PartyID
            + GEB_220_AccountMasc() +
            " Union All " +
            " Select t_Account, t_Code_Currency, t_limit from DAccount$_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Client        = " + sfcontr.PartyID
            + GEB_220_AccountMasc();
    rs = rsdRecordSet(query);
    while (rs and rs.moveNext() and not RestFreeAboveZero)

      Account = rs.value(0, null, V_STRING);
      CodeCur = rs.value(1, null, V_INTEGER);

      if (CodeCur == 0)
         RestSimple = ABS( RestA( Account, EndDate, null, 1) );
      else
         RestSimple = ABS( RestAC( Account, CodeCur, EndDate, null, 1) );
      end;

      /* Если обычный остаток нулевой, свободный остаток не проверяем (ессно, он
         тоже нулевой, следовательно, нас не интересует). */
      if ( RestSimple > $0 )
         RestSimpleAboveZero = true;
         /* Для каждого счёта смотрим свободный остаток. Если хотя бы на оодном
            счёте своб. остаток больше нуля, выходим из цикла и возвращаем false
            из функции. */
         /*FIV 02.03.2010 Убрал abs так как сумма претензий больше остатка должна давать отрицательную сумму
         приоритет должен быть 6 без минуса*/
         
         // RR 16.04.2012 Спасибо тому человеку который проверял это все, ты помог мне бесцельно потратить час моего времени!!!!
         // RestFree = /*ABS*/( AccGetFreeAmount( Account, 1, CodeCur, 6, 0, {curDate} ) );
         AccGetFreeAmount(RestFree, FreeLimitAmount, Account, 1, CodeCur, {curDate},6, 0 );
        
         //Kozina&Sagiyan добавили проверку на наличие лимита овердрафта по заявке I-041546 и ушли кушать и спать. 
         // EVG Уточните, куда пошли?... :)))
         Limit = rs.value(2, null, V_INTEGER);
         if ( (RestFree + Limit) > $0 )
            RestFreeAboveZero = true;
         end;
      end;
    end;

    if ( RestSimpleAboveZero and not RestFreeAboveZero )
       return true;
    end;

    return false;
end;


/* EVG Инкарнация функции CheckIndex2() для банка ГЭБ.
   Отличается тем, что игнорируются счета СКС и пр. */
MACRO GEB_CheckIndex2( EndDate, sfcontr )
    var query, rs;
    var CountAll = 0,
        CountI2  = 0,
        CurrAccRest = $0;

    /* Общее количество счетов */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter                  = 1 " +
            "    and t_Code_currency            = 0 " +
            "    and t_Client                   = " + sfcontr.PartyID
            + GEB_220_AccountMasc();
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       CountAll = rs.value(0, null, V_INTEGER);
    end;


    /* Счета с К2 */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter                  = 1 " +
            "    and t_Code_currency            = 0 " +
            "    and t_Index2                  != Chr(0) " +
            "    and t_Client                   = " + sfcontr.PartyID
            + GEB_220_AccountMasc();
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       CountI2 = rs.value(0, null, V_INTEGER);
    end;

    //msgbox (CountAll, "|", CountI2);

    /* Если К2 стоит по всем счетам клиента */
    if (CountI2 == CountAll)

       /* Посчитаем сумму остатков по валютным счетам на дату взимания комиссии */

       query = " Select acc.t_Account acc, acc.t_Code_Currency cur, acc.t_Chapter chap, acc.t_Limit lim " +
               "   from DAccount$_dbt acc " +
               "  Where acc.t_Chapter       = 1 " +
               "    and acc.t_Client        = " + sfcontr.PartyID
               + GEB_220_AccountMasc;
       rs = rsdRecordSet(query);
       while (rs and rs.moveNext())
       
          CurrAccRest = CurrAccRest + AccGetFreeAmount( rs.value("acc", null, V_STRING),
                                                        rs.value("chap", null, V_INTEGER),
                                                        rs.value("cur", null, V_INTEGER), 
                                                        -6,
                                                        null,           //PaymentObj.ClaimID
                                                        EndDate )
                                    + rs.value("lim", null, V_MONEY);

          //msgbox (CurrAccRest, " - ", rs.value("acc", null, V_STRING), " - ", rs.value("lim", null, V_MONEY));
       end;


       //msgbox (CurrAccRest);
       /* Освобождение от комиссии - только если на вылютных счетах нет средств */
       if (CurrAccRest == $0)
          return true;
       end;
    
    end;

    return false;
end;




MACRO GEB_GetComCurrencyControlSum( sfContr, BegDate, EndDate, sfCommNumber )
  var sql, rs, cmd;
  var TarifValue = $0, MinValue = $0, TarifType = 0;
  var CommSum = $0, OneOpCommSum = $0;


    /* EVG 8/08/2012 Функция определяет таблицу, в которой искать уведомления для рублей */
    macro DefineTable()
       var bnk = fg_life_subject( {OurBank} );

       if( bnk.is_Vuz or bnk.is_Prbb )
          return "usr_trnsf_notify";
       end;

       return "usr_trnsf_notify_rur";
    end;


    /* Получим значение тарифа */
    SQL =       "SELECT   NVL (trf.t_tarifsum / 10000, 0) tVal, NVL ( DECODE ( concom.t_SumMin, 0, trf.t_MinValue / 10000, concom.t_SumMin ), 0 ) minVal, trf.t_TarifType tType ";
    SQL = SQL + "  FROM   dsftarif_dbt trf, dsftarscl_dbt scl, dsfcomiss_dbt com, dsfconcom_dbt concom, ";
    SQL = SQL + "         ( SELECT   cp.t_sfplanid plId  ";
    SQL = SQL + "             FROM   dsfcontrplan_dbt cp ";
    SQL = SQL + "            WHERE   cp.t_sfcontrid = ?\n ";
    SQL = SQL + "              AND cp.t_begin = ";
    /*SQL = SQL + "                     (SELECT  MAX (cp.t_begin) "; 21-11-2012 I-00287979-3 joy cp-->cp1 Иначе находились тарифы и по старым ТП клиента*/
    SQL = SQL + "                     (SELECT  MAX (cp1.t_begin) "; 
    SQL = SQL + "                        FROM  dsfcontrplan_dbt cp1 ";
    SQL = SQL + "                       WHERE  cp1.t_sfcontrid = cp.t_sfcontrid ";
    SQL = SQL + "                         AND cp.t_begin      <= ? ";
    SQL = SQL + "                     ) ";
    SQL = SQL + "         ) sfPlan "; 
    SQL = SQL + " WHERE       com.t_feetype             = 1 ";              // 1 - периодическая комиссия
    SQL = SQL + "         AND com.t_number              = ? ";              // Id комиссии
    SQL = SQL + "         AND concom.t_ObjectType       = 57 ";
    SQL = SQL + "         AND concom.t_ObjectId         = sfPlan.plId ";
    SQL = SQL + "         AND concom.t_FeeType          = com.t_feetype\n ";
    SQL = SQL + "         AND concom.t_CommNumber       = com.t_number ";
    SQL = SQL + "         AND scl.t_feetype             = com.t_feetype ";
    SQL = SQL + "         AND scl.t_commnumber          = com.t_number ";
    SQL = SQL + "         AND (scl.t_begindate BETWEEN    ? ";
    SQL = SQL + "                                  AND    ? ";
    SQL = SQL + "              OR scl.t_begindate       = TO_DATE ('01-01-0001', 'DD-MM-YYYY')) ";
    SQL = SQL + "         AND scl.t_objecttype          = 57 ";
    SQL = SQL + "         AND scl.t_objectid            = sfPlan.plId ";
    SQL = SQL + "         AND trf.t_tarsclid            = scl.t_id ";
    SQL = SQL + "         AND trf.t_basesum             = 0 ";              // Тариф с нулевой базовой суммой 

    cmd = rsdCommand( sql );
    cmd.AddParam("", RSDBP_IN, sfContr.id);
    cmd.AddParam("", RSDBP_IN, EndDate);
    cmd.AddParam("", RSDBP_IN, sfCommNumber);
    cmd.AddParam("", RSDBP_IN, BegDate);
    cmd.AddParam("", RSDBP_IN, EndDate);
    cmd.AddParam("", RSDBP_IN, BegDate);

    rs = rsdRecordSet( cmd );
    
    /*
    SetOutPut("d:\\123123.txt");
    println (sql);
    SetOutPut(null);*/

    //getstring(sql);
    //msgbox (sfCommNumber, " - ", sfContr.id);

    if (rs and rs.moveNext())
       TarifValue = rs.value(0, null, V_DOUBLE);
       MinValue   = rs.value(1, null, V_DOUBLE);
       TarifType  = rs.value(2, null, V_INTEGER);
    end;

    //msgbox( TarifValue, " - ", MinValue, "|", TarifType);

    if ( TarifValue > 0 )

       /* EVG 22/05/2011 Для валюты ищем запись в usr_trnsf_notify, связь usr_trnsf_comiss и usr_trnsf_notify - через notify_num */
       if ( sfContr.Fiid > 0 )

          SQL = " SELECT   NVL(rsb_fiinstr.convsumtype (utc.SUM, ";
          SQL = SQL + "                                   " + sfContr.Fiid + ", ";
          SQL = SQL + "                                       0, ";
          SQL = SQL + "                                       7, ";
          SQL = SQL + "                                    " + GetSQLDate(EndDate) + "),0) ";
          SQL = SQL + "  FROM   dpmpaym_dbt pm, ";
          SQL = SQL + "         usr_trnsf_comiss utc, ";
          SQL = SQL + "         dsfcomiss_dbt com ";
          SQL = SQL + " WHERE       pm.t_futurereceiveraccount = ? ";
          SQL = SQL + "         AND pm.t_paymentid in ( Select Payment_Id From usr_trnsf_notify Where notify_num  = utc.notify_num ";
          // EVG 29.07.2011 Проверка даты больше не нужна SQL = SQL + "                                                                          and notify_date = utc.comdate )";

          /* EVG 18.01.2012 Нужна проверка года в дате потому, что с нового года номера уведомлений сбрасываются на 1, в результате 
             чего появляется дублирование. Поэтому нужно проверить, что год из даты уведомления соответствует году из даты комиссии. */
          /* EVG 16.02.2012 Сделаем проверку и на месяц, т.к. из-за того, что повторно обнулились счётчики, номера уведомлений дуб-
             лируются внутри года. */
             /* 04-05-2012 Жаворонкова Н. (joy) I-00190502-2 Проверку на месяцы убрала */
         // SQL = SQL + "                                   and to_char(notify_date, 'YYYY')||to_char(notify_date, 'MM') ";
         // SQL = SQL + "                                     = to_char(utc.comdate, 'YYYY')||to_char(utc.comdate, 'MM') ) ";
          SQL = SQL + "                                   and to_char(notify_date, 'YYYY') = to_char(utc.comdate, 'YYYY') ) ";
          SQL = SQL + "         AND utc.comdate BETWEEN ? ";
          SQL = SQL + "                                AND  ? ";
          SQL = SQL + "         AND com.t_number  = ? ";
          SQL = SQL + "         AND com.t_feetype = 1 ";
          SQL = SQL + "         AND utc.comid = com.t_number ";
          
    /*
    SetOutPut("d:\\123123.txt");
    println (sql);
    SetOutPut(null);*/

       /* EVG 22/05/2011 Для рублей notify_num равняется paymentId (да, приходится так), поэтому связь между pmpaym
          и usr_trnsf_comiss - через paymentId = notify_num.
          Дополнительно ищется запись в usr_trnsf_notify_rur для исключения случая взимания комиссии за ВК по левым платежам
          и по тем, по которым ещё не было напечатано уведомление. Связь также по paymentId = notify_num. */
       else
          SQL = " SELECT   NVL(utc.SUM,0) ";
          SQL = SQL + "  FROM   dpmpaym_dbt pm, ";
          SQL = SQL + "         usr_trnsf_comiss utc, ";
          SQL = SQL + "         dsfcomiss_dbt com ";
          SQL = SQL + " WHERE       pm.t_futurereceiveraccount = ? ";
          SQL = SQL + "         AND pm.t_paymentid = utc.notify_num";
          SQL = SQL + "         AND EXISTS (SELECT   1 ";
          
          /* EVG 8/08/2012 У нас же ж ВУЗ ещё, а у него нету _rur-таблицы.
          SQL = SQL + "                       FROM   usr_trnsf_notify_rur "; //RR 24.05.2012 искать нужно в рублях*/
          SQL = SQL + "                       FROM   " + DefineTable();

          SQL = SQL + "                      WHERE   payment_id = utc.notify_num) ";
          SQL = SQL + "         AND utc.comdate BETWEEN ? ";
          SQL = SQL + "                                AND  ? ";
          SQL = SQL + "         AND com.t_number  = ? ";
          SQL = SQL + "         AND com.t_feetype = 1 ";
          SQL = SQL + "         AND utc.comid = com.t_number ";
          
          //msgbox (sql, "|", sfContr.Fiid, " - ", BegDate, " - ", EndDate, " - ", sfContr.Object, " - ", sfCommNumber);
    /*
    SetOutPut("d:\\123123.txt");
    println (sql);
    println(sfContr.Object, " - ", BegDate, " - ", sfCommNumber);
    SetOutPut(null);*/

       end;
    
       cmd = rsdcommand( sql );
       cmd.AddParam("", RSDBP_IN, sfContr.Object);
       cmd.AddParam("", RSDBP_IN, BegDate);
       cmd.AddParam("", RSDBP_IN, EndDate);
       cmd.AddParam("", RSDBP_IN, sfCommNumber);
       rs = rsdRecordSet( cmd );

       while ( rs and rs.moveNext() )

          // Тариф = Сумма
          if   ( TarifType == 1 )        

             CommSum = CommSum + TarifValue;

          // Тариф = Процент
          elif ( TarifType == 2 )        

             OneOpCommSum = rs.Value(0, null, V_MONEY) * TarifValue / 100;
             if ( OneOpCommSum < MinValue )
                OneOpCommSum = MinValue;
             end;
             CommSum = CommSum + OneOpCommSum;

          end;
          
          //msgbox (TarifValue, " - ", OneOpCommSum, "|", CommSum);
       end;
    
    end;

    return CommSum;
END;

//RR 20.05.2012 Функция считает сумму списанную со счетов клиента на счета доходов банка - счета по маске 706*
MACRO GEB_GetSumFor222( account, enddate )
  var sql, rs, cmd;
  var SumOfCom = 0;
  sql =  " select nvl ( sum ( arh.t_sum ), 0 ) as sum "
+"\n         from darhdoc_dbt arh, daccount_dbt acc "
+"\n        where     acc.t_client = (select nvl ( t_client, 0 ) from daccount_dbt where t_account = ?) "
+"\n              and arh.t_account_payer = acc.t_account " 
+"\n              and arh.t_date_carry between ( select trunc ( to_date ( ? ), 'MONTH' ) from dual ) " 
+"\n                                       and  to_date ( ? ) " 
+"\n              and arh.t_chapter = 1 " 
+"\n              and arh.t_state = 0 " 
+"\n              and  substr ( arh.t_account_receiver, 1, 3 ) = '706' ";

    cmd = rsdcommand( sql );
    cmd.AddParam("", RSDBP_IN, account);
    cmd.AddParam("", RSDBP_IN, enddate);
    cmd.AddParam("", RSDBP_IN, enddate);
    rs = rsdRecordSet( cmd );
   
    if (rs and rs.movenext)
      SumOfCom = rs.value(0);
    end;
    return SumOfCom;
end;

//RR 01.06.2012 Процедура скопирована и доработана, старую не стал трогать, т.к. на нее ссылается и макрос расчета и процедура оптимизации.
MACRO GEB_GetCom34RecordSetTPTorg( Account, Origin, BegDate, EndDate, Tarif )
  var query, rs, cmd,SQL, StrNOT, StrAttrId;
  var OriginClause = "";

  if (ValType(Tarif) == V_UNDEF)
     StrAttrId = "";
     StrNot = "NOT";
  else    
     StrAttrId = " AND oc.t_attrid = "+string(Tarif);
     StrNot = "";
  end;
  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin =  "+CLB_DocOrigin;
  else
     OriginClause = " and ord.t_Origin <> "+CLB_DocOrigin;
  end;


  SQL = " SELECT   NVL(paym.t_amount, 0) ";
  SQL = SQL + "  FROM   dpmpaym_dbt paym, ";
  SQL = SQL + "         dpmrmprop_dbt prop, ";
  SQL = SQL + "         dpspayord_dbt ord, ";
  SQL = SQL + "         daccount_dbt acc ";
  SQL = SQL + " WHERE       paym.t_payeraccount = ?";
  SQL = SQL + "         AND acc.t_account = paym.t_payeraccount ";
  SQL = SQL + "         AND acc.t_chapter = paym.t_chapter ";
                        /* Кроме платежей на счета бюдж. организаций */
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
                        /* Кроме платежей на счета физ. лиц */
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT IN ('423', '426') ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 5) NOT IN ('40817', '40820', '30232') ";
                        /* Кроме платежей с перечисленными текстовками в основании */
  SQL = SQL + "         AND NOT ( REGEXP_LIKE( '\\s'||lower(prop.t_ground), '(\\sПК\\s|\\sп\\.карта|п/карта|карточный\\sсчет|\\sп/к\\s)' ) ";
  SQL = SQL + "                   OR REGEXP_LIKE ( prop.t_ground, '(40817|40820)\\d{15}' ) ";
  SQL = SQL + "                   OR REGEXP_LIKE ( prop.t_ground, '(423|426)\\d{17}' ) ";
  SQL = SQL + "                 ) ";
                               /* По regexp: \s - пробел, \. - точка */
  SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
  SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
  SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
  SQL = SQL + "         AND prop.t_shifroper <> '16' ";
  SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid ";
  SQL = SQL + "         AND EXISTS ";
  SQL = SQL + "               (SELECT /*+INDEX(arh darhdoc_dbt_idx5)*/ 1 ";
  SQL = SQL + "                  FROM   dpmdocs_dbt pmd, darhdoc_dbt arh ";
  SQL = SQL + "                 WHERE       pmd.t_paymentid = paym.t_paymentid ";
  SQL = SQL + "                         AND arh.t_applicationkey = pmd.t_applicationkey ";
  SQL = SQL + "                         AND arh.t_chapter = 1 ";
  SQL = SQL + "                         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate)+") ";
  SQL = SQL + "         AND "+StrNOT+" EXISTS ";
  SQL = SQL + "               (SELECT   1 ";
  SQL = SQL + "                  FROM   dobjatcor_dbt oc ";
  SQL = SQL + "                 WHERE       oc.t_objecttype = 501 ";
  SQL = SQL + "                         AND oc.t_groupid = 10 "+StrAttrId;
  SQL = SQL + "                         AND oc.t_object = LPAD(paym.t_paymentid, 10, 0)) " + OriginClause;

  /* EVG 23/08/2012 Доработка для исключения признака категории 200 "Категория для пакетов комиссий" */
  SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
  SQL = SQL + "                           FROM dobjatcor_dbt oc ";
  SQL = SQL + "                          WHERE     oc.t_objecttype = 3 ";
  SQL = SQL + "                                AND oc.t_groupid    = 200 ";
  SQL = SQL + "                                AND oc.t_object     = LPAD(acc.t_client, 10, 0)) ";

  cmd = rsdcommand(SQL);
  cmd.AddParam("", RSDBP_IN, Account);
  rs = rsdRecordSet(cmd);
  return rs;
  
END;

//RR 01.06.2012 Взят кусочек кода из процедуры расчета комиссий за ВК
  MACRO GEB_GetTarifInfoTPTorg( sfContr, BegDate, EndDate, sfCommNumber )
  var sql, rs, cmd;
  var TarifValue = $0, MaxValue = $0, TarifType = 0;
  var CommSum = $0, OneOpCommSum = $0;

    /* Получим значение тарифа */ 
    SQL =       "  SELECT NVL (trf.t_tarifsum / 10000, 0) tval, ";
    SQL = SQL + "         NVL (DECODE (concom.t_summin, 0, trf.t_minvalue / 10000, concom.t_summin), 0 ) minval, ";
    SQL = SQL + "         NVL (DECODE (concom.t_summax, 0, trf.t_maxvalue / 10000, concom.t_summax), 0 ) maxval, ";
    SQL = SQL + "         trf.t_tariftype ttype ";
    SQL = SQL + "  FROM   dsftarif_dbt trf, dsftarscl_dbt scl, dsfcomiss_dbt com, dsfconcom_dbt concom, ";
    SQL = SQL + "         ( SELECT   cp.t_sfplanid plId  ";
    SQL = SQL + "             FROM   dsfcontrplan_dbt cp ";
    SQL = SQL + "            WHERE   cp.t_sfcontrid = ?\n ";
    SQL = SQL + "              AND cp.t_begin = ";
    SQL = SQL + "                     (SELECT  MAX (cp.t_begin) ";
    SQL = SQL + "                        FROM  dsfcontrplan_dbt cp1 ";
    SQL = SQL + "                       WHERE  cp1.t_sfcontrid = cp.t_sfcontrid ";
    SQL = SQL + "                         AND cp.t_begin      <= ? ";
    SQL = SQL + "                     ) ";
    SQL = SQL + "         ) sfPlan "; 
    SQL = SQL + " WHERE       com.t_feetype             = 1 ";              // 1 - периодическая комиссия
    SQL = SQL + "         AND com.t_number              = ? ";              // Id комиссии
    SQL = SQL + "         AND concom.t_ObjectType       = 57 ";
    SQL = SQL + "         AND concom.t_ObjectId         = sfPlan.plId ";
    SQL = SQL + "         AND concom.t_FeeType          = com.t_feetype ";
    SQL = SQL + "         AND concom.t_CommNumber       = com.t_number ";
    SQL = SQL + "         AND scl.t_feetype             = com.t_feetype\n ";
    SQL = SQL + "         AND scl.t_commnumber          = com.t_number ";
    SQL = SQL + "         AND (scl.t_begindate BETWEEN    ? ";
    SQL = SQL + "                                  AND    ? ";
    SQL = SQL + "              OR scl.t_begindate       = TO_DATE ('01-01-0001', 'DD-MM-YYYY')) ";
    SQL = SQL + "         AND scl.t_objecttype          = 57 ";
    SQL = SQL + "         AND scl.t_objectid            = sfPlan.plId ";
    SQL = SQL + "         AND trf.t_tarsclid            = scl.t_id ";
    SQL = SQL + "         and trf.t_tariftype           = 1 "; //RR База сумма
    SQL = SQL + "         AND trf.t_basesum             = 0 ";              // Тариф с нулевой базовой суммой 

    cmd = rsdCommand( sql );
    cmd.AddParam("", RSDBP_IN, sfContr.id);
    cmd.AddParam("", RSDBP_IN, EndDate);
    cmd.AddParam("", RSDBP_IN, sfCommNumber);
    cmd.AddParam("", RSDBP_IN, BegDate);
    cmd.AddParam("", RSDBP_IN, EndDate);
    cmd.AddParam("", RSDBP_IN, BegDate);

    rs = rsdRecordSet( cmd );
    if (rs and rs.movenext())
     MaxValue = rs.value(2);
     return MaxValue;
    else
     return 0;
    end;
    
  END;
  
  //RR Также взято из CommLib'a чтобы не ломать уже работающий код
  MACRO GetCom34RecordSetTPTorg( Account, Origin, BegDate, EndDate, Tarif, ID, AnalizeTime )
  var query, rs, cmd, SQL, StrNOT, StrAttrId, rs1, cm1, BESP = "";
  var OriginClause = "";
  var DayEndTime;

  cm1 = rsdcommand("  SELECT   1 "+
  "  FROM   (  SELECT   * "+
  "              FROM   dsfcontrplan_dbt "+
  "             WHERE   T_SFCONTRID = ? AND t_sfplanid IN ("+TP_OLD+") "+
  "          ORDER BY   t_begin DESC) "+
  " WHERE   ROWNUM = 1 ");
  cm1.addparam("sf", RSDBP_IN, ID );
  cm1.execute();

  rs1 = rsdrecordset(cm1);

  if ( rs1.movenext)
     BESP =  "         AND INSTR ('ЭПТ', prop.T_PAYMENTKIND) > 0 "; //Tikh
  end;  
  
  if (ValType(Tarif) == V_UNDEF)
     StrAttrId = "";
     StrNot = "NOT";
  else    
     StrAttrId = " AND oc.t_attrid = "+string(Tarif);
     StrNot = "";
  end;
  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin =  "+CLB_DocOrigin;
  else
     OriginClause = " and ord.t_Origin <> "+CLB_DocOrigin;
  end;


  /* EVG 21/04/2011 Запрос полностью переписан для исключения EXISTS по darhdoc_dbt.
     Поддерживается возможность вызова без указания конкретного счёта. */
  debugbreak;
  SQL = " SELECT   paym.t_amount  sumDoc ";
  SQL = SQL + "  FROM  darhdoc_dbt arh,    ";
  SQL = SQL + "        dpmdocs_dbt pmd,    ";
  SQL = SQL + "        dpmpaym_dbt paym,   ";
  SQL = SQL + "        dpspayord_dbt ord,  ";
  SQL = SQL + "        dpmrmprop_dbt prop, ";
  SQL = SQL + "        daccount_dbt acc    ";
  SQL = SQL + " WHERE   arh.t_chapter = 1 ";
  SQL = SQL + "         AND arh.t_account_payer = ? ";
  SQL = SQL + "         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate);
  SQL = SQL + "         AND acc.t_account = arh.t_account_payer ";
  SQL = SQL + "         AND acc.t_chapter = arh.t_chapter ";
  SQL = SQL + "         AND acc.t_type_account NOT LIKE '%Z%' ";
  SQL = SQL + "         AND pmd.t_applicationkey = arh.t_applicationkey ";
  SQL = SQL + "         AND paym.t_paymentid = pmd.t_paymentid ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
  SQL = SQL + "         /* Кроме платежей на счета физ. лиц */ ";
  SQL = SQL + "         and ( substr ( paym.t_receiveraccount, 1, 3 ) not in ('423', '426') ";
  SQL = SQL + "            and SUBSTR(paym.t_receiveraccount, 1, 5) NOT IN ('40817', '40820') ";
  SQL = SQL + "            and not ( substr ( paym.t_receiveraccount, 1, 5 ) in ('30232', '47422')"; //RR 20.10.2011 По просьбе Байдуловой Г.В.
  SQL = SQL + "              and  ( regexp_like ( arh.t_ground, '(40817|40820|423|426)' ) ) ) ) ";//RR 26.10.2011 По просьбе Байдуловой Г.В.
  SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
  SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
  SQL = SQL + "         AND paym.t_receiverbankid NOT IN ( SELECT code.t_objectid "; //RR 10.07.2012 Теперь платежи между банками группы комиссией не облагаются
  SQL = SQL + "                                              FROM dobjcode_dbt code ";
  SQL = SQL + "                                             WHERE code.t_code IN ("+БИКиБанковГруппы+") ";
  SQL = SQL + "                                               AND code.t_codekind = 3 ";
  SQL = SQL + "                                               AND code.t_objecttype = 3) ";
  SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid ";
  SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
  SQL = SQL +           BESP;
  SQL = SQL + "         AND prop.t_shifroper <> '16' ";
  SQL = SQL +           OriginClause;
  if (( Account ) and (ValType(AnalizeTime) == V_UNDEF))
     SQL = SQL + "         AND " + StrNOT + " EXISTS ";
     SQL = SQL + "               (SELECT   1 ";
     SQL = SQL + "                  FROM   dobjatcor_dbt oc ";
     SQL = SQL + "                 WHERE       oc.t_objecttype = 501 ";
     SQL = SQL + "                         AND oc.t_groupid = 10 " + StrAttrId;
     SQL = SQL + "                         AND oc.t_object = LPAD(paym.t_paymentid, 10, 0)) ";
  elif (( Account ) and (AnalizeTime))
    DayEndTime = GetOperDayEndTime(); 
    if (AnalizeTime == 1)
     SQL = SQL + "         AND DECODE ( ";
     SQL = SQL + "         ord.t_userfield1, ";
     SQL = SQL + "         CHR (1), ";
     SQL = SQL + "         TO_DATE ('01.01.0001 01.01.01', 'dd.mm.yyyy hh24.mi.ss'), ";
     SQL = SQL + "         TO_DATE (ord.t_userfield1, 'dd.mm.yyyy hh24.mi.ss')) ";
     SQL = SQL + "          <= TO_DATE ('" + EndDate + " " + DayEndTime + "', 'dd.mm.yyyy hh24:mi:ss') ";
    elif (AnalizeTime == 2)
     SQL = SQL + "         AND DECODE ( ";
     SQL = SQL + "         ord.t_userfield1, ";
     SQL = SQL + "         CHR (1), ";
     SQL = SQL + "         TO_DATE ('01.01.0001 01.01.01', 'dd.mm.yyyy hh24.mi.ss'), ";
     SQL = SQL + "         TO_DATE (ord.t_userfield1, 'dd.mm.yyyy hh24.mi.ss')) ";
     SQL = SQL + "          > TO_DATE ('" + EndDate + " " + DayEndTime + "', 'dd.mm.yyyy hh24:mi:ss') ";
    end;
  end;
  //getstring(SQL);


/* EVG 21/04/2011
  /* EVG 21/04/2011 Доработка для возможности вызова без указания конкретного счёта
  SQL = " SELECT   COUNT(paym.t_paymentid), SUM(paym.t_amount) ";*/
  SQL = " SELECT   " + selectClause;
  SQL = SQL + "  FROM  dpmpaym_dbt paym,   ";
  SQL = SQL + "        dpspayord_dbt ord,  ";
  SQL = SQL + "        dpmrmprop_dbt prop, ";
  SQL = SQL + "        daccount_dbt acc    ";
  /* EVG 21/04/2011 Доработка для возможности вызова без указания конкретного счёта
  SQL = SQL + " WHERE       paym.t_payeraccount = ?";*/
  SQL = SQL + " WHERE       " + fixAccountClause;
  SQL = SQL + "             acc.t_account = paym.t_payeraccount ";
  SQL = SQL + "         AND acc.t_chapter = paym.t_chapter ";
  SQL = SQL + "         AND acc.t_type_account NOT LIKE '%Z%' ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
  SQL = SQL + "         /* Кроме платежей на счета физ. лиц */ ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT IN ('423', '426') ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 5) NOT IN ";
  SQL = SQL + "                  ('40817', '40820', '30232') ";
  SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
  SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
  SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid ";
  SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
  SQL = SQL +           BESP;
  SQL = SQL + "         AND prop.t_shifroper <> '16' ";
  SQL = SQL + "         AND EXISTS ";
  SQL = SQL + "               (SELECT /*+INDEX(arh darhdoc_dbt_idx5)*/ 1 ";
  SQL = SQL + "                  FROM   dpmdocs_dbt pmd, darhdoc_dbt arh ";
  SQL = SQL + "                 WHERE       pmd.t_paymentid = paym.t_paymentid ";
  SQL = SQL + "                         AND arh.t_applicationkey = pmd.t_applicationkey ";
  SQL = SQL + "                         AND arh.t_chapter = 1 ";
  SQL = SQL + "                         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate)+") ";

  /* EVG 21/04/2011 Проверка категории осуществляется только при вызове по конкретному счёту */
  if ( Account )
     SQL = SQL + "         AND "+StrNOT+" EXISTS ";
     SQL = SQL + "               (SELECT   1 ";
     SQL = SQL + "                  FROM   dobjatcor_dbt oc ";
     SQL = SQL + "                 WHERE       oc.t_objecttype = 501 ";
     SQL = SQL + "                         AND oc.t_groupid = 10 "+StrAttrId;
     SQL = SQL + "                         AND oc.t_object = LPAD(paym.t_paymentid, 10, 0)) ";
  end;

  SQL = SQL + OriginClause;
*/

  cmd = null;
  cmd = rsdcommand( SQL );

  //debugbreak;
  /* EVG 21/04/2011 Передача параметра только при вызове по конкретному счёту */
  if ( Account )
     cmd.AddParam( "acc", RSDBP_IN );
     cmd.Value( "acc" ) = Account;
     cmd.Execute();
     /* Возвращаем rsdRecordSet(), т.к. необходима передача параметра, а TRsbDataSet() отказывается
        работать в вызывающем модуле - видимо из-за того, что cmd туда не передаётся. */
     rs = rsdRecordSet( cmd );
  else
     /* EVG Нужно возвращать TRsbDataSet() из-за специфики обработки в вызывающем модуле */
     rs = TRsbDataSet( sql );
  end;


  return rs;
END;
