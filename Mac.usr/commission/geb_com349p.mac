/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   EVG Банк "Газэнергобанк" (ГЭБ)

       Макрос пользовательского алгоритма расчёта базовых сумм комиссии 3.4.9
       "Прочие платежи в пользу физического лица по системе <Интерет-Клиент> и
        на бумажных носителях, за исключением: - платежей на заработную плату и 
        приравненных к ней выплатам;- алиментов;- кредитных ресурсов".

       Тип комиссии - периодическая.

       ChangeLog:
    //joy 27.09.2012 I-00259284-2 Жаворонкова Н. joy Привела условия взимания в соответствие с ТЗ
    //RR 20.02.2014 Адаптирую под 2031(darhdoc_dbt -> dacctrn_dbt)
    //joy 21.05.2014 R-378178 В одной из \\sпк.№.\\d{4}.\\d{4}.\\d{4}.\\d{4}\\s убрана точка в конце
    //joy 14.11.2014 I-00532241 в 2031 обязательно надо проверять, что t_state в проводках = 1
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/



import sfinter, ctinter, cb_sql, globals;

/*
    Если при расчете произошла ошибка, поместить в эту переменную ненулевое значение
*/
var MacroError :integer = 0;
private var FICode_calc:string = "";

  /* Тип величины
enum SfBaseTypes{*/
private const   SF_BASETYPE_SUM     = 1;      /* Сумма*/
private const   SF_BASETYPE_QUONT   = 2;      /* Количество*/

private const NATCUR = 0;
record sfbassum( "sfbassum.str" );
record paym(pmpaym);

//RR Из название переменной все ясно
//private var БИКиБанковГруппы = "044525986, 046311808, 046577781, 042908701, 044583859, 040702756, 042007755, 047308902, 041806835, 046577859";

/*
    Расчет для периодических комиссий
*/
/* EVG Добавил приём структуры sfcontr для вызова из макроса sfacrpay.mac */
macro CalcServiceSum( sfcontr_addr/*Договор обслуживания*/, BeginDate/*Начало периода*/, EndDate/*Конец периода*/,
      sAddr /* EVG Какой-то ещё адрес */, sfcontrStruc /*Cтруктура sfcontr*/ )
    record sfcontr( sfcontr );
    var SQL, rs, cmd, stat;
    var CommQuont   = 0,
        CommSum     = $0;

    /* EVG При вызове из sfacrpay.mac используем полученную структуру sfcontrStruc вместо адреса sfcontr_addr */
    if ( ValType (sfcontr_addr) != V_UNDEF )
       SetBuff( sfcontr, sfcontr_addr );
    else
       Copy ( sfcontr, sfcontrStruc );
    end;
    SQL = " SELECT NVL( SUM( PAYM.T_AMOUNT ), 0 ) ";
    SQL = SQL + "  FROM   DPmPaym_dbt paym, dpmrmprop_dbt rm ";
    SQL = SQL + " WHERE       paym.t_PayerAccount = ? ";
    SQL = SQL + "         AND paym.t_PaymStatus = 32000 ";                                                      // Только закрытые
    SQL = SQL + "         AND rm.t_paymentid = paym.t_paymentid ";
    /*27-09-2012 I-00259284-2 joy Проверка всех ислючений перенесена в начало */
    SQL = SQL + "         AND SUBSTR (paym.t_ReceiverAccount, 1, 3) NOT BETWEEN '401' AND '404' ";              // Кроме бюджетных платежей
    SQL = SQL + "         AND NOT REGEXP_LIKE  ('\\s' || LOWER (rm.t_ground), '(зар\\.плата|зарплат[а-я]|з/п|\\sзп\\s|з\\.п|кредит[а-я]|аванс|пособие|стипенд[а-я][а-я])') ";      // 4. Нет текста в назначении
    SQL = SQL + "         AND NOT REGEXP_LIKE  ( LOWER (rm.t_ground), 'заработн[а-я][а-я]\\sплат[а-я]' ) "; 
    /* EVG 27/07/2012 Добавлены исключения беременност*(любое окончание), пособия (по просьбе Давида Акобия) */
    /* joy 15.11.2013 R-284781 Добавлено алимент* (по изначальному ТЗ было, потом пропало почему-то)         */
    SQL = SQL + "         AND NOT REGEXP_LIKE  ( LOWER (rm.t_ground), 'беременност|алимент|пособия' ) ";
    /*27-9-2012 joy end */
    /* Счёт плательщика - счёт юр. лица  - Условие А из ТЗ*/
    SQL = SQL + "         AND (SUBSTR (paym.t_PayerAccount, 1, 3) BETWEEN '405' AND '407' ";
    SQL = SQL + "              OR SUBSTR (paym.t_PayerAccount, 1, 5) IN ('40807', '40802')) ";
    /*Кончилось условие А*/
    /* Из ТЗ: условия взимания такие A+B or A+C or A+D, поэтому: A and (B or C or D). Начало проверки:*/
    SQL = SQL + "         AND ( ";     
   /* Счёт получателя - счёт физ. лица - Условие B из ТЗ*/
    SQL = SQL + "                   SUBSTR (paym.t_ReceiverAccount, 1, 3) IN ('423', '426') ";
    SQL = SQL + "                   OR SUBSTR (paym.t_ReceiverAccount, 1, 5) IN ('40817', '40820', '30232') ";
    /*Кончилось условие В*/
    /* Проверки назначения платежа  - Условие С*/
    SQL = SQL + "                OR (   REGEXP_LIKE (rm.t_ground, '(40817|40820)\\d{15}') ";                                                                    // 1. Есть счета 40817 / 40820 / 30232 в назначении
    SQL = SQL + "                       OR REGEXP_LIKE (rm.t_ground, '(423|426)\\d{17}') ";                                                                        // 2. Есть счета 423 - 426 в назначении
    SQL = SQL + "                       OR REGEXP_LIKE ('\\s' || LOWER (rm.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sп/к\\s)') ";                      // 3. Есть текст в назначении
    SQL = SQL + "                       OR REGEXP_LIKE ('\\s' || LOWER (rm.t_ground), '(\\sпк.№\\d{12}\\s|\\sпк|№\\d{12}\\s|\\sпк.№\\d{4}.\\d{4}.\\d{4}.\\d{4}.\\s|\\sпк.№.\\d{4}.\\d{4}.\\d{4}.\\d{4}\\s)')  ";//RR 22.08.2012
    SQL = SQL + "                       OR REGEXP_LIKE ('\\s' || LOWER (rm.t_ground), '(\\sбк.№\\d{12}\\s|\\sбк|№\\d{12}\\s|\\sбк.№\\d{4}.\\d{4}.\\d{4}.\\d{4}.\\s|\\sбк.№.\\d{4}.\\d{4}.\\d{4}.\\d{4}\\s)')) ";//по заявке I-00239812-2
    /*Кончилось условие С*/
                               /* По regexp: \s - пробел, \. - точка */
   /*Условие D из ТЗ*/
    SQL = SQL + "                OR (   SUBSTR (paym.t_ReceiverAccount, 1, 5) = '30301' ";
    SQL = SQL + "                       and REGEXP_LIKE (rm.t_ground, '(40817810|42301810)\\d{12}'))";
   /*Кончилось условие D*/
    SQL = SQL + "              )";
    /* Кончилась проверка на выполнение условий A and (B or C or D)*/
    SQL = SQL + "         AND paym.t_ReceiverBankID <> ? ";
    //SQL = SQL + "         AND paym.t_receiverbankid NOT IN ( SELECT code.t_objectid "; //RR 10.07.2012 Теперь платежи между банками группы комиссией не облагаются
    //SQL = SQL + "                                              FROM dobjcode_dbt code ";
    //SQL = SQL + "                                             WHERE code.t_code IN ("+БИКиБанковГруппы+") ";
    //SQL = SQL + "                                               AND code.t_codekind = 3 ";
    //SQL = SQL + "                                               AND code.t_objecttype = 3) ";
    SQL = SQL + "         AND EXISTS ";
    SQL = SQL + "               (SELECT ARH.T_ACCTRNID ";
    SQL = SQL + "                  FROM   dacctrn_dbt arh, dpmdocs_dbt pmd ";
    SQL = SQL + "                 WHERE       ARH.T_ACCTRNID = PMD.T_ACCTRNID ";
    /*Чесноков Д.С. Отзывы с К2 проверим по наличию балансовой проводки.
                    Во всех других случаях по идее нас тоже интересуют только балансовые проводки */
    SQL = SQL + "                         AND arh.t_chapter = 1 ";
    SQL = SQL + "                         AND arh.t_state = 1 ";
    SQL = SQL + "                         AND pmd.t_paymentid = paym.t_paymentid ";
    SQL = SQL + "                         AND arh.t_date_carry BETWEEN ? ";
    SQL = SQL + "                                                  AND ?) ";

    debugbreak;
    /*
    setoutput("d:\\12345.txt");
    println (SQL);
    println (sfcontr.Object, " - ", {OurBank}, " - ", BeginDate);
    setoutput(null);*/
    
    cmd = rsdcommand(SQL);
    cmd.AddParam("", RSDBP_IN, sfcontr.Object);
    cmd.AddParam("", RSDBP_IN, {OurBank});
    cmd.AddParam("", RSDBP_IN, BeginDate);
    cmd.AddParam("", RSDBP_IN, EndDate);
    rs = rsdRecordSet( cmd );
    
    if (rs and rs.moveNext())
       CommSum = rs.Value (0, null, V_MONEY);
    end;
    //msgbox (CommSum);

    
    /* EVG При вызове из sfacrpay.mac возвращаем true в случае положительного результата расчёта */
    if ( ValType (sfcontrStruc) != V_UNDEF )
       if (CommSum > 0)
          return true;
       end;
       return false;
    end;

    
    ClearRecord(sfbassum);

    sfbassum.baseType    = SF_BASETYPE_SUM;
    sfbassum.baseSum     = CommSum;

    sfbassum.baseType2   = SF_BASETYPE_SUM;
    sfbassum.baseSum2    = CommSum;

    stat = InsertSumList(sfbassum);

    if( stat )
      MsgBox("Ошибка при вставке базовой суммы");
    end;

    
end;/*CalcServiceSum*/
