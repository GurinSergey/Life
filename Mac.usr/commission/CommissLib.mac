/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ███████       █████      █████     ███
    █████████   ████████   ████████    ███
    ███   ███   ███        ███         ███
    ████████     ███████    ███████    ███
    ██████            ███        ███   ███
    ███ ████    █████████  █████████   ████████
    ███   ████    █████      █████     ████████

   R-Style Softlab
   
   EVG Библиотека общих функций, используемых при расчёте комиссий.
   
   ChangeLog:
  
  //RR 24.05.2012 добавил отладочный кусок кода 
  //RR 05.06.2012 Добавли функцию GetAccountsRecordSetPRBBB
  //joy 19.06.2012 Жаворонкова Н. I-00188424-2 Исправление в определении остатка по валютным счетам, при наличии К2 по рублевым (для освобождения 
                   от уплаты 2.2.0)
  //RR 20.06.2012 Добавил кусок отладочного кода
  //RR 02.07.2012 Для ЭВ добавляю 1 комиссию
  //RR 10.07.2012 Внес коррективы в GetCom34RecordSetB и GetComToPhisFacesRecordSet платежи внутри банков группы комиссией не облагаются
  //RR 03.08.2012 Внес доработки в GetComToPhisFacesRecordSet теперь часть комиссий не учитывают доработку на платежи внутри банков групп
  //Гуцу Е. 13.08.2012 Перенёс с теста доработку GetCom34RecordSetB(), исключающую из расчёта комиссий 3.4.* платежи на клиентов, которым подключены 
                  пакеты платежей (заявка C-11436-7).
  //RR 21.09.2012 Исправил проверку на ТП в функции CheckClientRegistration
  //RR 24.09.2012 Еще раз изменил алгоритм проверки на ТП для ПРББ и ЭВ в функции CheckClientRegistration
  //RR 24.09.2012 Исключил счета покрытия из выборки в CheckArrested_New
  //RR 28.09.2012 по заявке I-00260157-2 убрал проверку на "срочность" из GetCom34RecordSetB
  //RR 26.10.2012 Изменеия по заявке С-6889
  //Гуцу Е. 7.11.2012 Добавлены функции GetTarifInfo(), CountPayments(), CollectPaymentsInformation() и класс PaymentsInfo() в рамках реализации 
                      заявки C-15081.
  //Гуцу Е.15.11.2012 Скорректировал функцию Cash_CalcSymbSum_Period() для возможности обработки кассовых документов по всем счетам клиента (для 
                      комиссий, реализованных в рамках заявки C-15081).
  //RR 26.10.2012 Добавлена CheckCatOnAcc по заявке С-6889
  //Гуцу Е. 30/11/2012 Доработка функции GetComCurrencyControlSum() по заявке C-15790 - расчёт комиссии за валютный контроль по методике банка ГЭБ 
                      (наложение min/max сумм на каждый платёж).
  //Гуцу Е. 12.12.2012 Доработка функции GetCom34RecordSetB(), исключающая из расчёта комиссий 3.4.* платежи на клиентов, которым подключено пакетное 
                       предложение ДКБ (заявка C-15795).
  //Гуцу Е. 12.12.2012 Доработка функции GetComToPhisFacesRecordSet(), исключающая из расчёта комиссий 3.4.* платежи на клиентов, которым подключено 
                       пакетное предложение ДКБ (заявка C-15795).
  //Гуцу Е. 12.12.2012 Доработка функции GetCom37RecordSetB(), исключающая из расчёта комиссий 3.4.* платежи на клиентов, которым подключено пакетное 
                       предложение ДКБ (заявка C-15795).
  //Гуцу Е. 12.12.2012 Доработка функции GetCom34_11_18RecordSet(), исключающая из расчёта комиссий 3.4.* платежи на клиентов, которым подключено 
                       пакетное предложение ДКБ (заявка C-15795).
  //Гуцу Е. 15.01.2013 Добавлена функция CheckTurnover_ForTP() - перенесена из макроса расчёта комиссии 2.2.0 com220p_new.mac (заявка C-16619).
  //Гуцу Е. 15.01.2013 Поправил тип данных переменной MaxValue в функции GetTarifInfo() (V_INTEGER -> V_MONEY).
  //Гуцу Е. 24.01.2013 Функция GetCom37RecordSetB() модифицирована для возможности использования в процедуре подключения комиссий.
  //RR 25.01.2013 Добавил проверку в TurnOff_MonthCom_WhereYearComIsOn и TurnOff_AllButOne для исправления I-00316461-3
  //RR 05.02.2013 Исправил CC_ARM_Commiss_EventHandler для устранения ошибок при списании комиссий за ВК
  //RR 06.02.2013 Изменил механизм работы CheckTP добавил возможности вызова с передачей списка ТП
  //RR 11.02.2013 Перенес проверку из макроса расчета com221p.mac сюда под названием CheckForYearComiss
  //RR 13.02.2013 Гуцу Е. изменил параметризацию для вызова GetCom37RecordSetB и забыл об это написать - пишу за него.
  //RR 15.02.2013 Перенес проверку на FullPay из макросов расчета, CheckFullPay
  //RR 18.02.2013 Перенес проверку пользовательского поля1 из макроса, наименование функции CheckUserField1
  //RR 19.02.2013 Перенес проверку из макросов расчета единовременных комиссий 5.5.X, наименование функции Get55RecordSet                                                                                                  
  //Гуцу Е. 18.02.2013 Доработка функции CollectPaymentsInformation(): подсчёт количества платежей ведётся с даты подключения ТП, если она больше 
                       даты начала текущего месяца (заявка C-17591).
  //Гуцу Е. 19.02.2013 Доработка функции Cash_CalcSymbSum_Period(): подсчёт кассовых оборотов для пакетных ТП ведётся с даты подключения ТП, если она 
                       больше даты начала текущего месяца (заявка C-17591).
  //joy 25.03.2013 Жаворонкова Н.  I-00346365-2  В  GetTarifInfo добавила поиск наибольшей даты начала действия тарифной сетки  
  //joy 28.03.2013 Жаворонкова Н. I-00348185-2 В ф-ции Cash_IsProperCommission для ВУЗа исправлено Tarif 5.2.7 MIN на VuzTarif 5.2.7 MIN
  //joy 01.04.2013 Жаворонкова Н. C-18667 Поиск категорий в CheckCatOnAcc переписан так, чтобы не привязывать к названиям признаков категорий 
  //joy 19.04.2013 Жаворонкова Н. I-00346365-2 В  GetTarifInfo добавила локализацию по типу и ИД объекта
  //Гуцу Е. 22/04/2013 Для функции GetCom34RecordSetB() добавлен новый параметр ReturnUnsummarizedRecordset - указание функции возвращать не 
                      COUNT/SUM, а каждый документ отдельно (заявка C-19221, п. 1.1).
  //Гуцу Е. 24/04/2013 Для функции Cash_CalcSymbSum_Period() добавил приём параметра IncOrder - признак вызова для приходных документов 
                      (заявка C-19221, п. 2).
  //Гуцу Е.  6/05/2013 Реализована функция GetTarifInfo3EbeneTarifbildung(). Функция возвращает данные о тарифе комиссии при использовании 
                       3-уровневой тарификации комиссий (заявка C-19221, п. 1.2).
  //Гуцу Е.  6/05/2013 Функция CollectPaymentsInformation() доработана для возможности работы с комиссиями, настроенными по 3-уровневой тарификации 
                      (заявка C-19221, п. 1.2).
  //VV 29.04.2013 C-19666 Внесение изм. в экранную панель в RS-V6, в АРМ-позиционера, при прохождении операций шага ВК
  //RR 17.05.2013 Внесены коррективы в TurnOff_AllButOne
  //joy 05.06.2013 Жаворонкова Н. R-199745-2  В CheckClientRegistration нестрогое неравноство (< 6 ---> <= 6)
  //joy 29.07.2013 Жаворонкова Н. R-221409-2 Добавлена функция CheckPreviousUPK
  //Гуцу Е. 12/08/2013 Отключена доработка функции Cash_CalcSymbSum_Period(), выполненная по заявке C-17591. Реализована обработка в этой функции 
                       входящего параметра с датой начала периода анализа оборотов для того, чтобы логику перенести в вызывающий модуль.
  //joy 21.08.2013 Жаворонкова Н. R-234873-2 joy В CheckPreviousUPK добавлена проверка статуса УПК "К оплате"
  //joy 26.08.2013 C-21117 Добавлен поиск  авансовых комиссий 2.2.3 и 2.2.4
  //joy 04.09.2013 joy R-242733-2 + согласовано с Петренко О. в GetTarifInfo убрала проверку на то, что тариф должен быть больше 0
  //RR 23.09.2013 Исправил CheckYearCom поиск УПК нужно производить по всем счетам клиента.
  //joy 07.10.2013 I-00431329 Внесены исправления в CheckArrested_New: RestSimple определяем на текущую дату
  //KS 22.11.2013 Не адаптирован!!! После адаптации убрать мой коммент и внести свой
  //RR 17.12.2013 Частично адаптировал, добавил утрерянную константу TypeCover, устранив ошибку компиляции.
  //joy 30.01.2014 I-00454531 Перенос модификации от 25.11.2013 C-23416 Добавлены параметры в Cash_CalcSymbSum_Period: можно искать чеки за 1 день, 
                              ИД клиента передается 
  //RR 04.02.2014 Адаптировал CheckArrested, CheckIndex2, ПроверитьОстатокСумм(в связи с тем что таблица daccount_dbt изменилась)
  //joy 05.02.2014 Перенос модифкации от 11.12.2013  С-25038+R-308819 Для новых комиссий по счетам на оплату изменена функция 
                   CollectPaymentsInformation и добавлена CountPaymentsForInvoiceIBank
  //joy 10.02.2014 R-326063 Адаптация поиска тарифов (GetTarifInfo*)
  //RR 13.02.2014 Доадаптирую недоадаптированную GetCom34_11_18RecordSet
  //RR 19.02.2014 Адаптирую под 2031(darhdoc_dbt -> dacctrn_dbt)
  //RR 20.02.2014 Отключаю ПроверитьОстатокСумм для того чтобы проверить ее использование
  //RR 30.04.2014 Исправил ошибки падения CheckOborot
  //RR 13.05.2014 Убрал из GetCom37RecordSet'ов ссылки на неподключенную таблицу dpspayord_dbt
  //RR 14.05.2013 Изменил основной рекордсет Cash_CalcSymbSum_Period
  //joy 10.06.2014 R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е) добавлено t_state = 1 для таблицы проводок
  //RR 17.06.2014 Внесены правки в CollectPaymentsInformation и GetCom34RecordSetB() с целью исключения некоторых платежей для банка Солидарность
  //joy 15.08.2014 Жаворонкова Н. C-31392 Добавлена ф-ция GetComToPhisFacesRecordSet_new, в нескольких ф-циях по отбору платежей добавлены исключения на платежи на счета ФЛ
  //joy 10.10.2014 R-469873 добавлена маска счета  30232810?????08****7 в GetComToPhisFacesRecordSet_new
  //joy 08.10.2014  C-33886 по шифрам операции 06 и 02 комиссия за платежи берется и с платежей на физ.лиц
  //joy 30.10.2014 Перенос нового ТЗ по C-33886 (для ЭВ)
  //joy 14.11.2014 I-00532241 в 2031 обязательно надо проверять, что t_state в проводках = 1
  //joy 17.11.2014 Адаптация для 2031 CheckArrested_New
  //joy 30.12.2014  R-523619-1 GetComToPhisFacesRecordSet_new только рублевые платежи
  //joy 21.09.2015 I-00580449 в GetCom34_11_18RecordSet добавлена проверка что t_state = 1 (чтобы избежать дублирования проводок)
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

IMPORT FIInter, CTInter, CurrInter, Cb_SQL, Pm_Note, op_lib, fg_Life_parm, RsbDataSet, lib_str, lib_const;
import lib_comiss_common;

CONST CURRKIND_America  = 0,
      CURRKIND_Europe   = 1,
      CURRKIND_CIS      = 2,
      CURRKIND_Other    = 99;

CONST CHARGESKIND_Our   = 0,
      CHARGESKIND_Sha   = 1,
      CHARGESKIND_Ben   = 2,
      CHARGESKIND_Other = 99;

CONST FORMKIND_MT103    = 0,
      FORMKIND_MT200    = 1,
      FORMKIND_MT202    = 2,
      FORMKIND_Other    = 99;

CONST PMORIGIN_Paymnts  = 0,
      PMORIGIN_Other    = 99;

CONST NOTEKIND_RSPMMESSAGE = 122;

CONST PMGROUP_Internal  = 0,
      PMGROUP_External  = 1;

CONST CLB_DocOrigin = 2;

//CONST TP_OLD = "6, 2, 7, 8, 3, 26, 60, 97, 94";
CONST TP_OLD = "73, 74, 12, 9, 24, 10, 11, 61, 72, 70, 4, 5, 27";

/* EVG 29.10.2009 Отдельных вилок для ДМСБ больше нет.
CONST {Tarif 5.2.3 Common MIN} = $0,
      {Tarif 5.2.3 Common MAX} = $99999,
      {Tarif 5.2.3 Dmsb MIN}   = $0,
      {Tarif 5.2.3 Dmsb MAX}   = $299999,
      {Tarif 5.2.4 Common MIN} = $100000,
      {Tarif 5.2.4 Common MAX} = $599999,
      {Tarif 5.2.4 Dmsb MIN}   = $300000,
      {Tarif 5.2.4 Dmsb MAX}   = $599999;
*/
CONST {Tarif 5.2.3 MIN} =       $0,
      {Tarif 5.2.3 MAX} =  $100000,
      {Tarif 5.2.4 MIN} =  $100001,
      {Tarif 5.2.4 MAX} =  $300000,
      {Tarif 5.2.5 MIN} =  $300001,
      {Tarif 5.2.5 MAX} =  $600000,
      {Tarif 5.2.6 MIN} =  $600001,
      {Tarif 5.2.6 MAX} = $1000000,
      {Tarif 5.2.7 MIN} = $1000001,
      {Tarif 5.2.7 MAX} = $3000000,
      {Tarif 5.2.8 MIN} = $3000001;
      
CONST {VuzTarif 5.2.2 MIN} =       $0,
      {VuzTarif 5.2.2 MAX} =  $100000,
      {VuzTarif 5.2.3 MIN} =  $100001,
      {VuzTarif 5.2.3 MAX} =  $300000,
      {VuzTarif 5.2.4 MIN} =  $300001,
      {VuzTarif 5.2.4 MAX} =  $600000,
      {VuzTarif 5.2.5 MIN} =  $600001,
      {VuzTarif 5.2.5 MAX} = $1000000,
      {VuzTarif 5.2.6 MIN} = $1000001,
      {VuzTarif 5.2.6 MAX} = $3000000,
      {VuzTarif 5.2.7 MIN} = $3000001;
//RR Из название переменной все ясно
//private var БИКиБанковГруппы = "044525986, 046311808, 046577781, 042908701, 044583859, 040702756, 042007755, 044525732, 041806835, 043601706, 042406718, 046577859"; // joy 15.08.2014 добавляю недостающие БИКи
private var БИКиБанковГруппы = getBICsBanks();
private var LifeBank = fg_life_subject({OurBank});

PRIVATE CONST SovComAccounts = "'40817810501000000555', '70601810401002790204', '70601810201002790310'";

// EVG 25/5/2016 Изменился БИК московского филиала Совкомбанка.
// PRIVATE CONST SovComBIC = "044583967";
PRIVATE CONST SovComBIC    = "044525967";

/* EVG 10/3/2016 Вообще-то 044583967 - БИК московского филиала Совкомбанка.
   БИК ГО Совкомбанка (костромского) - 043469743. Добавил отдельную константу. */
/* EVG 18/3/2016 Комиссии по з/п проекту принято решение взимать за платежи в адрес
   филиала "Центральный" Совкомбанка. Так как необходимости вести БИКи всех филиалов
   для комиссий нет, указываем его в уже имеющейся константе. Если всё-таки появится 
   необходимость диверсифицировать комиссии по филиалам,добавим / поправим константы
   и скорректируем все ссылающиеся макросы.
CONST BIC_SOVCOMBANK = "043469743";*/
/* EVG 21/3/2016 Всё-таки настал этот момент. Нужен и БИК ГО, и БИК филиала Центральный.
   Делаем отдельные константы.
CONST BIC_SOVCOMBANK = "045003848";*/
CONST BIC_SOVCOMBANK_HEAD_COSTROMA   = "043469743";
CONST BIC_SOVCOMBANK_BRANCH_CENTRAL  = "045003848";
CONST BIC_SOVCOMBANK_BRANCH_BUSINESS = "044525058";
//  EVG 26/4/2016 Добавил третий филиал - "Бизнес"

CONST ZP_PRJ_GROUND  = "зарплатный проект базовый";



VAR Currencies_Europe = TArray(),
    Currencies_CIS    = TArray();

   // Валюты стран ЕЭС
   Currencies_Europe(0) = 56;           Currencies_Europe(9)  = 616;         Currencies_Europe(19) = 233;
   Currencies_Europe(1) = 276;          Currencies_Europe(10) = 620;         Currencies_Europe(20) = 978;
   Currencies_Europe(2) = 280;          Currencies_Europe(12) = 724;
   Currencies_Europe(3) = 380;          Currencies_Europe(13) = 40;
   Currencies_Europe(4) = 528;          Currencies_Europe(14) = 246;
   Currencies_Europe(5) = 250;          Currencies_Europe(15) = 752;
   Currencies_Europe(6) = 826;          Currencies_Europe(16) = 196;
   Currencies_Europe(7) = 208;          Currencies_Europe(17) = 428;
   Currencies_Europe(8) = 372;          Currencies_Europe(18) = 440;
                    

   // Валюты стран СНГ
   Currencies_CIS(0) = 112;         Currencies_CIS(2) = 498;         Currencies_CIS(4) = 860;
   Currencies_CIS(1) = 980;         Currencies_CIS(3) = 398;


/*
                         Тарифные планы ДМСБ
┌───────┬─────────────────────────┬────────────────┬────────────────┬───────────────────┐
│Номер  │Наименование             │Локализация     │Дата начала     │Дата окончания     │
├───────┼─────────────────────────┼────────────────┼────────────────┼───────────────────┤
│      0│Стартовый (регионы)      │Общая           │01.08.2009      │00.00.0000         │
│      4│ДМСБ Оптимальный № 1     │Общая           │01.01.2008      │00.00.0000         │
│      5│ДМСБ Оптимальный № 3     │Общая           │01.01.2008      │00.00.0000         │
│      9│Персональный № 6         │Общая           │01.01.2008      │00.00.0000         │
│     10│Персональный № 7         │Общая           │01.01.2008      │00.00.0000         │
│     11│Персональный № 8         │Общая           │01.01.2008      │00.00.0000         │
│     12│Персональный № 9         │Общая           │01.01.2008      │00.00.0000         │
│     27│ДМСБ Оптимальный № 2     │Общая           │01.01.2008      │00.00.0000         │
│     59│Персональный (регионы)   │Общая           │01.08.2009      │00.00.0000         │
│     61│Дистанционный (регионы)  │Общая           │01.08.2009      │00.00.0000         │
│     62│Стартовый                │Общая           │01.08.2009      │00.00.0000         │
│     63│Дистанционный            │Общая           │01.08.2009      │00.00.0000         │
└───────┴─────────────────────────┴────────────────┴────────────────┴───────────────────┘

*/
VAR SFPlans_Dmsb = TArray();

   SFPlans_Dmsb(0) = 0;           SFPlans_Dmsb(6)  = 12;
   SFPlans_Dmsb(1) = 4;           SFPlans_Dmsb(7)  = 27;
   SFPlans_Dmsb(2) = 5;           SFPlans_Dmsb(8)  = 59;
   SFPlans_Dmsb(3) = 9;           SFPlans_Dmsb(9)  = 61;
   SFPlans_Dmsb(4) = 10;          SFPlans_Dmsb(10) = 62;
   SFPlans_Dmsb(5) = 11;          SFPlans_Dmsb(11) = 63;


//RR 02.07.2012 Для ЭВ добавляю 1 комиссию
VAR BENeficiaryCom = TArray();
    BENeficiaryCom(0) = 1100;    // 3.4.3v (Перевод средств в пользу клиентов других банков, принятый к исполнению до 13-00 часов текущего дня с оговоркой "все комиссии и расходы отнести на счет бенефициара")
    BENeficiaryCom(1) = 1101;    // 3.5.3v (Перевод средств в пользу клиентов других банков, принятый к исполнению после 13-00 часов текущего дня с оговоркой "все комиссии и расходы отнести на счет бенефициара")

    /* EVG Комиссии банков также могут оплачиваться за счёт бенефициара */
    BENeficiaryCom(2)  = 1063;    // Банк_3.1.1v (Зачисления средств в любой иностранной валюте на корреспондентские счета банков-корреспондентов от нерезидентов РФ,  зарегистрированных согласно Приложению № 1 к настоящим Тарифам.)
    BENeficiaryCom(3)  = 1064;    // Банк_3.1.2v (Зачисление поступивших средств на счета корреспондентов в АКБ "Пробизнесбанк"- прочие зачисления)
    BENeficiaryCom(4)  = 1065;    // Банк_3.2.0v (Переводы средств по поручению банков-корреспондентов в пользу бенефициаров, имеющих счета в АКБ "Пробизнесбанк")
    BENeficiaryCom(5)  = 1066;    // Банк_3.3.1v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет перевододателя":     - межбанковские переводы)
    BENeficiaryCom(6)  = 1067;    // Банк_3.3.2v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет перевододателя": - переводы в пользу небанковских организаций)
    BENeficiaryCom(7)  = 1068;    // Банк_3.3.3v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет перевододателя":- переводы, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(8)  = 1069;    // Банк_3.4.1v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет бенефициара":  - межбанковские переводы)
    BENeficiaryCom(9)  = 1070;    // Банк_3.4.2v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет бенефициара": - переводы в пользу небанковских организаций)
    BENeficiaryCom(10) = 1071;    // Банк_3.4.3v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет бенефициара": - переводы, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(11) = 1072;    // Банк_3.5.1v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "комиссии и расходы АКБ "Пробизнесбанка" за счет перевододателя, комиссии и расходы других банков за счет бенефициара":  - межбанковские переводы)
    BENeficiaryCom(12) = 1073;    // Банк_3.5.2v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "комиссии и расходы АКБ "Пробизнесбанка" за счет перевододателя, комиссии и расходы других банков за счет бенефициара": - переводы в пользу небанковских организаций)
    BENeficiaryCom(13) = 1074;    // Банк_3.5.3v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "комиссии и расходы АКБ "Пробизнесбанка" за счет перевододателя, комиссии и расходы других банков за счет бенефициара": - переводы, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(14) = 1075;    // Банк_3.7.1v (Переводы  средств в ЕВРО и валютах стран Европейского Валютного Союза (межбанковские переводы): - по п.п. 3.3 и 3.5 платежных инструкций)
    BENeficiaryCom(15) = 1076;    // Банк_3.7.2v (Переводы  средств в ЕВРО и валютах стран Европейского Валютного Союза (межбанковские переводы):  - по п. 3.4 платежных инструкций)
    BENeficiaryCom(16) = 1077;    // Банк_3.8.1v (Переводы  средств в ЕВРО и валютах стран Европейского Валютного Союза переводы в пользу небанковских организаций): - по п.п. 3.3 и 3.5 платежных инструкций)
    BENeficiaryCom(17) = 1078;    // Банк_3.8.2v (Переводы  средств в ЕВРО и валютах стран Европейского Валютного Союза переводы в пользу небанковских организаций): - по п. 3.4 платежных инструкций)
    BENeficiaryCom(18) = 1079;    // Банк_3.8.3v (Переводы  средств в ЕВРО и валютах стран Европейского Валютного Союза переводы в пользу небанковских организаций): - переводы по п.п. 3.3 и 3.5 платежных инструкций, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(19) = 1080;    // Банк_3.8.4v (Переводы  средств в ЕВРО и валютах стран Европейского Валютного Союза переводы в пользу небанковских организаций):- переводы по п.3.4 платежных инструкций, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(20) = 1081;    // Банк_3.9.1v (Переводы  средств в других свободно конвертируемых валютах (межбанковские переводы): - по п.п. 3.3 и 3.5 платежных инструкций)
    BENeficiaryCom(21) = 1082;    // Банк_3.9.2v (Переводы  средств в других свободно конвертируемых валютах (межбанковские переводы): - по п. 3.4 платежных инструкций)
    BENeficiaryCom(22) = 1083;    // Банк_3.10.1v (Переводы  средств в других свободно конвертируемых валютах (переводы в пользу небанковских организаций): - по п.п. 3.3 и 3.5 платежных инструкций)
    BENeficiaryCom(23) = 1084;    // Банк_3.10.2v (Переводы  средств в других свободно конвертируемых валютах (переводы в пользу небанковских организаций):  - по п. 3.4 платежных инструкций)
    BENeficiaryCom(24) = 1085;    // Банк_3.10.3v (Переводы  средств в других свободно конвертируемых валютах (переводы в пользу небанковских организаций): - переводы по п.п. 3.3 и 3.5 платежных инструкций, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(25) = 1086;    // Банк_3.10.4v (Переводы  средств в других свободно конвертируемых валютах (переводы в пользу небанковских организаций): - переводы по п.3.4 платежных инструкций, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(26) = 1087;    // Банк_3.11.1v (Переводы  средств в валютах стран СНГ и стран Балтии ( межбанковские переводы) - по п.п. 3.3 и 3.5 платежных инструкций)
    BENeficiaryCom(27) = 1088;    // Банк_3.11.2v (Переводы  средств в валютах стран СНГ и стран Балтии ( межбанковские переводы) - по п. 3.4 платежных инструкций)
    BENeficiaryCom(28) = 1089;    // Банк_3.12.1v (Переводы  средств в валютах стран СНГ и стран Балтии (переводы в пользу небанковских организаций)  - по п.п. 3.3 и 3.5 платежных инструкций)
    BENeficiaryCom(29) = 1090;    // Банк_3.12.2v (Переводы  средств в валютах стран СНГ и стран Балтии (переводы в пользу небанковских организаций)  - по п. 3.4 платежных инструкций)
    BENeficiaryCom(30) = 1091;    // Банк_3.12.3v (Переводы  средств в валютах стран СНГ и стран Балтии (переводы в пользу небанковских организаций)  - переводы по п.п. 3.3 и 3.5 платежных инструкций, отправленные  с использованием системы "RS-Payments")
    BENeficiaryCom(31) = 1092;    // Банк_3.12.4v (Переводы  средств в валютах стран СНГ и стран Балтии (переводы в пользу небанковских организаций) - переводы по п.3.4 платежных инструкций, отправленные  с использованием системы "RS-Payments")
//RR Специально для ЭВ, для 1 клиента, добавляем еще 1 комиссию
    BENeficiaryCom(32)  = 1161;    // КО_Банк_3.4.3v (Переводы средств в долларах США по поручению банков-корреспондентов c инструкцией "все комиссии и расходы за счет бенефициара": - переводы, отправленные  с использованием системы "RS-Payments")
VAR SelComissions;
PRIVATE VAR PaymentObj, OrderNum = -1, MyRest = $0, _Id_Step;

/* EVG 03/05/2011 Функция чтения даты окончания операционного дня из реестра */
MACRO GetOperDayEndTime()

   var hh, mm, dayProlTime,
       error;

   GetRegistryValue( "PRBB\\СЕРВИС ГКБО\\ПРОДЛЕНИЕ ОПЕРДНЯ", V_STRING, dayProlTime, error );
   if ( ( error != 0 )
        or ( strLen( trim( dayProlTime ) ) == 0 )
        or ( index( dayProlTime, ":" ) == 0 ) )

      dayProlTime = "16:00";
   end;
   dayProlTime = trim( dayProlTime );

   // Перевод в формат времени
   hh = int( subStr( dayProlTime, 1, index( dayProlTime, ":" ) - 1 ) );
   mm = int( subStr( dayProlTime, index( dayProlTime, ":" ) + 1 ) );
   
   return( time( hh, mm ) );
END;

MACRO CheckArray( Arr, Curr )
  var i = 0;

  while (i < arr.Size)
     if (Arr(i) == Curr)
        return true;
     end;
     i = i + 1;
  end;

  return false;
END;



MACRO GetCurrencyKind( PaymentID )
  var CurCode, ErrCode,
      PaymentObj:RSBPayment;

   PaymentObj = RSBPayment( PaymentID );
   CurCode = int(ПолучитьКодФинИн(PaymentObj.BaseFIID, ErrCode, FICK_ISONUMBER));

   if ( CurCode == 840 )
      return CURRKIND_America;
   elif ( CheckArray(Currencies_Europe, CurCode) )
      return CURRKIND_Europe;
   elif ( CheckArray(Currencies_CIS, CurCode) )
      return CURRKIND_CIS;
   end;

   return CURRKIND_Other;
END;


MACRO ConnectComissToContr(_Account, _CommissCode, _FIID)
  var cmd, sql;
  SQL = " UPDATE   dsfconcom_dbt cnm1 ";
  SQL = SQL + "   SET   cnm1.t_status = 0 ";
  SQL = SQL + " WHERE   cnm1.t_id = ";
  SQL = SQL + "            (SELECT   cnm.t_id ";
  SQL = SQL + "               FROM   dsfconcom_dbt cnm, ";
  SQL = SQL + "                      (SELECT   ctr.t_id ";
  SQL = SQL + "                         FROM   dsfcontr_dbt ctr ";
  SQL = SQL + "                        WHERE       ctr.t_object = ? ";
  SQL = SQL + "                                AND t_servkind = 3 ";
  SQL = SQL + "                                AND t_objecttype = 1 ";
  SQL = SQL + "                                AND t_fiid = ?) ctr1 ";
  SQL = SQL + "              WHERE       cnm.t_status = 1 ";
  SQL = SQL + "                      AND cnm.t_objectid = ctr1.t_id ";
  SQL = SQL + "                      AND cnm.t_objecttype = 659 ";
  SQL = SQL + "                      AND cnm.t_feetype = 1 ";
  SQL = SQL + "                      AND cnm.t_commnumber = (SELECT   t_number ";
  SQL = SQL + "                                                FROM   dsfcomiss_dbt ";
  SQL = SQL + "                                               WHERE   t_code = ?) ";
  SQL = SQL + "                      AND cnm.t_sfplanid = ";
  SQL = SQL + "                            (SELECT   t_sfplanid ";
  SQL = SQL + "                               FROM   dsfcontrplan_dbt cp ";
  SQL = SQL + "                              WHERE   cp.t_sfcontrid = ctr1.t_id ";
  SQL = SQL + "                                      AND cp.t_begin = ";
  SQL = SQL + "                                            (SELECT   MAX (cp2.t_begin) ";
  SQL = SQL + "                                               FROM   dsfcontrplan_dbt cp2 ";
  SQL = SQL + "                                              WHERE   cp2.t_sfcontrid = ";
  SQL = SQL + "                                                         cp.t_sfcontrid)) ";
  SQL = SQL + "                      AND cnm.t_datebegin = ";
  SQL = SQL + "                            (SELECT   t_begin ";
  SQL = SQL + "                               FROM   dsfcontrplan_dbt cp ";
  SQL = SQL + "                              WHERE   cp.t_sfcontrid = ctr1.t_id ";
  SQL = SQL + "                                      AND cp.t_begin = ";
  SQL = SQL + "                                            (SELECT   MAX (cp2.t_begin) ";
  SQL = SQL + "                                               FROM   dsfcontrplan_dbt cp2 ";
  SQL = SQL + "                                              WHERE   cp2.t_sfcontrid = ";
  SQL = SQL + "                                                         cp.t_sfcontrid))) ";
                    cmd = rsdcommand(sql);
                    cmd.AddParam("", RSDBP_IN,_Account);
                    cmd.AddParam("", RSDBP_IN,_FIID);
                    cmd.AddParam("", RSDBP_IN,_CommissCode);
                  //  msgbox(sql);
                  //  msgbox(_Account);
                  //  msgbox(_FIID);
                  //  msgbox(_CommissCode);
                    cmd.Execute;
END;


MACRO GetChargesKind( PaymentID )
  var query, rs, cKind = "";
  var MsgNote, Field71pos;

   query = " Select val.t_Value " +
           "   From DWlPm_dbt wlp, DWlMesLnk_dbt lnk, DWlMes_dbt mes, DWlMesVal_dbt val, DWlTpFld_dbt wlt " +
           "  Where wlp.t_PaymentID = " + PaymentID +
           "    and lnk.t_ObjKind   = " + OBJTYPE_PAYMENT +
           "    and lnk.t_ObjID     = wlp.t_WlPmID " +
           "    and mes.t_MesID     = lnk.t_MesID " +
           "    and val.t_MesID     = mes.t_MesID " +
           "    and wlt.t_TpID      = 2 " +                                    // 2 - SWIFT
           "    and wlt.t_TpFieldID = val.t_TpFieldID " +
           "    and wlt.t_name      like ('71%') ";                            // 71 - Details of Charges
   rs = rsdRecordSet(query);
   if (rs and rs.moveNext())

      cKind = SQL_ConvTypeStr(rs.Value(0, null, V_STRING));

   else

      MsgNote = ReadNoteForPayment( PaymentID, NOTEKIND_RSPMMESSAGE );
      if ( strLen(MsgNote) > 0 )
         Field71pos = index(MsgNote, ":71A:");
         if ( Field71pos > 0 )
            cKind = trim(Substr(MsgNote, Field71pos + 5, 3));
         end;
      end;

   end;
   //msgbox (cKind);

   if ( ( cKind == "OUR" ) or ( cKind == "" ) )
      return CHARGESKIND_Our;
   elif ( cKind == "SHA" )
      return CHARGESKIND_Sha;
   elif ( cKind == "BEN" )
      return CHARGESKIND_Ben;
   end;

   return CHARGESKIND_Other;
END;



MACRO GetFormKind( PaymentID )
  var query, rs, fKind = "";
  var MsgNote, Field20pos;

   query = " Select frm.t_Name " +
           "   From DWlPm_dbt wlp, DWlMesLnk_dbt lnk, DWlMes_dbt mes, DWLMesRls_dbt rls, DWLMesFrm_dbt frm " +
           "  Where wlp.t_PaymentID = " + PaymentID +
           "    and lnk.t_ObjKind   = " + OBJTYPE_PAYMENT +
           "    and lnk.t_ObjID     = wlp.t_WlPmID " +
           "    and mes.t_MesID     = lnk.t_MesID " +
           "    and rls.t_RlsFormID = mes.t_RlsFormID " +
           "    and frm.t_FormID    = rls.t_FormID ";

   rs = rsdRecordSet(query);
   if (rs and rs.moveNext())

      fKind = SQL_ConvTypeStr(rs.Value(0, null, V_STRING));

   else

      MsgNote = ReadNoteForPayment( PaymentID, NOTEKIND_RSPMMESSAGE );
      if ( strLen(MsgNote) > 0 )
         Field20pos = index(MsgNote, ":20:");
         if ( Field20pos > 0 )
            fKind = trim(Substr(MsgNote, Field20pos + 11, 3));
         end;
      end;

   end;
   //msgbox (fKind);

   if ( fKind == "103" )
      return FORMKIND_MT103;
   elif ( fKind == "200" )
      return FORMKIND_MT200;
   elif ( fKind == "202" )
      return FORMKIND_MT202;
   end;


   return FORMKIND_Other;
END;



 MACRO GetPaymentOrigin( PaymentID )
  record paym(pmpaym);
  var retVal, Num = "";
  

  CONST GROUPID_Origin = 30,                    /* ID Категории "Происхождение ответного документа" */
        ORIGTEXT_Payments = "RS-Payments";      /* Текстовка категории для платежей из RS-Payments */

        
  ClearRecord(paym);
  paym.PaymentID = PaymentID;
  GetMainObjAttr (retVal, OBJTYPE_PAYMENT, UniID(paym, OBJTYPE_PAYMENT), GROUPID_Origin, null, null, Num);
  if ( Num == ORIGTEXT_Payments )
     return PMORIGIN_Paymnts;
  end;

  return PMORIGIN_Other;
 END;


 /* EVG 30/11/2012 Функция доработана по заявке C-15790 для расчёта комиссии за ВК по методике банка ГЭБ 
    (наложение min/max сумм на каждый платёж).
    Старую функцию оставил для истории.
 MACRO GetComCurrencyControlSum( Account, BegDate, EndDate, TariffCode, AccFIID )
  var sql, rs, cmd;
  var PaymID, PaymNote, RestNote, Separator, InSeparator, CommissionSum = $0;
  var NoteTariffCode, NoteTariffSum, SubTariff;

  const NOTEKIND_CC_Commission = 134;

/*FIV Берем все платежи, у которых счет получателя - объект договора, у которых есть привязанный поручения по транзитному счету
, у которых поле комиссий содержит текущую комиссию*/
   if (AccFIID > 0)
      SubTariff = "v_in";
      SQL = " SELECT   NVL(SUM(rsb_fiinstr.convsumtype (utc.SUM, ";
      SQL = SQL + "                                  ?, ";
      SQL = SQL + "                                  0, ";
      SQL = SQL + "                                  7, ";
      SQL = SQL + "                                  ?)),0)  ";
      SQL = SQL + "  FROM   dpmpaym_dbt pm, ";
      SQL = SQL + "         usr_trnsf_comiss utc, ";
      SQL = SQL + "         dsfcomiss_dbt com ";
      /* EVG 21/06/2012 Странно, но выявились входящие платежи, у которых в t_futurereceiveraccount после закрытия встал
         счёт плательщика (даже не корсчёт, а внешний счёт). Переходим на t_receiveraccount.
      SQL = SQL + " WHERE       pm.t_futurereceiveraccount = ? ";*/
      SQL = SQL + " WHERE       pm.t_receiveraccount = ? ";

      /* EVG 25/06/2012 Вернули, т.к. usr_trnsf_comiss.notify_num заполняется PaymentID.
      /* EVG 21/06/2012 Переход на связку через USR_TRNSF_NOTIFY
      SQL = SQL + "         AND pm.t_paymentid = utc.notify_num ";*/
      SQL = SQL + "         AND pm.t_paymentid = ( Select Payment_ID from USR_TRNSF_NOTIFY ";
      SQL = SQL + "                                                 where Payment_ID = utc.notify_num ";//RR 25.06.2012 тут нужно приравнивать Payment_ID а не notify_num
      SQL = SQL + "                                                   and to_char(notify_date, 'YYYY') = to_char(utc.comdate, 'YYYY') ) ";
      */
      SQL = SQL + "         AND pm.t_paymentid = utc.notify_num ";

      SQL = SQL + "         AND utc.comdate BETWEEN ? ";
      SQL = SQL + "                                AND  ? ";
      SQL = SQL + "         AND com.t_code = ? ";
      SQL = SQL + "         AND com.t_feetype = 1 ";
      SQL = SQL + "         AND com.t_number = utc.comid ";
      cmd = rsdcommand(sql);
      cmd.AddParam("", RSDBP_IN,AccFiid);
      cmd.AddParam("", RSDBP_IN,EndDate);
      cmd.AddParam("", RSDBP_IN,Account);
      cmd.AddParam("", RSDBP_IN,BegDate);
      cmd.AddParam("", RSDBP_IN,EndDate);
      cmd.AddParam("", RSDBP_IN,TariffCode+SubTariff);
   else
      SubTariff = "_in";
      SQL = " SELECT   NVL(SUM(utc.SUM),0) ";
      SQL = SQL + "  FROM   dpmpaym_dbt pm, usr_trnsf_comiss utc, dsfcomiss_dbt com ";
      /* EVG 21/06/2012 Странно, но выявились входящие платежи, у которых в t_futurereceiveraccount после закрытия встал
         счёт плательщика (даже не корсчёт, а внешний счёт). Переходим на t_receiveraccount.
      SQL = SQL + " WHERE       pm.t_futurereceiveraccount = ? ";*/
      SQL = SQL + " WHERE       pm.t_receiveraccount = ? ";

      /* EVG 25/06/2012 Вернули, т.к. usr_trnsf_comiss.notify_num заполняется PaymentID.
      /* EVG 21/06/2012 Переход на связку через USR_TRNSF_NOTIFY
      SQL = SQL + "         AND pm.t_paymentid = utc.notify_num ";*/
      SQL = SQL + "         AND pm.t_paymentid = ( Select Payment_ID from USR_TRNSF_NOTIFY ";
      SQL = SQL + "                                                 where Payment_ID = utc.notify_num ";//RR 25.06.2012 тут нужно приравнивать Payment_ID а не notify_num
      SQL = SQL + "                                                   and to_char(notify_date, 'YYYY') = to_char(utc.comdate, 'YYYY') ) ";
      */
      SQL = SQL + "         AND pm.t_paymentid = utc.notify_num ";

      SQL = SQL + "         AND com.t_code = ? ";
      SQL = SQL + "         AND com.t_feetype = 1 ";
      SQL = SQL + "         AND com.t_number = utc.comid ";
      SQL = SQL + "         AND utc.order_num = 0 ";
      SQL = SQL + "         AND utc.comdate between ? and ? ";
      cmd = rsdcommand(sql);
      cmd.AddParam("", RSDBP_IN,Account);
      cmd.AddParam("", RSDBP_IN,TariffCode+SubTariff);
      cmd.AddParam("", RSDBP_IN,BegDate);
      cmd.AddParam("", RSDBP_IN,EndDate);
   end;

  //setoutput("d:\\111222.txt");
  //println (sql, "|", AccFiid, " - ", BegDate, " - ", EndDate, " - ", Account, " - ", TariffCode+SubTariff);
  rs = rsdRecordSet(cmd);
  while (rs and rs.moveNext())

    return rs.Value(0, null, V_MONEY);

  end; 
  return $0;
 END;
*/


 /* EVG 30/11/2012 Функция доработана по заявке C-15790 для расчёта комиссии за ВК по методике банка ГЭБ 
    (наложение min/max сумм на каждый платёж). */
 MACRO GetComCurrencyControlSum( sfcontr, BegDate, EndDate, CommNumber )
  var sql, rs, cmd;
  var TarifValue = 0, MinValue = 0, MaxValue = 0, TarifType = 0;
  var CommSum = $0, OneOpCommSum = $0;


  /* Получим значение тарифа комиссии */
  /* Используем execMacro(), потому что вызываемая GetTarifInfo() находится в конце макроса (переносить её оттуда не хочется). */
  execMacro( "GetTarifInfo", sfcontr, BegDate, EndDate, 1, CommNumber, @TarifValue, @MinValue, @MaxValue, @TarifType );

  /* Получим базовые суммы */
  if ( sfContr.Fiid > 0 )
     SQL = " SELECT   NVL( rsb_fiinstr.convsumtype (utc.SUM,                                   ";
     SQL = SQL + "                                  ?,                                         ";
     SQL = SQL + "                                  0,                                         ";
     SQL = SQL + "                                  7,                                         ";
     SQL = SQL + "                                  ?), 0 )                                    ";
     SQL = SQL + "  FROM   dpmpaym_dbt pm, usr_trnsf_comiss utc, dsfcomiss_dbt com             ";
     SQL = SQL + " WHERE       pm.t_receiveraccount    = ?                                     ";
     SQL = SQL + "         AND pm.t_paymentid          = utc.notify_num                        ";
     SQL = SQL + "         AND com.t_number            = ?                                     ";
     SQL = SQL + "         AND com.t_feetype           = 1                                     ";
     SQL = SQL + "         AND utc.comid               = com.t_number                          ";
     SQL = SQL + "         AND utc.comdate     BETWEEN ?                                       ";
     SQL = SQL + "                                AND  ?                                       ";
     cmd = rsdcommand(sql);
     cmd.AddParam( "", RSDBP_IN, sfContr.Fiid   );
     cmd.AddParam( "", RSDBP_IN, EndDate        );
     cmd.AddParam( "", RSDBP_IN, sfContr.Object );
     cmd.AddParam( "", RSDBP_IN, CommNumber     );
     cmd.AddParam( "", RSDBP_IN, BegDate        );
     cmd.AddParam( "", RSDBP_IN, EndDate        );
  else
     SQL = " SELECT   NVL( utc.SUM, 0 )                                                        ";
     SQL = SQL + "  FROM   dpmpaym_dbt pm, usr_trnsf_comiss utc, dsfcomiss_dbt com             ";
     SQL = SQL + " WHERE       pm.t_receiveraccount    = ?                                     ";
     SQL = SQL + "         AND pm.t_paymentid          = utc.notify_num                        ";
     SQL = SQL + "         AND com.t_number            = ?                                     ";
     SQL = SQL + "         AND com.t_feetype           = 1                                     ";
     SQL = SQL + "         AND utc.comid               = com.t_number                          ";
     SQL = SQL + "         AND utc.order_num           = 0                                     ";
     SQL = SQL + "         AND utc.comdate     BETWEEN ?                                       ";
     SQL = SQL + "                                 and ?                                       ";
     cmd = rsdcommand(sql);
     cmd.AddParam( "", RSDBP_IN, sfContr.Object );
     cmd.AddParam( "", RSDBP_IN, CommNumber     );
     cmd.AddParam( "", RSDBP_IN, BegDate        );
     cmd.AddParam( "", RSDBP_IN, EndDate        );
  end;

  //setoutput("d:\\111222.txt");
  //println (sql, "|", AccFiid, " - ", BegDate, " - ", EndDate, " - ", Account, " - ", TariffCode+SubTariff);
  rs = rsdRecordSet(cmd);
  while (rs and rs.moveNext())

    /* Расчёт комиссии */

    // Тариф = Сумма
    if   ( TarifType == 1 )        

       CommSum = CommSum + TarifValue;

    // Тариф = Процент
    elif ( TarifType == 2 )        

       OneOpCommSum = rs.Value(0, null, V_MONEY) * TarifValue / 100;
       if ( OneOpCommSum < MinValue )
          OneOpCommSum = MinValue;
       end;
       if ((MaxValue != 0) and (OneOpCommSum > MaxValue))
          OneOpCommSum = MaxValue;
       end;
       CommSum = CommSum + OneOpCommSum;

    end;
    
    //msgbox (TarifValue, " - ", OneOpCommSum, "|", CommSum);
  end; 

  return CommSum;
 END;


 MACRO isDmsbPlan (NumPlan)
   var i = 0;

   while (i < SFPlans_Dmsb.Size())
      if (SFPlans_Dmsb(i) == NumPlan)
         return true;
      end;
      i = i + 1;
   end;

   return false;
 END;


 MACRO CheckMinMax (pSum, pMin, pMax)
   if ( (pSum >= pMin) and (pSum <= pMax) )
      return true;
   end;
   return false;
END;



 MACRO Cash_IsProperCommission (Contr, Calcal, Sum)
   var sql, rs;
   var TarifNumber, TarifPlan;

   /* EVG 13/11/2012 Блин, теперь появились ещё пакетные комиссии с "pack" после кода.
      Это pack нужно тоже отсекать, поэтому проще будет просто брать первые 5 символов кода.
   /* EVG 27/06/2012 Нужно убрать звёздочку (для вызова функции из банка ВУЗ)
   SQL = "SELECT com.t_code cod, pln.t_num num ";*/
   SQL = "SELECT rTrim(com.t_code, CHR(42)) cod, pln.t_num num ";*/
   SQL = "SELECT subStr(com.t_code, 1, 5) cod, pln.t_num num ";
   SQL = SQL + "  FROM dsfcomiss_dbt com, dsfplan_dbt pln, dsfcontrplan_dbt cplan ";
   SQL = SQL + " WHERE com.t_feetype     = " + Calcal.FeeType;
   SQL = SQL + "   AND com.t_number      = " + Calcal.CommNumber;
   SQL = SQL + "   AND cplan.t_sfcontrid = " + Contr.Id;
   SQL = SQL + "   AND cplan.t_begin     = (SELECT MAX (t_begin) ";
   SQL = SQL + "                              FROM dsfcontrplan_dbt ";
   SQL = SQL + "                             WHERE t_sfcontrid = cplan.t_sfcontrid) ";
   SQL = SQL + "   AND pln.t_sfplanid    = cplan.t_sfplanid ";

   rs = rsdRecordSet(SQL);
   if (rs and rs.MoveNext())
      TarifNumber = rs.Value("cod", null, V_STRING);
      TarifPlan   = rs.Value("num", null, V_INTEGER);
   end;

/*
{Tarif 5.2.3 MIN} =       $0,
{Tarif 5.2.3 MAX} =  $100000,
{Tarif 5.2.4 MIN} =  $100001,
{Tarif 5.2.4 MAX} =  $300000,
{Tarif 5.2.5 MIN} =  $300001,
{Tarif 5.2.5 MAX} =  $600000,
{Tarif 5.2.6 MIN} =  $600001,
{Tarif 5.2.6 MAX} = $1000000,
{Tarif 5.2.7 MIN} = $1000001,
{Tarif 5.2.7 MAX} = $3000000,
{Tarif 5.2.8 MIN} = $3000001;
*/

 if    (not LifeBank.is_VUZ())
 
           if   ( (TarifNumber == "5.2.3") )

              return CheckMinMax( Sum, {Tarif 5.2.3 MIN}, {Tarif 5.2.3 MAX});
      
           elif ( (TarifNumber == "5.2.4") )

              return CheckMinMax( Sum, {Tarif 5.2.4 MIN}, {Tarif 5.2.4 MAX});

           elif ( (TarifNumber == "5.2.5") )

              return CheckMinMax( Sum, {Tarif 5.2.5 MIN}, {Tarif 5.2.5 MAX});

           elif ( (TarifNumber == "5.2.6") )

              return CheckMinMax( Sum, {Tarif 5.2.6 MIN}, {Tarif 5.2.6 MAX});

           elif ( (TarifNumber == "5.2.7") )

              return CheckMinMax( Sum, {Tarif 5.2.7 MIN}, {Tarif 5.2.7 MAX});

           elif ( (TarifNumber == "5.2.8") )

              return ( Sum >= {Tarif 5.2.8 MIN} );           // Для тарифа 5.2.8 только минимум.

           elif ( (TarifNumber == "5.2.9") )

              return true;           // Граничных условия для тарифа 5.2.9 нет.
              
           end;
   
 elif (LifeBank.is_VUZ())
 
          if   ( (TarifNumber == "5.2.2") or (TarifNumber == "5.8.2") )

             return CheckMinMax( Sum, {VuzTarif 5.2.2 MIN}, {VuzTarif 5.2.2 MAX});
      
          elif ( (TarifNumber == "5.2.3") or (TarifNumber == "5.8.3") )

             return CheckMinMax( Sum, {VuzTarif 5.2.3 MIN}, {VuzTarif 5.2.3 MAX});

          elif ( (TarifNumber == "5.2.4") or (TarifNumber == "5.8.4") )

             return CheckMinMax( Sum, {VuzTarif 5.2.4 MIN}, {VuzTarif 5.2.4 MAX});

          elif ( (TarifNumber == "5.2.5") or (TarifNumber == "5.8.5") )

             return CheckMinMax( Sum, {VuzTarif 5.2.5 MIN}, {VuzTarif 5.2.5 MAX});

          elif ( (TarifNumber == "5.2.6") or (TarifNumber == "5.8.6") )

             return CheckMinMax( Sum, {VuzTarif 5.2.6 MIN}, {VuzTarif 5.2.6 MAX});

          elif ( (TarifNumber == "5.2.7") or (TarifNumber == "5.8.7") )

             return ( Sum >= {VuzTarif 5.2.7 MIN} );           // Для тарифа 5.2.7 только минимум.

          elif ( (TarifNumber == "5.2.8") or (TarifNumber == "5.8.8") )

             return true;           // Граничных условия для тарифа 5.2.8 нет.

          end;
/*
      {VuzTarif 5.2.2 MIN} =       $0,
      {VuzTarif 5.2.2 MAX} =  $100000,
      {VuzTarif 5.2.3 MIN} =  $100001,
      {VuzTarif 5.2.3 MAX} =  $300000,
      {VuzTarif 5.2.4 MIN} =  $300001,
      {VuzTarif 5.2.4 MAX} =  $600000,
      {VuzTarif 5.2.5 MIN} =  $600001,
      {VuzTarif 5.2.5 MAX} = $1000000,
      {VuzTarif 5.2.6 MIN} = $1000001,
      {VuzTarif 5.2.6 MAX} = $3000000,
      {VuzTarif 5.2.7 MIN} = $3000001; */
 end;


   return false;
 END;


 MACRO Cash_CalcSymbSum_Period( dKind, CashDoc, CashSymbols, ProcessAllClientAccounts, sfcontr, IncOrder, CheckDaysCashDocs_or_BegDate, PayerID ) // EVG 15/11/2012 Добавил приём параметров ProcessAllClientAccounts и sfcontr
  var query, rs, rs1, mm, yy, cmd;                                                                                // EVG 24/04/2013 Добавил приём параметра IncOrder - признак вызова для приходных документов
                                                                                                                                       // joy 25.11.2013 Добавила приём параметров CheckDaysCashDocs - поиск чеков за день,
                                                                                                                                       //                PayerID - напрямую передаем ИД клиента; 28.11.2013 переименовала в CheckDaysCashDocs_or_BegDate
  var PaymValueDate = date(0,0,0),
      MonthBegDate  = date(0,0,0),
      CashSymbSum   = $0,
      cdocAutokey = 0,
      cdocAppKind = 0,
      cdocAppKey  = "";
debugbreak;
      macro AddLeftZero( val, len )

         while ( strLen(val) < len )
            val = "0" + val;
         end;
         return val;

      end;

    /* Найдём из платежа дату документа */
    query = " Select paym.t_ValueDate " +
            "   From DPmPaym_dbt paym " +
            "  Where paym.t_DocKind    = " + dKind +
            "    and paym.t_DocumentID = " + CashDoc.AutoKey;
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       PaymValueDate = rs.value(0, null, V_DATE);
    /*26.11.2013 joy В случае вызова ф-ции из макроса скроллинга чеков при сохраненнии CashDoc не заполняется. Исползуем текущую дату*/
    else
        PaymValueDate = {curdate};
    end;

    /* Определим дату начала текущего месяца */
    dateSplit(PaymValueDate, null, mm, yy);
    MonthBegDate = date(1, mm, yy);
    
    
    /* EVG 12/08/2013 Доработка отменена по причине корректировки постановки задачи. С даты постановки клиента на пакетный ТП должны считаться
       не обороты по кассе, а только расход месячного лимита.

    /* EVG 19/02/2013 В соответствии с заявкой C-17591, для пакетных ТП анализ оборотов должен осуществояться с даты подключения ТП в случае,
       если ТП был подключен в текущем месяце (т.е. большая из дат <Дата начала месяца> и <Дата подключения ТП>). Иного признака того, что
       комиссия рассчитывается по пакетному ТП, кроме параметра ProcessAllClientAccounts, нет, поэтому будем использовать его, чтобы не вносить
       изменения в массу макросов комиссий. */
    var tpBegDate = date(0,0,0);
    if( ProcessAllClientAccounts )
       cmd = rsdcommand("   SELECT t_begin " +
                        "     FROM dsfcontrplan_dbt " +
                        "    WHERE T_SFCONTRID = ?  " +
                        "      AND t_end       = TO_DATE('01.01.0001','dd.mm.yyyy') " +
                        " ORDER BY t_begin DESC ");
       cmd.addparam( "ID", RSDBP_IN, sfcontr.id );
       rs = rsdrecordset( cmd );
       if ( rs and rs.movenext )
          tpBegDate = SQL_ConvTypeDate( rs.value(0, null, V_DATE) );
       end;
    end; */

    /* EVG 12/08/2013 Если в качестве параметра к функции передана дата начала анализа оборотов, используем её вместо полученной ранее даты
       начала месяца. Дата передаётся при расчёте использования лимита по пакетным комиссиям за кассу. */
    private var BeginDate;
    if( getParm( 6, BeginDate ) and ( valType( BeginDate ) == V_DATE ) and ( BeginDate > MonthBegDate ) )
       MonthBegDate = BeginDate;
    end;

    /*25.11.2013 joy Если нужно проверять чеки за день*/
    if (valType (CheckDaysCashDocs_or_BegDate) != V_DATE) //I-00446845 joy 28.11.2013 В CheckDaysCashDocs (6-ой параметр) может передаваться дата из пакетных комиссий, я это упустила. Каюсь, теперь всё выглядит некрасиво.
        if (CheckDaysCashDocs_or_BegDate)
            MonthBegDate = PaymValueDate;
        end;
    end;
    /*---end joy*/
    
    
    /* Посчитаем общую сумму снятия наличных по указанному символу за текущий месяц 
       (с начала месяца по дату выполнения данной операции). */
    CashSymbSum = $0;


    /* Цикл по кассовым документам со счёта клиента за указанный период */

    /* EVG 15/11/2012 Запрос скорректирован для возможности обработки кассовых документов по всем счетам клиента.*/
 

    var ProcAcc_clause = "and doc.t_ClientAccount   = " + GetSQLString(CashDoc.ClientAccount);


    if( ProcessAllClientAccounts )
        /*25.11.2013 joy Если ИД клиента передан параметром*/
        if (PayerID)
            ProcAcc_clause = "and pm.t_Payer        = " + PayerID;
        else
        ProcAcc_clause = "and pm.t_Payer        = " + sfcontr.PartyID;
        end;
        /* EVG 24/04/2013 Обработка вызова для приходных кассовых документов */
        if( IncOrder )
           ProcAcc_clause = "and pm.t_Receiver = " + sfcontr.PartyID;
        end;
    end;

    query = " SELECT   doc.t_AutoKey AutoKey, " +
            "          doc.t_ConnectAppKind AppKind, " +
            "          doc.t_ConnectAppKey AppKey, " +
            "          PM.T_VALUEDATE, " +
            "          PM.T_AMOUNT, " +
            "          (SELECT   NVL ( (SELECT   SUM(SYMB.T_SUM) " +
            "                             FROM   dsymbcash_dbt symb " +
            "                            WHERE   SYMB.T_ACCTRNID = pmd.T_ACCTRNID " +
            "                              AND   TRIM (symb.t_Symbol) IN " + CashSymbols + "),0) FROM   DUAL)" +
            "             sum, " +
            "          DOC.T_DOCKIND " +
            "   FROM   DPsCshDoc_dbt doc, DPmPaym_dbt pm, dpmdocs_dbt pmd " +
            "  WHERE       pm.t_PaymentId = doc.t_AutoKey " +
            "          AND pm.t_DocKind = doc.t_DocKind " +
            "          AND PM.T_PAYMENTID = PMD.T_PAYMENTID " +
            "          AND pm.t_ValueDate >= " + GetSQLDate(MonthBegDate) +
            "          AND pm.t_ValueDate <= " + GetSQLDate(PaymValueDate) +
            "          AND pm.t_PaymStatus = 32000 " +
            ProcAcc_clause;

/*
    query = " Select doc.t_AutoKey AutoKey, doc.t_ConnectAppKind AppKind, doc.t_ConnectAppKey AppKey" +
            "   From DPsCshDoc_dbt doc, DPmPaym_dbt pm " +
            "  Where pm.t_PaymentId        = doc.t_AutoKey " +
            "    and pm.t_DocKind          = doc.t_DocKind " +
            "    and pm.t_ValueDate       >= " + GetSQLDate(MonthBegDate) +
            "    and pm.t_ValueDate       <= " + GetSQLDate(PaymValueDate) +
            "    and pm.t_PaymStatus       = 32000 " +
            ProcAcc_clause; */

    rs = rsdRecordSet(query);
    //msgbox ("query);
    while (rs and rs.moveNext())
      CashSymbSum = CashSymbSum + rs.value("sum", null, V_MONEY);
    /*
       cdocAutokey = SQL_ConvTypeInteger(rs.value("AutoKey", null, V_INTEGER));
       cdocAppKind = SQL_ConvTypeInteger(rs.value("AppKind", null, V_INTEGER));
       cdocAppKey  = SQL_ConvTypeStr(rs.value("AppKey",  null, V_STRING));

       if ( (cdocAppKind == 0) and (cdocAppKey == "") )
          query = " Select nvl(sum(symb.t_Sum), 0) " +
                  "   From DSymbCash_dbt symb " +
                  "  Where trim(symb.t_Symbol)  in " + CashSymbols +
                  "    and symb.t_ApplicationKey = " + GetSQLString( AddLeftZero(cdocAutokey, 34) );
          rs1 = rsdRecordSet(query);
          while (rs1 and rs1.moveNext())
             CashSymbSum = CashSymbSum + rs1.value(0, null, V_MONEY);
          end;
       //msgbox ("2   ", query);
       else
          query = " Select nvl(sum(symb.t_Sum), 0) " +
                  "   From DSymbCash_dbt symb " +
                  "  Where trim(symb.t_Symbol)  in " + CashSymbols +
                  "    and symb.t_ApplicationKey = " + GetSQLString( AddLeftZero(cdocAppKind, 5) +
                                                                                 cdocAppKey );
          rs1 = rsdRecordSet(query);
          while (rs1 and rs1.moveNext())
             CashSymbSum = CashSymbSum + rs1.value(0, null, V_MONEY);
          end;
       //msgbox ("3   ", query);
       end; */

    end;

    return CashSymbSum;
END;


/* EVG */
 MACRO CC_ARM_Commiss_EventHandler (dlg, cmd, id, key) 
   const  KEY_F1       = 315,
          KEY_F2       = 316,
          KEY_F3       = 317,
          KEY_F9       = 323,
          KEY_ESC      = 27,
          KEY_SPACE    = 32,
          KEY_ENTER    = 13;

   var const_mess = "~ESC~ Выход ~F2~ Выполнить ~SPACE~ Установить ";

   var CommMasc = "", i, isSelect;
   var query, rs, sql;
   var CommCount = 5;         // Количество комиссий за ВК
   var LifeBank;
   var DopMasc = "", j, isSelect1;// VV 29.04.2013 C-19666 Внесение изм. в экранную панель в RS-V6, в АРМ-позиционера, при прохождении операций шага ВК

   LifeBank = fg_life_subject( {OurBank} );
   CommMasc = "'9.%in%'";
   DopMasc="'%.3_in'";// VV 29.04.2013 C-19666 Внесение изм. в экранную панель в RS-V6, в АРМ-позиционера, при прохождении операций шага ВК

   if ( PaymentObj.BaseFiid > 0 )
      CommMasc = "'7.%in%'";
      DopMasc="'7.3.1v_in'";// VV 29.04.2013 C-19666 Внесение изм. в экранную панель в RS-V6, в АРМ-позиционера, при прохождении операций шага ВК
      /* В ГЭБе 7 комиссий по рублёвым платежам */
      if ( LifeBank.is_GEB )
         CommCount = 7;
      end;
   end;

   /* EVG 3/06/2012 Доработка C-11624 Для ПРББ подключаются новые комиссии (временно) */
   if (    ( LifeBank.is_PRBB )
        or ( LifeBank.is_SLD ) )
      CommCount = 7;
   end;


        /* Возвращает остаток неразнесённой суммы */
        macro GetRest( Amnt )
           var i = 1, Sum = $0, RetSum;

           while (i <= CommCount)
              Sum = Sum + dlg.( fldIndex(dlg, "Sum" + i) );
              i = i + 1;
           end;

           RetSum = Amnt - Sum;
           if (RetSum < $0) 
              RetSum = $0;
           end;

           return RetSum;
        end;

   
   /*Первоначальная инициализация полей*/
   if(cmd == DLG_INIT)
      dlg.rec.Sel1 = "";
      dlg.rec.Sel2 = "";
      dlg.rec.Sel3 = "";
      dlg.rec.Sel4 = "";
      dlg.rec.Sel5 = "";

      i = 1;
      // VV 29.04.2013 C-19666 Внесение изм. в экранную панель в RS-V6, в АРМ-позиционера, при прохождении операций шага ВК
      query = " Select t_code Code, t_Name Name From DSFCOMISS_DBT " +
              "  Where t_FeeType = 1 " +        // Периодические
             "    and t_Code like " + CommMasc + "and t_code not like"+DopMasc+
              /* EVG 19/06/2012 Проверка периода действия комиссии */
              "    and ( " + GetSQLDate( PaymentObj.ValueDate ) + " between t_DateBegin and t_DateEnd " +
              "          or t_DateEnd = to_date('01-01-0001','dd-mm-rrrr') )" +
              /* EVG 3/06/2012 Добавил сортировку */
              "  Order by Code ";
      rs = rsdRecordSet(query);
      while (rs and rs.MoveNext() and (i <= CommCount))

         dlg.( fldIndex(dlg, "Cod" + i) )  = rs.Value("Code", null, V_STRING);
         dlg.( fldIndex(dlg, "Name" + i) ) = rs.Value("Name", null, V_STRING);

         i = i + 1;
      end;
      debugbreak;
      if (( PaymentObj.BaseFiid > 0 ) and ( substr(PaymentObj.FutureReceiverAccount, 1, 5) != "40807" ))
         SQL = " SELECT   (uto.transf_sum + sell_sum) rest, uto.order_num ";
         SQL = SQL + "  FROM   usr_trnsf_order uto , usr_trnsf_notify nt ";
         SQL = SQL + " WHERE       NT.PAYMENT_ID = ?  ";
         SQL = SQL + "         AND uto.notify_num = NT.NOTIFY_NUM ";
         SQL = SQL + "         AND NT.NOTIFY_DATE <= UTO.DATE_VALUE "; //RR совместно с TAM Ошибка из-за которой проставлялась неверная сумма за которую списывались комиссии
         SQL = SQL + "         AND NOT EXISTS (SELECT   1 ";
         SQL = SQL + "                           FROM   usr_trnsf_comiss utc ";
         SQL = SQL + "                          WHERE   utc.order_num = uto.order_num AND utc.notify_num = uto.notify_num AND utc.id_step = ? ) ";
         cmd = rsdcommand(sql);
         cmd.AddParam("", RSDBP_IN,PaymentObj.PaymentID);
         cmd.AddParam("", RSDBP_IN,_Id_Step);
         rs = rsdRecordSet(cmd);
         if (rs.MoveNext())
            MyRest = rs.Value(0);
            OrderNum = rs.Value(1);
         end;
       else 
          MyRest = PaymentObj.BaseAmount;
       end;


      message (const_mess);

      UpdateFields(dlg); 
      SetFocus(dlg, 0)
   end;
   
   
   /*Проверки*/
   if (cmd == DLG_REMFOCUS)

      /* Проверка корректности сумм */
      if ( subStr(FldName(dlg,id), 1, 3) == "Sum")
         if ( dlg.(id) < $0 )
            MsgBox("Базовая сумма комиссии должна быть больше нуля");
            return CM_CANCEL;
         end;
      end;

      UpdateFields(dlg); 
   end;

   
   if (cmd == DLG_KEY)

     /*Выход из диалогового окна формирования отчета*/
     if (KEY == KEY_ESC)
       if ( getTrue(false, "Выход без сохранения. Вы уверены?") )
          return CM_CANCEL;
       end;
       return CM_IGNORE;

     elif (KEY == KEY_SPACE)

        if ( subStr(FldName(dlg,id), 1, 3) == "Sel")
           if   ( dlg.(id) == "" )
              dlg.(id) = "X";
              dlg.( fldIndex(dlg, "Sum" + SubStr(FldName(dlg,id), 4, 1)) ) = GetRest(MyRest);
           elif ( dlg.(id) == "X" )
              dlg.(id) = "";     
              dlg.( fldIndex(dlg, "Sum" + SubStr(FldName(dlg,id), 4, 1)) ) = $0;
           end;
        end;

        UpdateFields(dlg);

     elif ( KEY == KEY_F2 )          //Проверки при вводе

        i = 1;
        isSelect = false;
        SelComissions = "";
        /*FIV Если валюта не рубли значит валютный документ и есть распоряжения по транзитному счету */
       // debugbreak;
        if (( PaymentObj.BaseFiid > 0 ) and ( substr(PaymentObj.FutureReceiverAccount, 1, 5) != "40807" ))
           if (OrderNum != -1)
              while ( i <= CommCount )
                 if ( dlg.(fldIndex(dlg, "Sel" + i)) == "X")
                    isSelect = true;
                    debugbreak;
                       /*Вставляем комиссию*/
                       SQL = " BEGIN INSERT INTO usr_trnsf_comiss (order_num, ";
                       SQL = SQL + "                              notify_num, ";
                       SQL = SQL + "                              comid, ";
                       SQL = SQL + "                              SUM, comdate,Id_Step) ";
                       SQL = SQL + "  VALUES   ( ?, ?,(select t_number from dsfcomiss_dbt where t_code =  ?),?,?,?); ";
                       SQL = SQL + " EXCEPTION ";
                       SQL = SQL + "   WHEN OTHERS ";
                       SQL = SQL + "   THEN ";
                       SQL = SQL + "      NULL; ";
                       SQL = SQL + "END; ";
                       cmd = rsdcommand(sql);
                       cmd.AddParam("", RSDBP_IN,OrderNum);
                       cmd.AddParam("", RSDBP_IN,PaymentObj.PaymentID);
                       cmd.AddParam("", RSDBP_IN,dlg.(fldIndex(dlg, "Cod" + i)));
                       cmd.AddParam("", RSDBP_IN,dlg.(fldIndex(dlg, "Sum" + i)));
                       cmd.AddParam("", RSDBP_IN, {curdate});
                       cmd.AddParam("", RSDBP_IN, _Id_Step);
                       cmd.Execute;
                 end;
                 i = i + 1;
              end;
           end;
        else
           while ( i <= CommCount )
              if ( dlg.(fldIndex(dlg, "Sel" + i)) == "X")
                 isSelect = true;
                 debugbreak;
                    SQL = " BEGIN INSERT INTO usr_trnsf_comiss (order_num, ";
                    SQL = SQL + "                              notify_num, ";
                    SQL = SQL + "                              comid, ";
                    SQL = SQL + "                              SUM, comdate,Id_Step) ";
                    SQL = SQL + "  VALUES   ( 0, ?,(select t_number from dsfcomiss_dbt where t_code =  ?),?,?,?); ";
                    SQL = SQL + " EXCEPTION ";
                    SQL = SQL + "   WHEN OTHERS ";
                    SQL = SQL + "   THEN ";
                    SQL = SQL + "      NULL; ";
                    SQL = SQL + "END; ";
                    cmd = rsdcommand(sql);
                    cmd.AddParam("", RSDBP_IN,PaymentObj.PaymentID);
                    cmd.AddParam("", RSDBP_IN,dlg.(fldIndex(dlg, "Cod" + i)));
                    cmd.AddParam("", RSDBP_IN,dlg.(fldIndex(dlg, "Sum" + i)));
                    cmd.AddParam("", RSDBP_IN, {curdate});
                    cmd.AddParam("", RSDBP_IN, _Id_Step);
                    cmd.Execute;
                    /*FIV Подключаем комиссию к договору, если была отключена - это было сделано для ускорения комиссий за ВК*/
                    ConnectComissToContr(PaymentObj.FutureReceiverAccount, dlg.(fldIndex(dlg, "Cod" + i)), PaymentObj.BaseFIID);
              end;
              i = i + 1;
           end;

        end;
       // ComSum = 0;

        if (not isSelect)
           if ( GetTrue(true, "Не выбрано ни одного тарифа. Вы уверены?") )
              return CM_SAVE;
           end;
           return CM_IGNORE;
        end;

        return CM_SAVE;

     elif ( KEY == KEY_ENTER )
        /* При нажатии Enter в последнем поле не закрывать окно */
        if (id == dlg.fldNumber()-1)
           SetFocus(dlg, 0);
           return CM_IGNORE;
        end;

     elif ( KEY == KEY_F9 )
        return CM_IGNORE;

     end;
   
   end;

 END;


 MACRO Execute_CC_CommissionChoice( Paym, Id_Step )
   var DlgLbrPath, DlgLbrName;
   const NOTEKIND_CC_Commission = 134;
   debugbreak;
   var LifeBank = fg_life_subject( {OurBank} );

   _Id_step = Id_Step;
   PaymentObj = Paym;

   GetRegistryValue("BANK_INI\\ОБЩИЕ ПАРАМЕТРЫ\\ДИРЕКТОРИИ\\LBRDIR", V_STRING, DlgLbrPath);
   DlgLbrName = "vk.lbr";
   DlgLbrPath = FindPath(DlgLbrName, DlgLbrPath);
   var dlg = tRecHandler("StepCom", DlgLbrPath, true);

   /* Для рублёвых платежей в банке ГЭБ панелька немного отличается */
   if ( LifeBank.is_GEB  and (PaymentObj.BaseFiid == 0) )
      dlg = tRecHandler("STEPCOM1", DlgLbrPath, true);
   /* EVG 3/06/2012 Доработка C-11624 Для ПРББ подключаются новые комиссии (временно) */
   elif(     ( LifeBank.is_PRBB )
          or ( LifeBank.is_SLD ) )
      dlg = tRecHandler("STEPCOM1", DlgLbrPath, true);
   end;

   if (RunDialog(dlg, "CC_ARM_Commiss_EventHandler"))
     // if ( strLen(SelComissions) > 0 )
         //InsertNoteForPayment(PaymentObj.PaymentID, NOTEKIND_CC_Commission, SelComissions);
    //  end;
      //msgbox (SelComissions);
      return 0;
   end;

   return 1;
 END;



 MACRO GetComissAccountFromPayment( OprsfcomID, ComAccount:@string, ComFiid:@integer )

   var SQL, rs, acc;

   SQL = " SELECT pm.t_comissaccount, pm.t_comissfiid ";
   SQL = SQL + "  FROM doproper_dbt oper, dpmpaym_dbt pm ";
   SQL = SQL + " WHERE oper.t_id_operation = " + OprsfcomID;
   SQL = SQL + "   AND oper.t_dockind      = DECODE (pm.t_dockind, 322, 320, pm.t_dockind) ";
   SQL = SQL + "   AND pm.t_documentid     = LTRIM (oper.t_documentid, '0') ";
   SQL = SQL + "   AND SUBSTR (pm.t_comissaccount, 11, 1) != '9' ";     /* Не счёт СКС */
   SQL = SQL + "   AND SUBSTR (pm.t_comissaccount, 1, 5) != '40821' ";     /* Не счёт платежного агента */
    
   rs = rsdRecordSet( SQL );

   if (rs and rs.MoveNext())

      acc = SQL_ConvTypeStr(rs.Value(0, null, V_STRING));
      if ( trim(acc) != "" )
         ComAccount = rs.Value(0, null, V_STRING);
         ComFiid    = rs.Value(1, null, V_INTEGER);

         //msgbox ("ComAccount ", ComAccount);
         return true;
      end;
      
   end;

   return false;
 END;

//RR 20.02.2014 Поиск результатов не дал, похоже что данная макро функция нигде не используется, коменчу для проверки сего факта
/****************************************************************************************************************************************************
 MACRO ПроверитьОстатокСумм( Account, FIID, todate, ComNdsSum )
  var AccRec = TRecHandler("account");
  var AccountRest = 0, AccountFreeRest = 0, PlanRest = $0;
              // EVG
  var q, rsb, cmd, AccLimit;
  var stat = false;

  /* EVG 19/05/2011 For Baidoolova */
  private var lfBank = fg_life_subject();


  AccGetFreeAmount( AccountFreeRest, null, Account, 1/*CHAPT1*/, FIID, todate, 6, 0 ); /* с учетом претензий */

  //msgbox (Account, " - ", FIID, " - ", AccountFreeRest);

  /* EVG Учтём лимит овердрафта. Для этого его нужно прибавить к свободному остатку, если на счёте стоит 
     тип "О". */
  AccLimit = $0;
  
  rsb = rsdRecordSet (" SELECT   ACCLIM.T_LIMIT, RST.T_PLANREST, ACC.T_TYPE_ACCOUNT " +
                      "   FROM   DACCOUNT_DBT ACC, DACCLIMIT_DBT ACCLIM, DRESTDATE_DBT RST " +
                      "  WHERE       ACC.T_ACCOUNT = '" + Account + "'" +
                      "          AND ACC.T_CHAPTER = 1 " +
                      "          AND ACC.T_CODE_CURRENCY = " + FIID +
                      "          AND ACCLIM.T_ACCOUNT = ACC.T_ACCOUNT " +
                      "          AND ACCLIM.T_CHAPTER = ACC.T_CHAPTER " +
                      "          AND ACCLIM.T_CODE_CURRENCY = ACC.T_CODE_CURRENCY " +
                      "          AND ACCLIM.T_LIMITDATE = " +
                      "                (SELECT   MAX (T_LIMITDATE) " +
                      "                   FROM   DACCLIMIT_DBT " +
                      "                  WHERE       T_ACCOUNT = ACC.T_ACCOUNT " +
                      "                          AND T_CHAPTER = ACC.T_CHAPTER " +
                      "                          AND T_CODE_CURRENCY = ACC.T_CODE_CURRENCY) " +
                      "          AND RST.T_ACCOUNTID = ACC.T_ACCOUNTID " +
                      "          AND RST.T_RESTDATE = '"+todate+"' " +
                      "          AND RST.T_RESTCURRENCY = ACC.T_CODE_CURRENCY ");
  if ( rsb and rsb.MoveNext )
     AccLimit = rsb.Value(0, null, V_MONEY);
     PlanRest = rsb.Value(1, null, V_MONEY);
  end;

  //msgbox (AccountFreeRest, "|", AccLimit);
  /*FIV Переписал как у Селезнева*/
  if (PlanRest < AccountFreeRest)
     AccountFreeRest = PlanRest; //возвращаем наименьший остаток
  end;


  /* EVG 17/01/2011 Если проверяется остаток валютного счёта, а комиссия в рублях, то
     необходимо сконвертировать валютный остаток в рубли (заявки I-104817 и I-112458). */

  if ( FIID > NATCUR )
     if( ConvSum( AccountFreeRest, AccountFreeRest, todate, FIID, NATCUR, 7 ) != 0 )
        AccountFreeRest = $0;
     end;
  end;


  //msgbox ( AccountFreeRest, "|", AccLimit, "|", (AccountFreeRest +  AccLimit) );

  /* EVG 2/12/2010 Всё, для оплаты комиссий овердрафт больше не используется.
  if (index(rsb.value("t_type_account"), "О")!=0)
     AccountFreeRest = AccountFreeRest + AccLimit;
  end;*/

  

  /* EVG 13.11.2009 Проверка отключена по согласованию с Фоменко. Комиссии оплачиваются,
     несмотря на наличие документов в картотеке.

  /* EVG Здесь же сделаем проверку на наличие документов картотеки 2 к счёту-плательщику.
     Если есть хоть один документ в картотеке 2, возвращаем false. */
  q = " select 1 " 
    + " from dpsindacc_dbt ind "
    + " where ind.t_account = '" + Account + "' "
    + " and ind.t_chapter = 1 and ind.t_fiid = " + string(FIID);
  rsb = TRsbDataSet( q );
  if( rsb.MoveNext() )
     return false;
  end;*/


  /* EVG 19/05/2011 For Baidoolova: для банка ЭВ проверяется наличие в 
     К2 документов с очерёдностью <= 4 и, если такие есть, комиссия не оплачивается. */
  /* EVG 12/08/2011 Для банка ВУЗ аналогично. */
  lfBank.ConsrtuctByBic( {MFO_Bank} );
  if ( lfBank.is_EXV() or lfBank.is_VUZ() or lfBank.is_PRBB() ) //rr 28.10.2011 по просьбе байдуловой добавил в проверку ПРББ

     q = " select 1 " 
       + " from dpmpaym_dbt pm, dpmrmprop_dbt pr "
       + " where pm.t_PaymStatus       = 2000 "
       + "       and pm.t_DocKind      = 201 "
       + "       and pm.t_PayerAccount = ? "
       + "       and pr.t_PaymentId    = pm.t_PaymentId ";

       /* 20/07/2011 EVG По просьбе Гульмиры Б.
       + "       and pr.t_Priority    <= 4 ";*/

     cmd = rsdCommand( q );
     cmd.AddParam( "acc", RSDBP_IN, Account );

     rsb = rsdRecordSet( cmd );
     if( rsb.MoveNext() )
        return false;
     end;

  end;

  
  /* EVG Вообще непонятно, что хотели сказать всем этим кодом.
     Зачем прибавлять к свободному остатку счёта сумму документов картотеки?
     Если свободный остаток 0.00, то эта штука увеличивает его на сумму документов картотеки - бред.
     Зачем сравникать в конце свободный остаток и просто остаток - также непонятно.
  /* с учетом картотек */
  q = " select nvl(sum(ind.t_Sum),0) Sum" 
    + " from dpsindacc_dbt ind"
    + " where ind.t_account = '" + Account + "' "
    + " and ind.t_chapter = " + 1/*CHAPT1*/ + " and ind.t_fiid = " + string(FIID);
  rsb = TRsbDataSet( q );
  if( rsb.MoveNext() )
    AccountFreeRest = AccountFreeRest + rsb.Sum;
  end;

  if( FIID == NATCUR )
    AccountRest = RestA( Account, todate, NULL, 1/*CHAPT1*/ );
  else
    AccountRest = RestAC( Account, FIID, todate, NULL, 1/*CHAPT1*/ );
  end;
  

  if( AccountRest > AccountFreeRest )
    stat = false;
  else
    stat = true;
  end;*/

  /* EVG Проверять нужно, хватает ли свободного остатка для оплаты комиссии + НДС.
  */
  if (AccountFreeRest >= ComNdsSum)
     return true;
  else
     return false;
  end;

 END;
***************************************************************************************************************************************************/


 MACRO IsPaymentForBankCommission( PaymentObj, Account )

  var obj1 = GetPrimObj(PaymentObj);
  //msgbox (account);

  if ( ((PaymentObj.PayerFiid > 0) or (PaymentObj.ReceiverFiid > 0))
       and
         ( (subStr(Account, 1, 5) == "30109")
            or
           (subStr(Account, 1, 5) == "30111")
            or
           (subStr(Account, 1, 5) == "30231")
         )
       and
       (obj1.Origin != 2000) )            // EVG Кроме документов "Перечислений на основании распоряжения к транзитному счету"

     return true;
  end;

  return false;
END;



MACRO IsPaymentForBeneficiaryCommission( PaymentObj )
  var obj1 = GetPrimObj(PaymentObj);

  if ( ( (PaymentObj.PayerFiid > 0) or (PaymentObj.ReceiverFiid > 0) )
       and
       (obj1.Origin != 2000)         // EVG Кроме документов "Перечислений на основании распоряжения к транзитному счету"
       and
       (GetChargesKind(PaymentObj.PaymentID) == CHARGESKIND_Ben) )

     return true;
  end;

  return false;
END;



MACRO IsBeneficiaryCommission( CommNumber )

  if ( CheckArray(BENeficiaryCom, CommNumber) )
     return true;
  end;

  return false;
END;


/* joy  23.04.2013 I-00361513-2 Добавила проверку, что счет не закрытый */
MACRO CheckUserField( ClnID, UsFld )
  var query, rs, cmd;
    
  query = " Select 1 from DUAL " +
          "  Where Exists ( Select t_UserTypeAccount From DAccount_dbt " +
          "                  Where t_Chapter       = 1 " +
          "                    and t_Client        = ? " +
          "                    and instr (t_UserTypeAccount, ? ) >0  " + 
          "                    and t_open_close != 'З') ";
  //msgbox (query);
  debugbreak;
  cmd = rsdcommand(query);
  cmd.AddParam("", RSDBP_IN,ClnID);
  cmd.AddParam("", RSDBP_IN,UsFld);
  rs = rsdRecordSet( cmd );

  if (rs and rs.moveNext())
     return true;
  end;

  return false;
END;


MACRO GetCom34ERecordSet( Account, Origin, BegDate, EndDate,  docKind, docid)
  var query, rs, cmd;
  var OriginClause = "";

  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin = ? ";
  else
     OriginClause = " and ord.t_Origin <> ? ";
  end;


     query = " Select paym.t_PaymentID, paym.t_Amount " +
             "   From DPmPaym_dbt paym, DPsPayOrd_dbt ord, DPmRmProp_dbt prop, DAccount_dbt acc " +
             "  Where paym.t_dockind = ? "  +
             "    AND paym.t_documentid = ? "  +
             "    AND paym.t_PayerAccount  ? "  +
             "    and acc.t_Account = paym.t_PayerAccount " +
             "    and INSTR (acc.t_type_account, 'Z') = 0 " +                               // Кроме платежей клиентов по зарплатным проектам
             "    and subStr(paym.t_ReceiverAccount, 1, 3) not between '401' and '404' " +           // Кроме бюджетных платежей

             /* Кроме платежей на счета физ. лиц */
             "    and subStr(paym.t_ReceiverAccount, 1, 3) not in ('423', '426') " +
             "    and subStr(paym.t_ReceiverAccount, 1, 5) not in ('40817', '40820','30232') " +

             "    and paym.t_PaymStatus = 32000 " +                           // Только закрытые
             "    and paym.t_PayerBankID <> paym.t_ReceiverBankID " +
             "    and ord.t_OrderID = paym.t_DocumentID " +
             "    and prop.t_paymentid = paym.t_paymentid " +
             "    and prop.t_shifroper <> 16 "+                                 // Кроме платёжных ордеров оплаты картотеки 2
             "    AND EXISTS (SELECT ARH.T_ACCTRNID "+
             "                  FROM   dacctrn_dbt arh, dpmdocs_dbt pmd "+
             "                 WHERE ARH.T_ACCTRNID = PMD.T_ACCTRNID"+
             "                   AND pmd.t_paymentid = paym.t_paymentid "+
             "                   and ord.t_origin <> 3201 "+ // 05.02.2014 joy Перенос модифкации от 11.12.2013  C-25038 Исключаем происхождение "Счет на оплату"
             "                   AND arh.t_chapter = 1                  "+
             "                   AND arh.t_date_carry BETWEEN ? AND ? ) " + OriginClause;

          cmd = rsdcommand(query);
          cmd.AddParam("", RSDBP_IN,docKind);
          cmd.AddParam("", RSDBP_IN,docid);
          cmd.AddParam("", RSDBP_IN,Account);
          cmd.AddParam("", RSDBP_IN,BegDate);
          cmd.AddParam("", RSDBP_IN,EndDate);
          cmd.AddParam("", RSDBP_IN,CLB_DocOrigin);
      //  msgbox (query);
       // println(query);
  rs = rsdRecordSet(cmd);
  return rs;
END;


/*
FIV Изменил алгоритм: 
1. Добавил хинт указания таблице проводок на конкретный индекс, без этого катастрофические тормоза
2. Внес в запрос определение категории на платеже сразу - если она должна быть, или ее отсутствие, если ее не должно быть
3. Сумма и количество тоже считается сразу, а не в цикле макроса
4. Параметром оставил только лицевой счет, т.к. за период расчета комиссии меняется только он, остальные параметры постоянны - по идее сокращение времени подстановки параметров
*/
MACRO GetCom34RecordSet( Account, Origin, BegDate, EndDate, Tarif )
  var query, rs, cmd,SQL, StrNOT, StrAttrId;
  var OriginClause = "";

  if (ValType(Tarif) == V_UNDEF)
     StrAttrId = "";
     StrNot = "NOT";
  else    
     StrAttrId = " AND oc.t_attrid = "+string(Tarif);
     StrNot = "";
  end;
  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin =  "+CLB_DocOrigin;
  else
     OriginClause = " and ord.t_Origin <> "+CLB_DocOrigin;
  end;


SQL = " SELECT   COUNT(paym.t_paymentid), SUM(paym.t_amount) ";
SQL = SQL + "  FROM   dpmpaym_dbt paym, ";
SQL = SQL + "         dpspayord_dbt ord, ";
SQL = SQL + "         dpmrmprop_dbt prop, ";
SQL = SQL + "         daccount_dbt acc ";
SQL = SQL + " WHERE       paym.t_payeraccount = ?";
SQL = SQL + "         AND acc.t_account = paym.t_payeraccount ";
SQL = SQL + "         AND acc.t_chapter = paym.t_chapter ";
SQL = SQL + "         AND acc.t_type_account NOT LIKE '%Z%' ";
SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
SQL = SQL + "         /* Кроме платежей на счета физ. лиц */ ";
SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT IN ('423', '426') ";
SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 5) NOT IN ";
SQL = SQL + "                  ('40817', '40820', '30232') ";
SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
//SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid "; RR 13.05.2014 непонятно зачем тут это было нужно
SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
SQL = SQL + "         AND prop.t_shifroper <> '16' ";
SQL = SQL + "         AND EXISTS ";
SQL = SQL + "               (SELECT ARH.T_ACCTRNID ";
SQL = SQL + "                  FROM   dpmdocs_dbt pmd, dacctrn_dbt arh ";
SQL = SQL + "                 WHERE       pmd.t_paymentid = paym.t_paymentid ";
SQL = SQL + "                         AND ARH.T_ACCTRNID = PMD.T_ACCTRNID ";
SQL = SQL + "                         AND arh.t_chapter = 1 ";
SQL = SQL + "                         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate)+") ";
SQL = SQL + "         AND "+StrNOT+" EXISTS ";
SQL = SQL + "               (SELECT   1 ";
SQL = SQL + "                  FROM   dobjatcor_dbt oc ";
SQL = SQL + "                 WHERE       oc.t_objecttype = 501 ";
SQL = SQL + "                         AND oc.t_groupid = 10 "+StrAttrId;
SQL = SQL + "                         AND oc.t_object = LPAD(paym.t_paymentid, 10, 0)) " + OriginClause;

          cmd = rsdcommand(SQL);
          cmd.AddParam("", RSDBP_IN, Account);
      //  msgbox (query);
       // println(query);
  rs = rsdRecordSet(cmd);
  return rs;
END;

/* EVG 22/04/2013 Добавлен новый параметр ReturnUnsummarizedRecordset - указание функции возвращать
       не COUNT/SUM, а каждый документ отдельно - для реализации C-19221 (граничные условия 3.4.8 на каждый документ).*/
MACRO GetCom34RecordSetB( Account, Origin, BegDate, EndDate, Tarif, ID, AnalizeTime, ReturnUnsummarizedRecordset )
  var query, rs, cmd, SQL, StrNOT, StrAttrId, rs1, cm1, BESP = "";
  var OriginClause = "";
  var DayEndTime;
  
/* RR 28.09.2012 по заявке I-00260157-2
  cm1 = rsdcommand("  SELECT   1 "+
  "  FROM   (  SELECT   * "+
  "              FROM   dsfcontrplan_dbt "+
  "             WHERE   T_SFCONTRID = ? AND t_sfplanid IN ("+TP_OLD+") "+
  "          ORDER BY   t_begin DESC) "+
  " WHERE   ROWNUM = 1 ");
  cm1.addparam("sf", RSDBP_IN, ID );
  cm1.execute();

  rs1 = rsdrecordset(cm1);

  if ( rs1.movenext)
     BESP =  "         AND INSTR ('ЭПТ', prop.T_PAYMENTKIND) > 0 "; //Tikh
  end;  
  */
  
  if (ValType(Tarif) == V_UNDEF)
     StrAttrId = "";
     StrNot = "NOT";
  else    
     StrAttrId = " AND oc.t_attrid = "+string(Tarif);
     StrNot = "";
  end;
    // 05.02.2014 joy Перенос модифкации от 11.12.2013 C-25038 Исключаем или добавляем происхождение "Счет на оплату"
  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin =  "+CLB_DocOrigin;
  else
     OriginClause = " and ord.t_Origin <> "+CLB_DocOrigin+" and ord.t_Origin <> 3201";
  end;


  /* EVG 21/04/2011 Доработка для возможности вызова без указания конкретного счёта */
  var fixAccountClause = "",
      selectClause     = " paym.t_PaymentId, paym.t_PayerAccount, paym.t_ReceiverAccount, paym.t_Amount, paym.t_ReceiverBankId, paym.t_Fiid ";
  if ( Account )
     fixAccountClause = " AND arh.t_account_payer = ? ";
     selectClause     = " COUNT( paym.t_paymentid ) cntDoc, SUM( paym.t_amount ) sumDoc ";
  end;

  /* EVG 22/04/2013 Выборка информации по каждому документу */
  if( ReturnUnsummarizedRecordset )
     selectClause = " paym.t_PaymentId pmId, paym.t_Amount pmAmount";
  end;


  /* EVG 21/04/2011 Запрос полностью переписан для исключения EXISTS по dacctrn_dbt.
     Поддерживается возможность вызова без указания конкретного счёта. */
  debugbreak;
  SQL = " SELECT   " + selectClause;
  SQL = SQL + "  FROM  dacctrn_dbt arh,    ";
  SQL = SQL + "        dpmdocs_dbt pmd,    ";
  SQL = SQL + "        dpmpaym_dbt paym,   ";
  SQL = SQL + "        dpspayord_dbt ord,  ";
  SQL = SQL + "        dpmrmprop_dbt prop, ";
  SQL = SQL + "        daccount_dbt acc    ";
  SQL = SQL + " WHERE   arh.t_chapter = 1 ";
  SQL = SQL + "         " + fixAccountClause;
  SQL = SQL + "         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate);
  SQL = SQL + "         AND acc.t_account = arh.t_account_payer ";
  SQL = SQL + "         AND acc.t_chapter = arh.t_chapter ";
// joy По C-31392 if (not LifeBank.is_SLD )
//    SQL = SQL + "         AND acc.t_type_account NOT LIKE '%Z%' ";
//  end;
  SQL = SQL + "         AND PMD.T_ACCTRNID = ARH.T_ACCTRNID ";
  SQL = SQL + "         AND arh.t_state = 1 "; //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
  SQL = SQL + "         AND paym.t_paymentid = pmd.t_paymentid ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
  SQL = SQL + "         /* Кроме платежей на счета физ. лиц */ ";
    // joy По C-31392 изменяю исключения на новые
//  SQL = SQL + "         and ( substr ( paym.t_receiveraccount, 1, 3 ) not in ('423', '426') ";
//  SQL = SQL + "            and SUBSTR(paym.t_receiveraccount, 1, 5) NOT IN ('40817', '40820') ";
//  SQL = SQL + "            and not ( substr ( paym.t_receiveraccount, 1, 5 ) in ('30232', '47422')"; //RR 20.10.2011 По просьбе Байдуловой Г.В.
//  SQL = SQL + "              and  ( regexp_like ( arh.t_ground, '(40817|40820|423|426)' ) ) ) ) ";//RR 26.10.2011 По просьбе Байдуловой Г.В.
  SQL = SQL + "         AND ( (substr (paym.t_receiveraccount, 1, 3) not in ('423', '426') ";
  SQL = SQL + "                and substr (paym.t_receiveraccount, 1, 5) not in ('40817', '40820') ";
  SQL = SQL + "                and not (substr (paym.t_receiveraccount, 1, 5) in ('30232', '47422', '30301', '30223') ";
  SQL = SQL + "                         and (  regexp_like (arh.t_ground, '(40817|40820\\d{15})') ";
  SQL = SQL + "                             or regexp_like (arh.t_ground, '(423|426)\\d{17}') ";
  SQL = SQL + "                             or regexp_like (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' )  " ;
  SQL = SQL + "                             or regexp_like (arh.t_ground, '\\sп/к\\s') " ;
  SQL = SQL + "                             or regexp_like ( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ))) ";
  SQL = SQL + "             OR ( (  (SUBSTR( paym.t_receiveraccount, 1, 3 )  IN ('423', '426') ";
  SQL = SQL + "                     or SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') ) "; 
  SQL = SQL + "                   AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') ";
  SQL = SQL + "                        or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
  SQL = SQL + "                   ) ";
  SQL = SQL + "                 OR (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422', '30301', '30223') "; 
  SQL = SQL + "                    AND (REGEXP_LIKE (arh.t_ground, '(40817|40820\\d{15})') OR REGEXP_LIKE ( arh.t_ground, '(423|426)\\d{17}' ) " ;
  SQL = SQL + "                         or regexp_like (arh.t_ground, '\\sп/к\\s') " ;
  SQL = SQL + "                         OR REGEXP_LIKE( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ";
  SQL = SQL + "                         OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) ) "; 
  SQL = SQL + "                 AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') ";
  SQL = SQL + "                      or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
  SQL = SQL + "             ) ) )";
// --- end joy
  SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
  SQL = SQL + "         AND paym.t_dockind <> 16 ";// joy По просьбе Петренко О. в рамках С-32315
  SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
  SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid ";
  SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
  SQL = SQL + "         AND paym.t_receiverbankid NOT IN ( SELECT code.t_objectid "; //RR 10.07.2012 Теперь платежи между банками группы комиссией не облагаются
  SQL = SQL + "                                              FROM dobjcode_dbt code ";
  SQL = SQL + "                                             WHERE code.t_code IN ("+БИКиБанковГруппы+") ";
  SQL = SQL + "                                               AND code.t_codekind = 3 ";
  SQL = SQL + "                                               AND code.t_objecttype = 3) ";
  SQL = SQL +           BESP;
  SQL = SQL + "         AND prop.t_shifroper <> '16' ";
  SQL = SQL +           OriginClause;
  
  if (LifeBank.is_SLD )
    SQL = SQL + " AND NOT (SUBSTR(paym.t_receiveraccount, 1, 5) IN ('30301', '30232','47422', '30223') ";
    SQL = SQL + "          AND (REGEXP_LIKE ('\\s' || LOWER (PROP.T_GROUND),'(40817|40820|423|426)') ";
    SQL = SQL + "               OR   REGEXP_LIKE ('\\s' || LOWER (PROP.T_RECEIVERNAME),'(40817|40820|423|426)'))) ";
  end;
  if (( Account ) and (ValType(AnalizeTime) == V_UNDEF))
     SQL = SQL + "         AND " + StrNOT + " EXISTS ";
     SQL = SQL + "               (SELECT   1 ";
     SQL = SQL + "                  FROM   dobjatcor_dbt oc ";
     SQL = SQL + "                 WHERE       oc.t_objecttype = 501 ";
     SQL = SQL + "                         AND oc.t_groupid = 10 " + StrAttrId;
     SQL = SQL + "                         AND oc.t_object = LPAD(paym.t_paymentid, 10, 0)) ";
  elif (( Account ) and (AnalizeTime))
    DayEndTime = GetOperDayEndTime(); 
    if (AnalizeTime == 1)
     SQL = SQL + "         AND DECODE ( ";
     SQL = SQL + "         ord.t_userfield1, ";
     SQL = SQL + "         CHR (1), ";
     SQL = SQL + "         TO_DATE ('01.01.0001 01.01.01', 'dd.mm.yyyy hh24.mi.ss'), ";
     SQL = SQL + "         TO_DATE (ord.t_userfield1, 'dd.mm.yyyy hh24.mi.ss')) ";
     SQL = SQL + "          <= TO_DATE ('" + EndDate + " " + DayEndTime + "', 'dd.mm.yyyy hh24:mi:ss') ";
    elif (AnalizeTime == 2)
     SQL = SQL + "         AND DECODE ( ";
     SQL = SQL + "         ord.t_userfield1, ";
     SQL = SQL + "         CHR (1), ";
     SQL = SQL + "         TO_DATE ('01.01.0001 01.01.01', 'dd.mm.yyyy hh24.mi.ss'), ";
     SQL = SQL + "         TO_DATE (ord.t_userfield1, 'dd.mm.yyyy hh24.mi.ss')) ";
     SQL = SQL + "          > TO_DATE ('" + EndDate + " " + DayEndTime + "', 'dd.mm.yyyy hh24:mi:ss') ";
    end;
  end;

  /* EVG 15/05/2012 Доработка для исключения признака категории 200 "Категория для пакетов комиссий" */
  SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
  SQL = SQL + "                           FROM dobjatcor_dbt oc ";
  SQL = SQL + "                          WHERE     oc.t_objecttype = 3 ";
  SQL = SQL + "                                AND oc.t_groupid    = 200 ";
  SQL = SQL + "                                AND oc.t_object     = LPAD(acc.t_client, 10, 0)) ";

  /* EVG 12/12/2012 Доработка для исключения пакетного предложения по ДО */
  SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
  SQL = SQL + "                           FROM dconstrcom_dbt ";
  SQL = SQL + "                          WHERE     t_object         = acc.t_account ";
  //SQL = SQL + "                                AND t_state          = 0 ";
  SQL = SQL + "                                AND t_datepack      <= "+GetSQLDate(BegDate);
  SQL = SQL + "                                AND(    t_dateclose  > "+GetSQLDate(EndDate);
  SQL = SQL + "                                     OR t_dateclose  = to_date('01-01-0001','dd-mm-rrrr') )) ";

  cmd = null;
  cmd = rsdcommand( SQL );

  //debugbreak;
  /* EVG 21/04/2011 Передача параметра только при вызове по конкретному счёту */
  if ( Account )
     cmd.AddParam( "acc", RSDBP_IN );
     cmd.Value( "acc" ) = Account;
     cmd.Execute();
     /* Возвращаем rsdRecordSet(), т.к. необходима передача параметра, а TRsbDataSet() отказывается
        работать в вызывающем модуле - видимо из-за того, что cmd туда не передаётся. */
     rs = rsdRecordSet( cmd );
  else
     /* EVG Нужно возвращать TRsbDataSet() из-за специфики обработки в вызывающем модуле */
     rs = TRsbDataSet( sql );
  end;


  return rs;
END;


/* EVG 24/01/2013 Добавил входящий параметр Origin для совместимости с процедурой подключения комиссий к ДО.
   В расчёте параметр не используется, просто занимает место.
MACRO GetCom37RecordSetB( Account, BegDate, EndDate)*/
MACRO GetCom37RecordSetB( Account, Origin, BegDate, EndDate)
  var query, rs, cmd, SQL;


  /* EVG 24/01/2013 Доработка для возможности вызова без указания конкретного счёта */
  var fixAccountClause = "",
      selectClause     = " paym.t_PaymentId, paym.t_PayerAccount, paym.t_ReceiverAccount, paym.t_Amount, paym.t_ReceiverBankId, paym.t_Fiid ";
  if ( Account )
     fixAccountClause = " AND paym.t_payeraccount = ?";
     selectClause     = " COUNT(paym.t_paymentid), SUM(paym.t_amount) ";
  end;

  /* EVG 24/01/2013 Запрос полностью переписан для исключения EXISTS по dacctrn_dbt.
     Поддерживается возможность вызова без указания конкретного счёта. */
  debugbreak;
  SQL = " SELECT   " + selectClause;
  SQL = SQL + "  FROM  dacctrn_dbt arh,    ";
  SQL = SQL + "        dpmdocs_dbt pmd,    ";
  SQL = SQL + "        dpmpaym_dbt paym,   ";
  SQL = SQL + "        dpmrmprop_dbt prop, ";
  SQL = SQL + "        daccount_dbt acc    ";
  SQL = SQL + " WHERE   arh.t_chapter = 1 ";
  SQL = SQL + "         " + fixAccountClause;
  SQL = SQL + "         AND arh.t_date_carry      BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate);
  SQL = SQL + "         AND acc.t_account               = arh.t_account_payer ";
  SQL = SQL + "         AND acc.t_chapter               = arh.t_chapter ";
  SQL = SQL + "         AND acc.t_type_account   NOT LIKE '%Z%' ";
  SQL = SQL + "         AND PMD.T_ACCTRNID              = ARH.T_ACCTRNID ";
  SQL = SQL + "         AND arh.t_state = 1 "; //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
  SQL = SQL + "         AND paym.t_paymentid            = pmd.t_paymentid ";
  SQL = SQL + "         AND SUBSTR(paym.t_receiveraccount, 1, 3) NOT BETWEEN '401' AND '404' ";
  SQL = SQL + "         AND paym.t_paymstatus           = 32000 ";
  SQL = SQL + "         AND paym.t_payerbankid         <> paym.t_receiverbankid ";
  SQL = SQL + "         AND prop.t_paymentid            = paym.t_paymentid ";
  SQL = SQL + "         AND prop.t_paymentkind          = 'С' ";
  SQL = SQL + "         AND prop.t_shifroper           <> '16' ";

  /* EVG 12/12/2012 Доработка для исключения пакетного предложения по ДО */
  SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
  SQL = SQL + "                           FROM dconstrcom_dbt ";
  SQL = SQL + "                          WHERE     t_object         = acc.t_account ";
  //SQL = SQL + "                                AND t_state          = 0 ";
  SQL = SQL + "                                AND t_datepack      <= "+GetSQLDate(BegDate);
  SQL = SQL + "                                AND(    t_dateclose  > "+GetSQLDate(EndDate);
  SQL = SQL + "                                     OR t_dateclose  = to_date('01-01-0001','dd-mm-rrrr') )) ";

  cmd = null;
  cmd = rsdcommand( SQL );

  //debugbreak;
  /* EVG 24/01/2013 Передача параметра только при вызове по конкретному счёту */
  if ( Account )
     cmd.AddParam( "acc", RSDBP_IN );
     cmd.Value( "acc" ) = Account;
     cmd.Execute();
     /* Возвращаем rsdRecordSet(), т.к. необходима передача параметра, а TRsbDataSet() отказывается
        работать в вызывающем модуле - видимо из-за того, что cmd туда не передаётся. */
     rs = rsdRecordSet( cmd );
  else
     /* EVG Нужно возвращать TRsbDataSet() из-за специфики обработки в вызывающем модуле */
     rs = TRsbDataSet( sql );
  end;
/*
SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
SQL = SQL + "         AND paym.t_payerbankid <> paym.t_receiverbankid ";
//SQL = SQL + "         AND ord.t_orderid = paym.t_paymentid "; RR 13.05.2014 непонятно зачем тут это было нужно
SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
SQL = SQL + "         AND prop.T_PAYMENTKIND = 'С' "; //Tikh
SQL = SQL + "         AND prop.t_shifroper <> '16' ";
SQL = SQL + "         AND EXISTS ";
SQL = SQL + "               (SELECT ARH.T_ACCTRNID ";
SQL = SQL + "                  FROM   dpmdocs_dbt pmd, dacctrn_dbt arh ";
SQL = SQL + "                 WHERE       pmd.t_paymentid = paym.t_paymentid ";
SQL = SQL + "                         AND ARH.T_ACCTRNID = PMD.T_ACCTRNID ";
SQL = SQL + "                         AND arh.t_chapter = 1 ";
SQL = SQL + "                         AND arh.t_date_carry BETWEEN "+GetSQLDate(BegDate)+" AND "+GetSQLDate(EndDate)+") ";

/* EVG 12/12/2012 Доработка для исключения пакетного предложения по ДО */
SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
SQL = SQL + "                           FROM dconstrcom_dbt ";
SQL = SQL + "                          WHERE     t_object         = acc.t_account ";
//SQL = SQL + "                                AND t_state          = 0 ";
SQL = SQL + "                                AND t_datepack      <= "+GetSQLDate(BegDate);
SQL = SQL + "                                AND(    t_dateclose  > "+GetSQLDate(EndDate);
SQL = SQL + "                                     OR t_dateclose  = to_date('01-01-0001','dd-mm-rrrr') )) ";

          cmd = rsdcommand(SQL);
          cmd.AddParam("", RSDBP_IN, Account);
//        msgbox (query);
//        println(query);
  rs = rsdRecordSet(cmd); */

  return rs;
END;



MACRO GetCom34_11_18RecordSet( Account, Origin, BegDate, EndDate, dayrset/*Рекордсет за день*/, monthrset/*рекордсет сначала месяца*/)
 var queryday, rsday, cmdday;
 var querymonth, rsmonth, cmdmonth;
 var OriginClause = "";
  
 /*FIV Возвращает первый день месяца*/
 private macro GetFirstDayForCurMonth(lastdate)
 var mm, yy;
    DateSplit(lastdate, null, mm, yy);
    return Date(1,mm,yy);
 end;

// 05.02.2014 joy Перенос модифкации от 11.12.2013 C-25038 Исключаем  происхождение "Счет на оплату"
  if ( Origin == CLB_DocOrigin )
     OriginClause = " and ord.t_Origin = ? ";
  else
     OriginClause = " and ord.t_Origin <> ? and ord.t_Origin <> 3201";
  end;

 /* EVG 12/12/2012 Проверка для исключения пакетного предложения по ДО */
 var ConstrComClause = " AND NOT EXISTS( SELECT 1  "+
                       "                   FROM dconstrcom_dbt " +
                       "                  WHERE     t_object         = acc.t_account " +
                       "                        AND t_datepack      <= to_date('"+BegDate+"')" +
                       "                        AND(    t_dateclose  > to_date('"+EndDate+"')" + 
                       "                             OR t_dateclose  = to_date('01.01.0001','dd.mm.yyyy') )) ";

    queryday = " Select count(paym.t_PaymentID) cnt " ;
    queryday = queryday + "   From DPmPaym_dbt paym, DPsPayOrd_dbt ord, DPmRmProp_dbt prop, DAccount_dbt acc " ;
    queryday = queryday + "   Where paym.t_PayerAccount                  = ? "  ;
    queryday = queryday +        "    and acc.t_Account                        = paym.t_PayerAccount " ;
    queryday = queryday +        "    and acc.t_Chapter = paym.t_Chapter                            " ;
    // joy По C-31392       "    and INSTR (acc.t_type_account, 'Z')      = 0 " +                               // Кроме платежей клиентов по зарплатным проектам
    queryday = queryday +        "    and subStr(paym.t_ReceiverAccount, 1, 3) not between '401' and '404' " ;           // Кроме бюджетных платежей
     /* Кроме платежей на счета физ. лиц */
    // joy 18.08.2014 C-32315 Для ВУЗа и ЭВ проверка будет другой, пока временно меняю для ВУЗа
    // joy 15.08.2014 В рамках выполнения C-31392 изменились условия исключения платежей на ФЛ
    if ( LifeBank.is_VUZ )
        queryday = queryday +  "    and subStr(paym.t_ReceiverAccount, 1, 3) not in ('423', '426') " ;
        queryday = queryday +  "    and subStr(paym.t_ReceiverAccount, 1, 5) not in ('40817', '40820','30232', '30223') " ;
    else
        queryday = queryday +  "    AND ( (substr (paym.t_receiveraccount, 1, 3) not in ('423', '426') " ;
        queryday = queryday +  "           and substr (paym.t_receiveraccount, 1, 5) not in ('40817', '40820') " ;
        queryday = queryday +  "           and not (substr (paym.t_receiveraccount, 1, 5) in ('30232', '47422', '30301', '30223') " ;
        queryday = queryday +  "                    and (  regexp_like (prop.t_ground, '(40817|40820\\d{15})') " ;
        queryday = queryday +  "                        or regexp_like (prop.t_ground, '(423|426)\\d{17}') " ;
        queryday = queryday +  "                        or regexp_like (prop.t_ground, '\\sп/к\\s') " ;
        queryday = queryday +  "                        or regexp_like (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) " ;
        queryday = queryday +  "                        or regexp_like ( '\\s'||lower (prop.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ))) " ;
        queryday = queryday +  "        OR ( (  (SUBSTR( paym.t_receiveraccount, 1, 3 )  IN ('423', '426') " ;
        queryday = queryday +  "                or SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') ) " ;
        if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ очередные изменения
             queryday = queryday +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') ";
        else
             queryday = queryday +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') ";
        end;
        if (LifeBank.is_EXV)
             queryday = queryday +  " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";
        end;
        queryday = queryday +  "                    or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
        queryday = queryday +  "              ) " ;
        queryday = queryday +  "            OR (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422', '30301', '30223') " ;
        queryday = queryday +  "               AND (REGEXP_LIKE (prop.t_ground, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.t_ground, '(423|426)\\d{17}' ) "  ;
        queryday = queryday +  "                    or regexp_like (prop.t_ground, '\\sп/к\\s') " ;
        queryday = queryday +  "                    OR REGEXP_LIKE( '\\s'||lower (prop.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) " ;
        queryday = queryday +  "                    OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) ) " ;
        if (LifeBank.is_EXV)
             queryday = queryday +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') ";

            // EVG 10/3/2016 Для ЭВ добавил исключение из расчёта комиссии платежей на счета Совкомбанка
            queryday = queryday + " and paym.t_receiverbankid NOT IN ( SELECT code.t_objectid                               " ;
            queryday = queryday + "                                      FROM dobjcode_dbt code                             " ;
            queryday = queryday + "                                     WHERE code.t_code = " + BIC_SOVCOMBANK_BRANCH_CENTRAL ;
            queryday = queryday + "                                       AND code.t_codekind = 3                           " ;
            queryday = queryday + "                                       AND code.t_objecttype = 3 )                   " ;

        else
             queryday = queryday +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') " ;
        end;
        queryday = queryday +  "                 or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
        queryday = queryday +  "        ) ) )" ;
    end;
    // --- end joy
    queryday = queryday +        "    and paym.t_PaymStatus                    = 32000  " ;                           // Только закрытые
    queryday = queryday +        "    and paym.t_PayerBankID                   <> paym.t_ReceiverBankID " ;
    queryday = queryday +        "    and ord.t_OrderID                        = paym.t_DocumentID " ;
    queryday = queryday +        "    and prop.t_paymentid                     = paym.t_paymentid " ;
    queryday = queryday +        "    and prop.t_shifroper                     <> 16 ";                                 // Кроме платёжных ордеров оплаты картотеки 2
    queryday = queryday +        "    AND EXISTS (SELECT 1 ";
    queryday = queryday +        "    FROM     dacctrn_dbt trn, dpmdocs_dbt pmd   ";
    queryday = queryday +        "    WHERE    trn.t_acctrnid  = pmd.t_acctrnid   ";
    queryday = queryday +        "         AND pmd.t_paymentid = paym.t_paymentid ";
    queryday = queryday +        "         AND trn.t_chapter   = 1                ";
    queryday = queryday +        "         AND trn.t_state   = 1                  "; // 21.09.2015 joy I-00580449
    queryday = queryday +        "         AND trn.t_date_carry BETWEEN ?         ";
    queryday = queryday +        "                                  AND ? ) " + OriginClause;

            /* EVG 12/12/2012 Добавим проверку для исключения пакетного предложения по ДО */
            queryday = queryday + ConstrComClause;


         cmdday = rsdcommand(queryday);
         cmdday.AddParam("", RSDBP_IN,Account);
         cmdday.AddParam("", RSDBP_IN,BegDate);
         cmdday.AddParam("", RSDBP_IN,EndDate);
         cmdday.AddParam("", RSDBP_IN,CLB_DocOrigin);
         
 rsday = rsdRecordSet(cmdday);
 SetParm(4, rsday);

    querymonth = " Select count(paym.t_PaymentID) cnt " ;
    querymonth = querymonth + "   From DPmPaym_dbt paym, DPsPayOrd_dbt ord, DPmRmProp_dbt prop, DAccount_dbt acc " ;
    querymonth = querymonth +        "  Where paym.t_PayerAccount                  = ? "  ;
    querymonth = querymonth +        "    and acc.t_Account                        = paym.t_PayerAccount " ;
    querymonth = querymonth +        "    and acc.t_Chapter = paym.t_Chapter                            " ;
// joy По C-31392         "    and INSTR (acc.t_type_account, 'Z')      = 0 " +                               // Кроме платежей клиентов по зарплатным проектам
    querymonth = querymonth +        "    and subStr(paym.t_ReceiverAccount, 1, 3) not between '401' and '404' " ;           // Кроме бюджетных платежей
            /* Кроме платежей на счета физ. лиц */
    // joy 15.08.2014 В рамках выполнения C-31392 изменились условия исключения платежей на ФЛ
    if ( (LifeBank.is_VUZ) )
        querymonth = querymonth +        "    and subStr(paym.t_ReceiverAccount, 1, 3) not in ('423', '426') " ;
        querymonth = querymonth +        "    and subStr(paym.t_ReceiverAccount, 1, 5) not in ('40817', '40820','30232', '30223') " ;
    else
        querymonth = querymonth +  "    AND ( (substr (paym.t_receiveraccount, 1, 3) not in ('423', '426') " ;
        querymonth = querymonth +  "           and substr (paym.t_receiveraccount, 1, 5) not in ('40817', '40820') " ;
        querymonth = querymonth +  "           and not (substr (paym.t_receiveraccount, 1, 5) in ('30232', '47422', '30301', '30223') " ;
        querymonth = querymonth +  "                    and (  regexp_like (prop.t_ground, '(40817|40820\\d{15})') " ;
        querymonth = querymonth +  "                        or regexp_like (prop.t_ground, '(423|426)\\d{17}') " ;
        querymonth = querymonth +  "                        or regexp_like (prop.t_ground, '\\sп/к\\s') " ;
        querymonth = querymonth +  "                        or regexp_like (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) " ;
        querymonth = querymonth +  "                        or regexp_like ( '\\s'||lower (prop.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ))) " ;
        querymonth = querymonth +  "        OR ( (  (SUBSTR( paym.t_receiveraccount, 1, 3 )  IN ('423', '426') " ;
        querymonth = querymonth +  "                or SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') ) " ;
        if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ очередные изменения
           querymonth = querymonth +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') ";
        else
           querymonth = querymonth +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|\\sоплат.{0,}\\sтруда') ";
        end;
        if (LifeBank.is_EXV)
           querymonth = querymonth +  " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";
        end;
        querymonth = querymonth +  "                    or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
        querymonth = querymonth +  "              ) " ;
        querymonth = querymonth +  "            OR (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422', '30301', '30223') " ;
        querymonth = querymonth +  "               AND (REGEXP_LIKE (prop.t_ground, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.t_ground, '(423|426)\\d{17}' ) "  ;
        querymonth = querymonth +  "                    or regexp_like (prop.t_ground, '\\sп/к\\s') " ;
        querymonth = querymonth +  "                    OR REGEXP_LIKE( '\\s'||lower (prop.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) " ;
        querymonth = querymonth +  "                    OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) ) " ;
         if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ очередные изменения
            querymonth = querymonth +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') ";

            // EVG 10/3/2016 Для ЭВ добавил исключение из расчёта комиссии платежей на счета Совкомбанка
            querymonth = querymonth + " and paym.t_receiverbankid NOT IN ( SELECT code.t_objectid                               " ;
            querymonth = querymonth + "                                      FROM dobjcode_dbt code                             " ;
            querymonth = querymonth + "                                     WHERE code.t_code = " + BIC_SOVCOMBANK_BRANCH_CENTRAL ;
            querymonth = querymonth + "                                       AND code.t_codekind = 3                           " ;
            querymonth = querymonth + "                                       AND code.t_objecttype = 3 )                       " ;

         else
            querymonth = querymonth +  "                AND (REGEXP_LIKE  ('\\s' || LOWER (prop.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|\\sоплат.{0,}\\sтруда') ";
         end;
        querymonth = querymonth +  "                    or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
        querymonth = querymonth +  "        ) ) )" ;

    end;
            // --- end joy
    querymonth = querymonth +        "    and paym.t_PaymStatus                    = 32000  " ;                           // Только закрытые
    querymonth = querymonth +        "    and paym.t_PayerBankID                   <> paym.t_ReceiverBankID " ;
    querymonth = querymonth +        "    and ord.t_OrderID                        = paym.t_DocumentID " ;
    querymonth = querymonth +        "    and prop.t_paymentid                     = paym.t_paymentid " ;
    querymonth = querymonth +        "    and prop.t_shifroper                     <> 16 ";                                 // Кроме платёжных ордеров оплаты картотеки 2
    querymonth = querymonth +        "    AND EXISTS (SELECT 1 ";
    querymonth = querymonth +        "    FROM     dacctrn_dbt trn, dpmdocs_dbt pmd   ";
    querymonth = querymonth +        "    WHERE    trn.t_acctrnid  = pmd.t_acctrnid   ";
    querymonth = querymonth +        "         AND pmd.t_paymentid = paym.t_paymentid ";
    querymonth = querymonth +        "         AND trn.t_chapter   = 1                ";
    querymonth = querymonth +        "         AND trn.t_state   = 1                  "; // 21.09.2015 joy I-00580449
    querymonth = querymonth +        "         AND trn.t_date_carry BETWEEN ?         ";
    querymonth = querymonth +        "                                  AND ? ) " + OriginClause;
            /* EVG 17/12/2013 end */

            /* EVG 12/12/2012 Добавим проверку для исключения пакетного предложения по ДО */
            querymonth = querymonth + ConstrComClause;

        
         cmdmonth = rsdcommand(querymonth);
         cmdmonth.AddParam("", RSDBP_IN,Account);
         cmdmonth.AddParam("", RSDBP_IN,GetFirstDayForCurMonth(BegDate));
         /*Проверка на первый день месяца*/
         if(GetFirstDayForCurMonth(BegDate) == EndDate)
           cmdmonth.AddParam("", RSDBP_IN,EndDate);
         else
           cmdmonth.AddParam("", RSDBP_IN,EndDate - 1);
         end;
         cmdmonth.AddParam("", RSDBP_IN,CLB_DocOrigin);
     //  msgbox (query);
      // println(query);
 rsmonth = rsdRecordSet(cmdmonth);

 SetParm(5, rsmonth);
 //return rsday;
END;


MACRO GetComBank32RecordSet( Account, BegDate, EndDate )
  var query, rs, cmd/*, {OurBank}*/;
  

  query = " Select paym.t_PaymentID, paym.t_Amount " +
          "   From DPmPaym_dbt paym " +
          "  Where ( paym.t_PayerAccount       = " + GetSQLString(Account) +
          "          or paym.t_ReceiverAccount = " + GetSQLString(Account) + ") " +
          "    and paym.t_PaymStatus           = 32000 " +                                    // Только закрытые
          "    and paym.t_ValueDate between      " + GetSQLDate(BegDate) +
          "                             and      " + GetSQLDate(EndDate) +
          "    and paym.t_PayerBankID <> paym.t_ReceiverBankID " +
          "    and paym.t_ReceiverBankID <> " + {OurBank} ;                                     // Банк получателя = ПРББ
  rs = rsdRecordSet(query);
  return rs;
END;


MACRO GetComToPhisFacesRecordSet( Account, Group, BegDate, EndDate, InsideGroup )
  var SQL, rs, cmd;
  var ExtIntClause = "";
  private var InsGrp = "";

  if (ValType(InsideGroup) == V_UNDEF )
     InsGrp = " AND paym.t_receiverbankid NOT IN ( SELECT code.t_objectid " 
             +"                                      FROM dobjcode_dbt code "
             +"                                     WHERE code.t_code IN ("+БИКиБанковГруппы+") "
             +"                                       AND code.t_codekind = 3 "
             +"                                       AND code.t_objecttype = 3) ";
  end;

  if ( Group == PMGROUP_Internal )
     ExtIntClause = " and paym.t_ReceiverBankID = ? ";
  elif ( Group == PMGROUP_External )
     ExtIntClause = " and paym.t_ReceiverBankID <> ? ";
  end;

  
  /* EVG 29/04/2011 Доработка для возможности вызова без указания конкретного счёта */
  var fixAccountClause = "",
      dateCarryClause  = " AND arh.t_date_carry BETWEEN " + GetSQLDate( BegDate ) + " AND " + GetSQLDate( EndDate ),
      selectClause     = " paym.t_PaymentId, paym.t_PayerAccount, paym.t_ReceiverAccount, paym.t_Amount, paym.t_ReceiverBankId, paym.t_Fiid ";
  if ( Account )
     fixAccountClause = " AND arh.t_account_payer = ? ";
     dateCarryClause  = " AND arh.t_date_carry BETWEEN ? AND ?";
     selectClause     = " paym.t_Amount ";
  else
     /* EVG 29/04/2011 Т.к. при вызове без указания счёта нам необходимо создать
        объект TRsbDataSet(), придётся вставить {OurBank} в строку ExtIntClause,
        т.к. передать его в виде параметра не получится из-за невозможности
        использования rsdcommand(). */
     ExtIntClause = strSubst( ExtIntClause, "?", string( {OurBank} ) );
  end;


  /* EVG 29/04/2011 Запрос полностью переписан для исключения EXISTS по dacctrn_dbt.
     Поддерживается возможность вызова без указания конкретного счёта. */
  
  SQL = " SELECT   " + selectClause;
  SQL = SQL + "  FROM  dacctrn_dbt arh,    ";
  SQL = SQL + "        dpmdocs_dbt pmd,    ";
  SQL = SQL + "        dpmpaym_dbt paym    ";
  SQL = SQL + " WHERE   arh.t_chapter = 1 ";
  SQL = SQL + "       " + fixAccountClause;
  SQL = SQL + "       " + dateCarryClause;
  SQL = SQL + "         AND PMD.T_ACCTRNID = ARH.T_ACCTRNID ";
  SQL = SQL + "         AND arh.t_state = 1 "; //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
  SQL = SQL + "         AND paym.t_paymentid = pmd.t_paymentid ";
  SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
  /* Кроме платежей в бюджет */
  SQL = SQL + "         AND SUBSTR( paym.t_receiveraccount, 1, 3 ) NOT BETWEEN '401' AND '404' ";
  /* Счёт плательщика - счёт юр. лица */
  SQL = SQL + "         AND ( subStr( paym.t_payeraccount, 1, 3 ) between '405' and '407' ";
  SQL = SQL + "               OR subStr( paym.t_payeraccount, 1, 5 ) IN ('40807', '40802') ) ";
  /* Счёт получателя - счёт физ. лица */
  SQL = SQL + "         AND ( SUBSTR( paym.t_receiveraccount, 1, 3 ) IN ('423', '426') ";
  SQL = SQL + "               OR SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') "; //RR 20.10.2011 По просьбе Байдуловой Г.В.
  SQL = SQL + "                 OR  (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422') "; 
  SQL = SQL + "                   AND REGEXP_LIKE (arh.t_ground, '(40817|40820|423|426)')) )"; //RR 26.10.2011 По просьбе Байдуловой Г.В.
  /* EVG 14/01/2012 В рамках C-16620 Добавлена проверка счетов-исключений */
  SQL = SQL + "         AND paym.t_receiveraccount not in ( '40817810809000060164', '40820810809000060164' ) ";
  SQL = SQL + InsGrp;
  SQL = SQL + ExtIntClause;
  //getstring(SQL);


  /* EVG 12/12/2012 Доработка для исключения пакетного предложения по ДО */
  SQL = SQL + "         AND NOT EXISTS( SELECT 1 ";
  SQL = SQL + "                           FROM dconstrcom_dbt ";
  SQL = SQL + "                          WHERE     t_object         = arh.t_account_payer ";
  //SQL = SQL + "                                AND t_state          = 0 ";
  SQL = SQL + "                                AND t_datepack      <= "+GetSQLDate(BegDate);
  SQL = SQL + "                                AND(    t_dateclose  > "+GetSQLDate(EndDate);
  SQL = SQL + "                                     OR t_dateclose  = to_date('01-01-0001','dd-mm-rrrr') )) ";


  /* EVG 29/04/2011 Передача параметров только при вызове по конкретному счёту */
  if ( Account )
     cmd = rsdcommand( SQL );
     cmd.AddParam( "", RSDBP_IN, Account );
     cmd.AddParam( "", RSDBP_IN, BegDate );
     cmd.AddParam( "", RSDBP_IN, EndDate );
     cmd.AddParam( "", RSDBP_IN, {OurBank} );
     rs = rsdRecordSet( cmd );
     /* Возвращаем rsdRecordSet(), т.к. необходима передача параметров, а TRsbDataSet() отказывается
        работать в вызывающем модуле - видимо из-за того, что cmd туда не передаётся. */
     rs = rsdRecordSet( cmd );
  else
     /* EVG Нужно возвращать TRsbDataSet() из-за специфики обработки в вызывающем модуле */
     rs = TRsbDataSet( sql );
  end;

   return rs;
END;


/*C-31392 15.08.2014 joy Отбор платежей на счета ФЛ + 10.10.2014 Внедрение C-32315 joy Изменения для  ЭВ*/
MACRO GetComToPhisFacesRecordSet_new( Payer, BegDate, EndDate, InsideGroup,  CommonPayments, IncludeZP, C_Code )
//  Параметры функции: Плательщик (ДО), даты, платежи внутри группы?, платежи со счетов ИП?, платежи зарплатные?, платежи общие (внутри группы и вне ее)?, остальные платежи? (т.е. не со счетов ИП и не зарплатные)
    //var LifeBics = "'044525986', '046311808', '046577781', '042908701', '044583859', '040702756', '042007755',  '041806835', '043601706', '044525732', '042406718', '046577859'";
    var LifeBics = getBICsBanks();
    var SQL, rs, cmd;
    var ExtIntClause = " ";
    var InsGrp = " ";
    var ZPAccount = " ";
    var ZPGround = " ";
    var Packet = " ";
    var LifeBank = fg_life_subject( {OurBank} );
    var com39_310 = false;

    if (ValType(C_Code) != V_UNDEF )
      com39_310 = true;
    end;

    //joy Отбираем платежи в сторонние банки или внутри гр. Лайф
    if ( (ValType(InsideGroup) == V_UNDEF ) or (InsideGroup == false) )
       InsGrp = " AND paym.t_receiverbankid NOT IN ";
    else
       InsGrp = " AND paym.t_receiverbankid  IN ";
    end;

    // joy пакетное предложение по ДО
    if (LifeBank.is_PRBB)
        Packet = "         AND NOT EXISTS( SELECT 1 "+
                "                           FROM dconstrcom_dbt " +
                "                          WHERE     t_object         = arh.t_account_payer " +
                "                                AND t_datepack      <= "+GetSQLDate(BegDate) +
                "                                AND(    t_dateclose  > "+GetSQLDate(EndDate) +
                "                                     OR t_dateclose  = to_date('01-01-0001','dd-mm-rrrr') )) ";
    end;
    debugbreak;
    // joy Счета-исключения по з\п проектам 2 счета - ПРББ, 2 сч. - Волгоград, 1 сч. - Саратов, 2 - ВУЗ, 1 - ГЭБ, 2 Солидарность
    ZPAccount = " AND paym.t_receiveraccount not in ('40817810809000060164', '40817810809000060164', '40817810901000000001', " +
                " '40820810901000000001', '40817810200000000706', '40817810701088880007', '40820810701088880007', '30232810209000060165', " + 
                " '40817810209000060164', '40820810209000060164' ) and paym.t_receiveraccount not like ('30232810_____08____7')"; // 10.10.2014 joy R-469873 добавлена маска счета  30232810?????08****7
  
    ZPGround = " REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])";
    ZPGround = ZPGround + "|погашен.{0,}\\sкредита|кредитн.{0,}\\sдоговор.{0,} ";
    ZPGround = ZPGround + "|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда' )";
  
  
  
  /* EVG 29/04/2011 Доработка для возможности вызова без указания конкретного счёта */
    var fixAccountClause = " ",
        dateCarryClause  = " AND arh.t_date_carry BETWEEN " +GetSQLDate(BegDate)+ " AND " +GetSQLDate(EndDate)  ,
        selectClause     = " distinct (paym.t_PayerAccount), paym.t_Fiid ";

    if  (ValType(Payer) != V_UNDEF ) 
       fixAccountClause = " AND paym.t_payer = :1" ;
       dateCarryClause  = " AND arh.t_date_carry BETWEEN " +GetSQLDate(BegDate)+ " AND " + GetSQLDate(EndDate);
       selectClause     = " /*+ LEADING(paym) INDEX(paym USR_DPMPAYM_DBT_IDXFC)*/  paym.t_Amount ";
    end;

    SQL = " SELECT  " + selectClause;
    SQL = SQL + "  FROM  dacctrn_dbt arh,    ";
    SQL = SQL + "        dpmdocs_dbt pmd,    ";
    SQL = SQL + "        dpmpaym_dbt paym,    ";
    SQL = SQL + "        dpmrmprop_dbt prop  ";
    SQL = SQL + " WHERE   arh.t_chapter = 1 ";
    SQL = SQL + "       " + fixAccountClause;
    SQL = SQL + "       " + dateCarryClause;
    SQL = SQL + "         AND pmd.t_acctrnid = arh.t_acctrnid ";
    SQL = SQL + "         AND paym.t_paymentid = pmd.t_paymentid ";
    SQL = SQL + "         AND prop.t_paymentid = paym.t_paymentid ";
    SQL = SQL + "         AND paym.t_paymstatus = 32000 ";
    SQL = SQL + "         AND paym.t_dockind <> 16 "; // joy 20.08.2014 Не платеж банка. По просьбе Петренко
    SQL = SQL + "         and prop.t_shifroper  not in ( '16', '02', '06') "; // 08.10.2014 joy C-33886 не оплата к2, не плат.треб, не инкасс.поручение
    SQL = SQL + "         AND paym.t_payerbankid = " + {OurBank};
    SQL = SQL + "         AND arh.t_state = 1 "; // 14.11.2014 joy  I-00532241 в 2031 это обязательно
    SQL = SQL + "         and arh.t_fiid_payer = 0 ";
    SQL = SQL + "         and arh.t_fiid_receiver = 0 "; // 30.12.2014 joy R-523619-1 только рублевые платежи
    /* Кроме платежей в бюджет и платежей на счета зарплатных проектов*/
    SQL = SQL + "         AND SUBSTR( paym.t_receiveraccount, 1, 3 ) NOT BETWEEN '401' AND '404' ";
    SQL = SQl +           ZPAccount;
    /* Счёт плательщика - счёт юр. лица или ИП.  */
    SQL = SQL + "         AND( subStr( paym.t_payeraccount, 1, 3 ) between '405' and '407' OR subStr( paym.t_payeraccount, 1, 5 ) IN ('40807', '40802', '40821') ) " ;
    if (LifeBank.is_EXV)
      SQL = SQL + " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";
      if (com39_310)
        SQL = SQL + " AND NOT ( REGEXP_LIKE (paym.t_ReceiverAccount, '40817[[:digit:]]{6}1200[[:digit:]]{4}') ";
        SQL = SQL + "           AND paym.t_receiverbankid IN ";
        SQL = SQL + "           ( SELECT code.t_objectid " ;
        SQL = SQL + "               FROM dobjcode_dbt code ";
        /* EVG 10/3/2016 Добавил БИК костромского Совкомбанка (SovComBIC - моск. филиал)
        SQL = SQL + "              WHERE code.t_code IN ("+SovComBIC+")";*/
        SQL = SQL + "              WHERE code.t_code IN ("+SovComBIC+","+BIC_SOVCOMBANK_BRANCH_CENTRAL+")";
        SQL = SQL + "                AND code.t_codekind = 3 ";
        SQL = SQL + "                AND code.t_objecttype = 3) ) ";
      end;
    end;
    
    /* Счёт получателя - счёт физ. лица */
    SQL = SQL + "         AND ( SUBSTR( paym.t_receiveraccount, 1, 3 ) IN ('423', '426') ";
    SQL = SQL + "               OR SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') "; 
    SQL = SQL + "                 OR  (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422', '30301', '30223') "; 
    SQL = SQL + "                   AND (REGEXP_LIKE (arh.t_ground, '(40817|40820\\d{15})') OR REGEXP_LIKE ( arh.t_ground, '(423|426)\\d{17}' ) " ;
    SQL = SQL + "                     or regexp_like (arh.t_ground, '\\sп/к\\s') " ;
    SQL = SQL + "                     OR REGEXP_LIKE( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ";
    SQL = SQL + "                     OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) ) ))"; 
    if ( (ValType(CommonPayments) == V_UNDEF ) or (CommonPayments == false) ) // если этот параметр передан, то внутренние это платежи или нет - не важно...
        SQL = SQL + InsGrp;
        SQL = SQL + "        ( SELECT code.t_objectid " ;
        SQL = SQL + "            FROM dobjcode_dbt code ";
        SQL = SQL + "           WHERE code.t_code IN ("+LifeBics+")";
        SQL = SQL + "             AND code.t_codekind = 3 ";
        SQL = SQL + "             AND code.t_objecttype = 3)  ";
    end;
    // joy 10.10.2014 C-32315 Для  ЭВ есть еще комиссии, которые списываются с зарплатных платежей
    if ( /*( LifeBank.is_EXV) and*/ (IncludeZP == true))
        if (( (ValType(InsideGroup) == V_UNDEF ) or (InsideGroup == false)  ) and ( LifeBank.is_EXV)) // 28.10.2014 joy C-33886 Для 3.4.10 (внешние платежи) зарплатные проекты  исключаем еще и по основанию
            SQL = SQL + "   AND NOT  REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') ";
        end;
        SQL = SQL + "       AND";
    else
        SQL = SQL + "       AND NOT";
    end;
    SQL = SQL + ZPGround; // 05.11.2014 joy добавила строку, упущенную при переносе на 2031
    SQL = SQL + Packet; 


    /* EVG 29/04/2011 Передача параметров только при вызове по конкретному счёту */
    if  (ValType(Payer) != V_UNDEF ) 
       cmd = rsdcommand( SQL );
       cmd.AddParam( "1", RSDBP_IN, payer.partyid  );
       rs = rsdRecordSet( cmd );
    else
        cmd = rsdcommand( SQL );
        rs = rsdRecordSet( cmd );
    end;

   return rs;
END;


MACRO GetComBank52RecordSet( IsCurrency, DocKind, DocAutoKey, CashSymb )
  var query, rs/*, {OurBank}*/;
  
  /* Определим сумму документа, отнесённую к кассовому символу (-ам), по которому взимается комиссия */
  query = " Select nvl(symb.t_Sum, 0) " +
          "   From DSymbCash_dbt symb " +
          "  Where symb.t_DocKind        = Decode( " + GetSQLChar(IsCurrency) +
          "                                          , Chr(0),  1  " +       // Рубли - DocKind = 1
          "                                          , Chr(88), 7  " +       // Валюта - DocKind = 7
          "                                                   , 1) " +       // Default 1
          "    and symb.t_Kind           = Decode( " + DocKind +
          "                                          , 410, 1 " +            // Объявление на взнос (410) - Kind = 1
          "                                          , 420, 2 " +            // Чек (420) - Kind = 2
          "                                               , 1) " +           // Default 1
          "    and symb.t_ApplicationKey = lPad( " + GetSQLString(DocAutoKey) + ", 34, '0') " +
          "    and trim(symb.t_Symbol)  in " + CashSymb;

  rs = rsdRecordSet(query);
  return rs;
END;

/*FIV Проверки на возможность формирования и проводки мемордера*/

MACRO ВозможенМемордер(acc)
var sql, rs, stat;
/*Если нет ареста на счет*/
SQL = " SELECT   COUNT (t_account) ";
SQL = SQL + "  FROM   (SELECT   ac.t_account ";
SQL = SQL + "            FROM   daccount_dbt ac ";
SQL = SQL + "           WHERE   INSTR (ac.t_type_account, 'Т') = 0 ";
SQL = SQL + "                   AND ac.t_account = '"+acc+"') ";
  rs = rsdRecordSet(sql);
  rs.MoveNext();
  stat = rs.Value(0) > 0;
  return stat;
END;

 


/* EVG 09.07.2010 Функции, которые раньше жили в com220p.mac и bank_com220p.mac */

CONST UsTypeAcCLB     = "Ё",             // Тип счёта "Интернет-Клиент"
      TypeRestricted  = "Т",             // Тип счёта "Арест на дебет"
      TypeCover       = "П",
      RestLimit       = $500000;         // Неснижаемый остаток по счетам некоммерческих организаций

MACRO CheckRestricted( sfcontr )
    var query, rs;
    var CountGeneral    = 0,
        CountRestricted = 0;
/*  if ({oper}==647)
      CountGeneral = 1; 
    end;
*/    /* Посчитаем общее количество счетов клиента */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Open_Close    = Chr(0) " +
            "    and t_Client        = " + sfcontr.PartyID +
            "    and SubStr(t_Account, 1, 3) between '405' and '408' ";
    rs = rsdRecordSet(query);
    while (rs and rs.moveNext())
       CountGeneral = CountGeneral + rs.value(0, null, V_INTEGER);
    end;


    /* Посчитаем количество счетов с типом "Т" */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter       = 1 " +
            "    and t_Open_Close    = Chr(0) " +
            "    and t_Client        = " + sfcontr.PartyID +
            "    and SubStr(t_Account, 1, 3) between '405' and '408' " +
            "    and instr(t_Type_Account, " + GetSQLString(TypeRestricted) + ") > 0 ";
    rs = rsdRecordSet(query);
    while (rs and rs.moveNext())
       CountRestricted = CountRestricted + rs.value(0, null, V_INTEGER);
    end;

    /* Если все счета имеют тип Т... */
    if (CountRestricted == CountGeneral)
       return true;
    end;

    return false;
end;

/* EVG 22/08/2012 Новая версия функции проверки наличия ограничений по счетам (C-12944).
   Отличия:
   - не анализируются валютные счета;
   - не обрабатываются счета СКС, платёжных агентов и с польз. типом "5";
   - запросы параметризованы.
*/
MACRO CheckRestricted_New( sfcontr )
    var query, cmd, rs;
    var CountGeneral    = 0,
        CountRestricted = 0;

    /* Посчитаем общее количество счетов клиента */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter                      = 1 " +
            "    and t_Code_currency                = 0 " +
            "    and t_Open_Close                   = Chr(0) " +
            "    and t_Client                       = ? " +
            "    and SubStr(t_Account, 1, 3)        between '405' and '408' " +

            "    and SubStr(t_Account, 11, 1)      <> '9' " +                   // Счета СКС не анализируются
            "    and SubStr(t_Account, 1, 5)       <> '40821' " +               // Счета платёжных агентов не анализируются
            "    and instr(t_UserTypeAccount, '5')  = 0 ";                      // Счета с "РКО не взимать" не анализируются
    cmd = rsdCommand( query );
    cmd.AddParam( "", RSDBP_IN, sfcontr.PartyID );

    rs  = rsdRecordSet( cmd );
    while (rs and rs.moveNext())
       CountGeneral = CountGeneral + rs.value(0, null, V_INTEGER);
    end;


    /* Посчитаем количество счетов с типом "Т" */
    query = query + " and instr(t_Type_Account, ?) > 0 ";       // Запрос тот же + проверка на тип Т

    cmd = rsdCommand( query );
    cmd.AddParam( "", RSDBP_IN, sfcontr.PartyID );
    cmd.AddParam( "", RSDBP_IN, TypeRestricted  );

    rs  = rsdRecordSet( cmd );
    while (rs and rs.moveNext())
       CountRestricted = CountRestricted + rs.value(0, null, V_INTEGER);
    end;

    /* Если все счета имеют тип Т... */
    if (CountRestricted == CountGeneral)
       return true;
    end;

    return false;
end;


MACRO CheckArrested( EndDate, sfcontr )
    var query, rs;
    var Account,
        CodeCur,
        RestSimpleAboveZero = false,
        RestFreeAboveZero = false,
        RestSimple = $0,
        RestFree = $0,
        Limit = 0;
    debugbreak;
    rs = rsdRecordSet(" SELECT   ACC.T_ACCOUNT, ACC.T_CODE_CURRENCY, ACCLIM.T_LIMIT " +
                      "   FROM   DACCOUNT_DBT ACC, DACCLIMIT_DBT ACCLIM " +
                      "  WHERE       ACC.T_CHAPTER = 1 " +
                      "          AND ACC.T_CLIENT = " + sfcontr.PartyID +
                      "          AND SUBSTR (ACC.T_ACCOUNT, 1, 3) BETWEEN '405' AND '408' " +
                      "          AND ACCLIM.T_ACCOUNT = ACC.T_ACCOUNT " +
                      "          AND ACCLIM.T_CHAPTER = ACC.T_CHAPTER " +
                      "          AND ACCLIM.T_CODE_CURRENCY = ACC.T_CODE_CURRENCY " +
                      "          AND ACCLIM.T_LIMITDATE = " +
                      "                (SELECT   MAX (T_LIMITDATE) " +
                      "                   FROM   DACCLIMIT_DBT " +
                      "                  WHERE       T_ACCOUNT = ACC.T_ACCOUNT " +
                      "                          AND T_CHAPTER = ACC.T_CHAPTER " +
                      "                          AND T_CODE_CURRENCY = ACC.T_CODE_CURRENCY)");
                      
    while (rs and rs.moveNext() and not RestFreeAboveZero)

      Account = rs.value(0, null, V_STRING);
      CodeCur = rs.value(1, null, V_INTEGER);

      if (CodeCur == 0)
         RestSimple = ABS( RestA( Account, EndDate, null, 1) );
      else
         RestSimple = ABS( RestAC( Account, CodeCur, EndDate, null, 1) );
      end;

      /* Если обычный остаток нулевой, свободный остаток не проверяем (ессно, он
         тоже нулевой, следовательно, нас не интересует). */
      if ( RestSimple > $0 )
         RestSimpleAboveZero = true;
         /* Для каждого счёта смотрим свободный остаток. Если хотя бы на оодном
            счёте своб. остаток больше нуля, выходим из цикла и возвращаем false
            из функции. */

         AccGetFreeAmount( RestFree, null, Account, 1, CodeCur, {curDate}, 6, 0 );
         
      //Kozina&Sagiyan добавили проверку на наличие лимита овердрафта по заявке I-041546 и ушли кушать и спать. 
      // EVG Уточните, куда пошли?... :)))
      Limit = rs.value(2, null, V_INTEGER);
         if ( (RestFree + Limit) > $0 )
            RestFreeAboveZero = true;
         end;
      end;
    end;

    if ( RestSimpleAboveZero and not RestFreeAboveZero )
       return true;
    end;

    return false;
end;

/* EVG 22/08/2012 Новая версия функции проверки ареста по счетам (C-12944).
   Отличия:
   - не анализируются валютные счета;
   - не обрабатываются счета СКС, платёжных агентов и с польз. типом "5";
   - запросы параметризованы.
*/
MACRO CheckArrested_New( EndDate, sfcontr )
    var query, cmd, rs;
    var Account,
        RestSimpleAboveZero = false,
        RestFreeAboveZero = false,
        RestSimple = $0,
        RestFree = $0,
        Limit = 0;
        
// 17.11.2014 joy Адаптация для 2031
    query = " Select acc.t_Account, acclim.t_limit from DAccount_dbt acc, dacclimit_dbt acclim " +
            "  Where acc.t_Chapter                      = 1 " +
            "    and acc.t_Code_currency                = 0 " +
            "    and t_Client                       = ? " +
            "    and SubStr(acc.t_Account, 1, 3)        between '405' and '408' " +
            "    AND INSTR (acc.t_Type_Account, 'П') = 0 " +                        //RR Исключаем счета покрытия
            "    and SubStr(acc.t_Account, 11, 1)      <> '9' " +                  // Счета СКС не анализируются
            "    and SubStr(acc.t_Account, 1, 5)       <> '40821' " +             // Счета платёжных агентов не анализируются
            "    and instr(acc.t_UserTypeAccount, '5')  = 0 "+                   // Счета с "РКО не взимать" не анализируются
            "    and acclim.t_account = acc.t_account " +
            "    and acclim.t_chapter = acc.t_chapter " +
            "    and acclim.t_code_currency = acc.t_code_currency " +
            "    and acclim.t_limitdate =  " +
            "        (select   max (t_limitdate) " + 
            "           from   dacclimit_dbt " +
            "          where   t_account = acc.t_account and t_chapter = acc.t_chapter and t_code_currency = acc.t_code_currency) ";
            
            
    
    cmd = rsdCommand( query );
    cmd.AddParam( "", RSDBP_IN, sfcontr.PartyID );

    rs = rsdRecordSet( cmd );
    while (rs and rs.moveNext() and not RestFreeAboveZero)

      Account = rs.value(0, null, V_STRING);

      //RestSimple = ABS( RestA( Account, EndDate, null, 1) ); /*07.10.2013 I-00431329 joy Думается мне, что анализировать нужно остаток на тек. момент, а не на дату окончания комиссии*/
      RestSimple = ABS( RestA( Account, {curDate}, null, 1) );

      /* Если обычный остаток нулевой, свободный остаток не проверяем (ессно, он
         тоже нулевой, следовательно, нас не интересует). */
      if ( RestSimple > $0 )
         RestSimpleAboveZero = true;
         /* Для каждого счёта смотрим свободный остаток. Если хотя бы на оодном
            счёте своб. остаток больше нуля, выходим из цикла и возвращаем false
            из функции. */

         AccGetFreeAmount( RestFree, null, Account, 1, NATCUR, {curDate}, 6, 0 );
         Limit = rs.value(1, null, V_INTEGER);

         if ( (RestFree + Limit) > $0 )
            RestFreeAboveZero = true;
         end;
      end;

    end;

    if ( RestSimpleAboveZero and not RestFreeAboveZero )
       return true;
    end;

    return false;
end;



MACRO CheckIndex2( EndDate, sfcontr )
    var query, rs;
    var CountAll = 0,
        CountI2  = 0,
        CurrAccRest = $0,
        RestFree    = $0;

    /* Общее количество счетов */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter                  = 1 " +
            "    and t_Code_currency            = 0 " +
            "    and t_Open_Close               = Chr(0) " +
            "    and instr(t_type_account, 'П') = 0 " +
            "    and t_Client                   = " + sfcontr.PartyID +
            "    and SubStr(t_Account, 1, 3) between '405' and '408' ";
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       CountAll = rs.value(0, null, V_INTEGER);
    end;


    /* Счета с К2 */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter                  = 1 " +
            "    and t_Code_currency            = 0 " +
            "    and t_Open_Close               = Chr(0) " +
            "    and t_Index2                  != Chr(0) " +
            "    and instr(t_type_account, 'П') = 0 " +
            "    and t_Client                   = " + sfcontr.PartyID +
            "    and SubStr(t_Account, 1, 3) between '405' and '408' ";
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       CountI2 = rs.value(0, null, V_INTEGER);
    end;

   
    //msgbox (CountAll, "|", CountI2);

    /* Если К2 стоит по всем счетам клиента */
    if (CountI2 == CountAll)

       rs = rsdRecordSet(" SELECT   ACC.T_ACCOUNT ACC, " +
                         "          ACC.T_CODE_CURRENCY CUR, " +
                         "          ACC.T_CHAPTER CHAP, " +
                         "          ACCLIM.T_LIMIT LIM " +
                         "   FROM   DACCOUNT_DBT ACC, DACCLIMIT_DBT ACCLIM " +
                         "  WHERE       ACC.T_CHAPTER = 1 " +
                         "          AND ACC.T_OPEN_CLOSE = CHR (0) " +
                         "          AND ACC.T_CODE_CURRENCY != 0 " +
                         "          AND ACC.T_CLIENT = " + sfcontr.PartyID +
                         "          AND SUBSTR (ACC.T_ACCOUNT, 1, 3) BETWEEN '405' AND '408' " +
                         "          AND ACCLIM.T_ACCOUNT = ACC.T_ACCOUNT " +
                         "          AND ACCLIM.T_CHAPTER = ACC.T_CHAPTER " +
                         "          AND ACCLIM.T_CODE_CURRENCY = ACC.T_CODE_CURRENCY " +
                         "          AND ACCLIM.T_LIMITDATE = " +
                         "                (SELECT   MAX (T_LIMITDATE) " +
                         "                   FROM   DACCLIMIT_DBT " +
                         "                  WHERE       T_ACCOUNT = ACC.T_ACCOUNT " +
                         "                          AND T_CHAPTER = ACC.T_CHAPTER " +
                         "                          AND T_CODE_CURRENCY = ACC.T_CODE_CURRENCY) ");
       while (rs and rs.moveNext())

          AccGetFreeAmount( RestFree, 
                            null, 
                            rs.value("acc", null, V_STRING),
                            rs.value("chap", null, V_INTEGER),
                            rs.value("cur", null, V_INTEGER),
                            EndDate,
                            6,
                            0 );
          
          CurrAccRest = CurrAccRest + RestFree + rs.value("lim", null, V_MONEY);

          
          //msgbox (CurrAccRest, " - ", rs.value("acc", null, V_STRING), " - ", rs.value("lim", null, V_MONEY));
       end;


       //msgbox (CurrAccRest);
       /* Освобождение от комиссии - только если на вылютных счетах нет средств */
       debugbreak;
      /* if (CurrAccRest == $0) 
      19-06-2012 joy I-00188424-2 Если к валютному счету есть претензии, то CurrAccRest будет <0*/
       if (CurrAccRest <= $0)
          return true;
       end;
    
    end;

    return false;
end;

/* EVG 22/08/2012 Новая версия функции проверки ареста по счетам (C-12944).
   Отличия:
   - не обрабатываются счета СКС, платёжных агентов и с польз. типом "5";
   - запросы параметризованы;
   - не проверяется остаток на валютных счетах клиента.
*/
MACRO CheckIndex2_New( EndDate, sfcontr )
    var query, cmd, rs;
    var CountAll = 0,
        CountI2  = 0,
        CurrAccRest = $0,
        RestFree    = $0;

    debugbreak;
    /* Общее количество счетов */
    query = " Select count(*) from DAccount_dbt " +
            "  Where t_Chapter                      = 1 " +
            "    and t_Code_currency                = 0 " +
            "    and t_Open_Close                   = Chr(0) " +
            "    and instr(t_type_account, 'П')     = 0 " +
            "    and t_Client                       = ? " + 
            "    and SubStr(t_Account, 1, 3)        between '405' and '408' " +

            "    and SubStr(t_Account, 11, 1)      <> '9' " +                   // Счета СКС не анализируются
            "    and SubStr(t_Account, 1, 5)       <> '40821' " +               // Счета платёжных агентов не анализируются
            "    and instr(t_UserTypeAccount, '5')  = 0 ";                      // Счета с "РКО не взимать" не анализируются
    
    cmd = rsdCommand( query );
    cmd.AddParam( "", RSDBP_IN, sfcontr.PartyID );

    rs = rsdRecordSet( cmd );
    if (rs and rs.moveNext())
       CountAll = rs.value(0, null, V_INTEGER);
    end;


    /* Счета с К2 */
    query = query + " and t_Index2 != Chr(0) ";         // Запрос тот же + проверка на заполнение поля "2"
    
    cmd = rsdCommand( query );
    cmd.AddParam( "", RSDBP_IN, sfcontr.PartyID );

    rs = rsdRecordSet( cmd );
    if (rs and rs.moveNext())
       CountI2 = rs.value(0, null, V_INTEGER);
    end;

   
    //msgbox (CountAll, "|", CountI2);

    /* Если К2 стоит по всем счетам клиента */
    if (CountI2 == CountAll)
       return true;
    end;

    return false;
end;



MACRO CheckRest( BeginDate, EndDate, sfcontr, CommNumber)
    var query, rs, sql, cmd;
    var return_value, Num, Account, Curr, Rest, vDate;
    var AllAccRest = $0, CheckAccountNonComm = false;
    var TPNotNeedCheckEXV = "129,80,135,161"; //ID тарифных планов ЭВ Стартовый, Дистанционный, Персональный, МСБ-3(Э-В)

    const GroupID = 1;  // Номер категории "Субъекты эк.деят-ти по 302-П"
    const Include_TP = "9, 12, 70, 97"; // 11-04-2012 I-00169380-1 (перенос с 2029) joy Это ИД (не номера!) ТП Консалтинговый, Персональный, Партнер (регионы), Персональный (регионы)
   

    record pty(party);


    macro isAccountNonComm(acc)
       var {Acc3} = subStr(acc, 1, 3),
           {Acc5} = subStr(acc, 1, 5);

       if ( ({Acc5} == "40503") or
            ({Acc5} == "40603") or
            ({Acc5} == "40703") or
            ({Acc3} == "416") or
            ({Acc3} == "419") or
            ({Acc3} == "422") or
            ({Acc3} == "433") or
            ({Acc3} == "436") or
            ({Acc3} == "439") )
          return true;
       end;
    
       return false;
    end;

    ClearRecord(pty);
    pty.PartyID = sfcontr.PartyID;
    GetMainObjAttr (return_value, OBJTYPE_PARTY, UniID(pty, OBJTYPE_PARTY), GroupID, null, null, Num);
    
    if (LifeBank.is_EXV)
      sql = " SELECT 1 FROM DSFCONTRPLAN_DBT WHERE T_SFCONTRID = ? AND T_SFPLANID not in ("+TPNotNeedCheckEXV+") " +
            "           AND T_END = TO_DATE('01.01.0001','dd.mm.yyyy')";
      cmd = rsdcommand(sql);
      cmd.AddParam("", RSDBP_IN,sfcontr.id);
      rs = rsdRecordSet(cmd);
      if (rs and rs.moveNext() )
       CheckAccountNonComm = true;
      end;
      rs    = null;
      sql   = null;
      cmd   = null;
      
    end;
    
    if ((CheckAccountNonComm) and not (LifeBank.is_EXV)) //RR 02.03.2016 Проверка отключена для ЭВ R-640968-2
    //RR Выключаем эту проверку если ТП клиента указан в TPNotNeedCheckEXV
    /* Только для некоммерческих организаций */
       if ( (Num == 7)  or
            (Num == 10) or
            (Num == 13) or
            isAccountNonComm(sfcontr.Object)
          )

         /*FIV Изменил запрос, вместо проверки на конец месяца - проверка по сумме на каждую дату остатков всех счетов клиента*/
         SQL = "   SELECT   COUNT (COUNT (1)) COUNT ";
         SQL = SQL + "    FROM   (SELECT   ABS (rsb_account.resta (acc.t_account, ";
         SQL = SQL + "                                             cd.t_curdate, ";
         SQL = SQL + "                                             1, ";
         SQL = SQL + "                                             0)) ";
         SQL = SQL + "                        rest, cd.t_curdate datevalue ";
         SQL = SQL + "              FROM   daccount_dbt acc, dcurdate_dbt cd ";
         SQL = SQL + "             WHERE       acc.t_chapter = 1 ";
         SQL = SQL + "                     AND acc.t_client = ? ";
         SQL = SQL + "                     AND SUBSTR (acc.t_account, 1, 3) BETWEEN '405' AND '408' ";
         SQL = SQL + "                     AND cd.t_curdate BETWEEN ? AND ? )";
         SQL = SQL + "  GROUP BY   datevalue ";
         SQL = SQL + "  HAVING   SUM (rest) < ? ";

         cmd = rsdcommand(sql);
         cmd.AddParam("", RSDBP_IN,sfcontr.PartyID);
         cmd.AddParam("", RSDBP_IN,BeginDate);
         cmd.AddParam("", RSDBP_IN,EndDate);
         cmd.AddParam("", RSDBP_IN,RestLimit);


          //msgbox (query);
          rs = rsdRecordSet(cmd);
          /*FIV Если = 0 значит суммарный остаток не падал ниже допустимого предела*/
          if (rs and rs.moveNext() and rs.Value(0) == 0)
             return true;
          end;
       end;

    end;
    /*Чесноков Д. 09.03.2011 Проверка движения по счету по заявке I-116020*/
    rs    = null;
    sql   = null;
    cmd   = null;
    /*Проверим к какому ТП привязан ДО*/
    sql = " SELECT 1 FROM DSFCONTRPLAN_DBT WHERE T_SFCONTRID = ? AND T_SFPLANID IN ("+Include_TP+") " +
          "           AND T_END = TO_DATE('01.01.0001','dd.mm.yyyy')";
    cmd = rsdcommand(sql);
    cmd.AddParam("", RSDBP_IN,sfcontr.id); //Id ДО
    cmd.AddParam("", RSDBP_IN,BeginDate);
    cmd.AddParam("", RSDBP_IN,EndDate);
       
    rs = rsdRecordSet(cmd);
       
    if (rs and rs.moveNext() )
      sql = " SELECT MAX(COUNT) FROM ( " +
            " SELECT   COUNT (0) as COUNT " + 
            "   FROM   dacctrn_dbt doc " + 
            "  WHERE   ? IN (doc.t_account_payer, doc.t_account_receiver) " + 
            "          AND (doc.t_date_carry >= " + 
            "                  (SELECT   NVL (MAX (sf.t_datefee) + 1, ?) " + 
            "                     FROM   dsfdefcom_dbt sf " + 
            "                    WHERE   sf.T_CONID = ? AND sf.t_commnumber = ?) " + 
            "               AND doc.t_date_carry <= ?) " + 
            "          AND doc.t_chapter = 1 " ;

      cmd = rsdcommand(sql);
      cmd.AddParam("", RSDBP_IN,sfcontr.object); // Номер счета
      cmd.AddParam("", RSDBP_IN,BeginDate);      // Дата начала периода
      cmd.AddParam("", RSDBP_IN,sfcontr.id);     // ID ДО
      cmd.AddParam("", RSDBP_IN,CommNumber);     // Номер комиссии
      cmd.AddParam("", RSDBP_IN,EndDate);        // Дата конца периода
       
      rs = rsdRecordSet(cmd);

      if (rs and rs.moveNext() and rs.Value(0) == 0)
         return true;
      end;
       
    end; // if ( (Num == ...

    return false;
 end;

MACRO CheckOborot( sfcontr, BeginDate, EndDate )
    var query, rs, sql, cmd;

      debugbreak;
      /*FIV получаем сумму оборотов по Дт и Кт по всем счетам клиента за период*/
      SQL = " SELECT   SUM(oborot) ";
      SQL = SQL + "  FROM   (SELECT   ABS( ";
      SQL = SQL + "                      rsb_account.debeta(acc.t_account, ";
      SQL = SQL + "                                         acc.t_chapter, ";
      SQL = SQL + "                                         TO_DATE('"+string(BeginDate)+"', 'dd.mm.yyyy'), ";
      SQL = SQL + "                                         TO_DATE('"+string(EndDate)+"', 'dd.mm.yyyy')) ";
      SQL = SQL + "                   ) ";
      SQL = SQL + "                   + ABS(rsb_account.kredita( ";
      SQL = SQL + "                            acc.t_account, ";
      SQL = SQL + "                            acc.t_chapter, ";
      SQL = SQL + "                            TO_DATE('"+string(BeginDate)+"', 'dd.mm.yyyy'), ";
      SQL = SQL + "                            TO_DATE('"+string(EndDate)+"', 'dd.mm.yyyy') ";
      SQL = SQL + "                         )) ";
      SQL = SQL + "                      oborot ";
      SQL = SQL + "            FROM   daccount_dbt acc ";
      SQL = SQL + "           WHERE   acc.t_client = ? ";
      SQL = SQL + "                   AND SUBSTR(acc.t_account, 1, 3) BETWEEN '405' AND '408') ";

      cmd = rsdcommand(sql);
      cmd.AddParam("", RSDBP_IN,sfcontr.PartyID);


       //msgbox (query);
       rs = rsdRecordSet(cmd);
       /*FIV Если = 0 значит не было движеня по счетам клиента и комиссию не взимаем*/
       if (rs and rs.moveNext() and rs.Value(0) == 0)
          return true;
       end;
    return false;
end;



MACRO CheckFreeDate( PartyID, EndDate )
   const NoteKind_TaxFreeDate = 101;             // Примечание "Дата освобождения от комиссии за ведение счёта"

   var TaxFreeDate:date,
       tfMounth, tfYear, commMounth, commYear;
   var sParty = TRecHandler("party.dbt");

   sParty.rec.PartyID = PartyID;
   TaxFreeDate = ReadNoteForObject( OBJTYPE_PARTY, UniID(sParty, OBJTYPE_PARTY), NoteKind_TaxFreeDate, EndDate );

   if ( (ValType( TaxFreeDate ) != V_UNDEF) and (TaxFreeDate > date(0,0,0)) )
      DateSplit(TaxFreeDate, null, tfMounth, tfYear);
      DateSplit(EndDate, null, commMounth, commYear);

      if ( String(tfMounth) + String(tfYear) == String(commMounth) + String(commYear) )
         return true;
      end;
   end;

   return false;
end;

/* EVG END 09.07.2010 Функции, которые раньше жили в com220p.mac и bank_com220p.mac */


/* EVG 23/08/2012 Функция проверяет наличие оплаченной годовой комиссии за ведение счёта по договору обслуживания */
MACRO CheckYearCom( BegDate, EndDate, sfcontr )
    var query, cmd, rs;
    debugbreak;
    query = " Select 1 from dsfdef_dbt " +
            "  Where t_feetype        = 1    " +        // Периодическая
            "    and t_commnumber     = 1073 " +        // 2.2.1 "Единая комиссия за ведение счетов Клиентов, в год"
            "    and t_sfcontrid in (select t_id from dsfcontr_dbt where t_partyid = ?)    " + //RR 23.09.2013
            "    and t_status         = 40   " +        // Оплачена
            "    and t_dateperiodend >= ?    ";
    cmd = rsdCommand( query );
    cmd.AddParam( "", RSDBP_IN, sfcontr.partyid );
    cmd.AddParam( "", RSDBP_IN, EndDate );

    rs = rsdRecordSet( cmd );
    if ( rs and rs.moveNext() )
       return true;
    end;

    return false;
END;


/* EVG 24/08/2012 Проверка на дату регистрации клиента. Если между датой начала регистрации 
   клиента и датой окончания периода оплаты комиссии прошло не более 6 месяцев, клиент освобождается
   от комиссии. */
MACRO CheckClientRegistration ( EndDate, sfcontr, tpforCheck, dateBeginCheck )
    var query, cmd, rs;
    var registrationBegDate;
    //RR Вводим массив и счетчик к нему
    private var ArrTp;
    private var ArrTpIxd = 0;

    /* Проверка выполняется только если счёт открыт позже даты, с которой действует это условие */
    /* EVG 17/01/2013 Поправил на нестрогое соответствие
    if( sfcontr.datebegin > dateBeginCheck )*/
    if( sfcontr.datebegin >= dateBeginCheck )

       /* Проверка выполняется в случае, если ТП договора равен tpforCheck */
       cmd = rsdcommand("  SELECT t_sfplanid       "+
                        "    FROM dsfcontrplan_dbt "+
                        "   WHERE t_sfcontrid = ?  "+
                        "     AND t_begin     = ( Select max( t_begin ) From dsfcontrplan_dbt Where t_sfcontrid = ? ) ");
       cmd.addparam( "",   RSDBP_IN, sfcontr.id );
       cmd.addparam( "",   RSDBP_IN, sfcontr.id );
       rs = rsdrecordset( cmd );
       if ( rs and rs.movenext) 
         //RR 24.09.2012 так проверка работает корректно
          ArrTp = split(tpforCheck, "|");
          debugbreak;
          while (ArrTpIxd < ArrTp.size() ) 
             if (rs.Value(0) == ArrTp(ArrTpIxd))
                          /* Определим дату регистрации клиента */         
                  cmd = rsdcommand("  SELECT t_startdate        "+
                                   "    FROM dobjrgdoc_dbt      "+
                                   "   WHERE t_objecttype   = 3 "+         // OBJTYPE_PARTY
                                   "     AND t_objectid     = ? "+
                                   "     AND t_regpartykind = 7 "+         // ФНС РФ
                                   "     AND t_regdockind   = 4 "+         // СВГОСРЕГ
                                   "     AND t_isclosed     = chr(0) "+
                                   /* Проверка на то, что по клиенту не стоит значение "Да (отключить)" категории
                                      "Отключить анализ даты регистрации при взимании комиссии за ведение счёта (2.2.0)" */
                                   "     AND NOT EXISTS( SELECT 1 "+
                                   "                       FROM dobjatcor_dbt oc "+
                                   "                      WHERE     oc.t_objecttype = 3 "+
                                   "                            AND oc.t_groupid    = 120 "+
                                   "                            AND oc.t_object     = LPAD(t_objectid, 10, 0) "+
                                   "                            AND oc.t_attrid     = 1 )" );
                  cmd.addparam( "",   RSDBP_IN, sfcontr.PartyID );
                  rs = rsdrecordset( cmd );
                  if ( rs and rs.movenext )
                     registrationBegDate = SQL_ConvTypeDate( rs.value( 0, null, V_DATE ) );

                     if( ( registrationBegDate > date(0,0,0) ) and ( floatMonths(registrationBegDate, EndDate) <= 6 ) ) /*05.06.2013 R-199745-2 Жаворонкова Н. joy*/
                        return true;
                     end;
                  end;
             end;
            ArrTpIxd = ArrTpIxd + 1;
          end;
         //if ( index( tpforCheck, string(rs.Value(0)) ) > 0 ) //RR 21.09.2012 данный вариант работает не корректно ищется любое вхождение

         end;
       // end;

    end;

    return false;
END;

MACRO CheckClientRegistration_new ( EndDate, sfcontr, tpforCheck, dateBeginCheck )
    var query, cmd, rs;
    var registrationBegDate;
    const dateBeginCheck2 = date(31,1,2015); // joy C-36721
    //RR Вводим массив и счетчик к нему
    private var ArrTp;
    private var ArrTpIxd = 0;

    if( sfcontr.datebegin >= dateBeginCheck )

       /* Проверка выполняется в случае, если ТП договора равен tpforCheck */
       cmd = rsdcommand("  SELECT t_sfplanid       "+
                        "    FROM dsfcontrplan_dbt "+
                        "   WHERE t_sfcontrid = ?  "+
                        "     AND t_begin     = ( Select max( t_begin ) From dsfcontrplan_dbt Where t_sfcontrid = ? ) ");
       cmd.addparam( "",   RSDBP_IN, sfcontr.id );
       cmd.addparam( "",   RSDBP_IN, sfcontr.id );
       rs = rsdrecordset( cmd );
       if ( rs and rs.movenext) 
         //RR 24.09.2012 так проверка работает корректно
          ArrTp = split(tpforCheck, "|");
          debugbreak;
          while (ArrTpIxd < ArrTp.size() ) 
             if (rs.Value(0) == ArrTp(ArrTpIxd))
                if (sfcontr.datebegin <= dateBeginCheck2 ) // joy C-36721 Теперь есть еще одна категория, которую надо проверять
                              /* Определим дату регистрации клиента */         
                      cmd = rsdcommand("  SELECT t_startdate        "+
                                       "    FROM dobjrgdoc_dbt      "+
                                       "   WHERE t_objecttype   = 3 "+         // OBJTYPE_PARTY
                                       "     AND t_objectid     = ? "+
                                       "     AND t_regpartykind = 7 "+         // ФНС РФ
                                       "     AND t_regdockind   = 4 "+         // СВГОСРЕГ
                                       "     AND t_isclosed     = chr(0) "+
                                       /* Проверка на то, что по клиенту не стоит значение "Да (отключить)" категории
                                          "Отключить анализ даты регистрации при взимании комиссии за ведение счёта (2.2.0)" */
                                       "     AND NOT EXISTS( SELECT 1 "+
                                       "                       FROM dobjatcor_dbt oc "+
                                       "                      WHERE     oc.t_objecttype = 3 "+
                                       "                            AND oc.t_groupid    = 120 "+
                                       "                            AND oc.t_object     = LPAD(t_objectid, 10, 0) "+
                                       "                            AND oc.t_attrid     = 1 )" );
                else 
                      cmd = rsdcommand("  SELECT t_startdate        "+
                                       "    FROM dobjrgdoc_dbt      "+
                                       "   WHERE t_objecttype   = 3 "+         // OBJTYPE_PARTY
                                       "     AND t_objectid     = ? "+
                                       "     AND t_regpartykind = 7 "+         // ФНС РФ
                                       "     AND t_regdockind   = 4 "+         // СВГОСРЕГ
                                       "     AND t_isclosed     = chr(0) "+
                                       /* Проверка на то, что по клиенту  стоит значение "Да (включить)" категории
                                          "Включить бесплатное ведение счетов для стартапов" */
                                       "     AND  EXISTS( SELECT 1 "+
                                       "                       FROM dobjatcor_dbt oc "+
                                       "                      WHERE     oc.t_objecttype = 3 "+
                                       "                            AND oc.t_groupid    = 121 "+
                                       "                            AND oc.t_object     = LPAD(t_objectid, 10, 0) "+
                                       "                            AND oc.t_attrid     = 1 )" );
                end; // ---end joy
                cmd.addparam( "",   RSDBP_IN, sfcontr.PartyID );
                rs = rsdrecordset( cmd );
                if ( rs and rs.movenext )
                   registrationBegDate = SQL_ConvTypeDate( rs.value( 0, null, V_DATE ) );

                    if( ( registrationBegDate > date(0,0,0) ) and 
                        ( ( floatMonths(registrationBegDate, EndDate) <= 6 )  and (sfcontr.datebegin <= dateBeginCheck2)   /*05.06.2013 R-199745-2 Жаворонкова Н. joy + 16.02.2015 C-36721 joy проверяем старое условие*/
                           or ( floatMonths(registrationBegDate, EndDate) <= 3 )  and (sfcontr.datebegin > dateBeginCheck2) // ... и новое условие для ДО, заключенных после 31-01-2015
                        ) )
                        return true;
                    end;
                end;
             end;
            ArrTpIxd = ArrTpIxd + 1;
          end;
         //if ( index( tpforCheck, string(rs.Value(0)) ) > 0 ) //RR 21.09.2012 данный вариант работает не корректно ищется любое вхождение

         end;
       // end;

    end;

    return false;
END;







/* EVG 15/01/2013 Процедура запускает функцию CheckOborot() (см. выше) для договоров на указанных в параметре
       tpMask тарифном плане. */
MACRO CheckTurnover_ForTP( begDate, endDate, sfContr, commNumber, tpMask )

    var cmd, rs;

    debugbreak;
    /* Проверим, подходит ли тарифный план ДО к полученной в параметре маске ТП. */
    cmd = rsdcommand("  SELECT   1 " +
                     "  FROM   (  SELECT   * "+
                     "              FROM   dsfcontrplan_dbt "+
                     "             WHERE   T_SFCONTRID = ? AND t_sfplanid in ( " + tpMask + " ) " +
                     "          ORDER BY   t_begin DESC) "+
                     " WHERE   ROWNUM = 1 ");
    
    cmd.addparam( "ID", RSDBP_IN, sfContr.id );
    //cmd.addparam( "M",  RSDBP_IN, tpMask );
    //cmd.execute();
    rs = rsdrecordset( cmd );
    if ( rs and rs.movenext )


       /* Обороты нужно анализировать, начиная с даты, следующей за датой предыдущей оплаты 2.2.0 */
     
       /* По умолчанию дата начала периода анализа - 1-е число месяца */
       var mm, yy;
       dateSplit( endDate, null, mm, yy );
       begDate = date(1, mm, yy);

       /* Находим дату последней УПК 2.2.0 (ID комиссии пришло входящим параметром) */
       cmd = rsdcommand(" SELECT max(t_DatePay)+1      " +
                        "   FROM dsfdef_dbt " +
                        "  WHERE t_feetype        = 1  " +        // Периодическая
                        "    AND t_commnumber     = ?  " + 
                        "    AND t_sfcontrid      = ?  " +
                        "    AND t_status         = 40 " +        // Оплачена
                        "    AND t_dateperiodend  < ?  ");
       cmd.AddParam( "", RSDBP_IN, commNumber );
       cmd.AddParam( "", RSDBP_IN, sfcontr.ID );
       cmd.AddParam( "", RSDBP_IN, endDate );
       rs = rsdRecordSet( cmd );
       if ( rs and rs.moveNext() )
          begDate = SQL_ConvTypeDate( rs.value( 0, null, V_DATE ) );
       end;


       /* Если дата оплаты последней УПК более чем на месяц отстоит от текущей даты, 
          делаем дату начала анализа 1-е число месяца.
          Аналогично и если предыдущая УПК не найдена - дата 0.0.0000. */
       if( ( begDate == date(0,0,0) ) or ( floatMonths( begDate, {CurDate} ) >= 1 ) )
          begDate = date(1, mm, yy);
       end;


       /* Вызов функции проверки оборотов */
       if( CheckOborot( sfcontr, begDate, endDate ) )
          return true;
       end;

    end;


    return false;
END;


/* EVG Функция возвращает true, если по операции уже рассчитаны единовременные комиссии */
MACRO OprComPayed( opID )
   var rs, query;

   query = " Select 1 From DOPRSFCOM_DBT Where t_Id_Operation = " + opID;
   rs = rsdRecordSet( query );
   if ( rs and rs.MoveNext() )
      return true;
   end;

   return false;
END;



/* EVG Функция корректировки времени платежа с учётом часового пояса
   (необходима по причине того, что время на всех серверах используется
   московское, в то время как банки расположены в разных часовых поясах). */
MACRO CorrectTimeZone( pmTime )
   var LifeBank = fg_life_subject( {OurBank} );

   /* Для банка ВУЗ разница с Москвой +2 часа */
   if ( LifeBank.is_VUZ() )
      return pmTime + time(2,0,0);
   end;

   return pmTime;
END;


/* EVG Функция, изначально разработанная Алексеем Т. и заимствованная из макроса ps_coprn.mac. 
   Назначение: определить время поступления  документа из системы Клиент-Банк в RS-Bank. Сначала ищем запись в 
   таблице usr_payments_log (для документов, загруженных PL/SQL-процедурой), затем - в фискальном журнале (для
   документов, полученных через DLM-интерфейс). */
MACRO gettimeP( PaymID, date1, crDate:@date )
 
   var cmdT, rsdT;
   
   /* EVG 6/04/2011 Поиск времени в UF1 */
   var ufValue, ufDate, ufTime;
   cmdT = rsdcommand("select t_UserField1 from DPsPayord_dbt where t_OrderId = ?");
   cmdT.addparam("Id",RSDBP_IN, PaymID);
   rsdT = rsdrecordset(cmdT);

   if (rsdT and rsdT.movenext())
      ufValue = SQL_ConvTypeStr( rsdT.value(0, null, V_STRING) );

      /* время в UF1 должно содержаться в формате '05.04.2011 19:27:07' */
      ufDate = trim( subStr( ufValue, 1, index( rsdT.value(0, null, V_STRING), " " ) ) );
      ufTime = trim( subStr( ufValue, index( rsdT.value(0, null, V_STRING), " " ) + 1) );

      if ( strLen( ufDate ) > 0 )
         crDate = date( ufDate );
      end;

      if ( ( strLen( ufTime ) > 0 ) and ( index( ufTime, ":" ) > 0 ) )
         return time( ufTime );
      end;
   end;
   

   /* Поиск в usr_payments_log */
   cmdT = rsdcommand("select create_time from  usr_payments_log where paymentid = ?");
   cmdT.addparam("Id",RSDBP_IN, PaymID);
   rsdT = rsdrecordset(cmdT);
   if (rsdT and rsdT.movenext())
      crDate = SQL_ConvTypeDate( rsdT.value(0) );

      /* EVG 10/03/2011 Добавлен вызов функции корректировки времени платежа
         с учётом часового пояса (актуально для банка ВУЗ). */
      return CorrectTimeZone( SQL_ConvTypeTime( rsdT.value(0) ) );
   end;


   /* EVG 01/04/2011 Лучше всё-таки оставить - на случай, если время не удалось определить ни
      по UF1, ни по usr_payments_log. */
   /* EVG 31/03/2011 С момента реализации триггера INSERT_USR_LOG поиск в фискальном журнале
      потерял свою актуальность. */

   /* Поиск в фискальном журнале */
   cmdT = rsdcommand("CALL rsb_struct.readstruct('dpmpaym_dbt') ");
   cmdT.execute;
   cmdT = rsdcommand(" SELECT fl.t_time, fl.t_date "+
                     "  FROM dfisclog_dbt fl "+
                     " WHERE fl.t_tablename = 'pmpaym.dbt' "+
                     "   AND fl.t_opcode    = 1004 " +                  // Транзакция ввода
                     "   AND rsb_struct.getlong ('T_PAYMENTID', fl.t_fmtblobdata_xxxx, 2) = ? "+
                     /* EVG 6/04/2011 И зачем я так сделал?... Из-за этого тормоза сгущаются тем больше,
                        чем за более глубокий день рассчитывается комиссия. Всё равно обрабатываются только
                        платежи, проводка по которым была в день, за который идёт расчёт комиссии. Ввод в архив
                        не учитываем, это уже перебор.
                     "   AND fl.t_date between ? and trunc(sysdate) ");*/
                     "   AND fl.t_date = ? ");
   cmdT.addparam("Id",RSDBP_IN, PaymID);
   cmdT.addparam("date",RSDBP_IN, date1);
   //msgbox (cmdT.cmdtext, "|", date1, " - ", PaymID);
   rsdT = rsdrecordset(cmdT);
   if (rsdT and rsdT.movenext())
      crDate = SQL_ConvTypeDate( rsdT.value(1) );

      /* EVG 11/03/2011 Для времени из журнала решено отключить корректировку
         часового пояса, т.к. старый ИК передаёт Екатеринбургское время.
      /* EVG 10/03/2011 Добавлен вызов функции корректировки времени платежа
         с учётом часового пояса (актуально для банка ВУЗ). */
      return CorrectTimeZone( SQL_ConvTypeTime( rsdT.value(0) ) );*/
      return SQL_ConvTypeTime( rsdT.value(0) );
   end;

   return Time( 0, 0, 0 );
END;


Macro CheckTP(ID, TpID)

var cmd, rs;

  cmd = rsdcommand("  SELECT   1 "+
  "  FROM   (  SELECT   * "+
  "              FROM   dsfcontrplan_dbt "+
  "             WHERE   T_SFCONTRID = ? AND t_sfplanid in ("+TpID+") "
  "               AND   T_END = TO_DATE('01.01.0001','dd.mm.yyyy')" + // joy 07.05.2013 I-00366228-2 Нужно искать только действующий ТП
  "          ORDER BY   t_begin DESC) "+
  " WHERE   ROWNUM = 1 ");
  
  cmd.addparam("ID", RSDBP_IN, ID );
  cmd.execute();

  rs = rsdrecordset(cmd);

  if ( rs.movenext)
    return true;
  else
    return false;
  end; 
  
end;


MACRO GetAccountsRecordSet( dBeg, dEnd )

  var rs, SQL;
  
  SQL = "      SELECT ac.t_Account PayerAccount, ac.t_Code_Currency Fiid ";
  SQL = SQL + "  FROM DAccount_dbt ac ";
  SQL = SQL + " WHERE ac.t_Code_Currency = 0 ";
  SQL = SQL + "   AND INSTR (ac.t_type_account, 'Т')    = 0 ";
  //SQL = SQL + "   and ac.t_client = 225901 "; //RR Отладочный код
  //SQL = SQL + "   AND ac.t_account = '40702810200000004118' ";
  SQL = SQL + "   AND INSTR (ac.t_type_account, 'П')    = 0 ";
  SQL = SQL + "   AND INSTR (ac.t_usertypeaccount, '5') = 0 ";
  SQL = SQL + "   AND (   ac.t_balance IN ('40802', '40807') ";                  
  SQL = SQL + "        OR SUBSTR (ac.t_balance, 1, 3) IN ('405', '406', '407') ";
  SQL = SQL + "       ) ";                                                       
  SQL = SQL + "   AND ac.t_chapter = 1 ";
  SQL = SQL + "   AND SUBSTR (ac.t_account, 11, 1) != '9' ";
  SQL = SQL + "   AND ac.t_Open_Date  <= " + getSQLDate( dEnd );
  SQL = SQL + "   AND (ac.t_Close_Date = " + getSQLDate( date( 0,0,0 ) );
  SQL = SQL + "    OR ac.t_Close_Date > " + getSQLDate( dEnd );
  SQL = SQL + "        )";
       
  rs = TRsbDataSet( sql, RSDVAL_CLIENT, RSDVAL_STATIC );
  //msgbox (sql);

  return rs;

END;

//RR 30.05.2012 Чтобы не коверкать уже работающую процедуру и не усложнять код, для пробки ввожу отдельную
// необходимость вызвана тем что отбирать в обработку счета с ТП Платежный ДМСБ не нужно, тупо их выключаем.
MACRO GetAccountsRecordSetPRBB( dBeg, dEnd )

  var rs, SQL;
  var TpDMSB = 100; //Id ТП Платежный ДМСБ
  SQL = "      SELECT ac.t_Account PayerAccount, ac.t_Code_Currency Fiid ";
  SQL = SQL + "  FROM daccount_dbt ac, dsfcontr_dbt contr, dsfcontrplan_dbt sfplan ";
  SQL = SQL + " WHERE ac.t_Code_Currency = 0 ";
  SQL = SQL + "   AND INSTR (ac.t_type_account, 'Т')    = 0 ";
  //SQL = SQL + "   and ac.T_CLIENT = 697622 ";
  //SQL = SQL + "   AND ac.T_BRANCH = 202 "; //RR Отладочный код
  SQL = SQL + "   AND INSTR (ac.t_type_account, 'П')    = 0 ";
  SQL = SQL + "   AND INSTR (ac.t_usertypeaccount, '5') = 0 ";
  SQL = SQL + "   AND (   ac.t_balance IN ('40802', '40807') ";                  
  SQL = SQL + "        OR SUBSTR (ac.t_balance, 1, 3) IN ('405', '406', '407') ";
  SQL = SQL + "       ) ";                                                       
  SQL = SQL + "   AND ac.t_chapter = 1 ";
  SQL = SQL + "   AND SUBSTR (ac.t_account, 11, 1) != '9' ";
  SQL = SQL + "   AND ac.t_Open_Date  <= " + getSQLDate( dEnd );
  SQL = SQL + "   AND (ac.t_Close_Date = " + getSQLDate( date( 0,0,0 ) );
  SQL = SQL + "    OR ac.t_Close_Date > " + getSQLDate( dEnd );
  SQL = SQL + "        )";
  SQL = SQL + "   and contr.T_OBJECT = ac.T_ACCOUNT ";
  SQL = SQL + "   and sfplan.T_SFCONTRID = contr.T_ID ";
  SQL = SQL + "   and sfplan.T_END = '01.01.0001' ";
  SQL = SQL + "   and sfplan.T_SFPLANID <> "+TpDMSB+" ";
       
  rs = TRsbDataSet( sql, RSDVAL_CLIENT, RSDVAL_STATIC );
  //msgbox (sql);

  return rs;

END;


//RR Наброски по оптимизации процедуры, этот код пока нигде не используется, не трогать!!!
MACRO GetAccountsRecordSetPRBBB( dBeg, dEnd )

  var rs, SQL,cmd;
  var TpDMSB = 100; //Id ТП Платежный ДМСБ
  var YearComiss = 1073;
  
   sql = "   SELECT ac.t_account payeraccount, ac.t_Code_Currency Fiid "
+"\n          FROM daccount_dbt ac, dsfcontr_dbt contr, dsfcontrplan_dbt sfplan "
+"\n         WHERE ac.t_code_currency = 0 "
//+"\n           AND ( ac.T_BRANCH = 2 or ac.T_BRANCH = 4 or ac.T_BRANCH = 8 or ac.T_BRANCH = 55 or ac.T_BRANCH = 168) " //RR Отладочный код
+"\n           AND INSTR (ac.t_type_account, 'Т') = 0 "
+"\n           AND INSTR (ac.t_type_account, 'П') = 0 "
+"\n           AND INSTR (ac.t_usertypeaccount, '5') = 0 "
+"\n           AND (   ac.t_balance IN ('40802', '40807') "
+"\n                OR SUBSTR (ac.t_balance, 1, 3) IN ('405', '406', '407') "
+"\n               ) "
+"\n           AND ac.t_chapter = 1 "
+"\n           AND SUBSTR (ac.t_account, 11, 1) != '9' "
+"\n           AND ac.t_open_date <= '"+dBeg+"' "
+"\n           AND (ac.t_close_date = '01.01.0001' OR ac.t_close_date > '"+dEnd+"' ) "
+"\n           AND contr.t_object = ac.t_account "
+"\n           AND sfplan.t_sfcontrid = contr.t_id "
+"\n           AND sfplan.t_end = '01.01.0001' "
+"\n           AND sfplan.t_sfplanid <> "+TpDMSB+" "
+"\n        MINUS "
+"\n        SELECT ac.t_account payeraccount, ac.t_code_currency fiid "
+"\n          FROM daccount_dbt ac, "
+"\n               dsfcontr_dbt contr, "
+"\n               dsfcontrplan_dbt sfplan, "
+"\n               dsfconcom_dbt com "
+"\n         WHERE ac.t_code_currency = 0 "
//+"\n           AND ( ac.T_BRANCH = 2 or ac.T_BRANCH = 4 or ac.T_BRANCH = 8 or ac.T_BRANCH = 55 or ac.T_BRANCH = 168) " //RR Отладочный код
+"\n           AND INSTR (ac.t_type_account, 'Т') = 0 "
+"\n           AND INSTR (ac.t_type_account, 'П') = 0 "
+"\n           AND INSTR (ac.t_usertypeaccount, '5') = 0 "
+"\n           AND (   ac.t_balance IN ('40802', '40807') "
+"\n                OR SUBSTR (ac.t_balance, 1, 3) IN ('405', '406', '407') "
+"\n               ) "
+"\n           AND ac.t_chapter = 1 "
+"\n           AND SUBSTR (ac.t_account, 11, 1) != '9' "
+"\n           AND ac.t_open_date <= '"+dBeg+"' "
+"\n           AND (ac.t_close_date = '01.01.0001' OR ac.t_close_date > '"+dEnd+"' ) "
+"\n           AND contr.t_object = ac.t_account "
+"\n           AND sfplan.t_sfcontrid = contr.t_id "
+"\n           AND sfplan.t_end = '01.01.0001' "
+"\n           AND sfplan.t_sfplanid <> "+TpDMSB+" "
+"\n           AND com.t_objectid = contr.t_id "
+"\n           AND com.t_objecttype = 659 "
+"\n           AND com.t_feetype = 1 "
+"\n           AND com.t_commnumber = "+YearComiss+" "
+"\n           AND com.t_status = 0 " ;                               
/*
  cmd = rsdcommand(sql);
  cmd.addparam("", RSDBP_IN, dBeg );
  cmd.addparam("", RSDBP_IN, dEnd );
  cmd.addparam("", RSDBP_IN, dBeg );
  cmd.addparam("", RSDBP_IN, dEnd );
*/
  rs = TRsbDataSet( sql, RSDVAL_CLIENT, RSDVAL_STATIC );
  msgbox (sql);

  return rs;

END;

/* EVG 26/03/2012 Процедура отключает месячные комиссии от всех ДО клиента, кроме одного */
 MACRO TurnOff_AllButOne(rArr)
 debugbreak;
 var cmd, SQL;
 var Counter = 0;
 var ComissNumTxt = "";
 
 while (Counter < rArr.size )
 
  if    (Counter > 0)
    ComissNumTxt = ComissNumTxt + " , " + rArr(Counter);
  elif (Counter == 0)
    ComissNumTxt = ComissNumTxt + rArr(Counter);
  end;
  Counter = Counter + 1;
 end;

 // Сначала состояние всех комиссии ДО делается "Не начисляется"
 SQL =       "UPDATE dsfconcom_dbt con ";
 SQL = SQL + "   SET con.t_status         = 1   ";
 SQL = SQL + " WHERE con.t_objecttype     = 659 ";                        // ДО
 SQL = SQL + "   AND con.t_feetype        = 1   ";                       // Только Периодические
 SQL = SQL + "   AND con.t_calcperiodtype = 2   ";                      // Только месячные
 SQL = SQL + "   AND con.t_commnumber in ( "+ComissNumTxt+" )   ";     // Отключаем только ту комиссию которую обрабатываем

 cmd = rsdCommand( SQL );
 cmd.execute;



 /* Затем состояние комиссий по одному из ДО субъекта делается "Начисляется".
    При этом, смотрится ДО с максимальной датой закрытия. Если дата закрытия не 
    указана, эта дата считается максимальной (31.12.9999) */

 SQL = " UPDATE   dsfconcom_dbt con "; 
 SQL = SQL + "   SET   con.t_status = 0 ";
 SQL = SQL + " WHERE   con.t_objectid IN ";
 SQL = SQL + "               (  SELECT   MIN (cntr.t_id) ";
 SQL = SQL + "                    FROM   dsfcontr_dbt cntr ";
 SQL = SQL + "                   WHERE   (cntr.t_dateclose = TO_DATE ('01.01.0001', 'dd.mm.rrrr') ";
 SQL = SQL + "                            OR (cntr.t_dateclose > (  SELECT   MAX (t_curdate) FROM dcurdate_dbt))) ";
 SQL = SQL + "                           AND CNTR.T_PARTYID not in (select T_PARTYID from dsfcontr_dbt where t_dateclose = to_date ( '01.01.9999' ))"; //RR Допил для исключения пустышек
 SQL = SQL + "                           AND CNTR.T_FIID = 0"; 
 SQL = SQL + "                           AND (SUBSTR (cntr.t_object, 1, 3) BETWEEN '405' AND '408'"; 
 SQL = SQL + "                                OR SUBSTR (cntr.t_object, 1, 5) IN ('40802', '40807'))";//RR Исправление I-00316461-3
 SQL = SQL + "                           AND (EXISTS ";
 SQL = SQL + "                                   (SELECT   1 ";
 SQL = SQL + "                                      FROM   daccount_dbt acc ";
 SQL = SQL + "                                     WHERE       acc.t_account = cntr.t_object ";
 SQL = SQL + "                                             AND acc.t_code_currency = cntr.t_fiid ";
                                                           // Не счета СКС
 SQL = SQL + "                                             AND INSTR (acc.t_usertypeaccount, 'D') = 0 ";
 SQL = SQL + "                                             AND acc.t_open_close != 'З' ";
 SQL = SQL + "                                             AND acc.t_chapter = 1 ";
                                                           // Не нужно учитывать счета с арестом на дебет
 SQL = SQL + "                                             AND INSTR (acc.t_type_account, 'Т') = 0 ";
 SQL = SQL + "                                             AND INSTR (acc.t_type_account, 'П') = 0 ";
 SQL = SQL + "                                             AND INSTR (acc.t_type_account, 'L') = 0 ";   // Не накопительный 
 SQL = SQL + "                                             AND INSTR (acc.t_type_account, 'Y') = 0 ";  // Не транзитный 
 SQL = SQL + "                                             AND INSTR (acc.t_type_account, 'Я') = 0 "; // Не специальный 
 SQL = SQL + "                                             AND INSTR (acc.t_usertypeaccount, '5') = 0))";
 SQL = SQL + "                GROUP BY   cntr.t_partyid) ";
 SQL = SQL + "         AND con.t_objecttype     = 659 ";                        // ДО
 SQL = SQL + "         AND con.t_feetype        = 1   ";                       // Только Периодические
 SQL = SQL + "         AND con.t_calcperiodtype = 2   ";                      // Только месячные
 SQL = SQL + "         AND con.t_commnumber in ( "+ComissNumTxt+" )   ";     // Отключаем только ту комиссию которую обрабатываем

 cmd = rsdCommand( SQL );
 cmd.execute;

END;



/* EVG 26/03/2012 Процедура отключает комиссию 2.2.0 (месячную) 
   для тех ДО, где подключена 2.2.1 (годовая). */
MACRO TurnOff_MonthCom_WhereYearComIsOn( nmComArr, yrComArr )
 debugbreak;
 var cmd, SQL,
     ind = 0,
     mnComNumberClause = "",
     yrComNumberClause = "";


 /* Разбираем массивы */
 while( ind < nmComArr.Size() )
    if ( ind > 0 )
       mnComNumberClause = mnComNumberClause + ", ";
    end;
    mnComNumberClause = mnComNumberClause + string( nmComArr(ind) );

    ind = ind + 1;
 end;

 ind = 0;
 while( ind < yrComArr.Size() )
    if ( ind > 0 )
       yrComNumberClause = yrComNumberClause + ", ";
    end;
    yrComNumberClause = yrComNumberClause + string( yrComArr(ind) );

    ind = ind + 1;
 end;

 
 
 SQL = " UPDATE   dsfconcom_dbt c ";
 SQL = SQL + "   SET   C.T_STATUS = 1 ";
 SQL = SQL + " WHERE   c.T_COMMNUMBER in (?) AND c.T_FEETYPE = 1 AND c.T_STATUS = 0 AND c.T_OBJECTTYPE = 659 ";
 SQL = SQL + "         AND EXISTS        ";
 SQL = SQL + "               (SELECT   1 ";
 SQL = SQL + "                  FROM   dsfconcom_dbt d ";
 SQL = SQL + "                 WHERE       d.T_COMMNUMBER in (?)   ";
 SQL = SQL + "                         AND d.T_FEETYPE     = 1   "; // Только Периодические
 SQL = SQL + "                         AND d.T_STATUS      = 0   "; // Начисляется
 SQL = SQL + "                         AND d.T_OBJECTTYPE  = 659 "; // ДО
 SQL = SQL + "                         AND D.T_DATEEND = to_date('01.01.0001','dd.mm.yyyy') "; //RR 25.01.2012 I-00316461-3
 SQL = SQL + "                         AND C.T_OBJECTID    = D.T_OBJECTID) ";

 cmd = rsdCommand( SQL );
 cmd.addparam("id220", RSDBP_IN, mnComNumberClause );
 cmd.addparam("id221", RSDBP_IN, yrComNumberClause );
 cmd.execute;

 END;



 macro UpdateSfcontr(BadAccountC)
 
 var BadAccountCollection = TArray();
 var i, AccColl, cmd, SQL,;
  i = 0;
  AccColl = "";
  
  if (ValType(BadAccountC) !=  V_UNDEF)
      BadAccountCollection = BadAccountC;
      while ( i < BadAccountCollection.Size() )
        if (i > 0 )
           AccColl = AccColl + ", ";
        end;
        AccColl = AccColl + string ( BadAccountCollection(i) );
      i = i + 1;
      end;
      
    SQL = " update dsfcontr_dbt c  ";
    SQL = SQL + "   set t_dateclose = to_date ( '01.01.9999' ) ";
    SQL = SQL + " where c.t_object in ( ? ); ";
 
    cmd = rsdCommand( SQL );
    cmd.addparam("", RSDBP_IN, AccColl );
    cmd.execute;
  else
    SQL = " update dsfcontr_dbt   ";
    SQL = SQL + "   set t_dateclose = to_date ( '01.01.0001' ) ";
    SQL = SQL + " where t_dateclose = to_date ( '01.01.9999' ); ";
 
    cmd = rsdCommand( SQL );
    cmd.addparam("", RSDBP_IN, AccColl );
    cmd.execute;
  end;
 
 end; 

//RR Небольшой апдейт чтобы выключить 2.2.0 на тарифном плане Платежный ДМСБ
 Macro Turn220OFFinTPDMSB()
   var cmd, sql;
   var idtpdmsb = 100;
   var numbercom220 = 1002;
   
    SQL =       " UPDATE dsfconcom_dbt con  ";
    SQL = SQL + "   SET con.t_status = 1 ";
    SQL = SQL + "  WHERE con.t_sfplanid = "+idtpdmsb+" AND con.t_commnumber = "+numbercom220+" AND con.t_feetype = 1 ";
    cmd = rsdCommand( SQL );
    cmd.execute;
    
 end;
 
 //RR 20.12.2011 функция проверки количества неоплаченных УПК по конкретной комиссии
 Macro CheckUPK(ComNum, Account)
  var rs, cmd, qwerty;
  private const UPKcnt = 3;
   
 qwerty = " select count (*) cnt "
+"\n          from dsfdefcom_dbt defc, dsfcontr_dbt contr "
+"\n         where defc.t_commnumber = ? "
+"\n           and DEFC.T_STATUS <> 40  "
+"\n           and defc.t_feetype = 1 "
+"\n           and defc.t_commsum <> 0 "
+"\n           and defc.t_conid = contr.t_id "
+"\n           and contr.t_fiid = 0 "
+"\n           and contr.t_object = ? ";

    cmd = rsdcommand(qwerty);
    cmd.AddParam("", RSDBP_IN,ComNum);
    cmd.AddParam("", RSDBP_IN,Account);
    rs = rsdRecordSet( cmd );
    if ( rs and rs.moveNext() )
      if ( (rs.value("cnt") < UPKcnt) )
       return true;
      else
       return false;
      end;
    else
      return false;
    end;
 END;


/* EVG 6/11/2012 Функция возвращает значение тарифа комиссии.
   Скопирована с VuzComLib.mac -> VUZ_GetTarifInfo() и доработана для анализа тарифа по ДО. */
MACRO GetTarifInfo( sfContr, BegDate, EndDate, sfComType, sfCommNumber, TarifValue:@variant, MinValue:@variant, MaxValue:@variant, TarifType:@integer )
  var sql, rs, cmd;
  var CommSum = $0, OneOpCommSum = $0;

   //   debugbreak;

    /* Получим значение тарифа */
    // 10.02.2014 joy R-326063 Адаптация поиска тарифа для 31 патча
    /* Запрос сразу отбирает тарифы и по ДО (индивидуальный), и по ТП. Записи сортируются по убыванию scl.t_ObjectType, в результате чего записть по ДО (если она есть)
       с scl.t_ObjectType = 659 становится первой в выборке. Если записи по ДО нет, то остаётся только запись с scl.t_ObjectType = 57 (по ТП). Для ускорения оставляем 
       только эту первую запись. */
    SQL =       " WITH t AS (                                                                                                                                           ";
    SQL = SQL + "SELECT   NVL (trf.t_tarifsum / 10000, 0) tVal, NVL (trf.t_MinValue / 10000, 0) minVal, NVL (trf.t_MaxValue / 10000, 0) maxVal, trf.t_TarifType tType   ";
    SQL = SQL + "  FROM   dsftarif_dbt trf, dsftarscl_dbt scl, dsfconcom_dbt concom,                                                                                    ";
    SQL = SQL + "         ( SELECT   cp.t_sfplanid plId                                                                                                                 ";
    SQL = SQL + "             FROM   dsfcontrplan_dbt cp                                                                                                                ";
    SQL = SQL + "            WHERE   cp.t_sfcontrid = ?                                                                                                                 ";
    SQL = SQL + "              AND cp.t_begin =                                                                                                                         ";
    SQL = SQL + "                     (SELECT  MAX (cp1.t_begin)                                                                                                        ";
    SQL = SQL + "                        FROM  dsfcontrplan_dbt cp1                                                                                                     ";
    SQL = SQL + "                       WHERE  cp1.t_sfcontrid = cp.t_sfcontrid                                                                                         ";
    SQL = SQL + "                         AND  cp1.t_begin    <= ?                                                                                                      ";
    SQL = SQL + "                     )                                                                                                                                 ";
    SQL = SQL + "         ) sfPlan                                                                                                                                      ";
    SQL = SQL + " WHERE   (  ( concom.t_ObjectType            = 659                                                                                                     ";
    SQL = SQL + "              AND concom.t_ObjectId          = ?                                                                                                       ";
    SQL = SQL + "              AND concom.t_sfplanid             = sfPlan.plId )                                                                                        ";
    SQL = SQL + "            OR                                                                                                                                         ";
    SQL = SQL + "            ( concom.t_ObjectType            = 57                                                                                                      ";
    SQL = SQL + "              AND concom.t_ObjectId          = sfPlan.plId )  )                                                                                        ";
    SQL = SQL + "         AND concom.t_FeeType                = ?                                                                                                       ";
    SQL = SQL + "         AND concom.t_CommNumber             = ?                                                                                                       ";
    SQL = SQL + "         AND scl.t_feetype                   = concom.t_feetype                                                                                        ";
    SQL = SQL + "         AND scl.t_commnumber                = concom.t_commnumber                                                                                     ";
    SQL = SQL + "         AND scl.t_begindate                 =                                                                                                         ";
    SQL = SQL + "                   (SELECT   max (t_begindate)                                                                                                         "; //25.03.2013 joy Дата должна быть наибольшей
    SQL = SQL + "                      FROM   dsftarscl_dbt                                                                                                             ";
    SQL = SQL + "                     WHERE   t_feetype  = concom.t_feetype                                                                                             ";
    SQL = SQL + "                       AND t_commnumber = concom.t_commnumber                                                                                          ";
    SQL = SQL + "                       AND t_concomid   = concom.t_id                                                                                                  ";  
    SQL = SQL + "                       AND (t_begindate <= ?                                                                                                           ";
    SQL = SQL + "                           OR t_begindate = to_date ('01.01.0001', 'dd.mm.yyyy'))                                                                      ";
    SQL = SQL + "                    )                                                                                                                                  ";
    SQL = SQL + "         AND scl.t_concomid                  = concom.t_id                                                                                             ";  
    SQL = SQL + "         AND (CONCOM.T_DATEEND > ? OR CONCOM.T_DATEEND = to_date ('01.01.0001', 'dd.mm.yyyy') )                                                        ";
    SQL = SQL + "         AND trf.t_tarsclid                  = scl.t_id                                                                                                ";
    SQL = SQL + "         AND trf.t_basesum                   = 0                                                                                                       ";  // Тариф с нулевой базовой суммой
    SQL = SQL + "         AND trf.t_basetype                  = 1                                                                                                       ";  // Тип базы = Сумма
  //  SQL = SQL + "         and NVL (trf.t_tarifsum / 10000, 0) > 0                                                                                                       ";  // Для отбора правильного алгоритма /*04.09.2013 joy R-242733-2 + согласовано с Петренко О.*/
    SQL = SQL + " ORDER BY concom.t_ObjectType DESC                                                                                                                        ";
    SQL = SQL + " )  SELECT * FROM t WHERE ROWNUM = 1                                                                                                                   ";

    /*
    setoutput("d:\\123", true);
    println (sql);
    setoutput(null, true);
    msgbox (sfContr.id, " - ", sfCommNumber);
    */

    cmd = rsdCommand( sql );
    cmd.AddParam("", RSDBP_IN, sfContr.id);
    cmd.AddParam("", RSDBP_IN, BegDate);
    cmd.AddParam("", RSDBP_IN, sfContr.id);
    cmd.AddParam("", RSDBP_IN, sfComType);
    cmd.AddParam("", RSDBP_IN, sfCommNumber);
    cmd.AddParam("", RSDBP_IN, BegDate);
    cmd.AddParam("", RSDBP_IN, EndDate);

    rs = rsdRecordSet( cmd );
    if ( rs and rs.MoveNext )

       TarifType = rs.value( "tType", null, V_INTEGER );
       
       if ( TarifType == 1 )        // Тариф = Сумма
          TarifValue = rs.value( "tVal", null, V_MONEY );
          MinValue   = $0;
          MaxValue   = $0;
       elif (   ( TarifType == 2 )      // Тариф = Процент
              or( TarifType == 3 ) )    // Тариф = Сумма за единицу
          TarifValue = rs.value( "tVal",   null, V_DOUBLE );
          MinValue   = rs.value( "minVal", null, V_MONEY );
          MaxValue   = rs.value( "maxVal", null, V_MONEY );
       end;

       /*
       setoutput("d:\\123", true);
       println (TarifValue, " - ", MinValue, " - ",MaxValue);
       setoutput(null, true);
       */

       return true;
    end;

    return false;
END;



/* EVG 6/05/2013 Функция, аналогично GetTarifInfo(), возвращает данные о тарифе комиссии, но предназначена для работы с 3-уровневой тарификацией комиссий:

      - 1-я строчка тарифа - информация об ограничениях пакета комиссий;
      - 2-я строчка тарифа - информация об ограничениях по каждому платежу, по которому рассчитывается комиссия;
      - 3-я строчка тарифа - служебная, для возврата рассчитанной комиссии в сишку и далее в документ оплаты.

   Реализовано по заявке C-19221, п. 1.2

*/
MACRO GetTarifInfo3EbeneTarifbildung( sfContr, BegDate, EndDate, sfComType, sfCommNumber, TarifValue:@variant, MinValue:@variant, MaxValue:@variant, TarifType:@integer, PackValue:@variant )
  var sql, rs, cmd;
  var CommSum = $0, OneOpCommSum = $0;

   //   debugbreak;

    /* Получим значение тарифа */

    /* Запрос сразу отбирает тарифы и по ДО (индивидуальный), и по ТП. Записи сортируются по убыванию scl.t_ObjectType, в результате чего записть по ДО (если она есть)
       с scl.t_ObjectType = 659 становится первой в выборке. Если записи по ДО нет, то остаётся только запись с scl.t_ObjectType = 57 (по ТП). Для ускорения оставляем 
       только эту первую запись. */
    SQL =       " WITH t AS (                                                                                                                                              ";
    SQL = SQL + "SELECT  NVL (trf1.t_MaxValue / 10000, 0) packVal,                                                                                                         ";
    SQL = SQL + "        NVL (trf2.t_tarifsum / 10000, 0) tVal, NVL (trf2.t_MinValue / 10000, 0) minVal, NVL (trf2.t_MaxValue / 10000, 0) maxVal, trf2.t_TarifType tType   ";
    SQL = SQL + "  FROM   dsftarif_dbt trf1, dsftarif_dbt trf2, dsftarscl_dbt scl, dsfconcom_dbt concom,                                                                   ";
    SQL = SQL + "         ( SELECT   cp.t_sfplanid plId                                                                                                                    ";
    SQL = SQL + "             FROM   dsfcontrplan_dbt cp                                                                                                                   ";
    SQL = SQL + "            WHERE   cp.t_sfcontrid = ?                                                                                                                    ";
    SQL = SQL + "              AND cp.t_begin =                                                                                                                            ";
    SQL = SQL + "                     (SELECT  MAX (cp1.t_begin)                                                                                                           ";
    SQL = SQL + "                        FROM  dsfcontrplan_dbt cp1                                                                                                        ";
    SQL = SQL + "                       WHERE  cp1.t_sfcontrid = cp.t_sfcontrid                                                                                            ";
    SQL = SQL + "                         AND  cp1.t_begin    <= ?                                                                                                         ";
    SQL = SQL + "                     )                                                                                                                                    ";
    SQL = SQL + "         ) sfPlan                                                                                                                                         ";
    SQL = SQL + " WHERE   (  ( concom.t_ObjectType            = 659                                                                                                        ";
    SQL = SQL + "              AND concom.t_ObjectId          = ?                                                                                                          ";
    SQL = SQL + "              AND concom.t_sfplanid             = sfPlan.plId )                                                                                           ";
    SQL = SQL + "            OR                                                                                                                                            ";
    SQL = SQL + "            ( concom.t_ObjectType            = 57                                                                                                         ";
    SQL = SQL + "              AND concom.t_ObjectId          = sfPlan.plId )  )                                                                                           ";
    SQL = SQL + "         AND concom.t_FeeType                = ?                                                                                                          ";
    SQL = SQL + "         AND concom.t_CommNumber             = ?                                                                                                          ";
    SQL = SQL + "         AND scl.t_feetype                   = concom.t_feetype                                                                                           ";
    SQL = SQL + "         AND scl.t_commnumber                = concom.t_commnumber                                                                                        ";
    SQL = SQL + "         AND scl.t_begindate                 =                                                                                                            ";
    SQL = SQL + "                   (SELECT   max (t_begindate)                                                                                                            ";
    SQL = SQL + "                      FROM   dsftarscl_dbt                                                                                                                ";
    SQL = SQL + "                     WHERE   t_feetype  = concom.t_feetype                                                                                                ";
    SQL = SQL + "                       AND t_commnumber = concom.t_commnumber                                                                                             ";
    SQL = SQL + "                       AND t_concomid = concom.t_id                                                                                                       ";
    SQL = SQL + "                       AND (t_begindate <= ?                                                                                                              ";
    SQL = SQL + "                           OR t_begindate = to_date ('01.01.0001', 'dd.mm.yyyy'))                                                                         ";
    SQL = SQL + "                    )                                                                                                                                     ";
    SQL = SQL + "         AND scl.t_concomid                  = concom.t_id                                                                                                ";  // 05.02.2014 joy Связь теперь по этим полям
    SQL = SQL + "         AND (CONCOM.T_DATEEND > ? OR CONCOM.T_DATEEND = to_date ('01.01.0001', 'dd.mm.yyyy') )                                                           ";  //                и проверяем, что комиссия действует

    // 1-я строчка тарифа - информация об ограничениях пакета комиссий
    SQL = SQL + "         AND trf1.t_tarsclid                  = scl.t_id                                                                                                  ";
    SQL = SQL + "         AND trf1.t_basesum                   = 0                                                                                                         ";  // Тариф с нулевой базовой суммой
    SQL = SQL + "         AND trf1.t_basetype                  = 1                                                                                                         ";  // Тип базы = Сумма
    //SQL = SQL + "         and NVL (trf1.t_tarifsum / 10000, 0) > 0                                                                                                         ";  // Для отбора правильного алгоритма

    // 2-я строчка тарифа - информация об ограничениях по каждому платежу, по которому рассчитывается комиссия
    SQL = SQL + "         AND trf2.t_tarsclid                  = scl.t_id                                                                                                  ";
    SQL = SQL + "         AND trf2.t_basesum                   = 0.01                                                                                                      ";  // Тариф с базовой суммой 0.01 руб
    SQL = SQL + "         AND trf2.t_basetype                  = 1                                                                                                         ";  // Тип базы = Сумма
    SQL = SQL + "         and NVL (trf2.t_tarifsum / 10000, 0) > 0                                                                                                         ";  // Для отбора правильного тарифа

    SQL = SQL + " ORDER BY concom.t_ObjectType DESC                                                                                                                        ";
    SQL = SQL + " )  SELECT * FROM t WHERE ROWNUM = 1                                                                                                                      ";

    /*
    setoutput("d:\\123", true);
    println (sql);
    setoutput(null, true);
    msgbox (sfContr.id, " - ", sfCommNumber);
    */

    cmd = rsdCommand( sql );
    cmd.AddParam("", RSDBP_IN, sfContr.id);
    cmd.AddParam("", RSDBP_IN, BegDate);
    cmd.AddParam("", RSDBP_IN, sfContr.id);
    cmd.AddParam("", RSDBP_IN, sfComType);
    cmd.AddParam("", RSDBP_IN, sfCommNumber);
    cmd.AddParam("", RSDBP_IN, BegDate);
    cmd.AddParam("", RSDBP_IN, BegDate);

    rs = rsdRecordSet( cmd );
    if ( rs and rs.MoveNext )

       TarifType = rs.value( "tType", null, V_INTEGER );
       
       if ( TarifType == 1 )        // Тариф = Сумма
          TarifValue = rs.value( "tVal", null, V_MONEY );
          MinValue   = $0;
          MaxValue   = $0;
       elif (   ( TarifType == 2 )      // Тариф = Процент
              or( TarifType == 3 ) )    // Тариф = Сумма за единицу
          TarifValue = rs.value( "tVal",   null, V_DOUBLE );
          MinValue   = rs.value( "minVal", null, V_MONEY );
          MaxValue   = rs.value( "maxVal", null, V_MONEY );
       end;

       PackValue = rs.value( "packVal", null, V_MONEY );

       /*
       setoutput("d:\\123", true);
       println (TarifValue, " - ", MinValue, " - ",MaxValue);
       setoutput(null, true);
       */

       return true;
    end;

    return false;
END;



/* EVG 7/11/2012 Функция возвращает количество платежей клиента за период.
   (рублёвые платежи РКО) */
MACRO CountPayments( clientID, BegDate, EndDate )

  var query, rs, cmd, str_sld = "", zar_str;
  //var LifeBics = "044525986, 046311808, 046577781, 042908701, 044583859, 040702756, 042007755, 044525732, 041806835, 043601706, 042406718, 046577859"; // 15.08.2014 joy Добавляю недостающие БИКи
  var LifeBics = getBICsBanks();

  if (LifeBank.is_SLD ) //joy 15.08.2014 C-31392 так как отбор стал общим, это условие отдельно для Солидарности не нужно
    str_sld = " ";      //" AND NOT (SUBSTR(paym.t_receiveraccount, 1, 5) IN ('30301', '30232','47422') " +
                        // "          AND (REGEXP_LIKE ('\\s' || LOWER (PROP.T_GROUND),'(40817|40820|423|426)') " +
                        // "               OR   REGEXP_LIKE ('\\s' || LOWER (PROP.T_RECEIVERNAME),'(40817|40820|423|426)'))) ";
  else
    zar_str = "    and acc.t_type_account NOT LIKE          '%Z%'                                ";
  end;

  query = " Select count(0)                                                                  " ;
  query = query + "   From DPmPaym_dbt paym, DPmRmProp_dbt prop, dacctrn_dbt arh, dpmdocs_dbt pmd,   " ;
  query = query +    "        DAccount_dbt acc                                                          " ;
  query = query +    "  Where arh.t_date_carry BETWEEN             ? AND ?                              " ;
  query = query +    "    and acc.t_Account                        = arh.t_Account_Payer                " ;
  query = query +    "    and acc.t_chapter                        = arh.t_chapter                      " ; // joy По C-31392 zar_str +
  query = query +    "    AND PMD.T_ACCTRNID                       = ARH.T_ACCTRNID                     " ;
  query = query +    "    AND arh.t_state = 1                                                           " ;     //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
  query = query +    "    and paym.t_paymentid                     = pmd.t_paymentid                    " ;
  query = query +    "    and paym.t_dockind                       = 201                                " ;     // Рублевый клиентский платеж
  query = query +    "    and paym.t_payer                         = ?                                  " ;
  query = query +    "    and subStr(paym.t_ReceiverAccount, 1, 3) not between '401' and '404'          " ;     // Кроме бюджетных платежей
  // joy 25.07.2014 C-31392 Изменяю отбор на новый вариант : Кроме платежей на счета физ. лиц, за исключением зарплатных
  // joy 18.08.2014 C-32315 Для ВУЗа временно
  if (LifeBank.is_VUZ )
      query = query +    "    and subStr(paym.t_ReceiverAccount, 1, 3) not in ('423', '426')                " ;     
      query = query +    "    and subStr(paym.t_ReceiverAccount, 1, 5) not in ('40817', '40820','30232', '30223')    " ;
  else
      query = query +    "    AND ( (substr (paym.t_receiveraccount, 1, 3) not in ('423', '426') " ;
      query = query +    "           and substr (paym.t_receiveraccount, 1, 5) not in ('40817', '40820') " ;
      query = query +    "           and not (substr (paym.t_receiveraccount, 1, 5) in ('30232', '47422', '30301', '30223') " ;
      query = query +    "                    and (  regexp_like (arh.t_ground, '(40817|40820\\d{15})') " ;
      query = query +    "                        or regexp_like (arh.t_ground, '(423|426)\\d{17}') " ;
      query = query +    "                        or regexp_like (arh.t_ground, '\\sп/к\\s') " ;
      query = query +    "                        OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' )  " ;
      query = query +    "                        or regexp_like ( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ))) " ;
      query = query +    "        OR ( (  (SUBSTR( paym.t_receiveraccount, 1, 3 )  IN ('423', '426') " ;
      query = query +    "                or SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') ) " ;
      if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ условия изменились
          query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') " ;
      else
          query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') " ;
      end;
      query = query +    "                  or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
      query = query +    "              ) " ;
      query = query +    "            OR (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422', '30301', '30223') " ;
      query = query +    "               AND (REGEXP_LIKE (arh.t_ground, '(40817|40820\\d{15})') OR REGEXP_LIKE ( arh.t_ground, '(423|426)\\d{17}' ) "  ;
      query = query +    "                    or regexp_like (arh.t_ground, '\\sп/к\\s') " ;
      query = query +    "                    OR REGEXP_LIKE( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) " ;
      query = query +    "                    OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) ) " ;
      if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ условия изменились
          query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') " ;
      else
          query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') " ;
      end;
      query = query +    "                    or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
      query = query +    "        ) ) )" ;
          // --- end joy
  end;
  query = query +    "    and paym.t_PaymStatus                    = 32000                              " ;     // Только закрытые
  query = query +    "    and paym.t_PayerBankID                   <> paym.t_ReceiverBankID             " ;
  query = query +    "    and prop.t_paymentid                     = paym.t_paymentid                   " ;
  query = query +    "    and prop.t_shifroper                     <> 16                                " ;     // Кроме платёжных ордеров оплаты картотеки 2
  query = query +    "    and paym.t_receiverbankid NOT IN ( SELECT code.t_objectid                     " ;     // Кроме платежей между банками группы (комиссией не облагаются)
  query = query +    "                                         FROM dobjcode_dbt code                   " ;
  query = query +    "                                        WHERE code.t_code IN (" + LifeBics + ")   " ;
  query = query +    "                                          AND code.t_codekind = 3                 " ;
  query = query +    "                                          AND code.t_objecttype = 3 )             " + str_sld;
  if (LifeBank.is_EXV)
    query = query + " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";
  end;
  cmd = rsdcommand(query);
  cmd.AddParam( "", RSDBP_IN, BegDate  );
  cmd.AddParam( "", RSDBP_IN, EndDate  );
  cmd.AddParam( "", RSDBP_IN, clientID );
  rs = rsdRecordSet(cmd);
  if( rs and rs.moveNext() )
     return rs.value( 0, null, V_INTEGER );
  end;

  return 0;
END;

/*04.02.2014 joy Перенос модифкации от 11.12.2013  C-25038 Для счетов на оплату количество платежей за период отбирается по-другому*/
MACRO CountPaymentsForInvoiceIBank( clientID, BegDate, EndDate, DocOrigin, CatGroupID, CatAttrid )

  var query, rs, cmd;
//05.02.2014 joy Адаптировала для 2031
         query =    " Select count(0)                                                             " +
                    "   From DPmPaym_dbt paym, dacctrn_dbt trn, dpmdocs_dbt pmd,                  " +
                    "        dpspayord_dbt ord, dobjatcor_dbt oc                                  " +
                    " WHERE   trn.t_chapter = 1                                                   " +
                    "         AND paym.t_payer = :payer                                           " +
                    "         AND trn.t_date_carry BETWEEN :BegDate AND :EndDate                  " +
                    "         AND trn.t_acctrnid =  pmd.t_acctrnid                                " +
                    "         AND trn.t_state = 1                                                 " + //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
                    "         AND paym.t_paymstatus = 32000                                       " +
                    "         AND paym.t_dockind    = 201                                         " +
                    "         AND ord.t_orderid = paym.t_paymentid                                " +
                    "         AND paym.t_paymentid = pmd.t_paymentid                              " +
                    "         AND trn.t_shifr_oper <> '16'                                        " +
                    "         AND ord.t_Origin = :DocOrigin                                       " +
                    "         AND oc.t_objecttype  = 501                                          " +
                    "         AND oc.t_groupid     = :catnumber                                   " +
                    "         AND oc.t_attrid      = :catattrid                                   " +
                    "         AND oc.t_object      = LPAD(paym.t_paymentid, 10, 0)                " ;
         if (LifeBank.is_EXV)
           query = query + " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";
         end;
                    /*--- end joy*/
    cmd = rsdcommand(query);
    cmd.AddParam( "payer",     RSDBP_IN, clientID );
    cmd.AddParam( "BegDate",   RSDBP_IN, BegDate  );
    cmd.AddParam( "EndDate",   RSDBP_IN, EndDate  );
    cmd.AddParam( "DocOrigin", RSDBP_IN, DocOrigin);
    cmd.AddParam ( "catnumber", RSDBP_IN, CatGroupID );
    cmd.AddParam ( "catattrid", RSDBP_IN, CatAttrid );

    rs = rsdRecordSet(cmd);
    if( rs and rs.moveNext() )
        return rs.value( 0, null, V_INTEGER );
    end;

  return 0;
 END;



/* EVG 7/11/2012 Класс для хранения информации о платежах */
CLASS PaymentsInfo( id, amnt, acp, acr, orig, tm, cat )

   var PaymID           = id,
       Amount           = amnt,
       AccountPayer     = acp,
       AccountReceiver  = acr,
       Origin           = orig,
       PaymTime         = tm,
       PaymCat          = cat;

END;


/* EVG 7/11/2012 

        Функция выполняет следующие действия:

        - находит информацию по тарифу (значение, лимит (макс. сумма), вид тарифа);
        - подсчитывает количество платежей;
        - определяет, были ли платежи сверх лимита;
        - записывает информацию обо всех платежах сверх лимита в массив.

        Возвращает заполненный массив с информацией по платежам сверх лимита.

   EVG 6/05/2013 Добавил приём и передачу в GetTarifInfo() параметра PackValue для 3-уровневой тарификации. Заполнение параметра в GetTarifInfo3EbeneTarifbildung() (C-19221, п. 1.2).
   05.02.2014 joy Перенос модифкации от 10.12.2013 Добавила в CollectPaymentsInformation приём параметра ForInvoiceIBank, CatGroupID, DocOrigin для комиссий по счетам оплаты C-25038
*/

MACRO CollectPaymentsInformation( sfcontr, BegDate, EndDate, CommNumber, TarifValue:@variant, MinValue:@variant, MaxValue:@variant, TarifType:@integer, PackValue:@variant, ForInvoiceIBank, CatGroupID, DocOrigin )
  var query, rs, cmd, SQL, n = 0, str_sld = "", zar_str = "";
  var PmInfoArray = TArray();
  //var TarifValue = 0, MinValue = 0, MaxValue = 0, TarifType = 0;

  //var LifeBics = "044525986, 046311808, 046577781, 042908701, 044583859, 040702756, 042007755, 044525732, 041806835, 043601706, 042406718, 046577859"; //  15.08.2014 joy Добавила недостающие БИКи
  var LifeBics = getBICsBanks();


  /* EVG 6/05/2013 Добавлена передача параметра PackValue (обрабатывается в случае подмены GetTarifInfo() на GetTarifInfo3EbeneTarifbildung())
  if( GetTarifInfo( sfcontr, BegDate, EndDate, 1, CommNumber, @TarifValue, @MinValue, @MaxValue, @TarifType ) )*/
  if( GetTarifInfo( sfcontr, BegDate, EndDate, 1, CommNumber, @TarifValue, @MinValue, @MaxValue, @TarifType, @PackValue ) )

     /* EVG 6/05/2013 Если определилась PackValue, то считаем её за размер пакета, иначе - MaxValue, как раньше. Далее
        по тексту заменил все проверки MaxValue на PackValue_local. */
     var PackValue_local = MaxValue;
     if( valType( PackValue ) != V_UNDEF )
        PackValue_local = PackValue;
     end;


     var mm, yy, monthBegDate;
     datesplit( BegDate, null, mm, yy );
     monthBegDate = date( 1, mm, yy );


     /* EVG 18/02/2013 В соответствии с заявкой C-17591, анализ оборотов должен осуществояться с даты подключения ТП в случае,
        если ТП был подключен в текущем месяце (т.е. большая из дат <Дата начала месяца> и <Дата подключения ТП>). */
     var tpBegDate = date(0,0,0);
     cmd = rsdcommand("   SELECT t_begin " +
                      "     FROM dsfcontrplan_dbt " +
                      "    WHERE T_SFCONTRID = ?  " +
                      "      AND t_end       = TO_DATE('01.01.0001','dd.mm.yyyy') " +
                      " ORDER BY t_begin DESC ");
     cmd.addparam( "ID", RSDBP_IN, sfcontr.id );
     rs = rsdrecordset( cmd );
     if ( rs and rs.movenext )
        tpBegDate = SQL_ConvTypeDate( rs.value(0, null, V_DATE) );
     end;

     /* EVG 18/02/2013
     var TotalPayments   = CountPayments( sfcontr.PartyId, monthBegDate, EndDate ),*/
    var TotalPayments, CurrentPayments; 
    
    if (ForInvoiceIBank == true) /*05.02.2014 joy Перенос модифкации от 11.12.2013  C-25038 Для счетов на оплату используем другую функцию отбора платежей*/
        var CatAttrid   = "1"; // Признак категории
        TotalPayments   = CountPaymentsForInvoiceIBank( sfcontr.PartyId, max(monthBegDate, tpBegDate), EndDate, DocOrigin, CatGroupID, CatAttrid );
        CurrentPayments = CountPaymentsForInvoiceIBank( sfcontr.PartyId, BegDate, EndDate, DocOrigin, CatGroupID, CatAttrid );
    else
        TotalPayments   = CountPayments( sfcontr.PartyId, max(monthBegDate, tpBegDate), EndDate );
        CurrentPayments = CountPayments( sfcontr.PartyId, BegDate, EndDate );
    end;


     /* Если за дату (период) расчёта были платежи, и их количество превысило лимит, идём дальше */
     if(( TotalPayments > PackValue_local ) and ( CurrentPayments > 0 ))

        /* Посчитаем количество платежей, попавших в лимит, если такие есть */
        var PaymentsInLimit = CurrentPayments - ( TotalPayments - PackValue_local );
        if( PaymentsInLimit < 0 ) PaymentsInLimit = 0 end;


        /* Сформируем массив платежей, не попадающих в лимит */

        if (ForInvoiceIBank == true)

            /* 05.02.2014 joy Адаптация для 2031*/
            query = " SELECT paym.t_PaymentId id, paym.t_PayerAccount acp, paym.t_ReceiverAccount acr, paym.t_Amount amnt,          " +
                    "       ord.t_Origin orig, NVL(oc.t_attrid, 0) cat,                                                             " +
                    "       DECODE ( ord.t_userfield1,                                                                              " +
                    "                CHR (1),                                                                                       " +
                    "                TO_DATE ('01.01.0001 01.01.01', 'dd.mm.yyyy hh24.mi.ss'),                                      " +
                    "                TO_DATE (ord.t_userfield1, 'dd.mm.yyyy hh24.mi.ss')      ) tm                                  " +
                    "   From DPmPaym_dbt paym, dacctrn_dbt trn, dpmdocs_dbt pmd,                                                    " +
                    "       dpspayord_dbt ord, dobjatcor_dbt oc                                                                     " +
                    " WHERE   trn.t_chapter = 1                                                                                     " +
                    "         AND paym.t_payer = :payer                                                                             " +
                    "         AND trn.t_date_carry BETWEEN :BegDate AND :EndDate                                                    " +
                    "         AND trn.t_acctrnid =  pmd.t_acctrnid                                                                  " +
                    "         AND trn.t_state = 1                                                                                   " + //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
                    "         AND paym.t_paymstatus = 32000                                                                         " +
                    "         AND paym.t_dockind    = 201                                                                           " +
                    "         AND ord.t_orderid = paym.t_paymentid                                                                  " +
                    "         AND paym.t_paymentid = pmd.t_paymentid                                                                " +
                    "         AND trn.t_shifr_oper <> '16'                                                                          " +
                    "         AND ord.t_Origin = :DocOrigin                                                                         " +
                    "         AND oc.t_objecttype  = 501                                                                            " +
                    "         AND oc.t_groupid     = :catnumber                                                                     " +
                    "         AND oc.t_attrid         = :catattrid                                                                  " +
                    "         AND oc.t_object      = LPAD(paym.t_paymentid, 10, 0)                                                  " ;
                    if (LifeBank.is_EXV)
                      query = query + " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";
                    end;
                    query = query + " Order by id ";
                    cmd = rsdcommand(query);
                    cmd.AddParam ( "payer",     RSDBP_IN, sfcontr.partyid );
                    cmd.AddParam ( "BegDate",   RSDBP_IN, BegDate ); 
                    cmd.AddParam ( "EndDate",   RSDBP_IN, EndDate);
                    cmd.AddParam ( "DocOrigin", RSDBP_IN, DocOrigin );
                    cmd.AddParam ( "catnumber", RSDBP_IN, CatGroupID );
                    cmd.AddParam ( "catattrid", RSDBP_IN, CatAttrid );
                    /*---end joy*/
        else
          //joy 15.08.2014 C-31392 так как отбор стал общим, это условие отдельно для Солидарности не нужно
          if (LifeBank.is_SLD )
            str_sld = " "; //" AND NOT (SUBSTR(paym.t_receiveraccount, 1, 5) IN ('30301', '30232','47422') " +
                      //"          AND (REGEXP_LIKE ('\\s' || LOWER (PROP.T_GROUND),'(40817|40820|423|426)') " +
                      //"               OR   REGEXP_LIKE ('\\s' || LOWER (PROP.T_RECEIVERNAME),'(40817|40820|423|426)'))) ";
          else
            zar_str = "    and acc.t_type_account NOT LIKE          '%Z%'                                                                ";
          end;
          query = " Select paym.t_PaymentId id, paym.t_PayerAccount acp, paym.t_ReceiverAccount acr, paym.t_Amount amnt,                            " ;
          query = query +        "       ord.t_Origin orig, NVL(oc.t_attrid, 0) cat,                                                                " ;
          query = query +        "       DECODE ( ord.t_userfield1,                                                                                 " ;
          query = query +        "                CHR (1),                                                                                          " ;
          query = query +        "                TO_DATE ('01.01.0001 01.01.01', 'dd.mm.yyyy hh24.mi.ss'),                                         " ;
          query = query +        "                TO_DATE (ord.t_userfield1, 'dd.mm.yyyy hh24.mi.ss')      ) tm                                     " ;
          query = query +        "   From DPmPaym_dbt paym, DPmRmProp_dbt prop, dacctrn_dbt arh, dpmdocs_dbt pmd,                                   " ;
          query = query +        "        DAccount_dbt acc, dpspayord_dbt ord, dobjatcor_dbt oc                                                     " ;
          query = query +        "  Where arh.t_date_carry BETWEEN             ? AND ?                                                              " ;
          query = query +        "    and acc.t_Account                        = arh.t_Account_Payer                                                " ;
          query = query +        "    and acc.t_chapter                        = arh.t_chapter                                                      " ; // joy По C-31392 zar_str +  
          query = query +        "    AND PMD.T_ACCTRNID                       = ARH.T_ACCTRNID                                                     " ;
          query = query +        "    AND arh.t_state = 1                                                                                           " ; //10.06.2014 joy R-390919 В 2031 важно состояние проводки (напр., если было перепозиц-е)
          query = query +        "    and paym.t_paymentid                     = pmd.t_paymentid                                                    " ;
          query = query +        "    and paym.t_dockind                       = 201                                                                " ;     // Рублевый клиентский платеж
          query = query +        "    and paym.t_payer                         = ?                                                                  " ;
          query = query +        "    and subStr(paym.t_ReceiverAccount, 1, 3) not between '401' and '404'                                          " ;     // Кроме бюджетных платежей
                // joy 15.08.2014 C-31392 Изменяю отбор на новый вариант
                // joy 18.08.2014 C- 32315 Для ВУЗа временные изменения
          if (LifeBank.is_VUZ)
            query = query +      "    and subStr(paym.t_ReceiverAccount, 1, 3) not in ('423', '426')                                                " ;     // Кроме платежей на счета физ. лиц
            query = query +      "    and subStr(paym.t_ReceiverAccount, 1, 5) not in ('40817', '40820','30232', '30223')                           " ;
          else
              query = query +    "    AND ( (substr (paym.t_receiveraccount, 1, 3) not in ('423', '426')                                        " ;
              query = query +    "           and substr (paym.t_receiveraccount, 1, 5) not in ('40817', '40820')                                " ;
              query = query +    "           and not (substr (paym.t_receiveraccount, 1, 5) in ('30232', '47422', '30301', '30223')                      " ;
              query = query +    "                    and (  regexp_like (arh.t_ground, '(40817|40820\\d{15})')                                  " ;
              query = query +    "                        or regexp_like (arh.t_ground, '(423|426)\\d{17}')                                      " ;
              query = query +    "                        or regexp_like (arh.t_ground, '\\sп/к\\s')                                             " ;
              query = query +    "                        or regexp_like ( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) ))) " ;
              query = query +    "                        or regexp_like (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) " ;
              query = query +    "        OR ( (  (SUBSTR( paym.t_receiveraccount, 1, 3 )  IN ('423', '426')                                    " ;
              query = query +    "                or SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('40817', '40820') )                             " ;
              if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ условия изменились
                  query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') " ;
              else
                  query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') " ;
              end;
              query = query +    "                  or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
              query = query +    "              )                                                                                               " ;
              query = query +    "            OR (SUBSTR( paym.t_receiveraccount, 1, 5 ) IN ('30232','47422', '30301', '30223')                          " ;
              query = query +    "               AND (REGEXP_LIKE (arh.t_ground, '(40817|40820\\d{15})') OR REGEXP_LIKE ( arh.t_ground, '(423|426)\\d{17}' ) "  ;
              query = query +    "                    or regexp_like (arh.t_ground, '\\sп/к\\s')                                                " ;
              query = query +    "                    OR REGEXP_LIKE( '\\s'||lower(arh.t_ground), '(\\sп\\.карта|п/карта|карточный\\sсчет|\\sбанковск.{0,}\\sкарт.{0,}|\\sпластик.{0,}\\sкарт.{0,})|\\sкарт.{0,}\\s№|\\sпластик/карта|\\sкарт.{0,}\\s\\d{1,}' ) " ;
              query = query +    "                    OR REGEXP_LIKE (prop.T_RECEIVERNAME, '(40817|40820\\d{15})') OR REGEXP_LIKE ( prop.T_RECEIVERNAME, '(423|426)\\d{17}' ) ) " ;
              if (LifeBank.is_EXV) // 28.10.2014 joy C-33886 Для ЭВ условия изменились
                  query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зарплатн.{0,}\\sпроект.{0,})') " ;
              else
                  query = query +     "               AND (REGEXP_LIKE  ('\\s' || LOWER (arh.t_ground), '(зар\\.плат.{0,}|заработн.{0,}\\sплат.{0,}|зарплат.{0,}|аванс.{0,}|пособи[а-я]|стипенд[а-я][а-я])|алимент.{0,}|беременност.{0,}|дивиденд.{0,}|погашение\\sкредита|кредитн.{0,}\\sдоговор.{0,}|отпуск.{0,}|премия|премии|премиальн.{0,}|больничн.{0,}|з/п|материаль.{0,}\\sпомощь|увольнен.{0,}|\\sзп\\s|оплат.{0,}\\sтруда') " ;
              end;
              query = query +    "                  or prop.t_shifroper in ('02','06'))" ; // 08.10.2014 joy C-33886
              query = query +    "        ) ) )                                                                                                 " ;
          end;
// -- end joy
          query = query +        "    and paym.t_PaymStatus                    = 32000                                                              " ;     // Только закрытые
          query = query +        "    and paym.t_PayerBankID                   <> paym.t_ReceiverBankID                                             " ;
          query = query +        "    and prop.t_paymentid                     = paym.t_paymentid                                                   " ;
          query = query +        "    and prop.t_shifroper                     <> 16                                                                " ;     // Кроме платёжных ордеров оплаты картотеки 2
          query = query +        "    and ord.t_orderid                        = paym.t_paymentid                                                   " ;
          query = query +        "    and oc.t_objecttype                   (+)= 501                                                                " ;
          query = query +        "    and oc.t_groupid                      (+)= 10                                                                 " ;
          query = query +        "    and oc.t_object                       (+)= LPAD(paym.t_paymentid, 10, 0)                                      " ;
          query = query +        "    and paym.t_receiverbankid NOT IN         ( SELECT code.t_objectid                                             " ;     // Кроме платежей между банками группы (комиссией не облагаются)
          query = query +        "                                                 FROM dobjcode_dbt code                                           " ;
          query = query +        "                                                WHERE code.t_code IN (" + LifeBics + ")                           " ;
          query = query +        "                                                  AND code.t_codekind = 3                                         " ;
          query = query +        "                                                  AND code.t_objecttype = 3 )                                     " + str_sld ;
          if (LifeBank.is_EXV)
            query = query + " AND paym.t_ReceiverAccount NOT IN ("+SovComAccounts+") ";

            // EVG 10/3/2016 Для ЭВ добавил исключение из расчёта комиссии платежей на счета Совкомбанка
            // EVG 26/4/2016 Добавлено исключение платежей на счёта филиала "Бизнес" Совкомбанка
            query = query + " and paym.t_receiverbankid NOT IN ( SELECT code.t_objectid                                             " ;
            query = query + "                                      FROM dobjcode_dbt code                                           " ;
            query = query + "                                     WHERE code.t_code in ( " + BIC_SOVCOMBANK_BRANCH_CENTRAL  + ",    " ;
            query = query + "                                                            " + BIC_SOVCOMBANK_BRANCH_BUSINESS + " )   " ;
            query = query + "                                       AND code.t_codekind = 3                                         " ;
            query = query + "                                       AND code.t_objecttype = 3 )                                     " ;

          end;
          query = query +        "  Order by id                                                                                                     ";
             
          cmd = rsdcommand(query);
          cmd.AddParam( "", RSDBP_IN, BegDate  );
          cmd.AddParam( "", RSDBP_IN, EndDate  );
          cmd.AddParam( "", RSDBP_IN, sfcontr.PartyID );
          
        end;

        // EVG 10/3/2016 Добавил БИК костромского Совкомбанка (SovComBIC - моск. филиал)
        // EVG 26/4/2016 Добавлено исключение платежей на счёта филиала "Бизнес" Совкомбанка
        query = query + " AND paym.t_ReceiverAccount NOT IN ("+SovComBIC+","+BIC_SOVCOMBANK_BRANCH_CENTRAL+","+BIC_SOVCOMBANK_BRANCH_BUSINESS+") ";



        rs = rsdRecordSet(cmd);
        while( rs and rs.moveNext() )
           n = n + 1;

           /* Платежи, укладывающиеся в лимит, пропускаем. Остальные - записываем в массив. */
           if( n > PaymentsInLimit )
              PmInfoArray( PmInfoArray.size ) = PaymentsInfo( rs.value( "id",   null, V_INTEGER ),
                                                              rs.value( "amnt", null, V_MONEY   ),
                                                              rs.value( "acp",  null, V_STRING  ),
                                                              rs.value( "acr",  null, V_STRING  ),
                                                              rs.value( "orig", null, V_INTEGER ),
                                                              rs.value( "tm",   null, V_DTTM    ),
                                                              rs.value( "cat",  null, V_INTEGER ) );
           end;
        end;

     end;  // if(( TotalPayments...
  end;  // if( GetTarifInfo(...

  return PmInfoArray;
END;

 /* RR 30.10.2012 Проверка наличия значений категории Авансовые комиссии на ЛС
      В зависимости от наличия той или иной категории возвращает следующие значения
        222 - если у категории задано только значение "Комиссия 2.2.2"
        223 - если у категории задано только значение "Комиссия 2.2.3"
        224 - если у категории задано только значение "Комиссия 2.2.4"
        753 - если у категории задано только значение "Комиссия 7.5.3"
        0   - если значения категорий не заданы
        1   - если заданы значения категорий 7.5.3 и 2.2.2
        3   - если заданы значения категорий 7.5.3 и 2.2.3
        4   - если заданы значения категорий 7.5.3 и 2.2.4
 */
 /* joy 01.04.2013 C-18667 Поиск категорий переписан так, чтобы не привязывать к названиям признаков категорий */ 
 /* joy 30.07.2013 C-21117 Добавлен поиск  авансовых комиссий 2.2.3 и 2.2.4*/
macro CheckCatOnAcc(PartyID)
    private const PT_USR_CAT_COMM_ADVANCE_HALFYEAR = 1; // Полугодовая  комиссия за ведение счета
    private const PT_USR_CAT_COMM_ADVANCE_INFORM   = 2; // Комиссия за информирование  
    private const PT_USR_CAT_COMM_ADVANCE_3MONTH   = 3; // Ком-я за ведение счета за 3 мес.
    private const PT_USR_CAT_COMM_ADVANCE_18MONTH  = 4; // Ком-я за ведение счета за 1,5 года
    debugbreak;
    var category  = RsbObjCategories(OBJTYPE_PARTY,  strLpad(string(PartyID), 10, "0"));
    var halfYear  = category.IsAttrPresense (PT_USR_CAT_COMM_ADVANCE, PT_USR_CAT_COMM_ADVANCE_HALFYEAR, NULL, NULL, false, {curdate} );
    var inform    = category.IsAttrPresense (PT_USR_CAT_COMM_ADVANCE, PT_USR_CAT_COMM_ADVANCE_INFORM,   NULL, NULL, false, {curdate} );
    var _3month   = category.IsAttrPresense (PT_USR_CAT_COMM_ADVANCE, PT_USR_CAT_COMM_ADVANCE_3MONTH,   NULL, NULL, false, {curdate} );
    var _18month  = category.IsAttrPresense (PT_USR_CAT_COMM_ADVANCE, PT_USR_CAT_COMM_ADVANCE_18MONTH,  NULL, NULL, false, {curdate} );
    
    if ( halfYear )
        if ( inform ) return 1;
        else          return 222;
        end;
    elif (_3month)
        if ( inform ) return 3;
        else          return 223;
        end;
    elif (_18month)
        if ( inform ) return 4;
        else          return 224;
        end;
    elif ( inform )   return 753;
    else              return 0;
    end;
    
 end;
 
 
 

//RR 11.02.2012 Перенес макрофункцию из макроса расчета комиссии
 Macro CheckForYearComiss(PartyID, CommNumber, EndDate)
  var query, rs, cmd;
  query = " SELECT   nvl(add_months(max(t_dateperiodend), 12), to_date('01.01.0001','dd.mm.yyyy')) "+
        "   FROM   dsfdefcom_dbt "+
        "  WHERE   t_conid IN (SELECT   t_id "+
        "                        FROM   dsfcontr_dbt "+
        "                       WHERE   t_partyid = ?) "+
        "          AND t_commnumber = ? " 
        "          AND t_status > 20 "; 
  cmd = rsdcommand(query);
  cmd.AddParam("", RSDBP_IN,PartyID);
  cmd.AddParam("", RSDBP_IN,CommNumber);
  rs = rsdRecordSet( cmd );
  if (rs and rs.moveNext())
    if (rs.value(0, null, V_DATE) <= EndDate)
      return 1;
    end;
  end;
  return 0;
 END;
 
 //RR 15.02.2013 Перенес макрофункцию из макроса расчета комиссии
 Macro CheckFullPay(PaymId)
  var query, rs, cmd;
  query = " select instr (nvl ((select upper (mes.t_value) "+
                       "                      from dpmpaym_dbt p, dwlpm_dbt wlp, dwlmesval_dbt mes "+
                       "                     where p.t_paymentid = ? "+
                       "                       and wlp.t_paymentid = p.t_paymentid "+
                       "                       and wlp.t_propstatus = 0 "+
                       "                       and mes.t_mesid = (select max (d.t_mesid) "+
                       "                                            from dwlmeslnk_dbt d "+
                       "                                           where d.t_objid = wlp.t_wlpmid) "+
                       "                       and mes.t_tpfieldid = 13), 0),'FULLPAY' ) val from dual "; 
  cmd = rsdcommand(query);
  cmd.AddParam("", RSDBP_IN,PaymId);
  rs = rsdRecordSet( cmd );
  if (rs and rs.moveNext())
    if (rs.value(0) == 0 )
      return true;
    end;
  end;
  return false;
 END;

MACRO CheckUserField1( NumPos,Count,Account )
  var query, rs, cmd;
  query =  " select nvl( to_number(substr(ACC.T_USERFIELD1, ? ,?)) , 0) "
  +"\n                 from daccount_dbt acc "
  +"\n               where     acc.t_chapter = 1 "
  +"\n                    and acc.t_close_date = to_date ( '01.01.0001', 'dd.mm.yyyy' ) "
  +"\n                    and ( substr ( acc.t_account, 1, 3 ) in (405, 407) or substr ( acc.t_account, 1, 5 ) in (40802, 40807) ) "
  +"\n                    and substr ( acc.t_account, 11, 1 ) = 9 "
  +"\n                        and acc.t_client = (select t_client "
  +"\n                             from daccount_dbt "
  +"\n                           where t_account = to_char ( ? )); ";
  debugbreak;
  cmd = rsdcommand(query);
  cmd.AddParam("", RSDBP_IN,NumPos);
  cmd.AddParam("", RSDBP_IN,Count);
  cmd.AddParam("", RSDBP_IN,Account);
  rs = rsdRecordSet( cmd );
  if (rs and rs.moveNext())
     return rs.value(0);
  end;
  return 0;
END;

MACRO Get55RecordSet( docKind, Autokey, TpOnline, CommCashSymbol )
  var query, rs, cmd;
            query = " Select paym.t_Amount, paym.t_FIID " +
                  "   From DPmPaym_dbt paym, dsymbcash_dbt symb, dpscshdoc_dbt doc " +
                  "  Where paym.t_DocKind      = ? " +
                  "    and paym.t_DocumentID   = ? " +
                  "    and paym.t_DocumentID   = doc.T_autokey " +
                  "    and symb.t_ApplicationKey = LPAD (doc.t_autokey, 34, '0') " +
                  "    and symb.t_kind = 1 " +
                  "    and symb.t_dockind = decode (doc.t_iscurrency, chr(0), 1, chr(88), 7, 1) ";
  debugbreak;
  if (TpOnline)
     query = query + "    and trim(symb.t_Symbol) not in " + CommCashSymbol;
  end;
  cmd = rsdcommand(query);
  cmd.AddParam("", RSDBP_IN,docKind);
  cmd.AddParam("", RSDBP_IN,Autokey);
  rs = rsdRecordSet( cmd );
  if (rs)
     return rs;
  end;
  return 0;
END;

/*29.07.2013 Жаворонкова Н. (joy) R-221409-2 Функция проверяет, когда была оплачена предудыщая УПК*/
Macro CheckPreviousUPK (comcode, sfcontrID, period, EndDate )
debugbreak;
    var query, cmd, rs;


    query = " Select nvl (max (t_dateperiodend), '01.01.0001' ) lastEndDate from dsfdef_dbt  " +
            "  Where t_feetype        = 1                               " +        // Периодическая
            "    and t_commnumber     = (select T_NUMBER from dsfcomiss_dbt where t_code = :comcode and t_feetype = 1  ) " +           
            "    and t_sfcontrid      = :sfcontrID                      " +
            "    and t_status         in (30, 40)                       " ;        // 40 - "Оплачена" 21.08.2013 R-234873-2 joy 
                                                                                   //                 Добавлена проверка статуса "К оплате" (30) 

    cmd = rsdCommand( query );
    cmd.AddParam( "comcode", RSDBP_IN, comcode );
    cmd.AddParam( "sfcontrID", RSDBP_IN, sfcontrID );


    rs = rsdRecordSet( cmd );
    if ( rs and rs.moveNext() )
        var lastEndDate = rs.value( "lastEndDate",   null, V_DATE );
        if ((floatMonths(lastEndDate, EndDate) < period) and (lastEndDate != "01.01.0001") )
            return false;
        else
            return true;
        end;
    else
        return true; // Может быть первый раз оплаты этой комиссии
    end;
END;


// 30.10.2014 joy Перенесла в рамках адаптации ждля 2031
 MACRO RCheckComState(contr_id, verifiable, checked)
  var rs = RSDRecordSet (" SELECT   1 " +
                         "   FROM   dsfconcom_dbt com " +
                         "  WHERE   COM.T_OBJECTID = "+contr_id+" AND COM.T_OBJECTTYPE = 659 " +
                         "          AND COM.T_SFPLANID = " +
                         "                (SELECT   CPL.T_SFPLANID " +
                         "                   FROM   dsfcontrplan_dbt cpl " +
                         "                  WHERE   CPL.T_ID = " +
                         "                            (SELECT   MAX (t_id) " +
                         "                                FROM   dsfcontrplan_dbt pl " +
                         "                               WHERE   PL.T_SFCONTRID = COM.T_OBJECTID)) " +
                         "          AND COM.T_COMMNUMBER = " +
                         "                (SELECT   C.T_NUMBER " +
                         "                   FROM   dsfcomiss_dbt c " +
                         "                  WHERE   C.T_FEETYPE = COM.T_FEETYPE AND C.T_CODE = "+checked+") " +
                         "          AND COM.T_FEETYPE = 1 " +
                         "          AND COM.T_STATUS = 0");
   if (rs and rs.movenext())
     return true;
   else
     return false;
   end;
 onerror(x)
   return false;
 END;


 // EVG 10/3/2016 Сделал отдельную функцию для нормализации основания при проверке
 // но отнесение к ЗП проектам, чтобы не рисовать это везде (используется в ЭВ).
 MACRO NormGround_ForZP_ProjCheck( pGround )

    pGround = StrLwr( StrSubst( StrSubst( pGround, StrFor(10), " " ), StrFor(13), " " ) );

    // Убираем двойные пробелы
    while( index(pGround, "  ") > 0 )
       pGround = StrSubst( pGround, "  ", " " );
    end;

    return pGround;
 END;


 
