/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   EVG Банк "Газэнергобанк" (ГЭБ)

       Макрос пользовательского алгоритма расчёта базовых сумм по комиссии 3.6.0 
       "Перевод денежных средств, поступивших в составе рейсов МЦИ текущего дня"

       Тип комиссии - периодическая.
       
       ChangeLog:
     20-03-2012 Жаворонкова Н. (joy) I-00164041-2 - Исправлено несоответсвие дат в запросах
     19-06-2012 Жаворонкова Н. (joy) I-00210168-2, C-12125 Добавляем исключение на счета депозитов коммерческих огранизаций 421*
                                    (согласовано с Байдуловой )
   //RR 20.02.2014 Адаптирую под 2031(darhdoc_dbt -> dacctrn_dbt)
   //joy 14.11.2014 I-00532241 в 2031 обязательно надо проверять, что t_state в проводках = 1
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/



import sfinter, ptinter, cb_sql;/*InsertSumList*/

/*
    Если при расчете произошла ошибка, поместить в эту переменную ненулевое значение
*/
var MacroError :integer = 0;
private var FICode_calc:string = "";

  /* Тип величины
enum SfBaseTypes{*/
private const   SF_BASETYPE_SUM     = 1;      /* Сумма*/
private const   SF_BASETYPE_QUONT   = 2;      /* Количество*/

private const NATCUR = 0;
record sfbassum( "sfbassum.str" );



macro CalculateExternalPaymentCoverage( PaymValueDate, PayerAccount )

    var stat:integer; 
    var query, rs;
    var OurBIC    = "",
        error,
        PrevRest,
        InternalIncome,
        PaySum,
        ExternalPaymentCoverage;
    

    PrevRest = InternalIncome = PaySum = ExternalPaymentCoverage = $0;

    /* Если остаток ЗА дату расчёта комиссии отрицательный (за счёт лимита),
       то комиссия не рассчитывается. */
    if ( RestA( PayerAccount, PaymValueDate ) < $0 )
       return $0;
    end;


    /* Получим остаток по счёту на конец дня, предшествующего дате документа */
    PrevRest = RestA( PayerAccount, (PaymValueDate - 1) );
    //msgbox (PrevRest, "|", PayerAccount, "|", (PaymValueDate - 1));
    
    /* Если остаток отрицательный (такое бывает по счетам с овердрафтом), 
       возвращаем 0. */
    if ( PrevRest < $0 )
       return $0;
    end;

    
    /* Рассчитаем сумму внутреннего прихода счёта за день проводки документа */
    query = " Select nvl(sum( doc.t_Sum_natcur ), 0) " +
            "   From dacctrn_dbt doc " +
            "  Where doc.t_Account_Receiver = " + GetSQLString(PayerAccount) +
/* 20-03-2012 Жаворонкова Н. (joy) I-00164041-2 - Смотрим на дату проводки, а не на дату значения остатка*/
            "   and doc.t_Date_Carry        = " + GetSQLDate(PaymValueDate) +
            "   and doc.t_state   = 1 "
//            "    and doc.t_Date_Value       = " + GetSQLDate(PaymValueDate) +
            "    and doc.t_Account_Payer not like '3%' " ;           // Внутренние платежи
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       InternalIncome = rs.Value(0, null, V_MONEY);
    end;


    /* Определим сумму платежей за дату документа */
    /* Cумму платежей считаем проводками */
    query = " Select nvl(sum( doc.t_Sum_natcur ), 0) " +
            "   From dacctrn_dbt doc " +
            "  Where doc.t_Account_Payer = " + GetSQLString(PayerAccount) +
            "    and doc.t_Date_Carry    = " + GetSQLDate(PaymValueDate) +
            "    AND doc.t_Account_Receiver NOT LIKE '421%' " + // 19-06-2012 joy I-00210168-2, C-12125 Добавляем исключение на счета депозитов коммерческих огранизаций
            "    AND doc.t_Account_Receiver NOT LIKE '45%' " + 
            "    AND doc.t_Account_Receiver NOT LIKE '706%' " + 
            "    and doc.t_state   = 1 "
            "    AND doc.t_Priority not between 1 and 4 " +             // Кроме бюджетных платежей
            "    and doc.t_Shifr_Oper   not like '02' " +               // Исключается погашение кредитов
            "    and doc.t_Shifr_Oper   not like '03' " +               // Исключается снятие наличности кассовыми чеками
            "    and doc.t_Shifr_Oper   not like '06' " +               // Исключается погашение кредитов
            "    and doc.t_Shifr_Oper   not like '09' " +               // Исключаются мемордера
            "    and doc.t_Shifr_Oper   not like '16' " +               // Кроме оплаты картотек
            "    and doc.t_Shifr_Oper   not like '17' " ;               // Исключаются банковские ордера
    rs = rsdRecordSet(query);
    if (rs and rs.moveNext())
       PaySum = rs.Value(0, null, V_MONEY);
    end;
    //msgbox (query);

    /* Определим, производится ли оплата за счёт сумм, поступивших внешним платежом */
    ExternalPaymentCoverage = PaySum - (PrevRest + InternalIncome);
    //msgbox (ExternalPaymentCoverage, "|", PaySum, " - ", PrevRest, " - ", InternalIncome);

    if (ExternalPaymentCoverage > $0)
       return ExternalPaymentCoverage;
    end;

    return $0;
end; /*CalculateExternalPaymentCoverage()*/



/*
    Расчет для периодических комиссий
*/
/* EVG Добавил приём структуры sfcontr для вызова из макроса sfacrpay.mac */
macro CalcServiceSum( sfcontr_addr/*Договор обслуживания*/, BeginDate/*Начало периода*/, EndDate/*Конец периода*/,
      sAddr /* EVG Какой-то ещё адрес */, sfcontrStruc /*Cтруктура sfcontr*/ )

    record sfcontr( sfcontr );
    var query, rs, stat;
    var CommQuont   = 0,
        CommSum     = $0;
    var retVal, Attrid, Code, Num;

    /* EVG При вызове из sfacrpay.mac используем полученную структуру sfcontrStruc вместо адреса sfcontr_addr */
    if ( ValType (sfcontr_addr) != V_UNDEF )
       SetBuff( sfcontr, sfcontr_addr );
    else
       Copy ( sfcontr, sfcontrStruc );
    end;

    query = " Select distinct(paym.t_ValueDate) dt " +
            "   From DPmPaym_dbt paym " +
            "  Where paym.t_PayerAccount    = " + GetSQLString(sfcontr.Object) +
            "    and paym.t_PaymStatus      = 32000 " +                                 // Только закрытые
            "    and paym.t_ValueDate between " + GetSQLDate(BeginDate) +
            "                             and " + GetSQLDate(BeginDate) +
            "  Order by dt ";
    rs = rsdRecordSet(query);
    while (rs and rs.moveNext())

       CommSum   = CommSum + CalculateExternalPaymentCoverage( rs.value(0, null, V_DATE), sfcontr.Object );

    end;

    /* EVG При вызове из sfacrpay.mac возвращаем true в случае положительного результата расчёта */
    if ( ValType (sfcontrStruc) != V_UNDEF )
       if (CommSum > 0)
          return true;
       end;
       return false;
    end;

    
    ClearRecord(sfbassum);

    sfbassum.baseType    = SF_BASETYPE_SUM;
    sfbassum.baseSum     = CommSum;

    sfbassum.baseType2   = SF_BASETYPE_SUM;
    sfbassum.baseSum2    = CommSum;

    stat = InsertSumList(sfbassum);

    if( stat )
      MsgBox("Ошибка при вставке базовой суммы");
    end;

    
end;/*CalcServiceSum*/